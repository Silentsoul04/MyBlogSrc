<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>


    <body>
	<div id="wrapper">
      <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


      
       
    <!-- Page Content -->
    <div class="container">

        <div class="row">

            <!-- Blog Post Content Column -->
            <div class="col-lg-8">
                <!-- Blog Post -->
                	<h1 style="color: #0F3C73;"><span class="outside-cats">golang</span></h1>
                    <div role="main" class="main-content">
                      

  <div class="post">

    <a href="/MyBlog/golang/2019/12/02/itoa.html" class="post-title-link">
      <h2>itoa</h2>
    </a>

    <div class="post-date">Dec 2, 2019</div>
    
    <div class="post-body">
      
      <p>iota常用于const表达式中，我们还知道其值是从零开始，const声明块中每增加一行iota值自增1。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/12/02/itoa.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/12/02/interceptor.html" class="post-title-link">
      <h2>interceptor</h2>
    </a>

    <div class="post-date">Dec 2, 2019</div>
    
    <div class="post-body">
      
      <p>gRPC-Go 增加了拦截器(interceptor)的功能， 就像Java Servlet中的 filter一样，可以对RPC的请求和响应进行拦截处理，而且既可以在客户端进行拦截，也可以对服务器端进行拦截。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/12/02/interceptor.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/12/02/http2.html" class="post-title-link">
      <h2>grpc http2</h2>
    </a>

    <div class="post-date">Dec 2, 2019</div>
    
    <div class="post-body">
      
      <p>gRPC是google开源的高性能跨语言的RPC方案。gRPC的设计目标是在任何环境下运行，支持可插拔的负载均衡，跟踪，运行状况检查和身份验证。它不仅支持数据中心内部和跨数据中心的服务调用，它也适用于分布式计算的最后一公里，将设备，移动应用程序和浏览器连接到后端服务。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/12/02/http2.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/12/02/gRPC.html" class="post-title-link">
      <h2>gRPC vs Thrift</h2>
    </a>

    <div class="post-date">Dec 2, 2019</div>
    
    <div class="post-body">
      
      <p>g.csdn.net/dazheng/article/details/48830511</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/12/02/gRPC.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/12/02/ProtoBuf.html" class="post-title-link">
      <h2>gRPC ProtoBuf</h2>
    </a>

    <div class="post-date">Dec 2, 2019</div>
    
    <div class="post-body">
      
      <p>https://doc.oschina.net/grpc?t=60133
https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-05-grpc-hack.html
https://blog.didiyun.com/index.php/2018/12/12/grpc-golang-1/</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/12/02/ProtoBuf.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/12/02/Caller.html" class="post-title-link">
      <h2>runtime.Caller runtime.FuncForPC</h2>
    </a>

    <div class="post-date">Dec 2, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/unknwon/gcblog/blob/master/content/04-go-caller.md</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/12/02/Caller.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/12/01/rc.html" class="post-title-link">
      <h2>Replication Controller、Replica Set</h2>
    </a>

    <div class="post-date">Dec 1, 2019</div>
    
    <div class="post-body">
      
      <p>Replication Controller（RC）
应用托管在K8S后，K8S需要保证应用能够持续运行，这是RC的工作内容。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/12/01/rc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/12/01/kubernetes.html" class="post-title-link">
      <h2>kubernetes</h2>
    </a>

    <div class="post-date">Dec 1, 2019</div>
    
    <div class="post-body">
      
      <p>k8s的部署架构
kubernetes中有两类资源，分别是master和nodes，master和nodes上跑的服务如下图，</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/12/01/kubernetes.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/12/01/cli.html" class="post-title-link">
      <h2>cli</h2>
    </a>

    <div class="post-date">Dec 1, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/mitchellh/cli
功能
该框架是个人开发的命令行程序框架，作者还成立了公司（HashiCorp），其公司的产品也采用这个CLI框架。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/12/01/cli.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/12/01/borg.html" class="post-title-link">
      <h2>borg</h2>
    </a>

    <div class="post-date">Dec 1, 2019</div>
    
    <div class="post-body">
      
      <p>https://tencentcloudcontainerteam.github.io/2019/04/17/google-borg/</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/12/01/borg.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/30/Sidecar.html" class="post-title-link">
      <h2>Sidecar</h2>
    </a>

    <div class="post-date">Nov 30, 2019</div>
    
    <div class="post-body">
      
      <p>Sidecar 是一个很纠结的名字，我们在翻译技术雷达时采用了一个比较通俗的翻译，即边车，而这个词随着微服务的火热与 Service Mesh 的逐渐成熟而进入人们的视野。虽然很多企业在自己的后台应用中已经大量的使用了 Sidecar，但是也是没有意识到这是一个极为有用的 pattern
<!-- more -->
Sidecar 直接表示就是挎斗摩托车，也就是常说的“三蹦子”
我们目前很多程序都是奔着 Cloud Native 的目标去的，我们的代码注定是要跑在云上的，当有人问我如果我要做到 Cloud Native 时，有没有合适的学习资料之类的时，我会考虑如果你是有一定经验的开发者，并且对 Design Pattern 有一些了解，那么你非常适合这本来自微软 P &amp; P Group 的书 Cloud Design Patterns，虽然这本书很简单，实例也不多，但是更多的是启发性。我也是在 Cloud Design Pattern 这本书中学到了很多，sidecar 也是其中之一，并且我们写了很多很多 Sidecar 用于管理自己的 Service Mesh 。
为什么你需要 Sidecar？
非常简单，想象一下你要编写一堆 Web Service API，使用 JSON 作为数据格式暴露给前端，这个应用程序是用最常见的 Spring Boot 编写的，然后你要把他丢在你的虚拟机或者 k8s 上，你除了写代码，还需要考虑什么？</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/30/Sidecar.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/30/SOFA-MOSN.html" class="post-title-link">
      <h2>SOFA-MOSN</h2>
    </a>

    <div class="post-date">Nov 30, 2019</div>
    
    <div class="post-body">
      
      <p>SOFAMosn是基于Go开发的sidecar，用于service mesh中的数据面代理。
<img src="https://xiazemin.github.io/MyBlog/img/mson.webp" />
https://github.com/sofastack/sofa-mosn
https://github.com/sofastack/sofa-rpc
<!-- more -->
启动mosn形似./main start -c config.json，那么我们可以先从分析配置入手，看看mosn作为数据代理的整个流转过程。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/30/SOFA-MOSN.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/29/injector.html" class="post-title-link">
      <h2>injector</h2>
    </a>

    <div class="post-date">Nov 29, 2019</div>
    
    <div class="post-body">
      
      <p>1,反射中调用 函数
既然函数可以像普通的类型变量一样可以的话，那么在反射机制中就和不同的变量是一样的，在反射中 函数 和 方法 的类型（Type）都是 reflect.Func，如果要调用函数的话，可以通过 Value 的 Call() 方法
Value 的 Call() 方法的参数是一个 Value 的 slice，对应的反射函数类型的参数，返回值也是一个 Value 的 slice，同样对应反射函数类型的返回值。通过这个例子，相信你一看就明白了：
func prints(i int) string {
    fmt.Println(“i =”, i)
    return strconv.Itoa(i)
}</p>

<p>func main() {
    fv := reflect.ValueOf(prints)
    params := make([]reflect.Value, 1)                 // 参数
    params[0] = reflect.ValueOf(20)                    // 参数设置为20
    rs := fv.Call(params)                              // rs作为结果接受函数的返回值
    fmt.Println(“result:”, rs[0].Interface().(string)) // 当然也可以直接是 rs[0].Interface()
2,反射中调用 方法
函数和方法可以说其实本质上是相同的，只不过方法与一个“对象”进行了“绑定”，方法是“对象”的一种行为，这种行为是对于这个“对象”的一系列操作，例如修改“对象”的某个属性
Method 和 MethodByName 的API,
ype MyType struct {
    i    int
    name string
}</p>

<p>func (mt *MyType) SetI(i int) {
    mt.i = i
}</p>

<p>func (mt *MyType) SetName(name string) {
    mt.name = name
}</p>

<p>func (mt *MyType) String() string {
    return fmt.Sprintf(“%p”, mt) + “–name:” + mt.name + “ i:” + strconv.Itoa(mt.i)
}
func main() {
    myType := &amp;MyType{22, “golang”}
    //fmt.Println(myType)     // 就是检查一下myType对象内容
    //println(“—————”)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mtV := reflect.ValueOf(&amp;myType).Elem()
// 也可以使用
//mtV := reflect.ValueOf(myType)
 
 
fmt.Println("Before:", mtV.MethodByName("String").Call(nil)[0])
 
params := make([]reflect.Value, 1)
params[0] = reflect.ValueOf(18)
mtV.MethodByName("SetI").Call(params)
 
params[0] = reflect.ValueOf("reflection test")
mtV.MethodByName("SetName").Call(params)
 
fmt.Println("After:", mtV.MethodByName("String").Call(nil)[0]) } mtV := reflect.ValueOf(&amp;myType).Elem() fmt.Println("Before:",mtV.Method(2).Call(nil)[0]) params = make([]reflect.Value,1) params[0] = reflect.ValueOf(18) mtV.Method(0).Call(params) params[0] = reflect.ValueOf("reflection test") mtV.Method(1).Call(params) fmt.Println("After:",mtV.Method(2).Call(nil)[0]) &lt;!-- more --&gt; martini的整个框架的后台动力都是来自inject这个包，它其实是独立于框架的一个功能包，里面主要是运用了反射的技术来完成所需要的功能。我自己在学习或者接触一段新代码或者知识点的时候都会先直接找sample运行看跑的结果，所以下面先看一段代码及执行结果&lt;代码1&gt;：
</code></pre></div></div>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/29/injector.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/29/Martini.html" class="post-title-link">
      <h2>Martini</h2>
    </a>

    <div class="post-date">Nov 29, 2019</div>
    
    <div class="post-body">
      
      <p>先看看injector类型的声明：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/29/Martini.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/28/hijack.html" class="post-title-link">
      <h2>hijack</h2>
    </a>

    <div class="post-date">Nov 28, 2019</div>
    
    <div class="post-body">
      
      <p>https://golang.org/pkg/net/http/</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/28/hijack.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/28/gometalinter.html" class="post-title-link">
      <h2>gometalinter</h2>
    </a>

    <div class="post-date">Nov 28, 2019</div>
    
    <div class="post-body">
      
      <p>SonarQube 是一个开源的代码分析平台, 用来持续分析和评测项目源代码的质量。 通过SonarQube我们可以检测出项目中重复代码， 潜在bug， 代码风格问题，缺乏单元测试等问题， 并通过一个web ui展示出来。
<!-- more -->
gometalinter 简介
该工具基本上集成了目前市场上所有的检测工具，然后可以并发的帮你静态分析你的代码</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/28/gometalinter.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/28/HandleFunc.html" class="post-title-link">
      <h2>HandleFunc</h2>
    </a>

    <div class="post-date">Nov 28, 2019</div>
    
    <div class="post-body">
      
      <p>golang http的handle模块（一般也称为钩子模块），通过高级语言的匿名函数很容易实现这种内嵌功能的handle</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/28/HandleFunc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/27/mcache.html" class="post-title-link">
      <h2>Go内存原理详解</h2>
    </a>

    <div class="post-date">Nov 27, 2019</div>
    
    <div class="post-body">
      
      <p>代码经过预处理、编译、汇编、链接4步后生成一个可执行程序。
size xxx 可以查看程序各个分区大小
在没有运行程序前，也就是说程序没有加载到内存前，可执行程序内部已经分好三段信息，分别为代码区（text）、<strong>数据区（data）和未初始化数据区（bss）</strong>3 个部分。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/27/mcache.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/27/hijack.html" class="post-title-link">
      <h2>hijack</h2>
    </a>

    <div class="post-date">Nov 27, 2019</div>
    
    <div class="post-body">
      
      <p>type Hijacker interface {
	Hijack() (net.Conn, *bufio.ReadWriter, error)
}
//返回连接接口net.Conn和ReadWriter,bufio读写的
// Hijack lets the caller take over the connection. —–翻译Hijack让调用者管理连接</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/27/hijack.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/27/heap.html" class="post-title-link">
      <h2>heap</h2>
    </a>

    <div class="post-date">Nov 27, 2019</div>
    
    <div class="post-body">
      
      <p>http://goog-perftools.sourceforge.net/doc/tcmalloc.html
基于Go 1.13的。
当内存不再被使用时，标准库就会自动执行Go内存管理，即从内存分配到Go自己的集合中（from allocation of the memory to its collection）。
虽然开发人员不用去和这些打交道，但是Go的内存管理做了很多优化以及有很多有趣的概念，所以也值得我们去探讨与学习。
<!-- more -->
堆上的分配 Allocation on the heap
内存管理是在高并发环境以及集成了垃圾回收功能上所设计的。我们来演示一些简单的例子：
package main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/27/heap.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/27/graceful.html" class="post-title-link">
      <h2>gracefull</h2>
    </a>

    <div class="post-date">Nov 27, 2019</div>
    
    <div class="post-body">
      
      <p>过早地部署这种行为非常粗鲁，尤其是在部署时还要中断用户请求的情况下更是如此，因此，我们在Betable构建的Go服务要在不中断任何用户请求的情况下优雅地中止服务。其基本思想就是停止侦听（llistening），假定会有一个新的进程来接管这些侦听，让所有已经建立起来的连接在最终停止服务前继续处理进行中的请求。顺便说一句，我们采用了goagain，从而可以甚至在不停止侦听的情况下重启服务，但这个话题超出了本文的讨论范围。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/27/graceful.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/27/cgo.html" class="post-title-link">
      <h2>cgo</h2>
    </a>

    <div class="post-date">Nov 27, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/golang/go/wiki/cgo</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/27/cgo.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/27/ast.html" class="post-title-link">
      <h2>ast rewrite</h2>
    </a>

    <div class="post-date">Nov 27, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/fatih/astrewrite
http://goast.yuroyoro.net/
https://github.com/xdg-go/go-rewrap-errors
<!-- more -->
At work, my team decided to switch our codebase from pkg/errors to Go 1.13’s native error wrapping. We used to wrap our errors like this:</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/27/ast.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/27/Pkg-Config.html" class="post-title-link">
      <h2>Pkg-Config cgo</h2>
    </a>

    <div class="post-date">Nov 27, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/xlab/c-for-go</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/27/Pkg-Config.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/27/Deadline.html" class="post-title-link">
      <h2>Deadline</h2>
    </a>

    <div class="post-date">Nov 27, 2019</div>
    
    <div class="post-body">
      
      <p>package main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/27/Deadline.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/27/CFLAGS.html" class="post-title-link">
      <h2>CFLAGS</h2>
    </a>

    <div class="post-date">Nov 27, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/chai2010/advanced-go-programming-book/blob/master/ch2-cgo/ch2-02-basic.md
要使用CGO特性，需要安装C/C++构建工具链，在macOS和Linux下是要安装GCC，在windows下是需要安装MinGW工具。同时需要保证环境变量CGO_ENABLED被设置为1，这表示CGO是被启用的状态。在本地构建时CGO_ENABLED默认是启用的，当交叉构建时CGO默认是禁止的。比如要交叉构建ARM环境运行的Go程序，需要手工设置好C/C++交叉构建的工具链，同时开启CGO_ENABLED环境变量。然后通过import “C”语句启用CGO特性。
<!-- more -->
2.2.1 import “C”语句
如果在Go代码中出现了import “C”语句则表示使用了CGO特性，紧跟在这行语句前面的注释是一种特殊语法，里面包含的是正常的C语言代码。当确保CGO启用的情况下，还可以在当前目录中包含C/C++对应的源文件。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/27/CFLAGS.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/26/Deadline.html" class="post-title-link">
      <h2>Deadline</h2>
    </a>

    <div class="post-date">Nov 26, 2019</div>
    
    <div class="post-body">
      
      <p>https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/
https://colobu.com/2016/07/01/the-complete-guide-to-golang-net-http-timeouts/
当用Go写HTTP的服务器和客户端的时候，超时处理总是最易犯错和最微妙的地方之一。错误可能来自很多地方，一个错误可能等待很长时间没有结果，直到网络故障或者进程挂起。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/26/Deadline.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/26/CFLAGS.html" class="post-title-link">
      <h2>CFLAGS</h2>
    </a>

    <div class="post-date">Nov 26, 2019</div>
    
    <div class="post-body">
      
      <p>https://golang.org/cmd/cgo/
CFLAGS, CPPFLAGS, CXXFLAGS, FFLAGS and LDFLAGS may be defined with pseudo #cgo directives within these comments to tweak the behavior of the C, C++ or Fortran compiler. Values defined in multiple directives are concatenated together. The directive can include a list of build constraints limiting its effect to systems satisfying one of the constraints (see https://golang.org/pkg/go/build/#hdr-Build_Constraints for details about the constraint syntax). For example:</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/26/CFLAGS.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/25/tags.html" class="post-title-link">
      <h2>tags</h2>
    </a>

    <div class="post-date">Nov 25, 2019</div>
    
    <div class="post-body">
      
      <p>在某个项目需要支持多平台时，某个功能可能需要针对不同平台编写专属这个平台的具体实现。 在c/c++中，不同平台的实现或者某个平台的特性往往通过#if, #else, #endif这类预处理指令来配合 交叉编译达到。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/25/tags.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/24/libc.html" class="post-title-link">
      <h2>Go写的程序需不需要glibc</h2>
    </a>

    <div class="post-date">Nov 24, 2019</div>
    
    <div class="post-body">
      
      <p>go build编译时，CGO_ENABLED=1的，自动添加了一些动态库链接，所以编译时吧CGO_ENABLED=0就OK了
go 要求的编译工具gcc libc6-dev 一般系统都自带了如果没有自行安装。
<!-- more -->
Golang 程序如此大的一个原因是它全是静态链接的。如果能用到动态链接，可以让各个 Golang 程序共用一个标准库，大大减少 RAM 和 ROM 的使用
我尝试用 OpenWrt buildroot 编译带 Golang 支持的 GCC，在解决几个编译错误后终于编译出 gccgo 和 libgo.so 共享标准库
结果用 gccgo 编译 helloworld 时，在链接时找不到几个 setcontext 等符号，查了下才发现 musl libc 没有实现 ucontext……
得，又在 GitHub 上找了个 https://github.com/kaniini/libucontext （暂时没有 MIPS），编译好后在 gccgo 加上参数 -lucontext 终于不报错了，程序大小只有 10kB
把程序和几个共享库传到我的 ARM 上，ldd 好像没有问题</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/24/libc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/24/gdb.html" class="post-title-link">
      <h2>实现一个 Golang 调试器</h2>
    </a>

    <div class="post-date">Nov 24, 2019</div>
    
    <div class="post-body">
      
      <p>写这个系列的目的不是为了列出 Golang 编程语言的调试器的所有特性。如果你想看这些内容，可以看下 Delve。在这篇文章里我们试着去探索下调试器通常是怎样工作的，怎么在 Linux 上完成一个基本的调试，Linux 上比较关心 Golang 的功能，比如 goroutine 。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/24/gdb.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/24/dll.html" class="post-title-link">
      <h2>Golang生成动态库及调用</h2>
    </a>

    <div class="post-date">Nov 24, 2019</div>
    
    <div class="post-body">
      
      <p>目前go动态库的生产只支持Linux，Windows下会报这样的错误，<code class="highlighter-rouge">-buildmode=plugin not supported on windows/amd64</code>
CODE
plugin.so</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/24/dll.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/24/cgo.html" class="post-title-link">
      <h2>cgo 原理</h2>
    </a>

    <div class="post-date">Nov 24, 2019</div>
    
    <div class="post-body">
      
      <p>GO调C基本原理CGO是实现Go与C互操作的方式，包括Go调C和C调Go两个过程。其中Go调C的过程比较简单。对于一个在C中定义的函数add3，在Go中调用时需要显式的使用C.add3调用。其中C是在程序中引入的一个伪包
代码中的import “C”即为在Go中使用的伪包。这个包并不真实存在，也不会被Go的compile组件见到，它会在编译前被CGO工具捕捉到，并做一些代码的改写和桩文件的生成。
<!-- more -->
CGO 提供了 golang 和 C 语言相互调用的机制。某些第三方库可能只有 C/C++ 的实现，完全用纯 golang 的实现可能工程浩大，这时候 CGO 就派上用场了。可以通 CGO 在 golang 在调用 C 的接口，C++ 的接口可以用 C 包装一下提供给 golang 调用。被调用的 C 代码可以直接以源代码形式提供或者打包静态库或动态库在编译时链接。推荐使用静态库的方式，这样方便代码隔离，编译的二进制也没有动态库依赖方便发布也符合 golang 的哲学。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/24/cgo.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/24/LD_PRELOAD.html" class="post-title-link">
      <h2>golang 实现 LD_PRELOAD 拦截 libc</h2>
    </a>

    <div class="post-date">Nov 24, 2019</div>
    
    <div class="post-body">
      
      <p>https://blog.gopheracademy.com/advent-2015/libc-hooking-go-shared-libraries/
先把 socket() 的 libc 调用拦截下来
package main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/24/LD_PRELOAD.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/23/%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE.html" class="post-title-link">
      <h2>tcmalloc</h2>
    </a>

    <div class="post-date">Nov 23, 2019</div>
    
    <div class="post-body">
      
      <p>从堆上申请内存
Go内存管理的设计目标是在并发环境下保持高性能，并且集成垃圾回收器。让我们从一个简单的例子开始：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/23/%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/23/select.html" class="post-title-link">
      <h2>select</h2>
    </a>

    <div class="post-date">Nov 23, 2019</div>
    
    <div class="post-body">
      
      <p>定义：在golang里头select的功能与epoll(nginx)/poll/select的功能类似，都是坚挺IO操作，当IO操作发生的时候，触发相应的动作
<!-- more -->
1.1 一些使用规范
　　在Go的语言规范中，select中的case的执行顺序是随机的，当有多个case都可以运行，select会随机公平地选出一个执行，其他的便不会执行：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/23/select.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/23/pod.html" class="post-title-link">
      <h2>Kubernetes Pod 的实现原理</h2>
    </a>

    <div class="post-date">Nov 23, 2019</div>
    
    <div class="post-body">
      
      <p>Pod、Service、Volume 和 Namespace 是 Kubernetes 集群中四大基本对象，它们能够表示系统中部署的应用、工作负载、网络和磁盘资源，共同定义了集群的状态。Kubernetes 中很多其他的资源其实只对这些基本的对象进行了组合。
<!-- more -->
在接下来的几篇文章中我们将简单介绍 Kubernetes 中的四种基本对象中 Pod 并根据源代码分析它的作用和实现原理。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/23/pod.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/23/k3s.html" class="post-title-link">
      <h2>k3s</h2>
    </a>

    <div class="post-date">Nov 23, 2019</div>
    
    <div class="post-body">
      
      <p>2019年11月19日，业界应用最为广泛的Kubernetes管理平台创建者Rancher Labs（以下简称Rancher）在KubeCon2019北美峰会上宣布，Rancher打造的轻量级Kubernetes发行版k3s正式GA，这款产品专为在资源有限的环境设计，可以满足在边缘计算环境中、在小型设备上运行Kubernetes集群的需求。与此同时，极简MicroPaaS平台Rio也正式发布beta版本。Rio是一款创造性的Kubernetes应用部署引擎，它提供了一整套从运维到流水线的、已集成好的部署体验。
<!-- more -->
“Kubernetes已经成为容器编排的事实标准，”Rancher联合创始人及CEO梁胜表示：“k3s、Rio以及近期发布的Rancher v2.3，组合成了Rancher‘Kubernetes即服务（Kubernetes-as-a-service）’的整套解决方案堆栈，从数据中心到云到边缘端，为ITOps和DevOps团队提供了全新的Kubernetes使用方式。”</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/23/k3s.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/23/dubbo-go.html" class="post-title-link">
      <h2>dubbo-go</h2>
    </a>

    <div class="post-date">Nov 23, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/apache/dubbo-go
Apache Dubbo是由阿里开源的一个RPC框架，而dubbogo则是相对应的go语言版本：
<!-- more -->
	<img src="https://xiazemin.github.io/MyBlog/img/dubbo_go.webp" /></p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/23/dubbo-go.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/23/buildgo.html" class="post-title-link">
      <h2>build go src</h2>
    </a>

    <div class="post-date">Nov 23, 2019</div>
    
    <div class="post-body">
      
      <p>安装go只需要在官网(https://golang.org/dl/)下载适合系统的二进制发布包，按照安装说明进行安装即可。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/23/buildgo.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/23/bfe.html" class="post-title-link">
      <h2>bfe</h2>
    </a>

    <div class="post-date">Nov 23, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/baidu/bfe
BFE（Baidu Front End，百度统一前端）是百度的统一七层流量转发平台。BFE平台目前已覆盖百度大部分产品，每日转发请求接近 1 万亿，峰值 QPS 超过 1000万。在 2019 年百度春晚红包活动中，BFE 平台在超大用户压力、数次流量波峰下平稳运行，保证了春晚红包活动的顺利进行。
<!-- more -->
从曝光的资料来看，作为综合的流量转发平台，BFE 平台的主要服务包括四大块，分别是：
流量接入和转发：支持HTTP、HTTPS、HTTP/2、QUIC等多种协议，并支持强大的应用层路由能力
流量全局调度：支持由外网流量调度和内网流量调度共同构成的全局流量调度系统
安全和防攻击：支持黑名单封禁、精细限流和应用层防火墙（WAF）等多种防攻击能力
实时数据分析：支持分钟级的超高维度时序报表
作为 BFE 平台的核心组件，BFE 转发引擎从 2012 年开始研发，并于 2014 年使用 Go 语言完成重构。</p>

<p>BFE目前已开源并支持以下重要能力：
1、主流网络协议接入
支持HTTP/HTTPS/SPDY/HTTP2/WebSocket等
支持TLS/HTTP/ WebSocket反向代理模式
2、可扩展插件框架
通过可扩展插件框架，快速定制开发扩展模块，满足业务定制化需求
内置重写、重定向、流量修改、封禁等丰富插件
3、基于请求内容的分流
基于领域专有语言的分流规则，满足复杂业务场景定制化流量转发
支持完备的分流条件原语集，包括基于请求内容（URI/Header/Cookie等）以及请求上下文（IP、协议、标签、时间等）的条件原语。
4、灵活的负载均衡策略
支持集群级别负载均衡及实例级别负载均衡，实现多可用区容灾及过载保护
内置加权轮询、加权最小连接数策略，基于IP或请求内容识别用户实现会话保持</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/23/bfe.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/23/BigCache.html" class="post-title-link">
      <h2>BigCache</h2>
    </a>

    <div class="post-date">Nov 23, 2019</div>
    
    <div class="post-body">
      
      <p>加速并发访问
避免高额的GC开销</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/23/BigCache.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/19/build.html" class="post-title-link">
      <h2>build</h2>
    </a>

    <div class="post-date">Nov 19, 2019</div>
    
    <div class="post-body">
      
      <p>go build 的时候，我们写的源码文件究竟经历了哪些事情，最终变成了可执行文件？</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/19/build.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/17/gometalinter.html" class="post-title-link">
      <h2>gometalinter</h2>
    </a>

    <div class="post-date">Nov 17, 2019</div>
    
    <div class="post-body">
      
      <p>当然代码质量分析是devops中持续集成部分非常重要的一个环节。涉及到团队协作的时候，很多公司会有自己的一套规则，最熟悉的是阿里巴巴的java代码参考手册，专家总结，大家按照规则去写代码。但是对于devops，有了规则远远不够，还需要提高代码检查的自动化程度，以及与其他的环节合作衔接上。
那么如果没有代码质量把控这个环节，那么可能带来以下问题：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/17/gometalinter.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/uintptr.html" class="post-title-link">
      <h2>uintptr 临时变量gc风险</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>unsafe.Pointer
这个类型比较重要，它是实现定位和读写的内存的基础，Go runtime大量使用它。官方文档对该类型有四个重要描述：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/uintptr.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/sysmon.html" class="post-title-link">
      <h2>sysmon</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>为什么抢占式调度很重要
随着Go的一步步发展，它的调度器部分的实现也越来越好了。goroutine以前是严格意义上的coroutine，也就是协程。用户负责让各个goroutine交互合作完成任务。一个goroutine只有在涉及到加锁，读写通道等操作才会触发gorouine的yield。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/sysmon.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/scheduler.html" class="post-title-link">
      <h2>scheduler</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>Golang支持语言级别的并发，并发的最小逻辑单位叫做goroutine，goroutine就是Go为了实现并发提供的用户态线程，这种用户态线程是运行在内核态线程(OS线程)之上。当我们创建了大量的goroutine并且同时运行在一个或则多个内核态线程上时(内核线程与goroutine是m:n的对应关系)，就需要一个调度器来维护管理这些goroutine，确保所有的goroutine都有相对公平的机会使用CPU。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/scheduler.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/rate.html" class="post-title-link">
      <h2>time/rate</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>限流器是后台服务中的非常重要的组件，可以用来限制请求速率，保护服务，以免服务过载。
限流器的实现方法有很多种，例如滑动窗口法、Token Bucket、Leaky Bucket等。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/rate.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/pprof.html" class="post-title-link">
      <h2>pprof</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/google/pprof/pull/188
<!-- more -->
Last week me and my cool coworker Josh were debugging some memory problems in a Go program using pprof.</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/pprof.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/netpoll.html" class="post-title-link">
      <h2>netpoll</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>Go 基于 I/O multiplexing 和 goroutine 构建了一个简洁而高性能的原生网络模型(基于 Go 的 I/O 多路复用 netpoll)，提供了 goroutine-per-connection 这样简单的网络编程模式。在这种模式下，开发者使用的是同步的模式去编写异步的逻辑，极大地降低了开发者编写网络应用时的心智负担，且借助于 Go runtime scheduler 对 goroutines 的高效调度，这个原生网络模型不论从适用性还是性能上都足以满足绝大部分的应用场景。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/netpoll.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/ldflags.html" class="post-title-link">
      <h2>ldflags</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>在编译期通过ldflags 改变包级别可见变量的值
<!-- more -->
Introduction
When deploying applications into a production environment, building binaries with version information and other metadata will improve your monitoring, logging, and debugging processes by adding identifying information to help track your builds over time. This version information can often include highly dynamic data, such as build time, the machine or user building the binary, the Version Control System (VCS) commit ID it was built against, and more. Because these values are constantly changing, coding this data directly into the source code and modifying it before every new build is tedious and prone to error: Source files can move around and variables/constants may switch files throughout development, breaking the build process.</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/ldflags.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/gc.html" class="post-title-link">
      <h2>gc</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html
https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html
https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html
<!-- more -->
https://github.com/ardanlabs/gotraining/tree/master/topics/go/profiling/trace</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/gc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/bitset.html" class="post-title-link">
      <h2>bitset</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/willf/bitset
状态标志中元素个数通常是固定的。而一般的集合中，元素个数通常是动态变化的。这会导致什么问题？
一般，我们使用一个整数就足以表示状态标志中的所有状态，最大的 int64 类型，足足有 64 个二进制位，最多可以包含 64 个元素，完全足够使用。但如果是集合，元素数量和值通常都不固定。
比如一个 bitset 集合最初可能只包含 1、2、4 几个元素，只要一个 int64 就能表示。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/bitset.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/automaxprocs.html" class="post-title-link">
      <h2>automaxprocs</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>GC停顿经常超过100ms
现象
有同事反馈说, 最近开始试用公司的k8s, 部署在docker里的go进程有问题, 接口耗时很长, 而且还有超时. 逻辑很简单, 只是调用了kv存储, kv存储一般响应时间&lt;5ms, 而且量很少, 小于40qps, 该容器分配了0.5个核的配额, 日常运行CPU不足0.1个核. 
<!-- more -->
GC停顿经常超过100ms
现象
有同事反馈说, 最近开始试用公司的k8s, 部署在docker里的go进程有问题, 接口耗时很长, 而且还有超时. 逻辑很简单, 只是调用了kv存储, kv存储一般响应时间&lt;5ms, 而且量很少, 小于40qps, 该容器分配了0.5个核的配额, 日常运行CPU不足0.1个核.</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/automaxprocs.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/Token.html" class="post-title-link">
      <h2>Token</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>编译型语言（比如 Go）的源码要经过编译和链接才能转化为计算机可以执行的程序，这个过程的第一步就是词法分析。
什么是词法分析呢？
它就是将源代码转化为一个个预先定义的 token 的过程。为了便于理解，我们将其分为两个阶段进行介绍。
第一阶段，对源码串进行扫描，按预先定义的 token 规则进行匹配并切分为一个个有语法含义、最小单元的字符串，即词素（lexme），并在此基础上将其划归为某一类 token。这个阶段，一些字符可能会被过滤掉，比如，空白符、注释等。
第二阶段，通过评估器 Evaluator 评估扫描出来的词素，并确定它字面值，生成最终的 Token。
<!-- more -->
一个简单的示例
先看一段代码，经典的 hello world，如下：
package main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/Token.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/TCP.html" class="post-title-link">
      <h2>Go实现简单TCP扫描器</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>TCP是比我们介绍的要复杂的多，但是我们只介绍一点基础知识。TCP的握手有三个过程。首先，客户端发送一个 syn 的包，表示建立回话的开始。如果客户端收到超时，说明端口可能在防火墙后面，
第二，如果服务端应答 syn-ack 包，意味着这个端口是打开的，否则会返回 rst 包。最后，客户端需要另外发送一个 ack 包。从这时起，连接就已经建立。
<!-- more -->
我们TCP扫描器第一步先实现单个端口的测试。使用标准库中的 net.Dial 函数，该函数接收两个参数：协议和测试地址（带端口号）。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/TCP.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/Staticcheck.html" class="post-title-link">
      <h2>Staticcheck</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/dominikh/go-tools
<!-- more -->
oo often we discover subtle bugs only after deploying to production. Even in a language like Go it’s possible to write ineffectual code and not catch bugs until it’s too late.</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/Staticcheck.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/Recover.html" class="post-title-link">
      <h2>Panic/Recover Mechanism</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>https://go101.org/article/control-flows-more.html#panic-recover</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/Recover.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/16/Balancers.html" class="post-title-link">
      <h2>Balancers</h2>
    </a>

    <div class="post-date">Nov 16, 2019</div>
    
    <div class="post-body">
      
      <p>Load Balancers plays a key role in Web Architecture. They allow distributing load among a set of backends. This makes services more scalable. Also since there are multiple backends configured the service become highly available as load balancer can pick up a working server in case of a failure.</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/16/Balancers.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/12/jobexecuter.html" class="post-title-link">
      <h2>分布式任务队列</h2>
    </a>

    <div class="post-date">Nov 12, 2019</div>
    
    <div class="post-body">
      
      <p>https://queue.acm.org/detail.cfm?id=2745840
https://landing.google.com/sre/sre-book/chapters/distributed-periodic-scheduling/
https://constd.com/2019/08/21/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6Dkron%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/12/jobexecuter.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/12/compaction.html" class="post-title-link">
      <h2>etcd compaction</h2>
    </a>

    <div class="post-date">Nov 12, 2019</div>
    
    <div class="post-body">
      
      <p>做etcd数据镜像的时候出现如下错误  Error: etcdserver: mvcc: database space exceeded</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/12/compaction.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/12/Quartz.html" class="post-title-link">
      <h2>Quartz</h2>
    </a>

    <div class="post-date">Nov 12, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/quartz-scheduler/quartz
一、什么是Quartz
什么是Quartz?</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/12/Quartz.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/09/gotype.html" class="post-title-link">
      <h2>go 类型系统</h2>
    </a>

    <div class="post-date">Nov 9, 2019</div>
    
    <div class="post-body">
      
      <p>值语义和引用语义
       值语义和引用语义的差别在于赋值：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/09/gotype.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/08/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.html" class="post-title-link">
      <h2>内存分析</h2>
    </a>

    <div class="post-date">Nov 8, 2019</div>
    
    <div class="post-body">
      
      <p>golang pprof
当你的golang程序在运行过程中消耗了超出你理解的内存时，你就需要搞明白，到底是 程序中哪些代码导致了这些内存消耗。此时golang编译好的程序对你来说是个黑盒，该 如何搞清其中的内存使用呢？幸好golang已经内置了一些机制来帮助我们进行分析和追 踪。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/08/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/08/expvar.html" class="post-title-link">
      <h2>expvar</h2>
    </a>

    <div class="post-date">Nov 8, 2019</div>
    
    <div class="post-body">
      
      <p>go自带的runtime包拥有各种功能，包括goroutine数量，设置逻辑线程数量，当前go版本，当前系统类型等等。前两天发现了go标准库还有一个更好用的可以监控服务运行各项指标和状态的包—-expvar。 expvar包为监控变量提供了一个标准化的接口，它以 JSON 格式通过 /debug/vars 接口以 HTTP 的方式公开这些监控变量以及我自定义的变量。通过它，再加上metricBeat，ES和Kibana，可以很轻松的对服务进行监控。我这里是用gin把接口暴露出来，其实用别的web框架也都可以。下面我们来看一下如何使用它（示例代码使用GIN HTTP web framework）：
<!-- more -->
package main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/08/expvar.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/07/map.html" class="post-title-link">
      <h2>map 如何进行删除</h2>
    </a>

    <div class="post-date">Nov 7, 2019</div>
    
    <div class="post-body">
      
      <p>只要你的channel没有引用关系了，就算你没有close关闭或者chan有大量的堆积数据没有消费，最终会被gc释放。 通过runtime的memstats可以看到memory heap stats各个数据的状态。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/07/map.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/07/MemStats.html" class="post-title-link">
      <h2>MemStats 查询度量内存和GC使用</h2>
    </a>

    <div class="post-date">Nov 7, 2019</div>
    
    <div class="post-body">
      
      <p>top、ps等命令。这些监控内存使用情况的方法，一般需要编写脚本，执行脚本后将执行结果发送给对应的监控服务，从而达到监控的效果。但是golang自带的包却有一个runtime包，可以轻松获取服务运行时候的各种包括内存使用情况的信息。
使用linux命令，一般情况下只能看服务使用了多少内存。但是服务内存具体的使用情况缺无法获取。golang的runtime包可以做到获取服务总共使用主机多少内存，也可以获取服务已经申请了多少内存，以及内存的分布
<!-- more -->
runtime中和内存使用情况相关的结构体为runtime.MemStats，这个结构定义了golang运行过程中所有内存相关的信息，在源代码中定义如下：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/07/MemStats.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/07/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9E%E6%97%B6GC.html" class="post-title-link">
      <h2>Go语言的实时GC</h2>
    </a>

    <div class="post-date">Nov 7, 2019</div>
    
    <div class="post-body">
      
      <p>https://segmentfault.com/a/1190000010753702?_ea=2426880
https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/
<!-- more -->
Go语言能够支持实时的，高并发的消息系统，在高达百万级别的消息系统中能够将延迟降低到100ms以下，这一切很大一部分需要归功于Go的高效的垃圾回收系统。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/07/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9E%E6%97%B6GC.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/07/GCStats.html" class="post-title-link">
      <h2>GCStats</h2>
    </a>

    <div class="post-date">Nov 7, 2019</div>
    
    <div class="post-body">
      
      <p>package main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/07/GCStats.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/06/automaxprocs.html" class="post-title-link">
      <h2>automaxprocs</h2>
    </a>

    <div class="post-date">Nov 6, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/uber-go/automaxprocs
解析了cgroup文件系统
通过cpu.cfs_quota_us／cpu.cfs_period_us 得到cpu数量然后
通过runtime.GOMAXPROCS设置cpu数量
由于runtime.GOMAXPROCS 入参小于1的时候，不会修改，且返回原值。故比值小于1的时候，默认值用0，防止误修改</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/06/automaxprocs.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/05/sprintf.html" class="post-title-link">
      <h2>mt.Sprint(e) 死循环</h2>
    </a>

    <div class="post-date">Nov 5, 2019</div>
    
    <div class="post-body">
      
      <p>package main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/05/sprintf.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/04/string.html" class="post-title-link">
      <h2>字符串高效拼接</h2>
    </a>

    <div class="post-date">Nov 4, 2019</div>
    
    <div class="post-body">
      
      <p>在我们变成的时候，和字符串打交道是必不可少的，我们对数据库里文本的处理，Web文本的显示，文本数据的存储等都需要和字符串打交道，那么对于字符串来说，查找、拼接这些都是常用的操作，尤其是以拼接使用的比较多，比如把一个人的姓名和年龄拼接在一起显示。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/04/string.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/03/rate.html" class="post-title-link">
      <h2>time/rate</h2>
    </a>

    <div class="post-date">Nov 3, 2019</div>
    
    <div class="post-body">
      
      <p>限流器是后台服务中的非常重要的组件，可以用来限制请求速率，保护服务，以免服务过载。
限流器的实现方法有很多种，例如滑动窗口法、Token Bucket、Leaky Bucket等。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/03/rate.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/03/endless.html" class="post-title-link">
      <h2>endless</h2>
    </a>

    <div class="post-date">Nov 3, 2019</div>
    
    <div class="post-body">
      
      <p>当go语言开发的server应用已经在运行时，如果更新了代码，直接编译并运行，那么不好意思，端口已经在使用中：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/03/endless.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/02/url.html" class="post-title-link">
      <h2>net/url</h2>
    </a>

    <div class="post-date">Nov 2, 2019</div>
    
    <div class="post-body">
      
      <p>URL(Uniform Resource Locator) 统一资源定位符如何定义有一套完整的规范。URL 的使用需要注意什么，js 的 encodeURI 又做了哪些转义？学习 Golang 对于此规范的实现，有助于 Golang 的熟悉和对规范在实际应用中处于何种地位有至关重要的作用。
背景
URL 是连接用户与服务的媒介，通过 URL 你可以获取到你需要的资源。在编程的过程中，经常会使用到。通常使用起来也非常简单，基本没有什么问题。可是当涉及到转义及空格时，经常会引起莫名的问题。以 http 开头的为 URL 的字集。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/02/url.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/02/tcmalloc.html" class="post-title-link">
      <h2>tcmalloc</h2>
    </a>

    <div class="post-date">Nov 2, 2019</div>
    
    <div class="post-body">
      
      <p>在 Golang 里面有三个基本的概念：G, M, P。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/02/tcmalloc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/02/golangci-lint.html" class="post-title-link">
      <h2>golangci-lint</h2>
    </a>

    <div class="post-date">Nov 2, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/golangci/golangci-lint#macos
https://github.com/alecthomas/gometalinter
GolangCI-Lint是一个lint聚合器，它的速度很快，平均速度是gometalinter的5倍。它易于集成和使用，具有良好的输出并且具有最小数量的误报。而且它还支持go modules。最重要的是免费开源。
<!-- more -->
下面公司或者产品都使用了golangci-lint，例如：Google、Facebook、Red Hat OpenShift、Yahoo、IBM、Xiaomi、Samsung、Arduino、Eclipse Foundation、WooCart、Percona、Serverless、ScyllaDB、NixOS、The New York Times和Istio。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/02/golangci-lint.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/02/ginkgo.html" class="post-title-link">
      <h2>ginkgo BDD</h2>
    </a>

    <div class="post-date">Nov 2, 2019</div>
    
    <div class="post-body">
      
      <p>早期的TDD</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/02/ginkgo.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/02/Mesh.html" class="post-title-link">
      <h2>Service Mesh</h2>
    </a>

    <div class="post-date">Nov 2, 2019</div>
    
    <div class="post-body">
      
      <p>A Service Mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the Service Mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware.</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/02/Mesh.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/11/02/CodeReviewComments.html" class="post-title-link">
      <h2>如何写出高质量代码</h2>
    </a>

    <div class="post-date">Nov 2, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/golang/go/wiki/CodeReviewComments
Go 语言比较常见并且使用广泛的代码规范就是官方提供的 Go Code Review Comments，无论你是短期还是长期使用 Go 语言编程，都应该至少完整地阅读一遍这个官方的代码规范指南，它既是我们在写代码时应该遵守的规则，也是在代码审查时需要注意的规范。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/11/02/CodeReviewComments.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/31/victim.html" class="post-title-link">
      <h2>victim cache</h2>
    </a>

    <div class="post-date">Oct 31, 2019</div>
    
    <div class="post-body">
      
      <p>Go 1.13持续对 sync.Pool进行了改进，这里我们有两个简单的灵魂拷问：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/31/victim.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/31/ast.html" class="post-title-link">
      <h2>ast</h2>
    </a>

    <div class="post-date">Oct 31, 2019</div>
    
    <div class="post-body">
      
      <p>许多自动化代码生成工具都离不开语法树分析，例如goimport，gomock，wire等项目都离不开语法树分析。基于语法树分析，可以实现许多有趣实用的工具。
<!-- more -->
许多自动化代码生成工具都离不开语法树分析，例如goimport，gomock，wire等项目都离不开语法树分析。基于语法树分析，可以实现许多有趣实用的工具。本篇将结合示例，展示如何基于ast标准包操作语法树。
本篇中的代码的完整示例可以在这里找到：ast-example
Quick Start
首先我们看下语法树长什么样子，以下代码将打印./demo.go文件的语法树：
package main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/31/ast.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/31/Gourtines.html" class="post-title-link">
      <h2>Gourtines</h2>
    </a>

    <div class="post-date">Oct 31, 2019</div>
    
    <div class="post-body">
      
      <p>定义于src/runtime/runtime2.go:</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/31/Gourtines.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/31/Debugging.html" class="post-title-link">
      <h2>Debugging</h2>
    </a>

    <div class="post-date">Oct 31, 2019</div>
    
    <div class="post-body">
      
      <p>https://software.intel.com/en-us/blogs/2014/05/10/debugging-performance-issues-in-go-programs
<!-- more -->
Let’s assume you have a Go program and want to improve its performance. There are several tools available that can help with this task. These tools can help you to identify various types of hotspots (CPU, IO, memory), hotspots are the places that you need to concentrate on in order to significantly improve performance. However, another outcome is possible – the tools can help you identify obvious performance defects in the program. For example, you prepare an SQL statement before each query while you could prepare it once at program startup. Another example is if an O(N^2) algorithm somehow slipped into where an obvious O(N) exists and is expected. In order to identify such cases you need to sanity check what you see in profiles. For example for the first case significant time spent in SQL statement preparation would be the red flag.</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/31/Debugging.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/27/workerpool.html" class="post-title-link">
      <h2>workerpool</h2>
    </a>

    <div class="post-date">Oct 27, 2019</div>
    
    <div class="post-body">
      
      <p>fasthttp 的源码，其中读到了 workpool
<!-- more -->
ackage fasthttp</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/27/workerpool.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/27/WaitGroup.html" class="post-title-link">
      <h2>WaitGroup</h2>
    </a>

    <div class="post-date">Oct 27, 2019</div>
    
    <div class="post-body">
      
      <p>针对Golang 1.9的sync.WaitGroup进行分析，与Golang 1.10基本一样除了将panic改为了throw之外其他的都一样。 源代码位置：sync\waitgroup.go。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/27/WaitGroup.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/27/Cond.html" class="post-title-link">
      <h2>Cond</h2>
    </a>

    <div class="post-date">Oct 27, 2019</div>
    
    <div class="post-body">
      
      <p>cond的主要作用就是获取锁之后，wait()方法会等待一个通知，来进行下一步锁释放等操作，以此控制锁合适释放，释放频率,适用于在并发环境下goroutine的等待和通知。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/27/Cond.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/22/wait.html" class="post-title-link">
      <h2>Cmd.start, Cmd.Wait</h2>
    </a>

    <div class="post-date">Oct 22, 2019</div>
    
    <div class="post-body">
      
      <p>在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。
<!-- more -->
package main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/22/wait.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/19/Defer.html" class="post-title-link">
      <h2>Defer recover</h2>
    </a>

    <div class="post-date">Oct 19, 2019</div>
    
    <div class="post-body">
      
      <p>结构概览
defer
type _defer struct {
   siz     int32   // 参数的大小
   started bool    // 是否执行过了
   sp      uintptr // sp at time of defer
   pc      uintptr
   fn      *funcval 
   _panic  *_panic // defer中的panic
   link    *_defer // defer链表，函数执行流程中的defer，会通过 link这个 属性进行串联
}
panic
type _panic struct {
   argp      unsafe.Pointer // pointer to arguments of deferred call run during panic; cannot move - known to liblink
   arg       interface{}    // argument to panic
   link      *_panic        // link to earlier panic
   recovered bool           // whether this panic is over
   aborted   bool           // the panic was aborted
}
g
因为 defer panic 都是绑定在 运行的g上的，所以这里说明一下g中与 defer panic相关的属性</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/19/Defer.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/18/recover.html" class="post-title-link">
      <h2>recover</h2>
    </a>

    <div class="post-date">Oct 18, 2019</div>
    
    <div class="post-body">
      
      <p>https://draveness.me/golang/keyword/golang-panic-recover.html</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/18/recover.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/18/println.html" class="post-title-link">
      <h2>println</h2>
    </a>

    <div class="post-date">Oct 18, 2019</div>
    
    <div class="post-body">
      
      <p>package main
import “fmt”
func main() {
	defer println(“defer 1”)
	defer func() {
		fmt.Println(“defer2.1”)
		println(“defer2”)
	}()
	defer println(“defer3”)
}</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/18/println.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/16/Thrift.html" class="post-title-link">
      <h2>Thrift 源码</h2>
    </a>

    <div class="post-date">Oct 16, 2019</div>
    
    <div class="post-body">
      
      <p>Thrift之代码生成器Compiler这个功能是一个单独的工具程序，它会独立的生成一个可执行文件。
<!-- more -->
第一节 类关系图
类关系图如下所示：
<img src="https://xiazemin.github.io/MyBlog/img/thrift.png" />
注意：实线代表继承关系；而虚线代表依赖关系。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/16/Thrift.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/15/annotation.html" class="post-title-link">
      <h2>thrift annotation</h2>
    </a>

    <div class="post-date">Oct 15, 2019</div>
    
    <div class="post-body">
      
      <p>1,作为注释(desc=”errno”)
2，在 thrift idl 语法的基础上, 加入一些扩展的 annotation 字段, 用于指导生成 http 以及 thrift 下游服务的 sdk
3，根据不同语言加上不同的前缀来做区分, 比如 go.type, go.filed_name 等.
4，Go语言特有语法
不支持无符号标量类型，如uint64
字段类型codegen和字段标识关系：
require：对于标量类型，codegen代码为标量类型json注解没有omitempty
optional：对于标量类型，codegen代码为指针类型，json注解有omitemtpy
结构体
require和optional结构体都是指针类型、包含omitempty
slice、map
require和optional结构体都是非指针类型、包含omitempty。如果元素是struct，则struct不能是指针。
<!-- more -->
Golang内置了对RPC支持，但只能适用于go语言程序之间调用，且貌似序列化、反序列化性能不高。如果go语言能使用Thrift开发，那么就如虎添翼了。可惜，thrift虽然很早就包含了golang的代码，但一直都存在各种问题无法正确执行，以至于GitHub上有许多大牛小牛自行实现的Thrift代码</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/15/annotation.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/14/Buffer.html" class="post-title-link">
      <h2>bytes.Buffer</h2>
    </a>

    <div class="post-date">Oct 14, 2019</div>
    
    <div class="post-body">
      
      <p>Go标准库中的bytes.Buffer（下文用Buffer表示）类似于一个FIFO的队列，它是一个流式字节缓冲区。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/14/Buffer.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/13/atomic.html" class="post-title-link">
      <h2>atomic 原理</h2>
    </a>

    <div class="post-date">Oct 13, 2019</div>
    
    <div class="post-body">
      
      <p>在 Go 语言标准库中，sync/atomic包将底层硬件提供的原子操作封装成了 Go 的函数。但这些操作只支持几种基本数据类型，因此为了扩大原子操作的适用范围，Go 语言在 1.4 版本的时候向sync/atomic包中添加了一个新的类型Value。此类型的值相当于一个容器，可以被用来“原子地”存储（Store）和加载（Load）任意类型的值。
https://www.kancloud.cn/digest/batu-go/153537
https://docs.kilvn.com/The-Golang-Standard-Library-by-Example/chapter16/16.02.html
https://www.codingsky.com/codebook/gobasic/ch7/atomic.html
<!-- more -->
历史起源
我在golang-dev邮件列表中翻到了14年的这段讨论，有用户报告了encoding/gob包在多核机器上（80-core）上的性能问题，认为encoding/gob之所以不能完全利用到多核的特性是因为它里面使用了大量的互斥锁（mutex），如果把这些互斥锁换成用atomic.LoadPointer/StorePointer来做并发控制，那性能将能提升20倍。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/13/atomic.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/13/Mutex.html" class="post-title-link">
      <h2>Mutex</h2>
    </a>

    <div class="post-date">Oct 13, 2019</div>
    
    <div class="post-body">
      
      <p>https://www.cl.cam.ac.uk/research/srg/netos/papers/2007-cpwl.pdf
1、概念
        互斥锁（Mutex）是在原子操作API的基础上实现的信号量行为。互斥锁不能进行递归锁定或解锁，能用于交互上下文但是不能用于中断上下文，同一时间只能有一个任务持有互斥锁，而且只有这个任务可以对互斥锁进行解锁。当无法获取锁时，线程进入睡眠等待状态。
        互斥锁是信号量的特例。信号量的初始值表示有多少个任务可以同时访问共享资源，如果初始值为1，表示只有1个任务可以访问，信号量变成互斥锁（Mutex）。但是互斥锁和信号量又有所区别，互斥锁的加锁和解锁必须在同一线程里对应使用，所以互斥锁只能用于线程的互斥；信号量可以由一个线程释放，另一个线程得到，所以信号量可以用于线程的同步。
    2、数据结构
struct mutex {
	/* 1: unlocked, 0: locked, negative: locked, possible waiters <em>/
	atomic_t		count;
	spinlock_t		wait_lock;
	struct list_head	wait_list;
#if defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_MUTEX_SPIN_ON_OWNER)
	struct task_struct	*owner;
#endif
#ifdef CONFIG_MUTEX_SPIN_ON_OWNER
	struct optimistic_spin_queue osq; /</em> Spinner MCS lock */
#endif
#ifdef CONFIG_DEBUG_MUTEXES
	void			*magic;
#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	struct lockdep_map	dep_map;
#endif
};
        结构体成员说明：
        1、atomic_t count;
        指示互斥锁的状态：1 没有上锁，可以获得；0 被锁定，不能获得。初始化为没有上锁。
        2、spinlock_t wait_lock;
        等待获取互斥锁中使用的自旋锁。在获取互斥锁的过程中，操作会在自旋锁的保护中进行。初始化为为锁定。
        3、struct list_head wait_list;
        等待互斥锁的进程队列。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/13/Mutex.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/13/Jaeger.html" class="post-title-link">
      <h2>Jaeger</h2>
    </a>

    <div class="post-date">Oct 13, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/jaegertracing/jaeger
https://www.jaegertracing.io/docs/1.14/getting-started/
https://github.com/jaegertracing/jaeger-client-go
<!-- more -->
trace
Micro通过Wrapper实现了三种trace接口，aswxray,opencensus,opentracing,这里主要关注opentracing，opentracing已成为行业标准。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/13/Jaeger.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/13/GC.html" class="post-title-link">
      <h2>GC</h2>
    </a>

    <div class="post-date">Oct 13, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md
Go的垃圾回收官方形容为 非分代 非紧缩 写屏障 三色并发标记清理算法。
非分代：不像Java那样分为年轻代和年老代，自然也没有minor gc和maj o gc的区别。
非紧缩：在垃圾回收之后不会进行内存整理以清除内存碎片。
写屏障：在并发标记的过程中，如果应用程序（mutator）修改了对象图，就可能出现标记遗漏的可能，写屏障就是为了处理标记遗漏的问题。
三色：将GC中的对象按照搜索的情况分成三种：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/13/GC.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/13/Channel.html" class="post-title-link">
      <h2>Channel</h2>
    </a>

    <div class="post-date">Oct 13, 2019</div>
    
    <div class="post-body">
      
      <p>Channel 是 Go 语言的主要同步和通信原语，它们必须速度快且可扩展。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/13/Channel.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/12/statsd.html" class="post-title-link">
      <h2>statsd</h2>
    </a>

    <div class="post-date">Oct 12, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/statsd/statsd
https://github.com/smira/go-statsd</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/12/statsd.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/12/runtimematrics.html" class="post-title-link">
      <h2>runtime matrics</h2>
    </a>

    <div class="post-date">Oct 12, 2019</div>
    
    <div class="post-body">
      
      <p>自从Go 1.5开始，每次Go release, Gopher Brian Hatfield都会将自己对新版Go的runtime的性能数据（与之前Go版本的比较）在twitter上晒出来。就连Go team staff在世界各地做speaking时也在slide中引用Brian的图片。后来，Brian Hatfield将其用于度量runtime性能数据的代码打包成library并放在github上开源了，我们也可以使用这个library来建立我们自己的Go Runtime metrics设施了。这里简要说一下搭建的步骤。
https://github.com/bmhatfield/go-runtime-metrics
http://graphiteapp.org/
https://github.com/statsd/statsd
<!-- more -->
Brian Hatfield的go-runtime-metrics library实现的很简单，其runtime data来自于Go runtime package中的MemStats、NumGoroutine和NumCgoCall等。被测试目标程序只需要import该library即可输出runtime states数据：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/12/runtimematrics.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/12/gomatrix.html" class="post-title-link">
      <h2>gomatrix</h2>
    </a>

    <div class="post-date">Oct 12, 2019</div>
    
    <div class="post-body">
      
      <p>Metrics本来是一个Java库, 捕获JVM和应用程序级指标。也就是说可以获得代码级别的数据指标，比如方法调用了多少次之类。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/12/gomatrix.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/12/falcon.html" class="post-title-link">
      <h2>open-falcon</h2>
    </a>

    <div class="post-date">Oct 12, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/g4zhuj/go-metrics-falcon
https://github.com/open-falcon/falcon-plus
指标统计是实现APM（Application performance management)的基础，通常通过一些指标的统计以及上报，我们可以了解程序的运行状况，及时发现程序的问题，提前预估系统瓶颈．
指标(metric)目前的实现有metrics,这是java的实现，可以直接引入程序作为库使用．go语言的实现见go-metrics.
另外，这里只是将指标在内存中进行处理及计算，如果我们想要展示，需要将数据抛出来，这里可以抛到日志里，也可以抛到时序数据库，最简单的做法就是直接抛到监控系统进行绘图或者报警．
<!-- more -->
2.指标统计方式
2.1 Meters
用于计算一段时间内的计量，通常用于计算接口调用频率，如QPS(每秒的次数)，主要分为rateMean,Rate1/Rate5/Rate15等指标．</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/12/falcon.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/12/atomic.html" class="post-title-link">
      <h2>golang atomic包</h2>
    </a>

    <div class="post-date">Oct 12, 2019</div>
    
    <div class="post-body">
      
      <p>go语言提供的原子操作都是非侵入式的，它们由标准库代码包sync/atomic中的众多函数代表。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/12/atomic.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/11/ratelimit.html" class="post-title-link">
      <h2>ratelimit</h2>
    </a>

    <div class="post-date">Oct 11, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/didip/tollbooth</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/11/ratelimit.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/10/select.html" class="post-title-link">
      <h2>select</h2>
    </a>

    <div class="post-date">Oct 10, 2019</div>
    
    <div class="post-body">
      
      <p>select为golang提供了多路IO复用机制，和其他IO复用一样，用于检测是否有读写事件是否ready。
golang 的 select 的功能和 select, poll, epoll 相似， 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/10/select.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/10/runtime.html" class="post-title-link">
      <h2>runtime</h2>
    </a>

    <div class="post-date">Oct 10, 2019</div>
    
    <div class="post-body">
      
      <p>http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf
Runtime管理任务调度，垃圾收集及运行环境。大家知道Go语言程序是编译为机器代码来执行的。同时，Go提供了一些高级的功能，如goroutine, channel, 以及Garbage collection。这些高级功能需要一个runtime的支持。1.4之前，runtime还是由C语言所编写的，（按照Go dev team的规划，1.5版本将去除C的代码，runtime将完全由Go语言来完成。）不论何种方式，runtime和用户编译后的代码被linker静态链接起来，形成一个可执行文件。这个文件从操作系统角度来说是一个user space的独立的可执行文件。
<!-- more -->
<img src="https://xiazemin.github.io/MyBlog/img/runtime.png" />
从运行的角度来说，这个文件由2部分组成，一部分是用户的代码，另一部分就是runtime。runtime通过接口函数调用来管理goroutine, channel及其他一些高级的功能。从用户代码发起的调用操作系统API的调用都会被runtime拦截并处理。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/10/runtime.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/10/rpc.html" class="post-title-link">
      <h2>rpc</h2>
    </a>

    <div class="post-date">Oct 10, 2019</div>
    
    <div class="post-body">
      
      <p>https://www.openapis.org/
https://github.com/OAI/OpenAPI-Specification/issues
https://www.jsonrpc.org/specification
https://www.grpc.io/docs/guides/concepts/</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/10/rpc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/10/router.html" class="post-title-link">
      <h2>HTTP路由</h2>
    </a>

    <div class="post-date">Oct 10, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/gin-gonic/gin
https://github.com/julienschmidt/httprouter
https://github.com/julienschmidt/go-http-routing-benchmark</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/10/router.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/10/radix_router.html" class="post-title-link">
      <h2>radix tree router</h2>
    </a>

    <div class="post-date">Oct 10, 2019</div>
    
    <div class="post-body">
      
      <p>golang的web框架echo和gin都使用了radix tree作为路由查找的算法
https://github.com/labstack/echo
https://github.com/gin-gonic/gin
<!-- more -->
在gin的路由中，每一个Http Method(GET, PUT, POST…)都对应了一棵 radix tree</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/10/radix_router.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/10/netstack.html" class="post-title-link">
      <h2>netstack</h2>
    </a>

    <div class="post-date">Oct 10, 2019</div>
    
    <div class="post-body">
      
      <p>使用 Go 语言编写的网络协议栈。
https://github.com/google/netstack</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/10/netstack.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/10/gops.html" class="post-title-link">
      <h2>gops</h2>
    </a>

    <div class="post-date">Oct 10, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/google/gops
一个用于列出和诊断分析系统中正在运行的 Go 程序的命令行工具,Google 自己出品的</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/10/gops.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/10/go_radix.html" class="post-title-link">
      <h2>go_radix</h2>
    </a>

    <div class="post-date">Oct 10, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/armon/go-radix
https://github.com/Kentik/patricia
作为一个基数树，它提供以下内容：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/10/go_radix.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/10/gRpc.html" class="post-title-link">
      <h2>gRpc</h2>
    </a>

    <div class="post-date">Oct 10, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/grpc/grpc-go
http://doc.oschina.net/grpc?t=58009
服务定义
正如其他 RPC 系统，gRPC 基于如下思想：定义一个服务， 指定其可以被远程调用的方法及其参数和返回类型。gRPC 默认使用 protocol buffers 作为接口定义语言，来描述服务接口和有效载荷消息结构。如果有需要的话，可以使用其他替代方案。
gRPC 允许你定义四类服务方法：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/10/gRpc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/10/expvar.html" class="post-title-link">
      <h2>expvar</h2>
    </a>

    <div class="post-date">Oct 10, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/astaxie/gopkg</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/10/expvar.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/09/gobreaker.html" class="post-title-link">
      <h2>gobreaker</h2>
    </a>

    <div class="post-date">Oct 9, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/sony/gobreaker
<!-- more -->
看了一下go-kit，发现这个微服务框架的熔断器，也是使用sony开源的作为基础。 sony开源在 github 的熔断器 在源代头注释中发现，原来sony实现的是微软2015时公布的CircuitBreaker标准，果然微软才开源界的大神。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/09/gobreaker.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/09/go-kit.html" class="post-title-link">
      <h2>go-kit</h2>
    </a>

    <div class="post-date">Oct 9, 2019</div>
    
    <div class="post-body">
      
      <p>“Go kit”是一种开源的微服务工具箱，可以用在现代企业应用程序栈中促进和规范化基于 Go 服务的创建。
https://github.com/go-kit/kit
https://gokit.io/
相似的还有
gizmo, a microservice toolkit from The New York Times ★
go-micro, a microservices client/server library ★
gotalk, async peer communication protocol &amp; library
Kite, a micro-service framework
gocircuit, dynamic cloud orchestration
<!-- more -->
gokit就是一个go语言相关的微服务工具包。它自身称为toolkit，并不是framework。也就是gokit是将一系列的服务集合在一起，提供接口，从而让开发者自由组合搭建自己的微服务项目</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/09/go-kit.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/10/09/Prometheus.html" class="post-title-link">
      <h2>Prometheus</h2>
    </a>

    <div class="post-date">Oct 9, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/prometheus/prometheus
Prometheus是由SoundCloud开发的开源监控报警系统和时序列数据库(TSDB)。Prometheus使用Go语言开发，是Google BorgMon监控系统的开源版本。
2016年由Google发起Linux基金会旗下的原生云基金会(Cloud Native Computing Foundation), 将Prometheus纳入其下第二大开源项目。
Prometheus目前在开源社区相当活跃。
Prometheus和Heapster(Heapster是K8S的一个子项目，用于获取集群的性能数据。)相比功能更完善、更全面。Prometheus性能也足够支撑上万台规模的集群。
<!-- more -->
Prometheus的特点
多维度数据模型。
灵活的查询语言。
不依赖分布式存储，单个服务器节点是自主的。
通过基于HTTP的pull方式采集时序数据。
可以通过中间网关进行时序列数据推送。
通过服务发现或者静态配置来发现目标服务对象。
支持多种多样的图表和界面展示，比如Grafana等。
官网地址：https://prometheus.io/
<img src="https://xiazemin.github.io/MyBlog/img/prometheus.png" /></p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/10/09/Prometheus.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/28/heatbeat.html" class="post-title-link">
      <h2>heatbeat</h2>
    </a>

    <div class="post-date">Sep 28, 2019</div>
    
    <div class="post-body">
      
      <p>心跳处理的必要性：
服务端需要同时处理上千甚至上万的客户端的连接，所以每个连接资源都是很宝贵的，当客户端断开连接的时候服务端应该及时移除该连接。
正常情况下，客户端断开连接的时候，会和服务端进行四次挥手，服务端就会知道这个连接 已经不能用了优雅的退出监听消息。但是总会有意外，比如客户端忽然断网了，没电了，这个时候客户端肯定不可能按照流程和 服务端进行挥手，不知道消息的 服务端还傻傻的在哪儿等着，不知道客户端早就走了。
这个时候 心跳包就很完美的解决了此问题。客户端和服务端约定好每隔一段时间 就会发消息，如果服务端每过一段时间没有收到客户端 的心跳消息 就说明 客户端出事了，服务端就删除此连接，确保 资源最大化。
一般心跳包就是 符合该协议的 最小包。
<!-- more -->
一般的go语言框架都是一个连接单独开一个协程 去处理读取超时问题
当协程数量多到一定程度的时候，协程之间的调度也是一个很大的 消耗
一个协程 进行 心跳检测。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/28/heatbeat.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/28/etcd.html" class="post-title-link">
      <h2>etcd</h2>
    </a>

    <div class="post-date">Sep 28, 2019</div>
    
    <div class="post-body">
      
      <p>加上一台服务器，然后 修改网关服务器的配置表 加上 新加的 服务器的IP 和端口，然后重启网关。还有就是 当 后面的 服务器万一 down 了，网关是不知道的，还会把 流量转发到 down的 服务器上，造成 服务的不可用。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/28/etcd.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/27/slot.html" class="post-title-link">
      <h2>slot map redis 槽映射</h2>
    </a>

    <div class="post-date">Sep 27, 2019</div>
    
    <div class="post-body">
      
      <p>Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/27/slot.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/27/hystrix.html" class="post-title-link">
      <h2>hystrix</h2>
    </a>

    <div class="post-date">Sep 27, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/afex/hystrix-go/
分布式系统中经常会出现某个基础服务不可用造成整个系统不可用的情况, 这种现象被称为服务雪崩效应. 为了应对服务雪崩, 一种常见的做法是手动服务降级. 而Hystrix的出现,给我们提供了另一种选择.
<!-- more -->
我把服务雪崩的参与者简化为 服务提供者 和 服务调用者, 并将服务雪崩产生的过程分为以下三个阶段来分析形成的原因:</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/27/hystrix.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/27/hash.html" class="post-title-link">
      <h2>一致性hash golang 实现</h2>
    </a>

    <div class="post-date">Sep 27, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/xiazemin/balance/tree/master/balance/balance</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/27/hash.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/27/gomacro.html" class="post-title-link">
      <h2>gomacro</h2>
    </a>

    <div class="post-date">Sep 27, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/micro/go-micro
https://www.kancloud.cn/linimbus/go-micro/529018
go-micro是基于Go语言实现的插件化RPC微服务框架，与go-kit，kite等微服务框架相比，它具有易上手、部署简单、工具插件化等优点。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/27/gomacro.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/27/gokit.html" class="post-title-link">
      <h2>Go-kit 熔断器</h2>
    </a>

    <div class="post-date">Sep 27, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/go-kit/kit
服务雪崩效应
原因：由于延时或负载过高等导致请求积压，占用大量系统资源，服务器达到性能瓶颈，服务提供者不可用
现象：上游服务故障导致下游服务瘫痪，出现连锁故障
应对策略
扩容
控制流量
熔断
服务降级
<!-- more -->
熔断器
以开关的模式实现，监控服务请求和响应的情况，当出现异常时, 快速给后续请求返回结果, 避免大量的同步等待</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/27/gokit.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/27/gateway.html" class="post-title-link">
      <h2>如何设计一个亿级网关</h2>
    </a>

    <div class="post-date">Sep 27, 2019</div>
    
    <div class="post-body">
      
      <p>1.1 什么是API网关</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/27/gateway.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/27/etcd.html" class="post-title-link">
      <h2>etcd实现服务发现机制</h2>
    </a>

    <div class="post-date">Sep 27, 2019</div>
    
    <div class="post-body">
      
      <p>构建高可用、高性能的通信服务，通常采用服务注册与发现、负载均衡和容错处理等机制实现。根据负载均衡实现所在的位置不同，通常可分为以下三种解决方案：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/27/etcd.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/27/Consul.html" class="post-title-link">
      <h2>Consul</h2>
    </a>

    <div class="post-date">Sep 27, 2019</div>
    
    <div class="post-body">
      
      <p>https://book-consul-guide.vnzmi.com/
服务发现 Consul的客户端可用提供一个服务,比如 api 或者mysql ,另外一些客户端可用使用Consul去发现一个指定服务的提供者.通过DNS或者HTTP应用程序可用很容易的找到他所依赖的服务.
健康检查 Consul客户端可用提供任意数量的健康检查,指定一个服务(比如:webserver是否返回了200 OK 状态码)或者使用本地节点(比如:内存使用是否大于90%). 这个信息可由operator用来监视集群的健康.被服务发现组件用来避免将流量发送到不健康的主机.
Key/Value存储 应用程序可用根据自己的需要使用Consul的层级的Key/Value存储.比如动态配置,功能标记,协调,领袖选举等等,简单的HTTP API让他更易于使用.
多数据中心: Consul支持开箱即用的多数据中心.这意味着用户不需要担心需要建立额外的抽象层让业务扩展到多个区域.
<!-- more -->
在利用go micro来实现服务发现便利很多，micro中默认支持使用 Consul 来做服务发现，当然它使用插件机制（go-plugins）还支持 Etcd, Gossip, NATS等其他的第三方服务注册发现工具。在每个服务启动的时候，都将自己注册到registry上，退出时也自动解注册</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/27/Consul.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/26/spf13-vim.html" class="post-title-link">
      <h2>spf13-vim</h2>
    </a>

    <div class="post-date">Sep 26, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/spf13/spf13-vim
spf13(Steve Francia)可是一个牛人。spf13是大名鼎鼎的开源项目Docker和MongoDB的Chief Operator，另外他还是spf13-vim, Hugo, Cobra &amp; Viper等开源项目的作者。能和这样的牛人交流学习，是一种不错的体验。他的博客地址：http://spf13.com
<!-- more -->
spf13-vim is a distribution of vim plugins and resources for Vim, Gvim and MacVim.</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/26/spf13-vim.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/26/jsoniter.html" class="post-title-link">
      <h2>jsoniter</h2>
    </a>

    <div class="post-date">Sep 26, 2019</div>
    
    <div class="post-body">
      
      <p>soniter（json-iterator）是一款快且灵活的 JSON 解析器；从 dsljson和 jsonparser 借鉴了大量代码。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/26/jsoniter.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/26/hugo.html" class="post-title-link">
      <h2>hugo</h2>
    </a>

    <div class="post-date">Sep 26, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/gohugoio/hugo
<!-- more -->
Hugo增加了内置的Jekyll迁移工具。这样之前的Jekyll用户可以通过一个简单的命令就可以将网站转化成Hugo站点：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/26/hugo.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/26/flag.html" class="post-title-link">
      <h2>pflag flag</h2>
    </a>

    <div class="post-date">Sep 26, 2019</div>
    
    <div class="post-body">
      
      <p>定义flags
import “flag”</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/26/flag.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/26/ffjson.html" class="post-title-link">
      <h2>ffjson</h2>
    </a>

    <div class="post-date">Sep 26, 2019</div>
    
    <div class="post-body">
      
      <p>ffjson 为Go中的结构生成 static MarshalJSON 和 UnmarshalJSON 函数。 生成的函数减少了对运行时反射进行序列化的依赖，通常是 2到 3倍。 在 ffjson 不理解类型的情况下，它返回 encoding/json，意味着它是一个安全的替代方法。 通过使用 ffjson，你的JSON序列化就变得更快，无需额外的代码更改。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/26/ffjson.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/26/cobra_detail.html" class="post-title-link">
      <h2>cobra detail</h2>
    </a>

    <div class="post-date">Sep 26, 2019</div>
    
    <div class="post-body">
      
      <p>Cobra是一个库，其提供简单的接口来创建强大现代的CLI接口，类似于git或者go工具。同时，它也是一个应用，用来生成个人应用框架，从而开发以Cobra为基础的应用。Docker源码中使用了Cobra。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/26/cobra_detail.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/26/cobra.html" class="post-title-link">
      <h2>cobra</h2>
    </a>

    <div class="post-date">Sep 26, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/spf13/cobra
 https://github.com/xiazemin/cobra
 Cobra提供的功能
简易的子命令行模式，如 app server， app fetch等等
完全兼容posix命令行模式
嵌套子命令subcommand
支持全局，局部，串联flags
使用Cobra很容易的生成应用程序和命令，使用cobra create appname和cobra add cmdname
如果命令输入错误，将提供智能建议，如 app srver，将提示srver没有，是否是app server
自动生成commands和flags的帮助信息
自动生成详细的help信息，如app help
自动识别-h，–help帮助flag
自动生成应用程序在bash下命令自动完成功能
自动生成应用程序的man手册
命令行别名
自定义help和usage信息
可选的紧密集成的viper apps
<!-- more -->
cobra init github.com/xiazemin/cobra/myapp
Error: required flag(s) “pkg-name” not set
Usage:
  cobra init [name] [flags]</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/26/cobra.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/26/Modules.html" class="post-title-link">
      <h2>Modules</h2>
    </a>

    <div class="post-date">Sep 26, 2019</div>
    
    <div class="post-body">
      
      <p>用 go get 获取依赖其实是有潜在危险的，因为我们不确定最新版依赖是否会破坏掉我们项目对依赖包的使用方式，即当前项目可能会出现不兼容最新依赖包的问题。之后官方出了一个 vendor 机制，将项目依赖的包都放在该目录中，但这也并没有很好地管理依赖的版本。之后官方出了一个准官方版本管理工具 go dep，这也算是 go modules 的前身了吧。随着 Go1.11 的发布，Golang 给我们带来了 module 全新特性，这是 Golang 新的一套依赖管理系统。现在 Go1.12 已经发布了，go modules 进一步稳定，但官方还是没有将其设为默认机制
<!-- more -->
创建 module
创建项目
在默认情况下，$GOPATH 默认情况下是不支持 go mudules 的，我们需要在项目目录下手动执行以下命令：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/26/Modules.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/25/json.html" class="post-title-link">
      <h2>json</h2>
    </a>

    <div class="post-date">Sep 25, 2019</div>
    
    <div class="post-body">
      
      <p>Golang的结构体可以增加类似于Java里面@JsonProperty(“id”)注释。在结构体里面通过反引号包含的字符串被称为Tag。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/25/json.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/25/dwarf.html" class="post-title-link">
      <h2>dwarf</h2>
    </a>

    <div class="post-date">Sep 25, 2019</div>
    
    <div class="post-body">
      
      <p>dwarf调试信息格式，内容包括有哪些类型的调试信息，调试信息的存放格式、某些调试信息的编码方法等。
在使用gcc编译程序的时候，加上-g参数，那么最后生成的目标文件中会有调试信息，调试信息格式使用dwarf2格式。使用readelf工具加上-S参数，可以查看目标文件中有哪些调试信息section</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/25/dwarf.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/23/https.html" class="post-title-link">
      <h2>https</h2>
    </a>

    <div class="post-date">Sep 23, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/xiazemin/rsa</p>

<p>openssl genrsa -out server.key 2048</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/23/https.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/22/rand.html" class="post-title-link">
      <h2>rand 随机数</h2>
    </a>

    <div class="post-date">Sep 22, 2019</div>
    
    <div class="post-body">
      
      <p>package main</p>

<p>import (
    “fmt”
    “math/rand”
)</p>

<p>func main() {
    fmt.Println(“My first lucky number is”, rand.Intn(10))
    fmt.Println(“My senond lucky number is”, rand.Intn(10))
}
不论编译运行多少次，都是这个输出。
此程序的运行环境是固定的，因此 rand.Intn 总是会返回相同的数字。 （要得到不同的数字，需为生成器提供不同的种子数）
<!-- more -->
package main</p>

<p>import (
    “fmt”
    “math/rand”
    “time”
)</p>

<p>func main() {
    rand.Seed(time.Now().Unix())
    fmt.Println(“My first lucky number is”, rand.Intn(10))
    fmt.Println(“My senond lucky number is”, rand.Intn(10))
}</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/22/rand.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/21/golang.html" class="post-title-link">
      <h2>golang 1.13</h2>
    </a>

    <div class="post-date">Sep 21, 2019</div>
    
    <div class="post-body">
      
      <p>Go SDK 1.13之前，很多可以安全地开辟在栈上的内存因为编译器中的逃逸分析器不够智能的原因而被开辟在了堆上。这在一定程度上影响了程序执行效率。从Go SDK 1.13开始，标准编译器将采用一个新的逃逸分析器，从而将避免很了多不必要的在堆上开辟内存的情况。
<!-- more -->
Go SDK 1.13之前，所有的defer延迟调用都是记录在堆上的，这严重影响了defer延迟调用的执行效率。从Go SDK 1.13开始，满足某些条件的某些defer延迟调用（标准库中93%的延迟调用满足此条件）将被记录在栈上而不是堆上，从而提高了defer延迟调用的执行效率。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/21/golang.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/15/req.html" class="post-title-link">
      <h2>Go 函数调用━栈和寄存器视角</h2>
    </a>

    <div class="post-date">Sep 15, 2019</div>
    
    <div class="post-body">
      
      <p>函数的调用过程主要要点在于借助寄存器和内存帧栈传递参数和返回值。虽然同为编译型语言，Go 相较 C 对寄存器和栈的使用有一些差别，同时，Go 语言自带协程并引入 defer 等语句，在调用过程上显得更加复杂。 理解Go函数调用在CPU指令层的过程有助于编写高效的代码，在性能优化、Bug排查的时候，能更迅速的确定要点。本文以简短的示例代码和对应的汇编代码演示了Go的调用过程，展示了不同数据类型的参数的实际传递过程，同时分析了匿名函数、闭包作为参数或者返回值传递时，在内存上的实际数据结构。对于协程对栈的使用和实现细节，本文不展开。
<!-- more -->
术语
栈：每个进程/线程/goroutine有自己的调用栈，参数和返回值传递、函数的局部变量存放通常通过栈进行。和数据结构中的栈一样，内存栈也是后进先出，地址是从高地址向低地址生长。
栈帧：（stack frame）又常被称为帧（frame）。一个栈是由很多帧构成的，它描述了函数之间的调用关系。每一帧就对应了一次尚未返回的函数调用，帧本身也是以栈的形式存放数据的。
caller 调用者
callee 被调用者，如在 函数 A 里 调用 函数 B，A 是 caller，B 是 callee
寄存器(X86)</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/15/req.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/15/call.html" class="post-title-link">
      <h2>golang 函数调用汇编</h2>
    </a>

    <div class="post-date">Sep 15, 2019</div>
    
    <div class="post-body">
      
      <p>func add(a, b int) int {
    return a + b
}
通过 go build -gcflags ‘-N -l’，我们禁用了编译优化，以使生成的汇编代码更加容易读懂。然后我们就可以用 go 工具 objdump -s main.add func （func是我们用的包名，也是 go build 生成的可执行文件的名称），将这个函数对应的汇编代码导出来。
<!-- more -->
main.go:20 0x22c0 48c744241800000000 MOVQ $0x0, 0x18(SP)
main.go:21 0x22c9 488b442408  MOVQ 0x8(SP), AX
main.go:21 0x22ce 488b4c2410  MOVQ 0x10(SP), CX
main.go:21 0x22d3 4801c8   ADDQ CX, AX
main.go:21 0x22d6 4889442418  MOVQ AX, 0x18(SP)
main.go:21 0x22db c3   RET</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/15/call.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/14/interface.html" class="post-title-link">
      <h2>interface</h2>
    </a>

    <div class="post-date">Sep 14, 2019</div>
    
    <div class="post-body">
      
      <p> interface(接口)是golang最重要的特性之一，Interface类型可以定义一组方法，但是这些不需要实现。请注意：此处限定是一组方法，既然是方法，就不能是变量；而且是一组，表明可以有多个方法。再多声明一点，interface本质上是一种类型，确切的说，是指针类型，此处暂且不多表，后文中自然能体会到。
  interface是为实现多态功能，多态是指代码可以根据类型的具体实现采取不同行为的能力。如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/14/interface.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/12/test.html" class="post-title-link">
      <h2>go test Build 缓存</h2>
    </a>

    <div class="post-date">Sep 12, 2019</div>
    
    <div class="post-body">
      
      <p>go 在 1.10 版本中引入了 go tool 的缓存，此功能会缓存 go test执行的结果。 每当执行 go test 时，如果功能代码和测试代码没有变动，则在下一次执行时，会直接读取缓存中的测试结果。 而且 go test -v . 和 go test .是分开缓存的。
<!-- more -->
我们是接受缓存的，只需要测试功能通过就行了。如果想跳过缓存，有什么办法呢？ 大部分人都会想到会有参数控制的，那么这个参数就是 -count=1,把上面的测试命令加上参数， go test -count=1 -v .，执行一下试试，果然可以跳过缓存。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/12/test.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/12/env.html" class="post-title-link">
      <h2>Go 语言运行时环境变量</h2>
    </a>

    <div class="post-date">Sep 12, 2019</div>
    
    <div class="post-body">
      
      <p>Go Runtime除了提供:GC, goroutine调度， 定时器，network polling等服务外， 还提供其它一些工具设施，用于开启额外的调试输出，</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/12/env.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/11/reflect_json.html" class="post-title-link">
      <h2>reflect性能</h2>
    </a>

    <div class="post-date">Sep 11, 2019</div>
    
    <div class="post-body">
      
      <p>Go reflect包提供了运行时获取对象的类型和值的能力，它可以帮助我们实现代码的抽象和简化，实现动态的数据获取和方法调用， 提高开发效率和可读性， 也弥补Go在缺乏泛型的情况下对数据的统一处理能力。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/11/reflect_json.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/11/reflect.html" class="post-title-link">
      <h2>reflect</h2>
    </a>

    <div class="post-date">Sep 11, 2019</div>
    
    <div class="post-body">
      
      <p>对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义
每种语言的反射模型都不同，并且有些语言根本不支持反射。Golang语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的reflect包就是反射相关的，只要包含这个包就可以使用。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/11/reflect.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/11/Header.html" class="post-title-link">
      <h2>go 语言内存布局</h2>
    </a>

    <div class="post-date">Sep 11, 2019</div>
    
    <div class="post-body">
      
      <p>1.Go对象有没有Object Header？Go语言中虚函数都在interface里面，普通类没有虚函数，所以不需要存储虚表。但是垃圾收集也需要有一个对象头来标记信息，反射信息也可能需要对象头来记录。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/11/Header.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/11/Assertion.html" class="post-title-link">
      <h2>Assertion</h2>
    </a>

    <div class="post-date">Sep 11, 2019</div>
    
    <div class="post-body">
      
      <p>Type assertion(断言)是用于 interface value 的一种操作，语法是 x.(T)，x 是 interface type 的表达式，而 T 是 assertd type，被断言的类型。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/11/Assertion.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/10/unsafe.html" class="post-title-link">
      <h2>unsafe</h2>
    </a>

    <div class="post-date">Sep 10, 2019</div>
    
    <div class="post-body">
      
      <p>unsafe包含以下资源：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/10/unsafe.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/10/godoc.html" class="post-title-link">
      <h2>godoc</h2>
    </a>

    <div class="post-date">Sep 10, 2019</div>
    
    <div class="post-body">
      
      <p>一. 约定
注释符//后面要加空格, 例如: // xxx</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/10/godoc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/10/builtin.html" class="post-title-link">
      <h2>builtin</h2>
    </a>

    <div class="post-date">Sep 10, 2019</div>
    
    <div class="post-body">
      
      <p>type bool bool 这种定义有两种用途：
1，提供godoc 文档
2，帮助IDE定位到内部标识的注释
<!-- more -->
1、介绍builtin包</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/10/builtin.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/10/Reflection.html" class="post-title-link">
      <h2>Reflection</h2>
    </a>

    <div class="post-date">Sep 10, 2019</div>
    
    <div class="post-body">
      
      <p>https://blog.golang.org/laws-of-reflection
<!-- more -->
Introduction
Reflection in computing is the ability of a program to examine its own structure, particularly through types; it’s a form of metaprogramming. It’s also a great source of confusion.</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/10/Reflection.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/10/Interfaces.html" class="post-title-link">
      <h2>Interfaces</h2>
    </a>

    <div class="post-date">Sep 10, 2019</div>
    
    <div class="post-body">
      
      <p>https://research.swtch.com/interfaces
<!-- more -->
Go’s interfaces—static, checked at compile time, dynamic when asked for—are, for me, the most exciting part of Go from a language design point of view. If I could export one feature of Go into other languages, it would be interfaces.</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/10/Interfaces.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/08/upx.html" class="post-title-link">
      <h2>upx</h2>
    </a>

    <div class="post-date">Sep 8, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/upx/upx</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/08/upx.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/08/reflect.html" class="post-title-link">
      <h2>reflect 为啥慢</h2>
    </a>

    <div class="post-date">Sep 8, 2019</div>
    
    <div class="post-body">
      
      <p>golang的反射很慢，这个和它的api设计有关。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/08/reflect.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/08/postman.html" class="post-title-link">
      <h2>Swagger与postman使用</h2>
    </a>

    <div class="post-date">Sep 8, 2019</div>
    
    <div class="post-body">
      
      <p>Swagger接口文档，在线自动生成模板和页面。服务器地址加上swagger-ui.html后缀即可访问到（https://域名:端口号/swagger-ui.html）。
使用时在java代码中引用navan管理pom.xml中添加依赖：
<!-- Swagger-mvc --></p>
<dependency>
    <groupId>com.mangofactory</groupId>
    <artifactId>swagger-springmvc</artifactId>
    <version>1.0.2</version>
</dependency>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/08/postman.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/08/openfalcon.html" class="post-title-link">
      <h2>openfalcon</h2>
    </a>

    <div class="post-date">Sep 8, 2019</div>
    
    <div class="post-body">
      
      <p>1、监控系统，可以从运营级别（基本配置即可），以及应用级别（二次开发，通过端口进行日志上报），对服务器、操作系统、中间件、应用进行全面的监控，及报警，对我们的系统正常运行的作用非常重要。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/08/openfalcon.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/08/json.html" class="post-title-link">
      <h2>json</h2>
    </a>

    <div class="post-date">Sep 8, 2019</div>
    
    <div class="post-body">
      
      <p>go-simplejson，用来封装与解析匿名的JSON，说白了就是用map或者slice等来解析JSON,用的Golang自带的encoding/json库去做的解析
<!-- more -->
#JSON value
一个完整的JSON应该包含一个value，这个value的类型可能是null，true，false，number，string， array以及 object共6种。而array和object还有可能包含子value结构。这些类型的值映射到Golang当中，便是nil, bool, bool, int64/float64, string, []interface{}, map[string]interface{}，用一个union结构便可以搞定。注意这里的number有可以转换成整数或者是浮点数，在JavaScript中，全部用64位双精度浮点数储存，所以最大的精确整数也就是非规约数是尾数部分2^53 - 1，已经远远大于int32了，所以这里将整数映射成了int64而不是int，因为在部分机器上可能溢出，严格的区分一个IEEE-754格式的整数和浮点数并不是一件轻松的事情</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/08/json.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/08/goupx.html" class="post-title-link">
      <h2>golang 编译压缩体积</h2>
    </a>

    <div class="post-date">Sep 8, 2019</div>
    
    <div class="post-body">
      
      <p>为了让体积更小一点，也许可以尝试以下方法
第一步 :  编译 go build 时加上 -ldflags “-s -w” 
其中  -ldflags 里的  -s 去掉符号信息， -w 去掉DWARF调试信息，得到的程序就不能用gdb调试了</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/08/goupx.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/08/goconvey.html" class="post-title-link">
      <h2>goconvey</h2>
    </a>

    <div class="post-date">Sep 8, 2019</div>
    
    <div class="post-body">
      
      <p>GoConvey是一款针对Golang的测试框架，可以管理和运行测试用例，同时提供了丰富的断言函数，并支持很多 Web 界面特性。
Golang虽然自带了单元测试功能，并且在GoConvey框架诞生之前也出现了许多第三方测试框架，但没有一个测试框架像GoConvey一样能够让程序员如此简洁优雅的编写测试代码。
<!-- more -->
go get github.com/smartystreets/goconvey
在$GOPATH/src目录下新增了github.com子目录，该子目录里包含了GoConvey框架的库代码
在$GOPATH/bin目录下新增了GoConvey框架的可执行程序goconvey</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/08/goconvey.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/08/go-swagger.html" class="post-title-link">
      <h2>go-swagger</h2>
    </a>

    <div class="post-date">Sep 8, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/go-swagger/go-swagger
https://legacy.gitbook.com/book/huangwenchao/swagger/details</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/08/go-swagger.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/08/easy-mock.html" class="post-title-link">
      <h2>easy-mock</h2>
    </a>

    <div class="post-date">Sep 8, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/easy-mock/easy-mock</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/08/easy-mock.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/08/Swagger.html" class="post-title-link">
      <h2>Swagger</h2>
    </a>

    <div class="post-date">Sep 8, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/swagger-api/swagger-editor
https://github.com/swagger-api/swagger-ui</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/08/Swagger.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/04/simplejson.html" class="post-title-link">
      <h2>simplejson  json.Decoder vs json.Unmarshal</h2>
    </a>

    <div class="post-date">Sep 4, 2019</div>
    
    <div class="post-body">
      
      <p>1,golang自带的json解析库encoding/json提供了json字符串到json对象的相互转换，在json字符串比较简单的情况下还是挺好用的，但是当json字符串比较复杂或者嵌套比较多的时候，就显得力不从心了，不可能用encoding/json那种为每个嵌套字段定义一个struct类型的方式，这时候使用simplejson库能够很方便的解析。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/04/simplejson.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/09/03/json.html" class="post-title-link">
      <h2>json</h2>
    </a>

    <div class="post-date">Sep 3, 2019</div>
    
    <div class="post-body">
      
      <p>Go 语言里面原生支持了这种数据格式的序列化以及反序列化，内部使用反射机制实现，性能有点差，在高度依赖 json 解析的应用里，往往会成为性能瓶颈
<!-- more -->
ffjson
go get -u github.com/pquerna/ffjson
原生的库性能比较差的主要原因是使用了很多反射的机制，为了解决这个问题，ffjson 通过预编译生成代码，类型的判断在预编译阶段已经确定，避免了在运行时的反射</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/09/03/json.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/25/torch.html" class="post-title-link">
      <h2>pprof 火焰图 实践</h2>
    </a>

    <div class="post-date">Aug 25, 2019</div>
    
    <div class="post-body">
      
      <p>pprof 原理是对cpu 或内存 相关数据进行采样。因此前提是程序在运行或者 web有请求，否则 由于采集不到数据而显示：profile is empty
heap 采样出现这个问题可能是采样频率设置不合理</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/25/torch.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/25/pprof.html" class="post-title-link">
      <h2>pprof</h2>
    </a>

    <div class="post-date">Aug 25, 2019</div>
    
    <div class="post-body">
      
      <p>0.12 go tool pprof
我们可以使用go tool pprof命令来交互式的访问概要文件的内容。命令将会分析指定的概要文件，并会根据我们的要求为我们提供高可读性的输出信息。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/25/pprof.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/25/gotrace.html" class="post-title-link">
      <h2>go tool trace</h2>
    </a>

    <div class="post-date">Aug 25, 2019</div>
    
    <div class="post-body">
      
      <p>该工具是Go 1.5版本加入的，通过度量go语言特定事件的运行时，例如：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/25/gotrace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/25/go-callvis.html" class="post-title-link">
      <h2>go-callvis 生成golang调用图</h2>
    </a>

    <div class="post-date">Aug 25, 2019</div>
    
    <div class="post-body">
      
      <p>安装graphviz
$ brew install graphviz
安装go-callvis
go get -u github.com/TrueFurby/go-callvis
cd $GOPATH/src/github.com/TrueFurby/go-callvis &amp;&amp; make
用法
$ go-callvis [flags] package
<!-- more -->
https://github.com/TrueFurby/go-callvis</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/25/go-callvis.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/18/wrk.html" class="post-title-link">
      <h2>wrk</h2>
    </a>

    <div class="post-date">Aug 18, 2019</div>
    
    <div class="post-body">
      
      <p>wrk 负载测试时可以运行在一个或者多核CPU，wrk 结合了可伸缩的事件通知系统 epoll 和 kqueue 等多线程设计思想。wrk 不仅能测试单条 URL，还能通过LuaJIT脚本实现对不同的 URL 和参数、请求内容进行测试</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/18/wrk.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/18/race.html" class="post-title-link">
      <h2>race</h2>
    </a>

    <div class="post-date">Aug 18, 2019</div>
    
    <div class="post-body">
      
      <p>比如一个全局变量，如果没有加上锁，我们写一个比较庞大的项目下来，就根本不知道这个变量是不是会引起多个goroutine竞争。
<!-- more -->
package main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/18/race.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/18/make.html" class="post-title-link">
      <h2>make new 的区别</h2>
    </a>

    <div class="post-date">Aug 18, 2019</div>
    
    <div class="post-body">
      
      <p>二者都在堆上分配内存，但是它们的行为不同，适用于不同的类型。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/18/make.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/18/interface.html" class="post-title-link">
      <h2>interface</h2>
    </a>

    <div class="post-date">Aug 18, 2019</div>
    
    <div class="post-body">
      
      <p>golang中的接口分为带方法的接口和空接口。 带方法的接口在底层用iface表示，空接口的底层则是eface表示。
<!-- more -->
//runtime/runtime2.go</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/18/interface.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/18/flamegraph.html" class="post-title-link">
      <h2>flame graph</h2>
    </a>

    <div class="post-date">Aug 18, 2019</div>
    
    <div class="post-body">
      
      <p>安装go-torch
go get github.com/uber/go-torch
安装 FlameGraph
cd $WORK_PATH &amp;&amp; git clone https://github.com/brendangregg/FlameGraph.git
export PATH=$PATH:$WORK_PATH/FlameGraph-master
安装graphviz
yum install graphviz(CentOS, Redhat)
<!-- more -->
package main</p>

<p>import (
    “net/http”
    “net/http/pprof”
)</p>

<p>func main() {
    // 主函数中添加
    go func() {
        http.HandleFunc(“/debug/pprof/block”, pprof.Index)
        http.HandleFunc(“/debug/pprof/goroutine”, pprof.Index)
        http.HandleFunc(“/debug/pprof/heap”, pprof.Index)
        http.HandleFunc(“/debug/pprof/threadcreate”, pprof.Index)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    http.ListenAndServe("0.0.0.0:8888", nil)
}()
 
var finishWaiter chan int
&lt;-finishWaiter }
</code></pre></div></div>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/18/flamegraph.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/18/defer.html" class="post-title-link">
      <h2>defer</h2>
    </a>

    <div class="post-date">Aug 18, 2019</div>
    
    <div class="post-body">
      
      <p>defer的行为规则，只有三条
规则一：延迟函数的参数在defer语句出现时就已经确定下来了
官方给出一个例子，如下所示：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/18/defer.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/09/sweep.html" class="post-title-link">
      <h2>mark and sweep</h2>
    </a>

    <div class="post-date">Aug 9, 2019</div>
    
    <div class="post-body">
      
      <p>golang的垃圾回收采用的是 标记-清理（Mark-and-Sweep） 算法</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/09/sweep.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/09/gc.html" class="post-title-link">
      <h2>gc 发展</h2>
    </a>

    <div class="post-date">Aug 9, 2019</div>
    
    <div class="post-body">
      
      <ol>
  <li>Golang GC 发展</li>
</ol>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/09/gc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/08/pool.html" class="post-title-link">
      <h2>sync.pool</h2>
    </a>

    <div class="post-date">Aug 8, 2019</div>
    
    <div class="post-body">
      
      <p>1.12及之前版本的sync.Pool有三个问题：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/08/pool.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/08/mutex.html" class="post-title-link">
      <h2>mutex</h2>
    </a>

    <div class="post-date">Aug 8, 2019</div>
    
    <div class="post-body">
      
      <p>CAS原子操作。
需要有一种阻塞和唤醒机制。
尽量减少阻塞和唤醒切换成本。
锁尽量公平，后来者要排队。即使被后来者插队了，也要照顾先来者，不能有“饥饿”现象。
先看3，4点。再看2，1点。最后是源码。
<!-- more -->
尽量减少阻塞和唤醒切换成本
减少切换成本的方法就是不切换，简单而直接。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/08/mutex.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/08/fasthttp.html" class="post-title-link">
      <h2>fasthttp</h2>
    </a>

    <div class="post-date">Aug 8, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/valyala/fasthttp
是 golang 中一个标志性的高性能 HTTP库, 主要用于 webserver 开发, 以及 web client / proxy 等. 
Fast HTTP package for Go. Tuned for high performance. Zero memory allocations in hot paths. Up to 10x faster than net/http</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/08/fasthttp.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/04/fasthttp.html" class="post-title-link">
      <h2>fasthttp</h2>
    </a>

    <div class="post-date">Aug 4, 2019</div>
    
    <div class="post-body">
      
      <p>fasthttp是golang下的一个http框架，顾名思义，与原生的http实现相比，它的特点在于快，按照官网的说法，它的客户端和服务端性能比原生有了十倍的提升。它的高性能主要源自于“复用”，通过服务协程和内存变量的复用，节省了大量资源分配的成本。工作协程的复用协程的复用可以参见​workerpool.go​
https://github.com/valyala/fasthttp
<!-- more -->
减少[]byte的分配，尽量去复用它们
两种方式进行复用：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/04/fasthttp.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/04/channel.html" class="post-title-link">
      <h2>channel</h2>
    </a>

    <div class="post-date">Aug 4, 2019</div>
    
    <div class="post-body">
      
      <p>并发问题一般有下面这几种：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/04/channel.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/03/opentracing.html" class="post-title-link">
      <h2>opentracing</h2>
    </a>

    <div class="post-date">Aug 3, 2019</div>
    
    <div class="post-body">
      
      <p>在Go 1.7，我们有一个新包/ HTTP / httptrace提供了一个方便的机制，观察一个HTTP请求时会发生什么
分布式跟踪是监测和分析微服务架构系统，导出结果到为X-TRACE，如谷歌的Dapper和Twitter的Zipkin 。 它们的底层原理是分布式环境传播 ，其中涉及的某些元数据与进入系统的每个请求相关联，并且跨线程和进程边界传播元数据跟随请求进出各种微服务调用。 如果我们为每个入站请求分配一个唯一的ID并将其作为分布式上下文的一部分，那么我们可以将来自多个线程和多个进程的各种性能分析数据合并到统一的表示我们系统执行请求的“跟踪”中。
分布式跟踪需要使用Hook钩子和上下文传播机制来测试应用程序代码（或其使用的框架）。
没有良好的API为开发人员提供在编程语言之间内部一致性，那就无法绑定到指定的跟踪系统。
2015年10月一个新的社区形成，催生了OpenTracing API，一个开放的，厂商中立的，与语言无关的分布式跟踪标准。你可以阅读更多关于Ben Sigelman有关OpenTracing动机和设计原理背后的文章 。
https://opentracing.io/
https://zipkin.io/
https://github.com/openzipkin/zipkin
https://github.com/openzipkin/zipkin-go
https://github.com/opentracing/opentracing-go
<!-- more --></p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/03/opentracing.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/08/03/httptrace.html" class="post-title-link">
      <h2>httptrace</h2>
    </a>

    <div class="post-date">Aug 3, 2019</div>
    
    <div class="post-body">
      
      <p>net/http/httptrace主要是用于追踪客户端的 Request 请求过程中发生的各种事件及行为，在标准库 net/http/httptrace/trace.go 中定义了一个叫 ClientTrace 的结构体，它包含了一系列的钩子函数 hooks 作为成员变量
<!-- more -->
// ClientTrace is a set of hooks to run at various stages of an outgoing HTTP request. 
type ClientTrace struct {
    GetConn func(hostPort string)
    GotConn func(GotConnInfo)
    PutIdleConn func(err error)</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/08/03/httptrace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/28/trace.html" class="post-title-link">
      <h2>Memory Allocator Trace</h2>
    </a>

    <div class="post-date">Jul 28, 2019</div>
    
    <div class="post-body">
      
      <p>一、由 iter 包引发的疑问
最近在 GitHub 上偶然发现了 Brad Fitzpatrick 的 iter 包，整个包只有 一个函数（一行代码）：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/28/trace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/28/scheduler.html" class="post-title-link">
      <h2>系统调度</h2>
    </a>

    <div class="post-date">Jul 28, 2019</div>
    
    <div class="post-body">
      
      <p>程序其实就是一堆需要按照顺序一个接一个执行的机器指令。为此，操作系统使用了一个线程的概念。线程的工作就是按顺序执行分配给它的指令集，直到没有指令可以执行了为止。
你运行的每一个程序都会创建一个进程，并且每一个进程都会有一个初始线程。线程拥有创建更多线程的能力。这些不同的线程都是独立运行的，调度策略都是在线程这一级别上的，而不是进程级别（或者说调度的最小单元是线程而不是进程）。线程是可以并发执行的（轮流使用同一个核），或并行（每个线程互不干扰的同时在不同的核上跑）。线程还维护这他们自己状态，好保证安全、隔离、独立的执行自己的指令。
系统调度器负责保证当有线程可以执行时，CPU 是不能处于空闲状态的。它还必须创建一个所有线程同时都在运行的假象。在创造这个假象的过程中，调度器需要优先运行优先级更高的线程。但是低优先级的线程又不能被饿死（就是一直不被运行）。调度器还需要通过快速、明智的决策尽可能的最小化调度延迟。
https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html
https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html
<!-- more -->
执行指令
Program counter(PC)，有时候也被叫做指令指针(instruction pointer, 简称IP)，线程用它来跟踪下一个要执行的指令。在大多数处理器中，PC 指向的是下一个指令，而不是当前指令。
如果你曾经看过 Go 程序的 stack trace，你可能注意到了每行的最后都有一个 16 进制数字。比如 +0x39和0x72。
goroutine 1 [running]:
   main.example(0xc000042748, 0x2, 0x4, 0x106abae, 0x5, 0xa)
       stack_trace/example1/example1.go:13 +0x39                 &lt;- LOOK HERE
   main.main()
       stack_trace/example1/example1.go:8 +0x72                  &lt;- LOOK HERE</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/28/scheduler.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/28/hey.html" class="post-title-link">
      <h2>hey</h2>
    </a>

    <div class="post-date">Jul 28, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/rakyll/hey</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/28/hey.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/28/gostub.html" class="post-title-link">
      <h2>gostub</h2>
    </a>

    <div class="post-date">Jul 28, 2019</div>
    
    <div class="post-body">
      
      <p>GoStub是一款轻量级的单元测试框架，接口友好，可以对全局变量、函数或过程进行打桩。
GoStub安装：
go get github.com/prashantv/gostub
<!-- more -->
二、GoStub常用方法
gostub用于在测试时打桩变量，一旦测试运行时，重置原来的值。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/28/gostub.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/28/goMonkey.html" class="post-title-link">
      <h2>goMonkey</h2>
    </a>

    <div class="post-date">Jul 28, 2019</div>
    
    <div class="post-body">
      
      <p>gomonkey 是 golang 的一款打桩框架，目标是让用户在单元测试中低成本的完成打桩，从而将精力聚焦于业务功能的开发
https://github.com/agiledragon/gomonkey
<!-- more -->
gomonkey 1.0 特性列表如下：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/28/goMonkey.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/28/GoConvey.html" class="post-title-link">
      <h2>GoConvey</h2>
    </a>

    <div class="post-date">Jul 28, 2019</div>
    
    <div class="post-body">
      
      <p>GoConvey是一款针对Golang的测试框架，可以管理和运行测试用例，同时提供了丰富的断言函数，并支持很多 Web 界面特性。
Golang虽然自带了单元测试功能，并且在GoConvey框架诞生之前也出现了许多第三方测试框架，但没有一个测试框架像GoConvey一样能够让程序员如此简洁优雅的编写测试代码。
安装
在命令行运行下面的命令：
go get github.com/smartystreets/goconvey</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/28/GoConvey.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/27/mock.html" class="post-title-link">
      <h2>mock</h2>
    </a>

    <div class="post-date">Jul 27, 2019</div>
    
    <div class="post-body">
      
      <p>全局变量可通过GoStub框架打桩
过程可通过GoStub框架打桩
函数可通过GoStub框架打桩
interface可通过GoMock框架打桩</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/27/mock.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/21/tiny.html" class="post-title-link">
      <h2>tiny compiler</h2>
    </a>

    <div class="post-date">Jul 21, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/xiazemin/the-super-tiny-compiler-1/blob/master/compiler.go
https://github.com/xiazemin/the-super-tiny-compiler
https://adampresley.github.io/2015/06/01/writing-a-lexer-and-parser-in-go-part-3.html
https://adampresley.github.io/2015/06/01/writing-a-lexer-and-parser-in-go-part-2.html
https://adampresley.github.io/2015/06/01/writing-a-lexer-and-parser-in-go-part-1.html
<!-- more -->
/**</p>
<ul>
  <li>TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE</li>
  <li>T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E</li>
  <li>T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E</li>
  <li>T:::::TT:::::::TT:::::THH::::::H     H::::::HHEE::::::EEEEEEEEE::::E</li>
  <li>TTTTTT  T:::::T  TTTTTT  H:::::H     H:::::H    E:::::E       EEEEEE</li>
  <li>T:::::T          H:::::H     H:::::H    E:::::E</li>
  <li>T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE</li>
  <li>T:::::T          H:::::::::::::::::H    E:::::::::::::::E</li>
  <li>T:::::T          H:::::::::::::::::H    E:::::::::::::::E</li>
  <li>T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE</li>
  <li>T:::::T          H:::::H     H:::::H    E:::::E</li>
  <li>T:::::T          H:::::H     H:::::H    E:::::E       EEEEEE</li>
  <li>TT:::::::TT      HH::::::H     H::::::HHEE::::::EEEEEEEE:::::E</li>
  <li>T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E</li>
  <li>T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E</li>
  <li>TTTTTTTTTTT      HHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE
 *</li>
  <li>SSSSSSSSSSSSSSS UUUUUUUU     UUUUUUUUPPPPPPPPPPPPPPPPP   EEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR</li>
  <li>SS:::::::::::::::SU::::::U     U::::::UP::::::::::::::::P  E::::::::::::::::::::ER::::::::::::::::R</li>
  <li>S:::::SSSSSS::::::SU::::::U     U::::::UP::::::PPPPPP:::::P E::::::::::::::::::::ER::::::RRRRRR:::::R</li>
  <li>S:::::S     SSSSSSSUU:::::U     U:::::UUPP:::::P     P:::::PEE::::::EEEEEEEEE::::ERR:::::R     R:::::R</li>
  <li>S:::::S             U:::::U     U:::::U   P::::P     P:::::P  E:::::E       EEEEEE  R::::R     R:::::R</li>
  <li>S:::::S             U:::::U     U:::::U   P::::P     P:::::P  E:::::E               R::::R     R:::::R</li>
  <li>S::::SSSS          U:::::U     U:::::U   P::::PPPPPP:::::P   E::::::EEEEEEEEEE     R::::RRRRRR:::::R</li>
  <li>SS::::::SSSSS     U:::::U     U:::::U   P:::::::::::::PP    E:::::::::::::::E     R:::::::::::::RR</li>
  <li>SSS::::::::SS   U:::::U     U:::::U   P::::PPPPPPPPP      E:::::::::::::::E     R::::RRRRRR:::::R</li>
  <li>SSSSSS::::S  U:::::U     U:::::U   P::::P              E::::::EEEEEEEEEE     R::::R     R:::::R</li>
  <li>S:::::S U:::::U     U:::::U   P::::P              E:::::E               R::::R     R:::::R</li>
  <li>S:::::S U::::::U   U::::::U   P::::P              E:::::E       EEEEEE  R::::R     R:::::R</li>
  <li>SSSSSSS     S:::::S U:::::::UUU:::::::U PP::::::PP          EE::::::EEEEEEEE:::::ERR:::::R     R:::::R</li>
  <li>S::::::SSSSSS:::::S  UU:::::::::::::UU  P::::::::P          E::::::::::::::::::::ER::::::R     R:::::R</li>
  <li>S:::::::::::::::SS     UU:::::::::UU    P::::::::P          E::::::::::::::::::::ER::::::R     R:::::R</li>
  <li>SSSSSSSSSSSSSSS         UUUUUUUUU      PPPPPPPPPP          EEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR
 *</li>
  <li>TTTTTTTTTTTTTTTTTTTTTTTIIIIIIIIIINNNNNNNN        NNNNNNNNYYYYYYY       YYYYYYY</li>
  <li>T:::::::::::::::::::::TI::::::::IN:::::::N       N::::::NY:::::Y       Y:::::Y</li>
  <li>T:::::::::::::::::::::TI::::::::IN::::::::N      N::::::NY:::::Y       Y:::::Y</li>
  <li>T:::::TT:::::::TT:::::TII::::::IIN:::::::::N     N::::::NY::::::Y     Y::::::Y</li>
  <li>TTTTTT  T:::::T  TTTTTT  I::::I  N::::::::::N    N::::::NYYY:::::Y   Y:::::YYY</li>
  <li>T:::::T          I::::I  N:::::::::::N   N::::::N   Y:::::Y Y:::::Y</li>
  <li>T:::::T          I::::I  N:::::::N::::N  N::::::N    Y:::::Y:::::Y</li>
  <li>T:::::T          I::::I  N::::::N N::::N N::::::N     Y:::::::::Y</li>
  <li>T:::::T          I::::I  N::::::N  N::::N:::::::N      Y:::::::Y</li>
  <li>T:::::T          I::::I  N::::::N   N:::::::::::N       Y:::::Y</li>
  <li>T:::::T          I::::I  N::::::N    N::::::::::N       Y:::::Y</li>
  <li>T:::::T          I::::I  N::::::N     N:::::::::N       Y:::::Y</li>
  <li>TT:::::::TT      II::::::IIN::::::N      N::::::::N       Y:::::Y</li>
  <li>T:::::::::T      I::::::::IN::::::N       N:::::::N    YYYY:::::YYYY</li>
  <li>T:::::::::T      I::::::::IN::::::N        N::::::N    Y:::::::::::Y</li>
  <li>TTTTTTTTTTT      IIIIIIIIIINNNNNNNN         NNNNNNN    YYYYYYYYYYYYY
 *</li>
  <li>CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPPPPPPPPP   IIIIIIIIIILLLLLLLLLLL             EEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR</li>
  <li>CCC::::::::::::C   OO:::::::::OO   M:::::::M             M:::::::MP::::::::::::::::P  I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::::::::::::R</li>
  <li>CC:::::::::::::::C OO:::::::::::::OO M::::::::M           M::::::::MP::::::PPPPPP:::::P I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::RRRRRR:::::R</li>
  <li>C:::::CCCCCCCC::::CO:::::::OOO:::::::OM:::::::::M         M:::::::::MPP:::::P     P:::::PII::::::IILL:::::::LL             EE::::::EEEEEEEEE::::ERR:::::R     R:::::R</li>
  <li>C:::::C       CCCCCCO::::::O   O::::::OM::::::::::M       M::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E       EEEEEE  R::::R     R:::::R</li>
  <li>C:::::C              O:::::O     O:::::OM:::::::::::M     M:::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E               R::::R     R:::::R</li>
  <li>C:::::C              O:::::O     O:::::OM:::::::M::::M   M::::M:::::::M  P::::PPPPPP:::::P   I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::RRRRRR:::::R</li>
  <li>C:::::C              O:::::O     O:::::OM::::::M M::::M M::::M M::::::M  P:::::::::::::PP    I::::I    L:::::L                 E:::::::::::::::E     R:::::::::::::RR</li>
  <li>C:::::C              O:::::O     O:::::OM::::::M  M::::M::::M  M::::::M  P::::PPPPPPPPP      I::::I    L:::::L                 E:::::::::::::::E     R::::RRRRRR:::::R</li>
  <li>C:::::C              O:::::O     O:::::OM::::::M   M:::::::M   M::::::M  P::::P              I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::R     R:::::R</li>
  <li>C:::::C              O:::::O     O:::::OM::::::M    M:::::M    M::::::M  P::::P              I::::I    L:::::L                 E:::::E               R::::R     R:::::R</li>
  <li>C:::::C       CCCCCCO::::::O   O::::::OM::::::M     MMMMM     M::::::M  P::::P              I::::I    L:::::L         LLLLLL  E:::::E       EEEEEE  R::::R     R:::::R</li>
  <li>C:::::CCCCCCCC::::CO:::::::OOO:::::::OM::::::M               M::::::MPP::::::PP          II::::::IILL:::::::LLLLLLLLL:::::LEE::::::EEEEEEEE:::::ERR:::::R     R:::::R</li>
  <li>CC:::::::::::::::C OO:::::::::::::OO M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R</li>
  <li>CCC::::::::::::C   OO:::::::::OO   M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R</li>
  <li>CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPP          IIIIIIIIIILLLLLLLLLLLLLLLLLLLLLLLLEEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR
 *</li>
  <li>=======================================================================================================================================================================</li>
  <li>=======================================================================================================================================================================</li>
  <li>=======================================================================================================================================================================</li>
  <li>=======================================================================================================================================================================
 */</li>
</ul>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/21/tiny.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/21/link.html" class="post-title-link">
      <h2>compile link</h2>
    </a>

    <div class="post-date">Jul 21, 2019</div>
    
    <div class="post-body">
      
      <p>go build
-gcflags: 传递给编译器的参数</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/21/link.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/20/tscan.html" class="post-title-link">
      <h2>tscan</h2>
    </a>

    <div class="post-date">Jul 20, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/google/sanitizers/wiki/AddressSanitizer
ThreadSanitizer又叫TSan，是一个检查线程Data Race的C/C++工具。它集成在新版的gcc和clang中，通过编译时加-fsanitize=thread，可以在运行时检测出Data Race的问题。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/20/tscan.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/20/race.html" class="post-title-link">
      <h2>race</h2>
    </a>

    <div class="post-date">Jul 20, 2019</div>
    
    <div class="post-body">
      
      <p>goroutine的使用增加了函数的危险系数论go语言中goroutine的使用。比如一个全局变量，如果没有加上锁，我们写一个比较庞大的项目下来，就根本不知道这个变量是不是会引起多个goroutine竞争。
<!-- more -->
package main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/20/race.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/20/goroutine.html" class="post-title-link">
      <h2>Memory Sanitizer</h2>
    </a>

    <div class="post-date">Jul 20, 2019</div>
    
    <div class="post-body">
      
      <p>// Race Detector的处理(用于检测线程冲突问题)
if raceenabled {
    racemalloc(x, size)
}</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/20/goroutine.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/20/go.html" class="post-title-link">
      <h2>go 编译器指示</h2>
    </a>

    <div class="post-date">Jul 20, 2019</div>
    
    <div class="post-body">
      
      <p>在计算机编程中，编译指示(pragma)是一种语言结构，它指示编译器应该如何处理其输入。指示不是编程语言语法的一部分，因编译器而异。
<!-- more -->
https://golang.org/cmd/compile/#hdr-Compiler_Directives
形如 //go: 就是 Go 语言编译指示的实现方式。
//go: 是连续的，// 和 go 之间并没有空格。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/20/go.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/20/gc.html" class="post-title-link">
      <h2>编译优化</h2>
    </a>

    <div class="post-date">Jul 20, 2019</div>
    
    <div class="post-body">
      
      <p>逃逸分析
内联
死码消除
Go 编译器在2007年左右开始作为 Plan9 编译器工具链的一个分支。当时的编译器与 Aho 和 Ullman 的 Dragon Book 非常相似。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/20/gc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/20/compile.html" class="post-title-link">
      <h2>调试golang编译器,增加自定义声明</h2>
    </a>

    <div class="post-date">Jul 20, 2019</div>
    
    <div class="post-body">
      
      <p>GO从源代码编译
github.com/golang/go/src/all.bash</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/20/compile.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/20/ast.html" class="post-title-link">
      <h2>语法树与抽象语法树（parse tree & abstract syntax tree）</h2>
    </a>

    <div class="post-date">Jul 20, 2019</div>
    
    <div class="post-body">
      
      <p>是在parsing阶段，derivation的图像化表示，parser tree focus on grammar的actual implemment，包括像white spaces, braces, keywords, parenthesis 等一些细节。 “parse tree” 也叫 “concrete syntax tree” ，它represents the syntactic structure of a string(or token stream)according to some context-free grammar.
<!-- more -->
The parse tree records a sequence of rules the parser applies to recognize the input.
parse tree记录解析器应用于识别输入的一系列规则
The root of the parse tree is labeled with the grammar start symbol.
parse tree的根是grammar的start non-terminal symbol。
Each interior node represents a non-terminal, that is it represents a grammar rule application, like expr, term, or factor in our case.
每个内部节点代表一个非终端，即它代表语法规则应用程序，如我们的情况下的expr，term或factor。
Each leaf node represents a token.
每个叶节点代表一个token。</p>

<p>AST is a tree representation of the abstract syntactic structure of source codewritten in a programming language.它 focus on source code的 各个 components 之间的abstract relationships。 it doesn’t need to contain all the syntactical elements
he AST captures the essence of the input while being smaller. AST在较小的情况下捕获了输入的本质</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/20/ast.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/19/ssa.html" class="post-title-link">
      <h2>静态单赋值（SSA,Static Single-Assignment)</h2>
    </a>

    <div class="post-date">Jul 19, 2019</div>
    
    <div class="post-body">
      
      <p>精确的数据流分析是让编译优化能高效进行的基础。 SSA就是一种高效的数据流分析技术，目前几乎所有的现代编译器，如GCC、Open64、LLVM都有将SSA技术的支持， 不仅仅是编译器，Jikes RVM, HotSpot JVM, .Net的Mono，Python的Pypy， Andoroid的Dalvik，这些虚拟机/解释器中的Just-in-Time Compiler也有了SSA的支持。 Firefox的下一代JavaScript引擎IonMonkey中，也将为其JIT引入SSA。
<!-- more -->
是一种中间表示形式。 之所以称之为单赋值，是因为每个名字在SSA中仅被赋值一次.将每个赋值语句中的变量赋予一个唯一的名称后，一般新名称采用原变量+版本号（Version）的形式。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/19/ssa.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/16/slice.html" class="post-title-link">
      <h2>slice</h2>
    </a>

    <div class="post-date">Jul 16, 2019</div>
    
    <div class="post-body">
      
      <p>slice 翻译成中文就是切片，它和数组（array）很类似，可以用下标的方式进行访问，如果越界，就会产生 panic。但是它比数组更灵活，可以自动地进行扩容。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/16/slice.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/16/plan9.html" class="post-title-link">
      <h2>plan9</h2>
    </a>

    <div class="post-date">Jul 16, 2019</div>
    
    <div class="post-body">
      
      <p>https://golang.org/doc/asm
GO语言汇编：plan9（贝尔操作系统）
go开发者与plan 9开发者同一人，Rob Pike
寄存器：
数据寄存器：R0-R7，地址寄存器：A0-A7，浮点寄存器：F0-F7。
伪栈寄存器：FP, SP, TOS
数据：
PC用来控制程序执行，SB用来引用全局变量。
Go语言汇编
FUNCDATA和PCDATA是编译器产生的，用于保存一些给垃圾收集的信息。
NOPTR和RODATA的数据不需要被垃圾收集。比指针还要小的数据也被当做NOPTR。不要在go汇编里写非只读数据。
plan9函数调用协议中采用的是caller-save的模式，也就是由调用者负责保存寄存器。
TEXT !$Add(SB),$0
MOVQ x+0(FP), BX
MOVQ y+8(FP), BP
ADDQ BP, BX
MOVQ BX, ret+16(FP)
RET
TEXT    ““.main(SB), $56-0
56 代表local 大小
0 代表args大小
movl 四字节mov intel指令集
movq 八字节
例子中的TEXT指令就定义了一个叫bytes·Equal的符号（注意是中点号·），接下来就是对应的指令（可以理解成函数体），而最后RET则是返回指令（退出当前stack）。通常情况下，参数大小后跟随着stack frame的大小，使用减号（-）分割。$0-49意味着这是一个0-byte的栈，并且有49-byte长的参数。NOSPLIT说明,不允许调度器调整stack frame的大小,这就意味着必须人工指定stack frame大小。
字符串 函数都放在SB   stack basic register</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/16/plan9.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/16/goasm.html" class="post-title-link">
      <h2>goasm</h2>
    </a>

    <div class="post-date">Jul 16, 2019</div>
    
    <div class="post-body">
      
      <p>一、资源</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/16/goasm.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/16/asm.html" class="post-title-link">
      <h2>asm</h2>
    </a>

    <div class="post-date">Jul 16, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/yangyuqian/technical-articles/blob/master/asm/golang-plan9-assembly-cn.md
http://xargin.com/go-and-plan9-asm/
https://davidwong.fr/goasm/
https://github.com/teh-cmc/go-internals/blob/master/chapter1_assembly_primer/README.md
https://golang.org/doc/asm
https://github.com/yangyuqian/technical-articles/blob/master/asm/golang-plan9-assembly-cn.md
<!-- more -->
https://colobu.com/goasm/
https://laily.net/article/Golang%20%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/16/asm.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/15/binaryen.html" class="post-title-link">
      <h2>binaryen</h2>
    </a>

    <div class="post-date">Jul 15, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/WebAssembly/binaryen
WebAssembly 的生态大致分为两部分, 编译器等工具链, 和执行环境
两者依据 spec 来完成对接, 并且实现解耦
工具链部分重要的新项目是 Binaryen, 一个编译器
https://github.com/WebAssembly/binaryen
实现语言是 C++, 可以用于 parse 和 emit WebAssembly
也可以基于 AST 规范进行转换
基于几个部分的工具:</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/15/binaryen.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/15/WebAssembly.html" class="post-title-link">
      <h2>WebAssembly</h2>
    </a>

    <div class="post-date">Jul 15, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/WebAssembly/design
Go 语言源代码的 cmd/compile/internal 中包含了非常多机器码生成相关的包，不同类型的 CPU 分别使用了不同的包进行生成 amd64、arm、arm64、mips、mips64、ppc64、s390x、x86 和 wasm，也就是说 Go 语言能够在上述的 CPU 指令集类型上运行，其中比较有趣的就是 WebAssembly 了。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/15/WebAssembly.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/14/trace.html" class="post-title-link">
      <h2>go tool trace</h2>
    </a>

    <div class="post-date">Jul 14, 2019</div>
    
    <div class="post-body">
      
      <p>单单使用 PProf 有时候不一定足够完整，因为在真实的程序中还包含许多的隐藏动作，例如 Goroutine 在执行时会做哪些操作？执行/阻塞了多长时间？在什么时候阻止？在哪里被阻止的？谁又锁/解锁了它们？GC 是怎么影响到 Goroutine 的执行的？这些东西用 PProf 是很难分析出来的，但如果你又想知道上述的答案的话，你可以用 go tool trace 来打开新世界的大门。
<!-- more -->
初步了解
import (
	“os”
	“runtime/trace”
)</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/14/trace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/11/goget.html" class="post-title-link">
      <h2>go get  go install</h2>
    </a>

    <div class="post-date">Jul 11, 2019</div>
    
    <div class="post-body">
      
      <p>一. 理解 Go 的环境变量</p>
<ol>
  <li>GOROOT
该环境变量的值为 Go 语言的当前安装目录。</li>
</ol>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/11/goget.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/11/cobra.html" class="post-title-link">
      <h2>cobra</h2>
    </a>

    <div class="post-date">Jul 11, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/spf13/cobra
Cobra提供简单的接口来创建强大的现代化CLI接口，比如git与go工具。Cobra同时也是一个程序, 用于创建CLI程序</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/11/cobra.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/09/alias.html" class="post-title-link">
      <h2>type aliases</h2>
    </a>

    <div class="post-date">Jul 9, 2019</div>
    
    <div class="post-body">
      
      <p>类型别名(type aliases) 最终还是加入到Go 1.9中</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/09/alias.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/05/hijack.html" class="post-title-link">
      <h2>hijack</h2>
    </a>

    <div class="post-date">Jul 5, 2019</div>
    
    <div class="post-body">
      
      <p>type Hijacker interface {
	Hijack() (net.Conn, *bufio.ReadWriter, error)
}
//返回连接接口net.Conn和ReadWriter,bufio读写的
// Hijack lets the caller take over the connection. —–Hijack让调用者管理连接</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/05/hijack.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/05/gotty.html" class="post-title-link">
      <h2>gotty 把你的 Linux 终端放到浏览器里面</h2>
    </a>

    <div class="post-date">Jul 5, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/yudai/gotty
GoTTY 是一个简单的基于 Go 语言的命令行工具，它可以将你的终端（TTY）作为 web 程序共享。它会将命令行工具转换为 web 程序。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/05/gotty.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/04/fcgi.html" class="post-title-link">
      <h2>fcgi</h2>
    </a>

    <div class="post-date">Jul 4, 2019</div>
    
    <div class="post-body">
      
      <p>nginx 配置
server {
        listen 80;
        server_name go.dev;
        root /root/go/src/godev;
        index index.html;
        #gzip off;
        #proxy_buffering off;</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/04/fcgi.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/03/gocgi.html" class="post-title-link">
      <h2>go-web + go-cgi + go-cgi-script</h2>
    </a>

    <div class="post-date">Jul 3, 2019</div>
    
    <div class="post-body">
      
      <p>CGI(Common Gateway Interface)是能让web服务器和CGI脚本共同处理客户的请求的协议。它的协议定义文档是http://www.ietf.org/rfc/rfc3875。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/03/gocgi.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/07/02/netListener.html" class="post-title-link">
      <h2>netListener.File</h2>
    </a>

    <div class="post-date">Jul 2, 2019</div>
    
    <div class="post-body">
      
      <p>POSIX提供了fork和exec调用来启动一个新进程，fork复制父进程，然后通过exec来替换自己要执行的程序。在go中，我们使用exec.Command或者os.StartProcess来达到类似效果。
在启动子进程时，需要让子进程知道，我正处于热更新过程中。通常使用环境变量或者参数来实现，例子中使用了-graceful这个参数。
file := netListener.File() // this returns a Dup()
path := “/path/to/executable”
args := []string{
    “-graceful”}</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/07/02/netListener.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/30/lantern.html" class="post-title-link">
      <h2>lantern mac编译 Proxy SwitchyOmega</h2>
    </a>

    <div class="post-date">Jun 30, 2019</div>
    
    <div class="post-body">
      
      <p>git clone –depth=1 https://github.com/getlantern/lantern.git</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/30/lantern.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/29/graceful.html" class="post-title-link">
      <h2>shutdown 源码分析</h2>
    </a>

    <div class="post-date">Jun 29, 2019</div>
    
    <div class="post-body">
      
      <p>我们知道在go 1.8.x后，golang在http里加入了shutdown方法，用来控制优雅退出。什么是优雅退出？ 简单说就是不处理新请求，但是会处理正在进行的请求，把旧请求都处理完，也就是都response之后，那么就退出。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/29/graceful.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/29/Shutdown.html" class="post-title-link">
      <h2>graceful Shutdown</h2>
    </a>

    <div class="post-date">Jun 29, 2019</div>
    
    <div class="post-body">
      
      <p>如何优雅的关闭http服务在Go Web开发中一直被提及和讨论的话题，今天Go 1.8的发布终于为我们带来了这个特性。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/29/Shutdown.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/28/nil.html" class="post-title-link">
      <h2>interface 和nil</h2>
    </a>

    <div class="post-date">Jun 28, 2019</div>
    
    <div class="post-body">
      
      <p>var val interface{} = (<em>interface{})(nil)
val的类型是</em>interface{}，值是nil
var val interface{} = nil
val的类型和值都是nil
<!-- more -->
ackage main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/28/nil.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/28/invoke.html" class="post-title-link">
      <h2>martini inject</h2>
    </a>

    <div class="post-date">Jun 28, 2019</div>
    
    <div class="post-body">
      
      <p>用(*interface{})(nil)传递参数类型
type injector struct {     <br />
  values map[reflect.Type]reflect.Value     <br />
  parent Injector
}</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/28/invoke.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/28/inject.html" class="post-title-link">
      <h2>Martini之inject源码</h2>
    </a>

    <div class="post-date">Jun 28, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/codegangsta/inject
依赖注入是一个业界标准技术，用于解决复杂应用状态下模块之间依赖的问题。有了依赖注入，不需要再写很多按照依赖顺序而编写的初始化代码。在没有使用依赖注入的前提下，在升级重构一个模块的时候是相当痛苦的，因为这意味着需要在项目依赖图里面把所有该模块涉及的一整套依赖关系重新构建。简而言之，依赖注入主要目的只有一个：旨在简化初始化代码的管理。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/28/inject.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/28/gcflags.html" class="post-title-link">
      <h2>gcflags</h2>
    </a>

    <div class="post-date">Jun 28, 2019</div>
    
    <div class="post-body">
      
      <p>在gdb调试程序输出变量：p var，会提示</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/28/gcflags.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/28/Martini.html" class="post-title-link">
      <h2>Martini</h2>
    </a>

    <div class="post-date">Jun 28, 2019</div>
    
    <div class="post-body">
      
      <p>Martini核心
我们从最简单的官方实例入手：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/28/Martini.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/27/godoc.html" class="post-title-link">
      <h2>godoc doc.go</h2>
    </a>

    <div class="post-date">Jun 27, 2019</div>
    
    <div class="post-body">
      
      <p>$ godoc -http=:6060 -index
http://localhost:6060/pkg/github.com/xiazemin/
可以看到各个目录及注释
<!-- more -->
o doc
go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/27/godoc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/19/validator.html" class="post-title-link">
      <h2>validator</h2>
    </a>

    <div class="post-date">Jun 19, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/go-validator/validator
这个包怎么用的
type NewUserRequest struct {
	Username string <code class="highlighter-rouge">validate:"min=3,max=40,regexp=^[a-zA-Z]*$"</code>
	Name string     <code class="highlighter-rouge">validate:"nonzero"</code>
	Age int         <code class="highlighter-rouge">validate:"min=21"</code>
	Password string <code class="highlighter-rouge">validate:"min=8"</code>
}</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/19/validator.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/17/goroutine.html" class="post-title-link">
      <h2>goroutine 状态机扭转</h2>
    </a>

    <div class="post-date">Jun 17, 2019</div>
    
    <div class="post-body">
      
      <p>goroutine的状态迁移图，圆形框表示状态，箭头及文字信息表示切换的方向和条件：
<img src="https://xiazemin.github.io/MyBlog/img/goroutine_statemachine.jpg" />
<!-- more -->
其中状态 Gidle 在Go调度器代码中并没有被真正被使用到，所以直接忽略。 事实上，一旦runtime新建了一个goroutine结构，就会将其状态置为Grunnable并加入到任务队列中，因此我们以该状态作为起点进行介绍。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/17/goroutine.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/16/mpg.html" class="post-title-link">
      <h2>m p g schedt sudog</h2>
    </a>

    <div class="post-date">Jun 16, 2019</div>
    
    <div class="post-body">
      
      <p>go的调度器只要实现在 runtime 包中，路径为： ./src/runtime/proc.go 文件中。
<!-- more -->
go语言其实是在操作系统提供的内核线程之上搭建了一个特有得 【两级线程】模型。下面再说两级线程模型前，有三个必知的核心元素。(G、M、P)</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/16/mpg.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/15/sync.Pool.html" class="post-title-link">
      <h2>sync.Pool 设计思路与原理</h2>
    </a>

    <div class="post-date">Jun 15, 2019</div>
    
    <div class="post-body">
      
      <p>我们通常用golang来构建高并发场景下的应用，但是由于golang内建的GC机制会影响应用的性能，为了减少GC，golang提供了对象重用的机制，也就是sync.Pool对象池。 sync.Pool是可伸缩的，并发安全的。其大小仅受限于内存的大小，可以被看作是一个存放可重用对象的值的容器。 设计的目的是存放已经分配的但是暂时不用的对象，在需要用到的时候直接从pool中取。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/15/sync.Pool.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/15/sync.Map.html" class="post-title-link">
      <h2>sync.Map</h2>
    </a>

    <div class="post-date">Jun 15, 2019</div>
    
    <div class="post-body">
      
      <p>普通的map是不支持并发的，换而言之,不是线程(goroutine)安全的。golang 1.4开始的map的并发读是没有支持，但是并发写会出现脏数据。golang 1.6之后，并发地读写会直接panic：
fatal error: concurrent map read and map write
<!-- more -->
package main
func main() {
    m := make(map[int]int)
    go func() {
        for {
            _ = m[1]
        }
    }()
    go func() {
        for {
            m[2] = 2
        }
    }()
    select {}
}
所以需要支持对map的并发读写时候，博主使用两种方法：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/15/sync.Map.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/14/rwmutex.html" class="post-title-link">
      <h2>rwmutex</h2>
    </a>

    <div class="post-date">Jun 14, 2019</div>
    
    <div class="post-body">
      
      <p>在某个数据需要被多个线程共享访问的时候，会出现读者-写者问题（这里的「问题」是复数形式的，因为读者-写者问题有多个变种）。访问共享数据的线程有两种类型：读者和写者。读者只会读取数据，而写者则是修改它。当写者拥有了访问数据的权限后，其它的线程（不管是读者还是写者）都不能访问这个数据。这种约束的需求在现实中是存在的，比如：当写者不能原子性地修改某个数据（例如数据库）时，在修改完成之前，要读取这个数据的读者要被阻塞，以免读者获取到损坏的数据（脏数据）。
<!-- more -->
代码实现
注意作者编写本文时分析的代码版本（718d6c58）与最新的版本相比可能会有差异。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/14/rwmutex.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/14/onece.html" class="post-title-link">
      <h2>onece</h2>
    </a>

    <div class="post-date">Jun 14, 2019</div>
    
    <div class="post-body">
      
      <p>sync.once可以控制函数只能被调用一次，不能多次重复调用。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/14/onece.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/14/mutex.html" class="post-title-link">
      <h2>mutex</h2>
    </a>

    <div class="post-date">Jun 14, 2019</div>
    
    <div class="post-body">
      
      <p>package sync_code</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/14/mutex.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/10/socket_go.html" class="post-title-link">
      <h2>Golang网络库中socket阻塞调度源码剖析</h2>
    </a>

    <div class="post-date">Jun 10, 2019</div>
    
    <div class="post-body">
      
      <ol>
  <li>TCP的连接对象：
连接对象：
在net.go中有一个名为Conn的接口，提供了对于连接的读写和其他操作：</li>
</ol>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/10/socket_go.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/10/gopark.html" class="post-title-link">
      <h2>gopark goready</h2>
    </a>

    <div class="post-date">Jun 10, 2019</div>
    
    <div class="post-body">
      
      <p>scheduler和channel里面都与gopark和goready这两个函数紧密相关，但是站在上层可以理解这两个函数的作用，但是出于对源码探索，我们要明白这两个函数不仅仅做了啥，还要知道怎么做的。本文主要内容是从底层源码分析这两个函数原理：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/10/gopark.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/09/SYSCALL.html" class="post-title-link">
      <h2>golang syscall原理</h2>
    </a>

    <div class="post-date">Jun 9, 2019</div>
    
    <div class="post-body">
      
      <p>1.入口
系统调用的入口根据不同系统有不同实现，对于AMD64, Linux环境是：syscall/asm_linux_amd64.s</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/09/SYSCALL.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/06/04/goroutine.html" class="post-title-link">
      <h2>goroutine 泄露</h2>
    </a>

    <div class="post-date">Jun 4, 2019</div>
    
    <div class="post-body">
      
      <p>如果有goroutine因为ch没有接收动作而被一直阻塞在发送处，无法被回收。
发现goroutine 泄露工具：https://github.com/uber-go/goleak
产生原因分析
产生goroutine leak（协程泄露）的原因可能有以下几种： * goroutine由于channel的读/写端退出而一直阻塞，导致goroutine一直占用资源，而无法退出 * goroutine进入死循环中，导致资源一直无法释放</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/06/04/goroutine.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/05/28/pprof.html" class="post-title-link">
      <h2>pprof</h2>
    </a>

    <div class="post-date">May 28, 2019</div>
    
    <div class="post-body">
      
      <p>runtime/pprof：采集程序（非 Server）的运行数据进行分析
net/http/pprof：采集 HTTP Server 的运行时数据进行分析</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/05/28/pprof.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/05/28/PrintStack.html" class="post-title-link">
      <h2>PrintStack</h2>
    </a>

    <div class="post-date">May 28, 2019</div>
    
    <div class="post-body">
      
      <p>runtime/debug 库可以把调用堆栈打出来
 package main
import (
    “fmt”
    “runtime/debug”
)
func test3() {
    fmt.Printf(“%s”, debug.Stack())
    debug.PrintStack()
}
Stack trace是指堆栈回溯信息，在当前时间，以当前方法的执行点开始，回溯调用它的方法的方法的执行点，然后继续回溯，这样就可以跟踪整个方法的调用,大家比较熟悉的是JDK所带的jstack工具，可以把Java的所有线程的stack trace都打印出来。
<!-- more -->
异常退出情况下输出stacktrace
通过panic
如果应用中有没recover的panic,或者应用在运行的时候出现运行时的异常，那么程序自动会将当前的goroutine的stack trace打印出来。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/05/28/PrintStack.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/05/27/Benchmark.html" class="post-title-link">
      <h2>Benchmark</h2>
    </a>

    <div class="post-date">May 27, 2019</div>
    
    <div class="post-body">
      
      <p>https://github.com/xiazemin/Benchmark/blob/master/READEME.md
https://github.com/brendangregg/FlameGraph
https://github.com/uber-archive/go-torch</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/05/27/Benchmark.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/05/24/tls.html" class="post-title-link">
      <h2>thread local storage Goroutine Local Storage</h2>
    </a>

    <div class="post-date">May 24, 2019</div>
    
    <div class="post-body">
      
      <p>每个线程除了共享进程的资源外还拥有各自的私有资源：
一个寄存器组（或者说是线程上下文）；一个专属的堆栈；一个专属的消息队列；一个专属的Thread Local Storage（TLS）；一个专属的结构化异常处理串链。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/05/24/tls.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/05/24/getg.html" class="post-title-link">
      <h2>获取 goroutine id</h2>
    </a>

    <div class="post-date">May 24, 2019</div>
    
    <div class="post-body">
      
      <p>需要使用Go ID的场景， 比如在多goroutine长时间运行任务的时候，我们通过日志来跟踪任务的执行情况，可以通过go id来大致地跟踪程序并发执行的时候的状况。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/05/24/getg.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/05/23/method.html" class="post-title-link">
      <h2>method 接收者</h2>
    </a>

    <div class="post-date">May 23, 2019</div>
    
    <div class="post-body">
      
      <p>Go的类方法中，分为值接收者方法和指针接收者方法
指针类型，能够调用值和指针接收者方法，反之不行；值实现接口类型，能够被值和指针调用；反之不行；
函数返回值（没有值向指针隐式转换）和实现接口的时候需要注意；
<!-- more -->
值方法和指针方法</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/05/23/method.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/05/09/time_wait.html" class="post-title-link">
      <h2>TIME_WAIT和CLOSE_WAIT</h2>
    </a>

    <div class="post-date">May 9, 2019</div>
    
    <div class="post-body">
      
      <table>
  <tbody>
    <tr>
      <td>netstat -n</td>
      <td>awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’</td>
    </tr>
  </tbody>
</table>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/05/09/time_wait.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/05/09/netpoller.html" class="post-title-link">
      <h2>netpoller</h2>
    </a>

    <div class="post-date">May 9, 2019</div>
    
    <div class="post-body">
      
      <p>Go中网络交互采用多路复用的技术，具体到各个平台，即Kqueue、Epoll、Select、Poll等，下面以Linux下的Epoll实现为例进行分析。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/05/09/netpoller.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/05/09/gopsutil.html" class="post-title-link">
      <h2>gopsutil</h2>
    </a>

    <div class="post-date">May 9, 2019</div>
    
    <div class="post-body">
      
      <p>发现 python 上收集系统信息的著名模块 psutil (https://github.com/giampaolo/psutil)已经有 go 的版本(https://github.com/shirou/gopsutil)
获取进程信息、网络信息、磁盘信息、内存信息、CPU信息
它主要用来做系统监控，性能分析，进程管理。它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等。目前支持32位和64位的Linux、Windows、OS X、FreeBSD和Sun Solaris等操作系统.
<!-- more -->
go get github.com/shirou/gopsutil</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/05/09/gopsutil.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/26/goprof.html" class="post-title-link">
      <h2>goprof</h2>
    </a>

    <div class="post-date">Apr 26, 2019</div>
    
    <div class="post-body">
      
      <p>https://blog.golang.org/profiling-go-programs
https://software.intel.com/en-us/blogs/2014/05/10/debugging-performance-issues-in-go-programs
<!-- more -->
假设你手上有个Go语言编写的程序，你打算提升它的性能。目前有一些工具可以为此提供帮助。这些工具能帮你发现包括CPU、IO和内存在内多种类型的热点。所谓热点，是指那些为了能显著提升性能而值得你去关注的地方。有时候这些工具还能帮助你发现程序中主要的性能瑕疵。举个例子，你没必要每次执行SQL查询前都对SQL语句进行参数化解析，你可以将这个准备过程在程序启动时一次完成。再举个例子，当前某个算法的复杂度是O(N²)，但其实存在一个复杂度是O(N)的解决方案。为了能发现这些问题，需要理智地检查你在优化分析器中获取到的信息。比如上面提到的第一个问题，你会注意到相当长的时间被花费在了对SQL语句的准备上。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/26/goprof.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/26/Context.html" class="post-title-link">
      <h2>Context</h2>
    </a>

    <div class="post-date">Apr 26, 2019</div>
    
    <div class="post-body">
      
      <p>控制并发有两种经典的方式，一种是WaitGroup，另外一种就是Context。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/26/Context.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/23/gctrace.html" class="post-title-link">
      <h2>gctrace</h2>
    </a>

    <div class="post-date">Apr 23, 2019</div>
    
    <div class="post-body">
      
      <p>如何开启打印gc信息
只要在程序执行之前加上环境变量GODEBUG gctrace =1 ，如：
GODEBUG gctrace =1 ./xxxx.exe or GODEBUG gctrace =1 go run main.go
<!-- more -->
垃圾回收信息
gc 1 @2.104s 0%: 0.018+1.3+0.076 ms clock, 0.054+0.35/1.0/3.0+0.23 ms cpu, 4-&gt;4-&gt;3 MB, 5 MB goal, 4 P。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/23/gctrace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/22/mutex.html" class="post-title-link">
      <h2>mutex</h2>
    </a>

    <div class="post-date">Apr 22, 2019</div>
    
    <div class="post-body">
      
      <p>二. golang 最新版本的 sync.Mutex</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/22/mutex.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/22/WaitGroup.html" class="post-title-link">
      <h2>WaitGroup</h2>
    </a>

    <div class="post-date">Apr 22, 2019</div>
    
    <div class="post-body">
      
      <p>WaitGroup，可理解为Wait-Goroutine-Group，即等待一组goroutine结束。比如某个goroutine需要等待其他几个goroutine全部完成，那么使用WaitGroup可以轻松实现。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/22/WaitGroup.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/22/TCMalloc.html" class="post-title-link">
      <h2>TCMalloc</h2>
    </a>

    <div class="post-date">Apr 22, 2019</div>
    
    <div class="post-body">
      
      <p>Golang 竟然就用了鼎鼎大名的 TCMalloc
 TCMalloc 是 Google 开发的内存分配器，在不少项目中都有使用，例如在 Golang 中就使用了类似的算法进行内存分配。它具有现代化内存分配器的基本特征：对抗内存碎片、在多核处理器能够 scale。据称，它的内存分配速度是 glibc2.3 中实现的 malloc的数倍。
<!-- more -->
如何分配定长记录？</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/22/TCMalloc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/20/schedule.html" class="post-title-link">
      <h2>go schedule</h2>
    </a>

    <div class="post-date">Apr 20, 2019</div>
    
    <div class="post-body">
      
      <p>Goroutine是Go语言原生支持并发的具体实现，你的Go代码都无一例外地跑在goroutine中。你可以启动许多甚至成千上万的goroutine，Go的runtime负责对goroutine进行管理。所谓的管理就是“调度”，粗糙地说调度就是决定何时哪个goroutine将获得资源开始执行、哪个goroutine应该停止执行让出资源、哪个goroutine应该被唤醒恢复执行等。goroutine的调度是Go team care的事情，大多数gopher们无需关心。但个人觉得适当了解一下Goroutine的调度模型和原理，对于编写出更好的go代码是大有裨益的。因此，在这篇文章中，我将和大家一起来探究一下goroutine调度器的演化以及模型/原理。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/20/schedule.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/20/gc.html" class="post-title-link">
      <h2>gc</h2>
    </a>

    <div class="post-date">Apr 20, 2019</div>
    
    <div class="post-body">
      
      <p>go在程序启动时会分配一块虚拟内存地址是连续的内存, 结构如下:
spans 512M  bitmap 16G arena  512G
这一块内存分为了3个区域, 在X64上大小分别是512M, 16G和512G, 它们的作用如下:</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/20/gc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/20/channel.html" class="post-title-link">
      <h2>channel</h2>
    </a>

    <div class="post-date">Apr 20, 2019</div>
    
    <div class="post-body">
      
      <p>https://golang.org/ref/mem
一，初始化过程在这之前，先看下asm_arm64.s中的汇编代码关于启动这块的逻辑
CALL    runtime·args(SB)
CALL    runtime·osinit(SB)
CALL    runtime·hashinit(SB)
CALL    runtime·schedinit(SB)</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/20/channel.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/18/lldb.html" class="post-title-link">
      <h2>lldb</h2>
    </a>

    <div class="post-date">Apr 18, 2019</div>
    
    <div class="post-body">
      
      <p>xcode里有内置的Debugger，老版使用的是GDB，xcode自4.3之后默认使用的就是LLDB了。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/18/lldb.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/18/goroutine.html" class="post-title-link">
      <h2>goroutine实现原理</h2>
    </a>

    <div class="post-date">Apr 18, 2019</div>
    
    <div class="post-body">
      
      <p>G (goroutine)
G是goroutine的头文字, goroutine可以解释为受管理的轻量线程, goroutine使用go关键词创建.</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/18/goroutine.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/18/Vet.html" class="post-title-link">
      <h2>go Vet</h2>
    </a>

    <div class="post-date">Apr 18, 2019</div>
    
    <div class="post-body">
      
      <p>go vet是一个用于检查Go语言源码中静态错误的简单工具，消灭go vet扫描出的静态错误，有利于提高代码质量和养成良好的编码习惯，常见go vet错误总结如下：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/18/Vet.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/17/runtime.html" class="post-title-link">
      <h2>runtime</h2>
    </a>

    <div class="post-date">Apr 17, 2019</div>
    
    <div class="post-body">
      
      <p>１.　runtime.ＧＯＭＡＸＰＲＯＣＳ函数</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/17/runtime.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/17/linkname.html" class="post-title-link">
      <h2>go:linkname go:nosplit</h2>
    </a>

    <div class="post-date">Apr 17, 2019</div>
    
    <div class="post-body">
      
      <p>go:linkname
指令的格式如下：
//go:linkname hello github.com/lastsweetop/testlinkname/hello.hellofunc
go:linkname引导编译器将当前(私有)方法或者变量在编译时链接到指定的位置的方法或者变量，第一个参数表示当前方法或变量，第二个参数表示目标方法或变量，因为这关指令会破坏系统和包的模块化，因此在使用时必须导入unsafe
代码详见：https://github.com/xiazemin/golink
<!-- more -->
这个指令不经常用，最好也不要用，但理解这个指令可以帮助你理解核心包的很多代码。在标准库中是为了可以使用另一个包的unexported的方法或者变量，在敲代码的时候是不可包外访问的，但是运行时用这个命令hack了一下，就变得可以访问。
比如runtime 包 sema.go文件
//go:linkname notifyListWait sync.runtime_notifyListWait</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/17/linkname.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/17/go.html" class="post-title-link">
      <h2>Go 语言编译指示</h2>
    </a>

    <div class="post-date">Apr 17, 2019</div>
    
    <div class="post-body">
      
      <p>https://golang.org/cmd/compile/#hdr-Compiler_Directives
<!-- more -->
C 语言的 #include
一上来不太好说明白 Go 语言里 //go: 是什么，我们先来看下非常简单，也是几乎每个写代码的人都知道的东西：C 语言的 #include。
我猜，大部分人第一行代码都是 #include 吧。完整的就是#include <stdio.h>。意思很简单，引入一个 stdio.h。谁引入？答案是编译器。那么，# 字符的作用就是给 编译器 一个 指示，让编译器知道接下来要做什么。</stdio.h></p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/17/go.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/17/Cond.html" class="post-title-link">
      <h2>Cond</h2>
    </a>

    <div class="post-date">Apr 17, 2019</div>
    
    <div class="post-body">
      
      <p>Cond用于在并发环境下routine的等待和通知</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/17/Cond.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/14/reflection.html" class="post-title-link">
      <h2>reflection</h2>
    </a>

    <div class="post-date">Apr 14, 2019</div>
    
    <div class="post-body">
      
      <p>反射指的是程序借助某种手段检查自己结构的一种能力，通常就是借助编程语言中定义的各种类型（types）。
<!-- more -->
类型和接口（Types and interfaces）
因为反射是建立在类型系统（the type system）上的，所以让我们从复习Go中的类型开始讲起。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/14/reflection.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/04/06/net.html" class="post-title-link">
      <h2>Golang服务器的网络层实现--总结对比常用epoll模型</h2>
    </a>

    <div class="post-date">Apr 6, 2019</div>
    
    <div class="post-body">
      
      <p>对基于C/C++的网络模型实现和基于GoLang的实现对比下来，发现Golang的网络模型编程难度大大降低，这得益于Golang的goroutine，可以在编程的时候肆无忌惮的创建并发”线程”，当服务器能为每一个客户端都开启若干”线程”的话，编程变的简单很多。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/04/06/net.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/03/17/interface.html" class="post-title-link">
      <h2>interface</h2>
    </a>

    <div class="post-date">Mar 17, 2019</div>
    
    <div class="post-body">
      
      <p>package main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/03/17/interface.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/03/17/gc.html" class="post-title-link">
      <h2>gc</h2>
    </a>

    <div class="post-date">Mar 17, 2019</div>
    
    <div class="post-body">
      
      <p>垃圾回收方法
引用计数（reference counting）
这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。当引用计数为0时则立即回收对象。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/03/17/gc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/03/17/escape.html" class="post-title-link">
      <h2>escape 逃逸分析</h2>
    </a>

    <div class="post-date">Mar 17, 2019</div>
    
    <div class="post-body">
      
      <p>在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，可以分析在程序的哪些地方可以访问到指针。它涉及到指针分析和形状分析。 当一个变量(或对象)在子程序中被分配时，一个指向变量的指针可能逃逸到其它执行线程中，或者去调用子程序。如果使用尾递归优化（通常在函数编程语言中是需要的），对象也可能逃逸到被调用的子程序中。 如果一个子程序分配一个对象并返回一个该对象的指针，该对象可能在程序中的任何一个地方被访问到——这样指针就成功“逃逸”了。如果指针存储在全局变量或者其它数据结构中，它们也可能发生逃逸，这种情况是当前程序中的指针逃逸。 逃逸分析需要确定指针所有可以存储的地方，保证指针的生命周期只在当前进程或线程中。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/03/17/escape.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/03/10/slice.html" class="post-title-link">
      <h2>golang slice append 陷阱</h2>
    </a>

    <div class="post-date">Mar 10, 2019</div>
    
    <div class="post-body">
      
      <p>func main() {
    a := make([]int, 2, 2)
    a[0], a[1] = 1, 2</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/03/10/slice.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/02/24/sync.html" class="post-title-link">
      <h2>go语言sync包的学习(Mutex、WaitGroup、Cond)</h2>
    </a>

    <div class="post-date">Feb 24, 2019</div>
    
    <div class="post-body">
      
      <p>//加锁，注意锁要以指针的形式传进来，不然只是拷贝
func total1(num *int, mu *sync.Mutex, ch chan bool) {
    mu.Lock();
    for i := 0; i &lt; 1000; i++ {
        *num += i;
    }
    ch &lt;- true;
    mu.Unlock();
}
//Lock、Unlock与RLock、RUnlock不能嵌套使用
func printNum(num int, cond *sync.Cond) {
    cond.L.Lock();
    if num &lt; 5 {
        //num小于5时，进入等待状态
        cond.Wait();
    }
    //大于5的正常输出
    fmt.Println(num);
    cond.L.Unlock();
}
    //Once.Do()保证多次调用只执行一次
    once := sync.Once{};
    ch := make(chan bool, 3);
    for i := 0; i &lt; 3; i++ {
        go func(n int) {
            once.Do(func() {
                //只会执行一次，因为闭包引用了变量n，最后的值为2
                fmt.Println(n)</p>

<p>//读写锁，多了读锁定，和读解锁，让多个goroutine同时读取对象
    rwmutex := sync.RWMutex{};
   //组等待，等待一组goroutine的结束
    wg := sync.WaitGroup{};
    //增加计数器
    wg.Add(10);
    for i:= 0; i&lt; 10; i++ {
        go func(n int) {
            fmt.Print(n, “ “);
            //这里表示该goroutine执行完成
            wg.Done();
        }(i);
    }
    //等待所有线程执行完成
    wg.Wait();
<!-- more -->
无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/02/24/sync.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/02/24/stack.html" class="post-title-link">
      <h2>golang 的栈</h2>
    </a>

    <div class="post-date">Feb 24, 2019</div>
    
    <div class="post-body">
      
      <p>当启动一个C实现的thread时，C标准库会负责分配一块内存作为这个线程的栈。标准库分配这块内存，告诉内核它的位置并让内核处理这个线程 的执行。
在linux系统中，可通过 ulimit -s查看系统栈大小（8M）。
ulimit -s 10240可修改栈大小为10M。
这里最大的一个问题是，分配大数组，或者循环递归函数时，默认的栈空间不够用，会导致Segmentation fault错误。
解决方法有两个：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/02/24/stack.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/02/24/goasm.html" class="post-title-link">
      <h2>Go语言汇编</h2>
    </a>

    <div class="post-date">Feb 24, 2019</div>
    
    <div class="post-body">
      
      <p>Go语言的汇编基于Plan 9的汇编，但是有一些不同。最主要的一个区别是，Go语言的汇编指令不一定直接对应机器表示。有一些直接对应，有一些则不是。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/02/24/goasm.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/02/24/csp_actor.html" class="post-title-link">
      <h2>Actor模型和CSP模型的区别</h2>
    </a>

    <div class="post-date">Feb 24, 2019</div>
    
    <div class="post-body">
      
      <p>在Actor模型中，主角是Actor，类似一种worker，Actor彼此之间直接发送消息，不需要经过什么中介，消息是异步发送和处理的：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/02/24/csp_actor.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/02/24/csp.html" class="post-title-link">
      <h2>CSP(Communicating Sequential Processes)模型</h2>
    </a>

    <div class="post-date">Feb 24, 2019</div>
    
    <div class="post-body">
      
      <p>CSP 描述这样一种并发模型：多个Process 使用一个 Channel 进行通信,  这个 Channel 连结的 Process 通常是匿名的，消息传递通常是同步的（有别于 Actor Model）。
CSP 最早是由 Tony Hoare 在 1977 年提出，据说老爷子至今仍在更新这个理论模型
Golang，其实只用到了 CSP 的很小一部分，即理论中的 Process/Channel（对应到语言中的 goroutine/channel）：这两个并发原语之间没有从属关系， Process 可以订阅任意个 Channel，Channel 也并不关心是哪个 Process 在利用它进行通信；Process 围绕 Channel 进行读写，形成一套有序阻塞和可预测的并发模型。
<!-- more -->
Golang Scheduler
调度器由三方面实体构成：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/02/24/csp.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/02/24/Context.html" class="post-title-link">
      <h2>Context</h2>
    </a>

    <div class="post-date">Feb 24, 2019</div>
    
    <div class="post-body">
      
      <p>Go 中的 context 包在与 API 和慢处理交互时可以派上用场，特别是在生产级的 Web 服务中。在这些场景中，您可能想要通知所有的 goroutine 停止运行并返回。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/02/24/Context.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/02/23/unsafepointer.html" class="post-title-link">
      <h2>Go unsafe Pointer</h2>
    </a>

    <div class="post-date">Feb 23, 2019</div>
    
    <div class="post-body">
      
      <p>强类型意味着一旦定义了，它的类型就不能改变了；静态意味着类型检查在运行前就做了。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/02/23/unsafepointer.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/01/26/traps.html" class="post-title-link">
      <h2>traps</h2>
    </a>

    <div class="post-date">Jan 26, 2019</div>
    
    <div class="post-body">
      
      <p>译文：Golang 新手可能会踩的 50 个坑
https://github.com/wuYin/blog/blob/master/50-shades-of-golang-traps-gotchas-mistakes.md
原文：50 Shades of Go: Traps, Gotchas, and Common Mistakes
http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/
<!-- more -->
花时间学习官方 doc、wiki、讨论邮件列表、 Rob Pike 的大量文章以及 Go 的源码，会发现这篇文章中的坑是很常见的，新手跳过这些坑，能减少大量调试代码的时间。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/01/26/traps.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/01/26/stack.html" class="post-title-link">
      <h2>golang 内存分配</h2>
    </a>

    <div class="post-date">Jan 26, 2019</div>
    
    <div class="post-body">
      
      <p>1 变量的生命周期　　 
　　生命周期是指程序执行过程中变量存在的时间段。下面我们分别来看看包变量（全局变量）和局部变量两种变量的生命周期。 
　　① 包变量一直常驻在内存到程序的结束，然后被系统垃圾回收器回收。也就是说包变量的生命周期是整个程序的执行时间。 
　　② 局部变量，例如一个函数中定义的变量。它有一个动态的生命周期：每次执行生命语句时创建一个新的实体，变量一直生存到它变得不可访问（例如没有外部指针指向它，函数退出我们没有路径能访问到这个变量），这时它占用的存储空间就会被回收。 
　　所以我们有结论： 
　　并不是定义在函数内部的局部变量在访问退出函数后就会被回收! 
2 堆与栈的分配 
　　学过其他诸如C/C++语言的都知道，变量定义完成一般是分配在堆和栈空间上的。存在哪个空间上是跟你是否动态分配内存有关（new/malloc）。但是在Go语言上这个选择并不是基于使用var和new关键字来声明变量的。 
　　我们看下面两个程序实例：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/01/26/stack.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/01/26/nil.html" class="post-title-link">
      <h2>golang  nil 总结</h2>
    </a>

    <div class="post-date">Jan 26, 2019</div>
    
    <div class="post-body">
      
      <p>1.”“用法
使用”“判断string变量是否为空。
2.nil用法
使用nil判断结构体的指针是否为空。
3.len(s)用法
用于求数组、切片和字典的长度。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/01/26/nil.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2019/01/04/reflect.html" class="post-title-link">
      <h2>reflect golang 反射</h2>
    </a>

    <div class="post-date">Jan 4, 2019</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>Reflection（反射）在计算机中表示 程序能够检查自身结构的能力，尤其是类型。它是元编程的一种形式，也是最容易让人迷惑的一部分。
虽然Go语言没有继承的概念，但为了便于理解，如果一个struct A 实现了 interface B的所有方法时，我们称之为“继承”。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2019/01/04/reflect.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/12/29/recover.html" class="post-title-link">
      <h2>recover panic defer</h2>
    </a>

    <div class="post-date">Dec 29, 2018</div>
    
    <div class="post-body">
      
      <p>defer　　</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/12/29/recover.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/12/25/godebug.html" class="post-title-link">
      <h2>golang debug dlv</h2>
    </a>

    <div class="post-date">Dec 25, 2018</div>
    
    <div class="post-body">
      
      <p>https://github.com/go-lang-plugin-org/go-lang-idea-plugin#pre-release-builds
这个插件可以在idea上看到调试按钮，但是不好用
https://github.com/derekparker/delve
Go 官方的debug tool文档写的啥。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/12/25/godebug.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/12/25/gdbdlv.html" class="post-title-link">
      <h2>gdb dlv 对比</h2>
    </a>

    <div class="post-date">Dec 25, 2018</div>
    
    <div class="post-body">
      
      <p>https://guidao.github.io/go_debug.html#orgheadline3
1 调试工具gdb
gdb 是一个调试工具，可以调试很多种语言，当然其中就有golang。由于gdb不能显示go的数据类型，所以在go的runtime源码下有一个python代码文件,runtime-gdb.py，提供给gdb一个扩展。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/12/25/gdbdlv.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/12/25/gdb_.html" class="post-title-link">
      <h2>gdb 工作原理和内核实现</h2>
    </a>

    <div class="post-date">Dec 25, 2018</div>
    
    <div class="post-body">
      
      <p>gdb主要功能的实现依赖于一个系统函数ptrace，通过man手册可以了解到，ptrace可以让父进程观察和控制其子进程的检查、执行，改变其寄存器和内存的内容，主要应用于打断点（也是gdb的主要功能）和打印系统调用轨迹。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/12/25/gdb_.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/12/25/gdb.html" class="post-title-link">
      <h2>gdb 调试golang</h2>
    </a>

    <div class="post-date">Dec 25, 2018</div>
    
    <div class="post-body">
      
      <p>编译过的二进制文件已经包含了 DWARFv3 调试信息，只要 GDB7.1 以上版本都可以进行调试。 在OSX下，如无法执行调试指令，可尝试用sudo方式执行gdb。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/12/25/gdb.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/12/24/go-bindata.html" class="post-title-link">
      <h2>go-bindata Go 语言打包静态文件</h2>
    </a>

    <div class="post-date">Dec 24, 2018</div>
    
    <div class="post-body">
      
      <p>https://github.com/jteeuwen/go-bindata
go get -u github.com/jteeuwen/go-bindata/…
执行后仍然没有找到go-bindata命令</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/12/24/go-bindata.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/12/24/esc.html" class="post-title-link">
      <h2>esc</h2>
    </a>

    <div class="post-date">Dec 24, 2018</div>
    
    <div class="post-body">
      
      <p>https://github.com/mjibson/esc
https://mattjibson.com/esc/</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/12/24/esc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/12/24/Generate.html" class="post-title-link">
      <h2>go Generate</h2>
    </a>

    <div class="post-date">Dec 24, 2018</div>
    
    <div class="post-body">
      
      <p>在有些场景下，我们会使用go generate：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/12/24/Generate.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/12/22/gotest_subline.html" class="post-title-link">
      <h2>subline text3 自动生成测试代码</h2>
    </a>

    <div class="post-date">Dec 22, 2018</div>
    
    <div class="post-body">
      
      <p>方式1:命令行
#!/bin/bash
cd shell/
~/goLang/bin/gotests -all -w ./
#生成测试文件,添加测试用例
go test -coverprofile=coverage.out
#生成coverage.out
go tool cover -html=coverage.out
#弹出页面
#file:///var/folders/r9/35q9g3d56_d9g0v59w9x2l9w0000gn/T/cover915348153/coverage.html#file0</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/12/22/gotest_subline.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/12/21/gotest.html" class="post-title-link">
      <h2>go test</h2>
    </a>

    <div class="post-date">Dec 21, 2018</div>
    
    <div class="post-body">
      
      <p>https://blog.golang.org/cover
go test -cover
go test -coverprofile=coverage.out 
go tool cover -func=coverage.out
go tool cover -html=coverage.out</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/12/21/gotest.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/12/20/strcut.html" class="post-title-link">
      <h2>golang strcut 初始化</h2>
    </a>

    <div class="post-date">Dec 20, 2018</div>
    
    <div class="post-body">
      
      <p>package main</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/12/20/strcut.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/12/14/reference.html" class="post-title-link">
      <h2>golang 传值传引用</h2>
    </a>

    <div class="post-date">Dec 14, 2018</div>
    
    <div class="post-body">
      
      <p>golang中大多数是传值的,有：
基本类型:byte,int,bool,string
复合类型:数组,数组切片,结构体,map,channnel
在函数中参数的传递可以是传值（对象的复制,需要开辟新的空间来存储该新对象）和传引用（指针的复制，和原来的指针指向同一个对象），建议使用指针，原因有两个：能够改变参数的值，避免大对象的复制操作节省内存。struct和数组的用法类似
channel和数组切片，map一样，传参的方式是传值，都可以直接使用，其内部维护着指向真正存储空间的指针。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/12/14/reference.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/11/26/postfile.html" class="post-title-link">
      <h2>Multipart File Upload</h2>
    </a>

    <div class="post-date">Nov 26, 2018</div>
    
    <div class="post-body">
      
      <p>multipart/form-data 顾名思义可以上传多个form-data 并且用分隔符进行分割，多用于文件上传
multipart/form-data 请求样例</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/11/26/postfile.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/11/26/float64.html" class="post-title-link">
      <h2>golang 的坑</h2>
    </a>

    <div class="post-date">Nov 26, 2018</div>
    
    <div class="post-body">
      
      <p>Golang 使用 JSON unmarshal 数字到 interface{} 数字变成 float64 类型
由于 JSON 里的数字默认都会转成 Golang 的 float64 类型引起的，
使用 Golang 解析 JSON  格式数据时，若以 interface{} 接收数据，则会按照下列规则进行解析：
    bool, for JSON booleans
    float64, for JSON numbers</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/11/26/float64.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/11/26/authentication.html" class="post-title-link">
      <h2>http basic authentication</h2>
    </a>

    <div class="post-date">Nov 26, 2018</div>
    
    <div class="post-body">
      
      <p>何为basic authentication
In the context of a HTTP transaction, basic access authentication is a method for a HTTP user agent to provide a user name and password when making a request.</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/11/26/authentication.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/09/27/goautomic.html" class="post-title-link">
      <h2>go 原子操作</h2>
    </a>

    <div class="post-date">Sep 27, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>主要用于数值的操作，由于原子操作可有底层硬件实现，通常比操作系统层的锁机制效率要高。
一共分为5类，LoadT、StoreT、AddT、SwapT和CompareAndSwapT。
func
 LoadT(addr <em>T) (val T) 
func
 StoreT(addr </em>T) (val T)
func
 AddT(addr *T, delta T) (new T)
func
 SwapT(addr *T, new T) (old T)
func
 CompareAndSwapT(addr *T, old, new T) (swapped bool)
T代表int32、int64、uint32、uint64、unitptr、pointer。</p>

    </div>

    <a class="read-more" href="/MyBlog/golang/2018/09/27/goautomic.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/07/04/golang_list.html" class="post-title-link">
      <h2>golang list jsonMarshal之后一个为null一个为[ ]问题</h2>
    </a>

    <div class="post-date">Jul 4, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>两种不同的初始化方式引起的，函数返回值和var方式都是“声明”，而不是“定义”。fmt的输出和jsonMarshal也不一样</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/07/04/golang_list.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/06/26/pool.html" class="post-title-link">
      <h2>pool</h2>
    </a>

    <div class="post-date">Jun 26, 2018</div>
    
    <div class="post-body">
      
      <p>一个sync.Pool对象就是一组临时对象的集合。Pool是协程安全的。
Pool用于存储那些被分配了但是没有被使用，而未来可能会使用的值，以减小垃圾回收的压力。一个比较好的例子是fmt包，fmt包总是需要使用一些[]byte之类的对象，golang建立了一个临时对象池，存放着这些对象，如果需要使用一个[]byte，就去Pool里面拿，如果拿不到就分配一份。
这比起不停生成新的[]byte，用完了再等待gc回收来要高效得多。
<!-- more -->
sync.Pool有两个公开的方法。一个是Get，另一个是Put。前者的功能是从池中获取一个interface{}类型的值，而后者的作用则是把一个interface{}类型的值放置于池中。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/06/26/pool.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/05/24/fsnotify_go.html" class="post-title-link">
      <h2>golang fsnotify</h2>
    </a>

    <div class="post-date">May 24, 2018</div>
    
    <div class="post-body">
      
      <p>fsnotify是一个文件系统监控库, 它可以支持在如下系统上使用:</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/05/24/fsnotify_go.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/05/18/PostForm.html" class="post-title-link">
      <h2>PostForm</h2>
    </a>

    <div class="post-date">May 18, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>golang http.request的三个属性Form、PostForm、MultipartForm</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/05/18/PostForm.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/05/17/template.html" class="post-title-link">
      <h2>template</h2>
    </a>

    <div class="post-date">May 17, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>1， 前端部分：
【模板标签】
模板标签用”qqqq”和”qqqq”括起来
【注释】
qqqq/* a comment <em>/qqqq
使用“qqqq/</em>”和“*/qqqq”来包含注释内容
【变量】
qqqq.qqqq
此标签输出当前对象的值
qqqq.Admpubqqqq
表示输出Struct对象中字段或方法名称为“Admpub”的值。
当“Admpub”是匿名字段时，可以访问其内部字段或方法,比如“Com”：qqqq.Admpub.Comqqqq ，
如果“Com”是一个方法并返回一个Struct对象，同样也可以访问其字段或方法：qqqq.Admpub.Com.Field1qqqq
qqqq.Method1 “参数值1” “参数值2”qqqq
调用方法“Method1”，将后面的参数值依次传递给此方法，并输出其返回值。
qqqq$admpubqqqq
此标签用于输出在模板中定义的名称为“admpub”的变量。当$admpub本身是一个Struct对象时，可访问其字段：qqqq$admpub.Field1qqqq
在模板中定义变量：变量名称用字母和数字组成，并带上“$”前缀，采用符号“:=”进行赋值。
比如：qqqq$x := “OK”qqqq 或 qqqq$x := pipelineqqqq
【管道函数】
用法1：
qqqqFuncName1qqqq
此标签将调用名称为“FuncName1”的模板函数（等同于执行“FuncName1()”，不传递任何参数）并输出其返回值。
用法2：
qqqqFuncName1 “参数值1” “参数值2”qqqq
此标签将调用“FuncName1(“参数值1”, “参数值2”)”，并输出其返回值
用法3：
qqqq.Admpub|FuncName1qqqq
此标签将调用名称为“FuncName1”的模板函数（等同于执行“FuncName1(this.Admpub)”，将竖线“|”左边的“.Admpub”变量值作为函数参数传送）并输出其返回值。
【条件判断】
用法1：
qqqqif pipelineqqqq T1 qqqqendqqqq
标签结构：qqqqif …qqqq … qqqqendqqqq
用法2：
qqqqif pipelineqqqq T1 qqqqelseqqqq T0 qqqqendqqqq
标签结构：qqqqif …qqqq … qqqqelseqqqq … qqqqendqqqq
用法3：
qqqqif pipelineqqqq T1 qqqqelse if pipelineqqqq T0 qqqqendqqqq
标签结构：qqqqif …qqqq … qqqqelse if …qqqq … qqqqendqqqq
其中if后面可以是一个条件表达式（包括管道函数表达式。pipeline即管道），也可以是一个字符窜变量或布尔值变量。当为字符窜变量时，如为空字符串则判断为false，否则判断为true。
【遍历】
用法1：
qqqqrange $k, $v := .Varqqqq qqqq$kqqqq =&gt; qqqq$vqqqq qqqqend}}
range…end结构内部如要使用外部的变量，比如.Var2，需要这样写：$.Var2
（即：在外部变量名称前加符号“$”即可，单独的“$”意义等同于global）
用法2：
qqqqrange .Varqqqq qqqq.qqqq qqqqendqqqq
用法3：
qqqqrange pipelineqqqq T1 qqqqelseqqqq T0 qqqqendqqqq
当没有可遍历的值时，将执行else部分。
【嵌入子模板】
用法1：
qqqqtemplate “name”qqqq
嵌入名称为“name”的子模板。使用前，请确保已经用“qqqqdefine “name”qqqq子模板内容qqqqendqqqq”定义好了子模板内容。
用法2：
qqqqtemplate “name” pipelineqqqq
将管道的值赋给子模板中的“.”（即“qqqq.qqqq”）
【子模板嵌套】
qqqqdefine “T1”qqqqONEqqqqendqqqq
qqqqdefine “T2”qqqqTWOqqqqendqqqq
qqqqdefine “T3”qqqqqqqqtemplate “T1”qqqq qqqqtemplate “T2”qqqqqqqqend}}
qqqqtemplate “T3”qqqq
输出：
ONE TWO
【定义局部变量】
用法1：
qqqqwith pipelineqqqq T1 qqqqendqqqq
管道的值将赋给该标签内部的“.”。（注：这里的“内部”一词是指被qqqqwith pipelineqqqq…qqqqendqqqq包围起来的部分，即T1所在位置）
用法2：
qqqqwith pipelineqqqq T1 qqqqelseqqqq T0 qqqqendqqqq
如果管道的值为空，“.”不受影响并且执行T0，否则，将管道的值赋给“.”并且执行T1。
说明：qqqqendqqqq标签是if、with、range的结束标签。
【例子：输出字符窜】
qqqq”"output"“qqqq
输出一个字符窜常量。
qqqq<code class="highlighter-rouge">"output"</code>qqqq
输出一个原始字符串常量
qqqqprintf “%q” “output”qqqq
函数调用.（等同于：printf(“%q”, “output”)。）
qqqq”output” | printf “%q”qqqq
竖线“|”左边的结果作为函数最后一个参数。（等同于：printf(“%q”, “output”)。）
qqqqprintf “%q” (print “out” “put”)qqqq
圆括号中表达式的整体结果作为printf函数的参数。（等同于：printf(“%q”, print(“out”, “put”))。）
qqqq”put” | printf “%s%s” “out” | printf “%q”qqqq
一个更复杂的调用。（等同于：printf(“%q”, printf(“%s%s”, “out”, “put”))。）
qqqq”output” | printf “%s” | printf “%q”qqqq
等同于：printf(“%q”, printf(“%s”, “output”))。
qqqqwith “output”qqqqqqqqprintf “%q” .qqqqqqqqendqqqq
一个使用点号“.”的with操作。（等同于：printf(“%q”, “output”)。）
qqqqwith $x := “output” | printf “%q”qqqqqqqq$xqqqqqqqqendqqqq
with结构，定义变量，值为执行管道函数之后的结果（等同于：$x := printf(“%q”, “output”)。）
qqqqwith $x := “output”qqqqqqqqprintf “%q” $xqqqqqqqqendqqqq
with结构中，在其它动作中使用定义的变量
qqqqwith $x := “output”qqqqqqqq$x | printf “%q”qqqqqqqqendqqqq
同上，但使用了管道。（等同于：printf(“%q”, “output”)。）
===============【预定义的模板全局函数】================
【and】
qqqqand x yqqqq
表示：if x then y else x
如果x为真，返回y，否则返回x。等同于Golang中的：x &amp;&amp; y
【call】
qqqqcall .X.Y 1 2qqqq
表示：dot.X.Y(1, 2)
call后面的第一个参数的结果必须是一个函数（即这是一个函数类型的值），其余参数作为该函数的参数。
该函数必须返回一个或两个结果值，其中第二个结果值是error类型。
如果传递的参数与函数定义的不匹配或返回的error值不为nil，则停止执行。
【html】
转义文本中的html标签，如将“&lt;”转义为“&lt;”，“&gt;”转义为“&gt;”等
【index】
qqqqindex x 1 2 3qqqq
返回index后面的第一个参数的某个索引对应的元素值，其余的参数为索引值
表示：x[1][2][3]
x必须是一个map、slice或数组
【js】
返回用JavaScript的escape处理后的文本
【len】
返回参数的长度值（int类型）
【not】
返回单一参数的布尔否定值。
【or】
qqqqor x yqqqq
表示：if x then x else y。等同于Golang中的：x || y
如果x为真返回x，否则返回y。
【print】
fmt.Sprint的别名
【printf】
fmt.Sprintf的别名
【println】
fmt.Sprintln的别名
【urlquery】
返回适合在URL查询中嵌入到形参中的文本转义值。（类似于PHP的urlencode）
=================【布尔函数】===============
布尔函数对于任何零值返回false，非零值返回true。
这里定义了一组二进制比较操作符函数：
【eq】
返回表达式“arg1 == arg2”的布尔值
【ne】
返回表达式“arg1 != arg2”的布尔值
【lt】
返回表达式“arg1 &lt; arg2”的布尔值
【le】
返回表达式“arg1 &lt;= arg2”的布尔值
【gt】
返回表达式“arg1 &gt; arg2”的布尔值
【ge】
返回表达式“arg1 &gt;= arg2”的布尔值
对于简单的多路相等测试，eq只接受两个参数进行比较，后面其它的参数将分别依次与第一个参数进行比较，
qqqqeq arg1 arg2 arg3 arg4qqqq
即只能作如下比较：
arg1==arg2 || arg1==arg3 || arg1==arg4 …</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/05/17/template.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/04/24/flag.html" class="post-title-link">
      <h2>flag</h2>
    </a>

    <div class="post-date">Apr 24, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>一、命令行语法
命令行语法主要有以下几种形式：</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/04/24/flag.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/04/16/json.html" class="post-title-link">
      <h2>json</h2>
    </a>

    <div class="post-date">Apr 16, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>“encoding/json”的源码：
func Unmarshal(data []byte, v interface{}) error {
	// Check for well-formedness.
	// Avoids filling out half a data structure
	// before discovering a JSON syntax error.
	var d decodeState
	err := checkValid(data, &amp;d.scan)
	if err != nil {
		return err
	}</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/04/16/json.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/04/15/fsnotify.html" class="post-title-link">
      <h2>fsnotify bee 热编译</h2>
    </a>

    <div class="post-date">Apr 15, 2018</div>
    
    <div class="post-body">
      
      <p>参考：
https://github.com/howeyc/fsnotify
https://beego.me/docs/install/bee.md
<!-- more -->
bee 使用fsnotify包，使用kqueue检查文件变化，根据修改时间戳，每s检查一次，如果有变化就重新编译，调用路径如下：
beego/bee/bee.go
var commands = []*Command{
	cmdNew,
	cmdRun,
	…
	}
func main() {
  …
  for _, cmd := range commands {
		…
		os.Exit(cmd.Run(cmd, args))
		…
}</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/04/15/fsnotify.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/03/27/intellij.html" class="post-title-link">
      <h2>intellij 配置</h2>
    </a>

    <div class="post-date">Mar 27, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>下载http://xclient.info/s/intellij-idea.html?_=a52dae8e0223d9651b825587a606f66f#history_versions
IntelliJ IDEA Ultimate Edition_2016.2_xclient.info.dmg
这个版本可用
Golang插件是是个开源项目，项目地址：https://github.com/go-lang-plugin-org/go-lang-idea-plugin
	<img src="https://xiazemin.github.io/MyBlog/img/goIdea.png" /></p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/03/27/intellij.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/03/27/context.html" class="post-title-link">
      <h2>context</h2>
    </a>

    <div class="post-date">Mar 27, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>1 什么是Context
分析gRPC源码，proto文件生成的代码，接口函数第一个参数统一是ctx context.Context接口</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/03/27/context.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/03/23/online_build.html" class="post-title-link">
      <h2>golang热编译工具</h2>
    </a>

    <div class="post-date">Mar 23, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>fswatch是一个工具, 通过检测文件的变化,并触发指定的命令
bee只适合Go语言; 而fswatch可以适用各种语言, 甚至是文件的远程同步
bee可以通过配置指定监控的文件夹; fswatch可以配置监控的文件夹并指定监控的深度(0代表当前目录)
bee可以指定监控文件的后缀; fswatch支持使用正则表达式, 来过滤监控到的文件.
bee.json需要重其他地方拷贝;但是.fsw.yml可以自动生成出来.
fswatch支持group kill. 这样可以确保fswatch停止后,不会有垃圾进程的存在.
fswatch会根据程序的运行时间自动判断, 是否为服务端程序, 并适当的修改重启策略.
bee功能庞大; fswatch的代码精简.</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/03/23/online_build.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/03/23/glide.html" class="post-title-link">
      <h2>glide 包依赖管理</h2>
    </a>

    <div class="post-date">Mar 23, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>Golang亦有godep、govendor、glide、gvt、gopack等等</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/03/23/glide.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/03/17/unsafe.html" class="post-title-link">
      <h2>unsafe cgo</h2>
    </a>

    <div class="post-date">Mar 17, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>unsafe包是一个采用特殊方式实现的包。虽然它可以和普通包一样的导入和使用，但它实际上是由编译器实现的。unsafe包被广泛地用于比较低级的包, 例如runtime、os、syscall还有net包等，因为它们需要和操作系统密切配合，但是对于普通的程序一般是不需要使用unsafe包的。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/03/17/unsafe.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/03/17/reflect.html" class="post-title-link">
      <h2>reflect</h2>
    </a>

    <div class="post-date">Mar 17, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/03/17/reflect.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/03/17/package.html" class="post-title-link">
      <h2>go package</h2>
    </a>

    <div class="post-date">Mar 17, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/03/17/package.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/03/17/goroutine.html" class="post-title-link">
      <h2>goroutine</h2>
    </a>

    <div class="post-date">Mar 17, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<ol>
  <li>动态栈
每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。这个固定大小的栈同时很大又很小。因为2MB的栈对于一个小小的goroutine来说是很大的内存浪费，比如对于我们用到的，一个只是用来WaitGroup之后关闭channel的goroutine来说。而对于go程序来说，同时创建成百上千个goroutine是非常普遍的，如果每一个goroutine都需要这么大的栈的话，那这么多的goroutine就不太可能了。除去大小的问题之外，固定大小的栈对于更复杂或者更深层次的递归函数调用来说显然是不够的。修改固定的大小可以提升空间的利用率允许创建更多的线程，并且可以允许更深的递归调用，不过这两者是没法同时兼备的。</li>
</ol>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/03/17/goroutine.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/03/17/go_test.html" class="post-title-link">
      <h2>go test</h2>
    </a>

    <div class="post-date">Mar 17, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/03/17/go_test.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/03/17/coroutine.html" class="post-title-link">
      <h2>进程和线程、协程的区别</h2>
    </a>

    <div class="post-date">Mar 17, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/03/17/coroutine.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/03/16/go_func.html" class="post-title-link">
      <h2>golang 返回函数的匿名函数 vs 接收器的方法</h2>
    </a>

    <div class="post-date">Mar 16, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>返回函数的匿名函数:</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">
</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">Point</span><span class="x"> </span><span class="k">struct</span><span class="p">{</span><span class="x"> </span><span class="n">X</span><span class="p">,</span><span class="x"> </span><span class="n">Y</span><span class="x"> </span><span class="kt">float64</span><span class="x"> </span><span class="p">}</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">f</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">p</span><span class="x"> </span><span class="n">Point</span><span class="p">)</span><span class="x">  </span><span class="k">func</span><span class="x"> </span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="k">var</span><span class="x"> </span><span class="n">x</span><span class="x"> </span><span class="kt">int</span><span class="x">
		</span><span class="k">return</span><span class="x"> </span><span class="k">func</span><span class="x"> </span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="n">x</span><span class="o">++</span><span class="x">
			</span><span class="k">return</span><span class="x"> </span><span class="n">x</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">x</span><span class="x">
		</span><span class="p">}</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="n">p</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">Point</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="m">2</span><span class="p">}</span><span class="x">
	</span><span class="n">g</span><span class="o">:=</span><span class="n">f</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="x">
	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"result:"</span><span class="p">,</span><span class="n">g</span><span class="p">())</span><span class="x">
	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"result:"</span><span class="p">,</span><span class="n">g</span><span class="p">())</span><span class="x">
</span><span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure>

<p>result: 1
result: 4</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/03/16/go_func.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/golang/2018/03/16/go-tour.html" class="post-title-link">
      <h2>go-tour 安装</h2>
    </a>

    <div class="post-date">Mar 16, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>由于 go get code.google.com/p/go-tour/gotour<br />
报错： 
 # cd .; hg clone -U https://code.google.com/p/go-tour /usr/home/huaying/go/src/pkg/code.google.com/p/go-tour<br />
abort: error: EOF occurred in violation of protocol<br />
package code.google.com/p/go-tour/gotour: exit status 255</p>


    </div>

    <a class="read-more" href="/MyBlog/golang/2018/03/16/go-tour.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>



                    </div>
					<hr>
            </div>

            <!-- Blog Sidebar Widgets Column -->
            <div class="col-md-4">

            	 <div class="well">
            	 	<span id='statics' ></span>
            	 </div>

                <!-- Blog Search Well -->
                <div class="well">
                    <h4>Search</h4>
                    <div class="input-group">
					<form action="#" id="cse-search-box">
					  <div>
					    <input type="hidden" name="cx" value="" />
					    <input type="hidden" name="ie" value="UTF-8" />
					    <!-- 搜索框 -->   
					    <input type="text" name="q" size="20" id='txt' />
					    <input type="submit" name="sa" value="Search" />
						<!-- 模糊查询结果显示框 -->
						<div id="msg"></div>
							<script type="text/javascript">  
							var searchIndex={
							"code" : 0 ,
							"data" : [
							
							{
							"title" : "tcp_tw_reuse - ",
							"url" : "/MyBlog/linux/2019/12/13/tcp_tw_reuse.html"
							}
							
							,
							
							
							{
							"title" : "tcp_tw_recycle - ",
							"url" : "/MyBlog/linux/2019/12/13/tcp_tw_recycle.html"
							}
							
							,
							
							
							{
							"title" : "tcp_retries - ",
							"url" : "/MyBlog/linux/2019/12/13/tcp_retries.html"
							}
							
							,
							
							
							{
							"title" : "MTU、MSS、MSL、RTT、TTL、RTO - ",
							"url" : "/MyBlog/linux/2019/12/13/rto.html"
							}
							
							,
							
							
							{
							"title" : "chrome 无法打开https 网站问题解决 - ",
							"url" : "/MyBlog/web/2019/12/13/chrome.html"
							}
							
							,
							
							
							{
							"title" : "gateway - ",
							"url" : "/MyBlog/linux/2019/12/12/gateway.html"
							}
							
							,
							
							
							{
							"title" : "cni cnm - ",
							"url" : "/MyBlog/docker/2019/12/12/cni_cnm.html"
							}
							
							,
							
							
							{
							"title" : "ip netns - ",
							"url" : "/MyBlog/linux/2019/12/10/netns.html"
							}
							
							,
							
							
							{
							"title" : "netfilter iptables - ",
							"url" : "/MyBlog/linux/2019/12/10/netfilter.html"
							}
							
							,
							
							
							{
							"title" : "12306 抢票，极限并发带来的思考 - ",
							"url" : "/MyBlog/web/2019/12/10/12306.html"
							}
							
							,
							
							
							{
							"title" : "tcp - ",
							"url" : "/MyBlog/linux/2019/12/09/tcp.html"
							}
							
							,
							
							
							{
							"title" : "redis ssh 漏洞 - ",
							"url" : "/MyBlog/storage/2019/12/09/ssh.html"
							}
							
							,
							
							
							{
							"title" : "redis config - ",
							"url" : "/MyBlog/storage/2019/12/09/redis.html"
							}
							
							,
							
							
							{
							"title" : "skydns - ",
							"url" : "/MyBlog/docker/2019/12/08/skydns.html"
							}
							
							,
							
							
							{
							"title" : "resolv.conf - ",
							"url" : "/MyBlog/linux/2019/12/08/resolv.html"
							}
							
							,
							
							
							{
							"title" : "itoa - ",
							"url" : "/MyBlog/golang/2019/12/02/itoa.html"
							}
							
							,
							
							
							{
							"title" : "interceptor - ",
							"url" : "/MyBlog/golang/2019/12/02/interceptor.html"
							}
							
							,
							
							
							{
							"title" : "grpc http2 - ",
							"url" : "/MyBlog/golang/2019/12/02/http2.html"
							}
							
							,
							
							
							{
							"title" : "gRPC vs Thrift - ",
							"url" : "/MyBlog/golang/2019/12/02/gRPC.html"
							}
							
							,
							
							
							{
							"title" : "gRPC ProtoBuf - ",
							"url" : "/MyBlog/golang/2019/12/02/ProtoBuf.html"
							}
							
							,
							
							
							{
							"title" : "runtime.Caller runtime.FuncForPC - ",
							"url" : "/MyBlog/golang/2019/12/02/Caller.html"
							}
							
							,
							
							
							{
							"title" : "scp - ",
							"url" : "/MyBlog/web/2019/12/01/scp.html"
							}
							
							,
							
							
							{
							"title" : "Replication Controller、Replica Set - ",
							"url" : "/MyBlog/golang/2019/12/01/rc.html"
							}
							
							,
							
							
							{
							"title" : "kubernetes - ",
							"url" : "/MyBlog/golang/2019/12/01/kubernetes.html"
							}
							
							,
							
							
							{
							"title" : "cli - ",
							"url" : "/MyBlog/golang/2019/12/01/cli.html"
							}
							
							,
							
							
							{
							"title" : "borg - ",
							"url" : "/MyBlog/golang/2019/12/01/borg.html"
							}
							
							,
							
							
							{
							"title" : "Sidecar - ",
							"url" : "/MyBlog/golang/2019/11/30/Sidecar.html"
							}
							
							,
							
							
							{
							"title" : "SOFA-MOSN - ",
							"url" : "/MyBlog/golang/2019/11/30/SOFA-MOSN.html"
							}
							
							,
							
							
							{
							"title" : "injector - ",
							"url" : "/MyBlog/golang/2019/11/29/injector.html"
							}
							
							,
							
							
							{
							"title" : "Martini - ",
							"url" : "/MyBlog/golang/2019/11/29/Martini.html"
							}
							
							,
							
							
							{
							"title" : "hijack - ",
							"url" : "/MyBlog/golang/2019/11/28/hijack.html"
							}
							
							,
							
							
							{
							"title" : "gometalinter - ",
							"url" : "/MyBlog/golang/2019/11/28/gometalinter.html"
							}
							
							,
							
							
							{
							"title" : "HandleFunc - ",
							"url" : "/MyBlog/golang/2019/11/28/HandleFunc.html"
							}
							
							,
							
							
							{
							"title" : "pkgconfig - ",
							"url" : "/MyBlog/linux/2019/11/27/pkgconfig.html"
							}
							
							,
							
							
							{
							"title" : "Go内存原理详解 - ",
							"url" : "/MyBlog/golang/2019/11/27/mcache.html"
							}
							
							,
							
							
							{
							"title" : "hijack - ",
							"url" : "/MyBlog/golang/2019/11/27/hijack.html"
							}
							
							,
							
							
							{
							"title" : "heap - ",
							"url" : "/MyBlog/golang/2019/11/27/heap.html"
							}
							
							,
							
							
							{
							"title" : "gracefull - ",
							"url" : "/MyBlog/golang/2019/11/27/graceful.html"
							}
							
							,
							
							
							{
							"title" : "cgo - ",
							"url" : "/MyBlog/golang/2019/11/27/cgo.html"
							}
							
							,
							
							
							{
							"title" : "ast rewrite - ",
							"url" : "/MyBlog/golang/2019/11/27/ast.html"
							}
							
							,
							
							
							{
							"title" : "Pkg-Config cgo - ",
							"url" : "/MyBlog/golang/2019/11/27/Pkg-Config.html"
							}
							
							,
							
							
							{
							"title" : "Deadline - ",
							"url" : "/MyBlog/golang/2019/11/27/Deadline.html"
							}
							
							,
							
							
							{
							"title" : "CFLAGS - ",
							"url" : "/MyBlog/golang/2019/11/27/CFLAGS.html"
							}
							
							,
							
							
							{
							"title" : "Deadline - ",
							"url" : "/MyBlog/golang/2019/11/26/Deadline.html"
							}
							
							,
							
							
							{
							"title" : "CFLAGS - ",
							"url" : "/MyBlog/golang/2019/11/26/CFLAGS.html"
							}
							
							,
							
							
							{
							"title" : "tags - ",
							"url" : "/MyBlog/golang/2019/11/25/tags.html"
							}
							
							,
							
							
							{
							"title" : "Go写的程序需不需要glibc - ",
							"url" : "/MyBlog/golang/2019/11/24/libc.html"
							}
							
							,
							
							
							{
							"title" : "hook glibc - ",
							"url" : "/MyBlog/linux/2019/11/24/glibc.html"
							}
							
							,
							
							
							{
							"title" : "实现一个 Golang 调试器 - ",
							"url" : "/MyBlog/golang/2019/11/24/gdb.html"
							}
							
							,
							
							
							{
							"title" : "dlsym - ",
							"url" : "/MyBlog/linux/2019/11/24/dlsym.html"
							}
							
							,
							
							
							{
							"title" : "Golang生成动态库及调用 - ",
							"url" : "/MyBlog/golang/2019/11/24/dll.html"
							}
							
							,
							
							
							{
							"title" : "cgo 原理 - ",
							"url" : "/MyBlog/golang/2019/11/24/cgo.html"
							}
							
							,
							
							
							{
							"title" : "golang 实现 LD_PRELOAD 拦截 libc - ",
							"url" : "/MyBlog/golang/2019/11/24/LD_PRELOAD.html"
							}
							
							,
							
							
							{
							"title" : "DYLD_INTERPOSE - ",
							"url" : "/MyBlog/linux/2019/11/24/DYLD_INTERPOSE.html"
							}
							
							,
							
							
							{
							"title" : "DYLD_FORCE_FLAT_NAMESPACE - ",
							"url" : "/MyBlog/linux/2019/11/24/DYLD_FORCE_FLAT_NAMESPACE.html"
							}
							
							,
							
							
							{
							"title" : "LD_LIBRARY_PATH - ",
							"url" : "/MyBlog/linux/2019/11/24/.html"
							}
							
							,
							
							
							{
							"title" : "tcmalloc - ",
							"url" : "/MyBlog/golang/2019/11/23/%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE.html"
							}
							
							,
							
							
							{
							"title" : "set - ",
							"url" : "/MyBlog/linux/2019/11/23/set.html"
							}
							
							,
							
							
							{
							"title" : "select - ",
							"url" : "/MyBlog/golang/2019/11/23/select.html"
							}
							
							,
							
							
							{
							"title" : "Kubernetes Pod 的实现原理 - ",
							"url" : "/MyBlog/golang/2019/11/23/pod.html"
							}
							
							,
							
							
							{
							"title" : "k3s - ",
							"url" : "/MyBlog/golang/2019/11/23/k3s.html"
							}
							
							,
							
							
							{
							"title" : "flutter - ",
							"url" : "/MyBlog/web/2019/11/23/flutter.html"
							}
							
							,
							
							
							{
							"title" : "dubbo-go - ",
							"url" : "/MyBlog/golang/2019/11/23/dubbo-go.html"
							}
							
							,
							
							
							{
							"title" : "build go src - ",
							"url" : "/MyBlog/golang/2019/11/23/buildgo.html"
							}
							
							,
							
							
							{
							"title" : "bfe - ",
							"url" : "/MyBlog/golang/2019/11/23/bfe.html"
							}
							
							,
							
							
							{
							"title" : "BigCache - ",
							"url" : "/MyBlog/golang/2019/11/23/BigCache.html"
							}
							
							,
							
							
							{
							"title" : "docker - ",
							"url" : "/MyBlog/docker/2019/11/20/docker.html"
							}
							
							,
							
							
							{
							"title" : "git Patch - ",
							"url" : "/MyBlog/web/2019/11/20/Patch.html"
							}
							
							,
							
							
							{
							"title" : "build - ",
							"url" : "/MyBlog/golang/2019/11/19/build.html"
							}
							
							,
							
							
							{
							"title" : "gometalinter - ",
							"url" : "/MyBlog/golang/2019/11/17/gometalinter.html"
							}
							
							,
							
							
							{
							"title" : "uintptr 临时变量gc风险 - ",
							"url" : "/MyBlog/golang/2019/11/16/uintptr.html"
							}
							
							,
							
							
							{
							"title" : "sysmon - ",
							"url" : "/MyBlog/golang/2019/11/16/sysmon.html"
							}
							
							,
							
							
							{
							"title" : "scheduler - ",
							"url" : "/MyBlog/golang/2019/11/16/scheduler.html"
							}
							
							,
							
							
							{
							"title" : "time/rate - ",
							"url" : "/MyBlog/golang/2019/11/16/rate.html"
							}
							
							,
							
							
							{
							"title" : "pprof - ",
							"url" : "/MyBlog/golang/2019/11/16/pprof.html"
							}
							
							,
							
							
							{
							"title" : "netpoll - ",
							"url" : "/MyBlog/golang/2019/11/16/netpoll.html"
							}
							
							,
							
							
							{
							"title" : "ldflags - ",
							"url" : "/MyBlog/golang/2019/11/16/ldflags.html"
							}
							
							,
							
							
							{
							"title" : "gc - ",
							"url" : "/MyBlog/golang/2019/11/16/gc.html"
							}
							
							,
							
							
							{
							"title" : "bitset - ",
							"url" : "/MyBlog/golang/2019/11/16/bitset.html"
							}
							
							,
							
							
							{
							"title" : "automaxprocs - ",
							"url" : "/MyBlog/golang/2019/11/16/automaxprocs.html"
							}
							
							,
							
							
							{
							"title" : "Token - ",
							"url" : "/MyBlog/golang/2019/11/16/Token.html"
							}
							
							,
							
							
							{
							"title" : "Go实现简单TCP扫描器 - ",
							"url" : "/MyBlog/golang/2019/11/16/TCP.html"
							}
							
							,
							
							
							{
							"title" : "Staticcheck - ",
							"url" : "/MyBlog/golang/2019/11/16/Staticcheck.html"
							}
							
							,
							
							
							{
							"title" : "Panic/Recover Mechanism - ",
							"url" : "/MyBlog/golang/2019/11/16/Recover.html"
							}
							
							,
							
							
							{
							"title" : "Balancers - ",
							"url" : "/MyBlog/golang/2019/11/16/Balancers.html"
							}
							
							,
							
							
							{
							"title" : "微服务架构下的分布式事务问题 - ",
							"url" : "/MyBlog/web/2019/11/14/tcc_cap.html"
							}
							
							,
							
							
							{
							"title" : "tcc - ",
							"url" : "/MyBlog/web/2019/11/14/tcc.html"
							}
							
							,
							
							
							{
							"title" : "perf - ",
							"url" : "/MyBlog/linux/2019/11/14/perf.html"
							}
							
							,
							
							
							{
							"title" : "GTS - ",
							"url" : "/MyBlog/web/2019/11/14/GTS.html"
							}
							
							,
							
							
							{
							"title" : "pstree - ",
							"url" : "/MyBlog/linux/2019/11/13/pstree.html"
							}
							
							,
							
							
							{
							"title" : "pid namespace - ",
							"url" : "/MyBlog/docker/2019/11/13/pid.html"
							}
							
							,
							
							
							{
							"title" : "chroot - ",
							"url" : "/MyBlog/linux/2019/11/13/chroot.html"
							}
							
							,
							
							
							{
							"title" : "Namespaces - ",
							"url" : "/MyBlog/docker/2019/11/13/Namespaces.html"
							}
							
							,
							
							
							{
							"title" : "Namespace - ",
							"url" : "/MyBlog/docker/2019/11/13/Namespace.html"
							}
							
							,
							
							
							{
							"title" : "分布式任务队列 - ",
							"url" : "/MyBlog/golang/2019/11/12/jobexecuter.html"
							}
							
							,
							
							
							{
							"title" : "etcd compaction - ",
							"url" : "/MyBlog/golang/2019/11/12/compaction.html"
							}
							
							,
							
							
							{
							"title" : "Quartz - ",
							"url" : "/MyBlog/golang/2019/11/12/Quartz.html"
							}
							
							,
							
							
							{
							"title" : "netns - ",
							"url" : "/MyBlog/linux/2019/11/11/netns.html"
							}
							
							,
							
							
							{
							"title" : "gzencode、gzdeflate和gzcompress的区别 - ",
							"url" : "/MyBlog/lang/2019/11/11/deflate.html"
							}
							
							,
							
							
							{
							"title" : "virtual(虚函数) vtbl(虚函数表)与vptr(虚函数表指针) - ",
							"url" : "/MyBlog/linux/2019/11/10/votr.html"
							}
							
							,
							
							
							{
							"title" : "sbrk brk break linux-malloc底层实现原理 - ",
							"url" : "/MyBlog/linux/2019/11/10/sbrk.html"
							}
							
							,
							
							
							{
							"title" : "文件描述符与文件指针的区别 - ",
							"url" : "/MyBlog/linux/2019/11/10/file.html"
							}
							
							,
							
							
							{
							"title" : "malloc()与 alloc()区别 - ",
							"url" : "/MyBlog/linux/2019/11/10/calloc.html"
							}
							
							,
							
							
							{
							"title" : "alloca - ",
							"url" : "/MyBlog/linux/2019/11/10/alloca.html"
							}
							
							,
							
							
							{
							"title" : "类型系统 - ",
							"url" : "/MyBlog/lang/2019/11/09/type.html"
							}
							
							,
							
							
							{
							"title" : "go 类型系统 - ",
							"url" : "/MyBlog/golang/2019/11/09/gotype.html"
							}
							
							,
							
							
							{
							"title" : "从机器语言到高级语言的原理 - ",
							"url" : "/MyBlog/lang/2019/11/09/01100001.html"
							}
							
							,
							
							
							{
							"title" : "内存分析 - ",
							"url" : "/MyBlog/golang/2019/11/08/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.html"
							}
							
							,
							
							
							{
							"title" : "tcmalloc原理剖析 - ",
							"url" : "/MyBlog/linux/2019/11/08/tcmalloc%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.html"
							}
							
							,
							
							
							{
							"title" : "malloc - ",
							"url" : "/MyBlog/linux/2019/11/08/malloc.html"
							}
							
							,
							
							
							{
							"title" : "expvar - ",
							"url" : "/MyBlog/golang/2019/11/08/expvar.html"
							}
							
							,
							
							
							{
							"title" : "slab/slob/slub的区别 - ",
							"url" : "/MyBlog/linux/2019/11/07/slab.html"
							}
							
							,
							
							
							{
							"title" : "进程的页表 - ",
							"url" : "/MyBlog/linux/2019/11/07/pcb.html"
							}
							
							,
							
							
							{
							"title" : "map 如何进行删除 - ",
							"url" : "/MyBlog/golang/2019/11/07/map.html"
							}
							
							,
							
							
							{
							"title" : "TCMalloc - ",
							"url" : "/MyBlog/linux/2019/11/07/TCMalloc.html"
							}
							
							,
							
							
							{
							"title" : "MemStats 查询度量内存和GC使用 - ",
							"url" : "/MyBlog/golang/2019/11/07/MemStats.html"
							}
							
							,
							
							
							{
							"title" : "Go语言的实时GC - ",
							"url" : "/MyBlog/golang/2019/11/07/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9E%E6%97%B6GC.html"
							}
							
							,
							
							
							{
							"title" : "GCStats - ",
							"url" : "/MyBlog/golang/2019/11/07/GCStats.html"
							}
							
							,
							
							
							{
							"title" : "page - ",
							"url" : "/MyBlog/linux/2019/11/06/page.html"
							}
							
							,
							
							
							{
							"title" : "c语言内存管理 - ",
							"url" : "/MyBlog/linux/2019/11/06/c.html"
							}
							
							,
							
							
							{
							"title" : "automaxprocs - ",
							"url" : "/MyBlog/golang/2019/11/06/automaxprocs.html"
							}
							
							,
							
							
							{
							"title" : "mt.Sprint(e) 死循环 - ",
							"url" : "/MyBlog/golang/2019/11/05/sprintf.html"
							}
							
							,
							
							
							{
							"title" : "memory 内存管理机制 - ",
							"url" : "/MyBlog/linux/2019/11/05/memory.html"
							}
							
							,
							
							
							{
							"title" : "crontab - ",
							"url" : "/MyBlog/linux/2019/11/05/crontab.html"
							}
							
							,
							
							
							{
							"title" : "字符串高效拼接 - ",
							"url" : "/MyBlog/golang/2019/11/04/string.html"
							}
							
							,
							
							
							{
							"title" : "time/rate - ",
							"url" : "/MyBlog/golang/2019/11/03/rate.html"
							}
							
							,
							
							
							{
							"title" : "endless - ",
							"url" : "/MyBlog/golang/2019/11/03/endless.html"
							}
							
							,
							
							
							{
							"title" : "Redis - ",
							"url" : "/MyBlog/storage/2019/11/03/Redis.html"
							}
							
							,
							
							
							{
							"title" : "net/url - ",
							"url" : "/MyBlog/golang/2019/11/02/url.html"
							}
							
							,
							
							
							{
							"title" : "tcmalloc - ",
							"url" : "/MyBlog/golang/2019/11/02/tcmalloc.html"
							}
							
							,
							
							
							{
							"title" : "percona-toolkit - ",
							"url" : "/MyBlog/storage/2019/11/02/percona-toolkit.html"
							}
							
							,
							
							
							{
							"title" : "golangci-lint - ",
							"url" : "/MyBlog/golang/2019/11/02/golangci-lint.html"
							}
							
							,
							
							
							{
							"title" : "ginkgo BDD - ",
							"url" : "/MyBlog/golang/2019/11/02/ginkgo.html"
							}
							
							,
							
							
							{
							"title" : "fmt - ",
							"url" : "/MyBlog/algorithm/2019/11/02/fmt.html"
							}
							
							,
							
							
							{
							"title" : "Service Mesh - ",
							"url" : "/MyBlog/golang/2019/11/02/Mesh.html"
							}
							
							,
							
							
							{
							"title" : "如何写出高质量代码 - ",
							"url" : "/MyBlog/golang/2019/11/02/CodeReviewComments.html"
							}
							
							,
							
							
							{
							"title" : "victim cache - ",
							"url" : "/MyBlog/golang/2019/10/31/victim.html"
							}
							
							,
							
							
							{
							"title" : "ast - ",
							"url" : "/MyBlog/golang/2019/10/31/ast.html"
							}
							
							,
							
							
							{
							"title" : "HTTP - ",
							"url" : "/MyBlog/web/2019/10/31/HTTP.html"
							}
							
							,
							
							
							{
							"title" : "Gourtines - ",
							"url" : "/MyBlog/golang/2019/10/31/Gourtines.html"
							}
							
							,
							
							
							{
							"title" : "Debugging - ",
							"url" : "/MyBlog/golang/2019/10/31/Debugging.html"
							}
							
							,
							
							
							{
							"title" : "Exactly Once语义与事务机制 - ",
							"url" : "/MyBlog/storage/2019/10/28/Exactly.html"
							}
							
							,
							
							
							{
							"title" : "kafka EOS - ",
							"url" : "/MyBlog/storage/2019/10/28/EOS.html"
							}
							
							,
							
							
							{
							"title" : "workerpool - ",
							"url" : "/MyBlog/golang/2019/10/27/workerpool.html"
							}
							
							,
							
							
							{
							"title" : "WaitGroup - ",
							"url" : "/MyBlog/golang/2019/10/27/WaitGroup.html"
							}
							
							,
							
							
							{
							"title" : "Cond - ",
							"url" : "/MyBlog/golang/2019/10/27/Cond.html"
							}
							
							,
							
							
							{
							"title" : "微信小程序底层原理 - ",
							"url" : "/MyBlog/web/2019/10/26/wx.html"
							}
							
							,
							
							
							{
							"title" : "Pessimistic Lock - ",
							"url" : "/MyBlog/storage/2019/10/26/storage.html"
							}
							
							,
							
							
							{
							"title" : "livenessProbe - ",
							"url" : "/MyBlog/linux/2019/10/26/livenessProbe.html"
							}
							
							,
							
							
							{
							"title" : "单列索引和联合索引区别 - ",
							"url" : "/MyBlog/storage/2019/10/26/index_merge.html"
							}
							
							,
							
							
							{
							"title" : "回表查询 - ",
							"url" : "/MyBlog/storage/2019/10/26/index.html"
							}
							
							,
							
							
							{
							"title" : "http2 - ",
							"url" : "/MyBlog/web/2019/10/26/http2.html"
							}
							
							,
							
							
							{
							"title" : "PHP7数组的有序性 - ",
							"url" : "/MyBlog/lang/2019/10/26/array.html"
							}
							
							,
							
							
							{
							"title" : "DNS 劫持 - ",
							"url" : "/MyBlog/web/2019/10/26/DNS.html"
							}
							
							,
							
							
							{
							"title" : "Kafka的ACK含义 - ",
							"url" : "/MyBlog/storage/2019/10/26/ACK.html"
							}
							
							,
							
							
							{
							"title" : "mysql 最左前缀原则 - ",
							"url" : "/MyBlog/storage/2019/10/25/mysql.html"
							}
							
							,
							
							
							{
							"title" : "lock - ",
							"url" : "/MyBlog/linux/2019/10/25/lock.html"
							}
							
							,
							
							
							{
							"title" : "ssh tty - ",
							"url" : "/MyBlog/linux/2019/10/24/ssh.html"
							}
							
							,
							
							
							{
							"title" : "js - ",
							"url" : "/MyBlog/lang/2019/10/24/js.html"
							}
							
							,
							
							
							{
							"title" : "tty - ",
							"url" : "/MyBlog/linux/2019/10/23/tty.html"
							}
							
							,
							
							
							{
							"title" : "session - ",
							"url" : "/MyBlog/linux/2019/10/23/session.html"
							}
							
							,
							
							
							{
							"title" : "ptmx - ",
							"url" : "/MyBlog/linux/2019/10/23/ptmx.html"
							}
							
							,
							
							
							{
							"title" : "Cmd.start, Cmd.Wait - ",
							"url" : "/MyBlog/golang/2019/10/22/wait.html"
							}
							
							,
							
							
							{
							"title" : "命令行界面 (CLI)、终端 (Terminal)、Shell、TTY的区别 - ",
							"url" : "/MyBlog/linux/2019/10/22/tty.html"
							}
							
							,
							
							
							{
							"title" : "setns - ",
							"url" : "/MyBlog/docker/2019/10/22/setns.html"
							}
							
							,
							
							
							{
							"title" : "runC - ",
							"url" : "/MyBlog/docker/2019/10/22/runC.html"
							}
							
							,
							
							
							{
							"title" : "docker exec 进入容器原理 - ",
							"url" : "/MyBlog/docker/2019/10/22/exec.html"
							}
							
							,
							
							
							{
							"title" : "如何进入Docker容器 - ",
							"url" : "/MyBlog/docker/2019/10/22/attach.html"
							}
							
							,
							
							
							{
							"title" : "artifactory - ",
							"url" : "/MyBlog/web/2019/10/22/artifactory.html"
							}
							
							,
							
							
							{
							"title" : "Namespace - ",
							"url" : "/MyBlog/docker/2019/10/22/Namespace.html"
							}
							
							,
							
							
							{
							"title" : "HTTPS - ",
							"url" : "/MyBlog/web/2019/10/22/HTTPS.html"
							}
							
							,
							
							
							{
							"title" : "zval 弱类型实现 - ",
							"url" : "/MyBlog/lang/2019/10/20/zval.html"
							}
							
							,
							
							
							{
							"title" : "top、free、uptime、htop - ",
							"url" : "/MyBlog/linux/2019/10/20/top.html"
							}
							
							,
							
							
							{
							"title" : "request_slowlog_timeout - ",
							"url" : "/MyBlog/lang/2019/10/20/request_slowlog_timeout.html"
							}
							
							,
							
							
							{
							"title" : "mysql - ",
							"url" : "/MyBlog/storage/2019/10/20/mysql.html"
							}
							
							,
							
							
							{
							"title" : "mt_rand rand - ",
							"url" : "/MyBlog/lang/2019/10/20/mt_rand.html"
							}
							
							,
							
							
							{
							"title" : "dvwa - ",
							"url" : "/MyBlog/lang/2019/10/20/dvwa.html"
							}
							
							,
							
							
							{
							"title" : "autoload - ",
							"url" : "/MyBlog/lang/2019/10/20/autoload.html"
							}
							
							,
							
							
							{
							"title" : "array_map 与array_walk的用法与区别 - ",
							"url" : "/MyBlog/lang/2019/10/20/array_map.html"
							}
							
							,
							
							
							{
							"title" : "FPM 多进程模型 - ",
							"url" : "/MyBlog/lang/2019/10/20/FPM.html"
							}
							
							,
							
							
							{
							"title" : "php Coroutine - ",
							"url" : "/MyBlog/lang/2019/10/20/Coroutine.html"
							}
							
							,
							
							
							{
							"title" : "CSRF、XSS、sql注入、DDOS流量攻击 - ",
							"url" : "/MyBlog/web/2019/10/20/CSRF.html"
							}
							
							,
							
							
							{
							"title" : "composer update - ",
							"url" : "/MyBlog/lang/2019/10/19/update.html"
							}
							
							,
							
							
							{
							"title" : "spl_auto_register - ",
							"url" : "/MyBlog/lang/2019/10/19/spl_auto_register.html"
							}
							
							,
							
							
							{
							"title" : "satis composer - ",
							"url" : "/MyBlog/lang/2019/10/19/satis.html"
							}
							
							,
							
							
							{
							"title" : "perl POSIX 正则 - ",
							"url" : "/MyBlog/lang/2019/10/19/perl.html"
							}
							
							,
							
							
							{
							"title" : "php fig psr - ",
							"url" : "/MyBlog/lang/2019/10/19/fig.html"
							}
							
							,
							
							
							{
							"title" : "Packagist - ",
							"url" : "/MyBlog/lang/2019/10/19/Packagist.html"
							}
							
							,
							
							
							{
							"title" : "HTTP_X_FORWARDED_FOR - ",
							"url" : "/MyBlog/web/2019/10/19/HTTP_X_FORWARDED_FOR.html"
							}
							
							,
							
							
							{
							"title" : "Defer recover - ",
							"url" : "/MyBlog/golang/2019/10/19/Defer.html"
							}
							
							,
							
							
							{
							"title" : "Composer - ",
							"url" : "/MyBlog/lang/2019/10/19/Composer.html"
							}
							
							,
							
							
							{
							"title" : "recover - ",
							"url" : "/MyBlog/golang/2019/10/18/recover.html"
							}
							
							,
							
							
							{
							"title" : "println - ",
							"url" : "/MyBlog/golang/2019/10/18/println.html"
							}
							
							,
							
							
							{
							"title" : "ArrayObject getArrayCopy - ",
							"url" : "/MyBlog/lang/2019/10/18/getArrayCopy.html"
							}
							
							,
							
							
							{
							"title" : "thrift t_generator_registry map初始化 - ",
							"url" : "/MyBlog/lang/2019/10/17/thrift.html"
							}
							
							,
							
							
							{
							"title" : "magic - ",
							"url" : "/MyBlog/lang/2019/10/17/magic.html"
							}
							
							,
							
							
							{
							"title" : "__call call_user_func_array - ",
							"url" : "/MyBlog/lang/2019/10/17/__call.html"
							}
							
							,
							
							
							{
							"title" : "php Reflection - ",
							"url" : "/MyBlog/lang/2019/10/17/Reflection.html"
							}
							
							,
							
							
							{
							"title" : "c++ 前向声明(forward declaration) - ",
							"url" : "/MyBlog/lang/2019/10/16/declaration.html"
							}
							
							,
							
							
							{
							"title" : "Thrift 源码 - ",
							"url" : "/MyBlog/golang/2019/10/16/Thrift.html"
							}
							
							,
							
							
							{
							"title" : "thrift annotation - ",
							"url" : "/MyBlog/golang/2019/10/15/annotation.html"
							}
							
							,
							
							
							{
							"title" : "Dapper - ",
							"url" : "/MyBlog/web/2019/10/15/Dapper.html"
							}
							
							,
							
							
							{
							"title" : "Istio - ",
							"url" : "/MyBlog/algorithm/2019/10/14/Istio.html"
							}
							
							,
							
							
							{
							"title" : "bytes.Buffer - ",
							"url" : "/MyBlog/golang/2019/10/14/Buffer.html"
							}
							
							,
							
							
							{
							"title" : "load - ",
							"url" : "/MyBlog/linux/2019/10/13/load.html"
							}
							
							,
							
							
							{
							"title" : "缓存穿透，缓存击穿，缓存雪崩 - ",
							"url" : "/MyBlog/storage/2019/10/13/cache.html"
							}
							
							,
							
							
							{
							"title" : "内存屏障 - ",
							"url" : "/MyBlog/linux/2019/10/13/barrier.html"
							}
							
							,
							
							
							{
							"title" : "atomic 原理 - ",
							"url" : "/MyBlog/golang/2019/10/13/atomic.html"
							}
							
							,
							
							
							{
							"title" : "孤儿进程、僵尸进程和守护进程 - ",
							"url" : "/MyBlog/linux/2019/10/13/PCB.html"
							}
							
							,
							
							
							{
							"title" : "Mutex - ",
							"url" : "/MyBlog/golang/2019/10/13/Mutex.html"
							}
							
							,
							
							
							{
							"title" : "Jaeger - ",
							"url" : "/MyBlog/golang/2019/10/13/Jaeger.html"
							}
							
							,
							
							
							{
							"title" : "GC - ",
							"url" : "/MyBlog/golang/2019/10/13/GC.html"
							}
							
							,
							
							
							{
							"title" : "Channel - ",
							"url" : "/MyBlog/golang/2019/10/13/Channel.html"
							}
							
							,
							
							
							{
							"title" : "select for update - ",
							"url" : "/MyBlog/storage/2019/10/12/update.html"
							}
							
							,
							
							
							{
							"title" : "statsd - ",
							"url" : "/MyBlog/golang/2019/10/12/statsd.html"
							}
							
							,
							
							
							{
							"title" : "runtime matrics - ",
							"url" : "/MyBlog/golang/2019/10/12/runtimematrics.html"
							}
							
							,
							
							
							{
							"title" : "nowait - ",
							"url" : "/MyBlog/storage/2019/10/12/nowait.html"
							}
							
							,
							
							
							{
							"title" : "matrix - ",
							"url" : "/MyBlog/web/2019/10/12/matrix.html"
							}
							
							,
							
							
							{
							"title" : "gomatrix - ",
							"url" : "/MyBlog/golang/2019/10/12/gomatrix.html"
							}
							
							,
							
							
							{
							"title" : "open-falcon - ",
							"url" : "/MyBlog/golang/2019/10/12/falcon.html"
							}
							
							,
							
							
							{
							"title" : "coordtransform - ",
							"url" : "/MyBlog/algorithm/2019/10/12/coordtransform.html"
							}
							
							,
							
							
							{
							"title" : "golang atomic包 - ",
							"url" : "/MyBlog/golang/2019/10/12/atomic.html"
							}
							
							,
							
							
							{
							"title" : "Lockless - ",
							"url" : "/MyBlog/web/2019/10/12/Lockless.html"
							}
							
							,
							
							
							{
							"title" : "HEXAGON 六边形 - ",
							"url" : "/MyBlog/algorithm/2019/10/12/HEXAGON.html"
							}
							
							,
							
							
							{
							"title" : "高效的多维空间点索引算法 — Geohash 和 Google S2 - ",
							"url" : "/MyBlog/algorithm/2019/10/11/s2.html"
							}
							
							,
							
							
							{
							"title" : "redis-cell - ",
							"url" : "/MyBlog/storage/2019/10/11/redis-cell.html"
							}
							
							,
							
							
							{
							"title" : "ratelimit - ",
							"url" : "/MyBlog/golang/2019/10/11/ratelimit.html"
							}
							
							,
							
							
							{
							"title" : "php heredoc - ",
							"url" : "/MyBlog/web/2019/10/11/heredoc.html"
							}
							
							,
							
							
							{
							"title" : "evalsha - ",
							"url" : "/MyBlog/storage/2019/10/11/evalsha.html"
							}
							
							,
							
							
							{
							"title" : "分布式限流 - ",
							"url" : "/MyBlog/web/2019/10/11/dratelimit.html"
							}
							
							,
							
							
							{
							"title" : "地理索引 uber s3 - ",
							"url" : "/MyBlog/algorithm/2019/10/11/PHXIS.html"
							}
							
							,
							
							
							{
							"title" : "uber H3 - ",
							"url" : "/MyBlog/algorithm/2019/10/11/H3.html"
							}
							
							,
							
							
							{
							"title" : "select - ",
							"url" : "/MyBlog/golang/2019/10/10/select.html"
							}
							
							,
							
							
							{
							"title" : "runtime - ",
							"url" : "/MyBlog/golang/2019/10/10/runtime.html"
							}
							
							,
							
							
							{
							"title" : "rpc - ",
							"url" : "/MyBlog/golang/2019/10/10/rpc.html"
							}
							
							,
							
							
							{
							"title" : "HTTP路由 - ",
							"url" : "/MyBlog/golang/2019/10/10/router.html"
							}
							
							,
							
							
							{
							"title" : "radix tire - ",
							"url" : "/MyBlog/algorithm/2019/10/10/radix_tire.html"
							}
							
							,
							
							
							{
							"title" : "radix tree router - ",
							"url" : "/MyBlog/golang/2019/10/10/radix_router.html"
							}
							
							,
							
							
							{
							"title" : "radix 基数树 - ",
							"url" : "/MyBlog/linux/2019/10/10/radix.html"
							}
							
							,
							
							
							{
							"title" : "netstack - ",
							"url" : "/MyBlog/golang/2019/10/10/netstack.html"
							}
							
							,
							
							
							{
							"title" : "gops - ",
							"url" : "/MyBlog/golang/2019/10/10/gops.html"
							}
							
							,
							
							
							{
							"title" : "go_radix - ",
							"url" : "/MyBlog/golang/2019/10/10/go_radix.html"
							}
							
							,
							
							
							{
							"title" : "gRpc - ",
							"url" : "/MyBlog/golang/2019/10/10/gRpc.html"
							}
							
							,
							
							
							{
							"title" : "expvar - ",
							"url" : "/MyBlog/golang/2019/10/10/expvar.html"
							}
							
							,
							
							
							{
							"title" : "gobreaker - ",
							"url" : "/MyBlog/golang/2019/10/09/gobreaker.html"
							}
							
							,
							
							
							{
							"title" : "go-kit - ",
							"url" : "/MyBlog/golang/2019/10/09/go-kit.html"
							}
							
							,
							
							
							{
							"title" : "Prometheus - ",
							"url" : "/MyBlog/golang/2019/10/09/Prometheus.html"
							}
							
							,
							
							
							{
							"title" : "sed - ",
							"url" : "/MyBlog/linux/2019/10/08/sed.html"
							}
							
							,
							
							
							{
							"title" : "heatbeat - ",
							"url" : "/MyBlog/golang/2019/09/28/heatbeat.html"
							}
							
							,
							
							
							{
							"title" : "etcd - ",
							"url" : "/MyBlog/golang/2019/09/28/etcd.html"
							}
							
							,
							
							
							{
							"title" : "slot map redis 槽映射 - ",
							"url" : "/MyBlog/golang/2019/09/27/slot.html"
							}
							
							,
							
							
							{
							"title" : "hystrix - ",
							"url" : "/MyBlog/golang/2019/09/27/hystrix.html"
							}
							
							,
							
							
							{
							"title" : "一致性hash golang 实现 - ",
							"url" : "/MyBlog/golang/2019/09/27/hash.html"
							}
							
							,
							
							
							{
							"title" : "gomacro - ",
							"url" : "/MyBlog/golang/2019/09/27/gomacro.html"
							}
							
							,
							
							
							{
							"title" : "Go-kit 熔断器 - ",
							"url" : "/MyBlog/golang/2019/09/27/gokit.html"
							}
							
							,
							
							
							{
							"title" : "如何设计一个亿级网关 - ",
							"url" : "/MyBlog/golang/2019/09/27/gateway.html"
							}
							
							,
							
							
							{
							"title" : "etcd实现服务发现机制 - ",
							"url" : "/MyBlog/golang/2019/09/27/etcd.html"
							}
							
							,
							
							
							{
							"title" : "/dev/udp - ",
							"url" : "/MyBlog/linux/2019/09/27/dev.html"
							}
							
							,
							
							
							{
							"title" : "Consul - ",
							"url" : "/MyBlog/golang/2019/09/27/Consul.html"
							}
							
							,
							
							
							{
							"title" : "xdebug - ",
							"url" : "/MyBlog/web/2019/09/26/xdebug.html"
							}
							
							,
							
							
							{
							"title" : "spf13-vim - ",
							"url" : "/MyBlog/golang/2019/09/26/spf13-vim.html"
							}
							
							,
							
							
							{
							"title" : "jsoniter - ",
							"url" : "/MyBlog/golang/2019/09/26/jsoniter.html"
							}
							
							,
							
							
							{
							"title" : "hugo - ",
							"url" : "/MyBlog/golang/2019/09/26/hugo.html"
							}
							
							,
							
							
							{
							"title" : "pflag flag - ",
							"url" : "/MyBlog/golang/2019/09/26/flag.html"
							}
							
							,
							
							
							{
							"title" : "ffjson - ",
							"url" : "/MyBlog/golang/2019/09/26/ffjson.html"
							}
							
							,
							
							
							{
							"title" : "cobra detail - ",
							"url" : "/MyBlog/golang/2019/09/26/cobra_detail.html"
							}
							
							,
							
							
							{
							"title" : "cobra - ",
							"url" : "/MyBlog/golang/2019/09/26/cobra.html"
							}
							
							,
							
							
							{
							"title" : "Modules - ",
							"url" : "/MyBlog/golang/2019/09/26/Modules.html"
							}
							
							,
							
							
							{
							"title" : "json - ",
							"url" : "/MyBlog/golang/2019/09/25/json.html"
							}
							
							,
							
							
							{
							"title" : "dwarf - ",
							"url" : "/MyBlog/golang/2019/09/25/dwarf.html"
							}
							
							,
							
							
							{
							"title" : "https - ",
							"url" : "/MyBlog/golang/2019/09/23/https.html"
							}
							
							,
							
							
							{
							"title" : "sso - ",
							"url" : "/MyBlog/web/2019/09/22/sso.html"
							}
							
							,
							
							
							{
							"title" : "rsa - ",
							"url" : "/MyBlog/algorithm/2019/09/22/rsa.html"
							}
							
							,
							
							
							{
							"title" : "rand 随机数 - ",
							"url" : "/MyBlog/golang/2019/09/22/rand.html"
							}
							
							,
							
							
							{
							"title" : "签名和加密的区别 - ",
							"url" : "/MyBlog/algorithm/2019/09/22/openssl.html"
							}
							
							,
							
							
							{
							"title" : "sso oauth - ",
							"url" : "/MyBlog/web/2019/09/22/oauth.html"
							}
							
							,
							
							
							{
							"title" : "cors - ",
							"url" : "/MyBlog/web/2019/09/22/cors.html"
							}
							
							,
							
							
							{
							"title" : "tengine - ",
							"url" : "/MyBlog/web/2019/09/21/tengine.html"
							}
							
							,
							
							
							{
							"title" : "stream - ",
							"url" : "/MyBlog/storage/2019/09/21/stream.html"
							}
							
							,
							
							
							{
							"title" : "id 生成器 - ",
							"url" : "/MyBlog/web/2019/09/21/snowflake.html"
							}
							
							,
							
							
							{
							"title" : "shortUrl - ",
							"url" : "/MyBlog/web/2019/09/21/shortUrl.html"
							}
							
							,
							
							
							{
							"title" : "redis 4 特性 - ",
							"url" : "/MyBlog/storage/2019/09/21/redis4.html"
							}
							
							,
							
							
							{
							"title" : "redis 5 新特性 - ",
							"url" : "/MyBlog/storage/2019/09/21/redis.html"
							}
							
							,
							
							
							{
							"title" : "php7 - ",
							"url" : "/MyBlog/web/2019/09/21/php.html"
							}
							
							,
							
							
							{
							"title" : "openretry - ",
							"url" : "/MyBlog/web/2019/09/21/openretry.html"
							}
							
							,
							
							
							{
							"title" : "nginx - ",
							"url" : "/MyBlog/web/2019/09/21/nginx.html"
							}
							
							,
							
							
							{
							"title" : "md5 - ",
							"url" : "/MyBlog/algorithm/2019/09/21/md5.html"
							}
							
							,
							
							
							{
							"title" : "linux 5.3 - ",
							"url" : "/MyBlog/linux/2019/09/21/linux.html"
							}
							
							,
							
							
							{
							"title" : "kafka - ",
							"url" : "/MyBlog/storage/2019/09/21/kafka.html"
							}
							
							,
							
							
							{
							"title" : "golang 1.13 - ",
							"url" : "/MyBlog/golang/2019/09/21/golang.html"
							}
							
							,
							
							
							{
							"title" : "docker - ",
							"url" : "/MyBlog/docker/2019/09/21/docker.html"
							}
							
							,
							
							
							{
							"title" : "CentOS - ",
							"url" : "/MyBlog/linux/2019/09/21/CentOS.html"
							}
							
							,
							
							
							{
							"title" : "xa - ",
							"url" : "/MyBlog/storage/2019/09/19/xa.html"
							}
							
							,
							
							
							{
							"title" : "mariadb - ",
							"url" : "/MyBlog/storage/2019/09/19/mariadb.html"
							}
							
							,
							
							
							{
							"title" : "system call table - ",
							"url" : "/MyBlog/linux/2019/09/18/systemcalltab.html"
							}
							
							,
							
							
							{
							"title" : "函数调用帧栈 - ",
							"url" : "/MyBlog/linux/2019/09/18/stackFrame.html"
							}
							
							,
							
							
							{
							"title" : "C语言的异常机制 setjump longjump函数 - ",
							"url" : "/MyBlog/linux/2019/09/18/setjump.html"
							}
							
							,
							
							
							{
							"title" : "rtld_fini - ",
							"url" : "/MyBlog/linux/2019/09/18/rtld_fini.html"
							}
							
							,
							
							
							{
							"title" : "main - ",
							"url" : "/MyBlog/linux/2019/09/18/main.html"
							}
							
							,
							
							
							{
							"title" : "heap 内存管理之堆和栈 - ",
							"url" : "/MyBlog/linux/2019/09/18/heap.html"
							}
							
							,
							
							
							{
							"title" : "dumpbin - ",
							"url" : "/MyBlog/linux/2019/09/18/dumpbin.html"
							}
							
							,
							
							
							{
							"title" : "c++filt - ",
							"url" : "/MyBlog/linux/2019/09/18/c++filt.html"
							}
							
							,
							
							
							{
							"title" : "Linux进程分配内存的两种方式--brk() 和mmap() - ",
							"url" : "/MyBlog/linux/2019/09/18/brk.html"
							}
							
							,
							
							
							{
							"title" : "atexit - ",
							"url" : "/MyBlog/linux/2019/09/18/atexit_linux.html"
							}
							
							,
							
							
							{
							"title" : "atexit - ",
							"url" : "/MyBlog/linux/2019/09/18/atexit.html"
							}
							
							,
							
							
							{
							"title" : "0x80 0x21 软中断 - ",
							"url" : "/MyBlog/linux/2019/09/18/0x80.html"
							}
							
							,
							
							
							{
							"title" : "readelf - ",
							"url" : "/MyBlog/linux/2019/09/16/readelf.html"
							}
							
							,
							
							
							{
							"title" : "ar - ",
							"url" : "/MyBlog/linux/2019/09/16/ar.html"
							}
							
							,
							
							
							{
							"title" : "压栈的工作原理 - ",
							"url" : "/MyBlog/linux/2019/09/15/statck.html"
							}
							
							,
							
							
							{
							"title" : "Go 函数调用━栈和寄存器视角 - ",
							"url" : "/MyBlog/golang/2019/09/15/req.html"
							}
							
							,
							
							
							{
							"title" : "图的连通性 - ",
							"url" : "/MyBlog/algorithm/2019/09/15/graph.html"
							}
							
							,
							
							
							{
							"title" : "clang - ",
							"url" : "/MyBlog/web/2019/09/15/clang.html"
							}
							
							,
							
							
							{
							"title" : "golang 函数调用汇编 - ",
							"url" : "/MyBlog/golang/2019/09/15/call.html"
							}
							
							,
							
							
							{
							"title" : "setxx setnx - ",
							"url" : "/MyBlog/storage/2019/09/14/setxx.html"
							}
							
							,
							
							
							{
							"title" : "p2p 打洞 - ",
							"url" : "/MyBlog/web/2019/09/14/p2p.html"
							}
							
							,
							
							
							{
							"title" : "max_execution_time fpm - ",
							"url" : "/MyBlog/web/2019/09/14/max_execution_time.html"
							}
							
							,
							
							
							{
							"title" : "interface - ",
							"url" : "/MyBlog/golang/2019/09/14/interface.html"
							}
							
							,
							
							
							{
							"title" : "gimple - ",
							"url" : "/MyBlog/algorithm/2019/09/14/gimple.html"
							}
							
							,
							
							
							{
							"title" : "go test Build 缓存 - ",
							"url" : "/MyBlog/golang/2019/09/12/test.html"
							}
							
							,
							
							
							{
							"title" : "Go 语言运行时环境变量 - ",
							"url" : "/MyBlog/golang/2019/09/12/env.html"
							}
							
							,
							
							
							{
							"title" : "reflect性能 - ",
							"url" : "/MyBlog/golang/2019/09/11/reflect_json.html"
							}
							
							,
							
							
							{
							"title" : "reflect - ",
							"url" : "/MyBlog/golang/2019/09/11/reflect.html"
							}
							
							,
							
							
							{
							"title" : "go 语言内存布局 - ",
							"url" : "/MyBlog/golang/2019/09/11/Header.html"
							}
							
							,
							
							
							{
							"title" : "Assertion - ",
							"url" : "/MyBlog/golang/2019/09/11/Assertion.html"
							}
							
							,
							
							
							{
							"title" : "unsafe - ",
							"url" : "/MyBlog/golang/2019/09/10/unsafe.html"
							}
							
							,
							
							
							{
							"title" : "godoc - ",
							"url" : "/MyBlog/golang/2019/09/10/godoc.html"
							}
							
							,
							
							
							{
							"title" : "builtin - ",
							"url" : "/MyBlog/golang/2019/09/10/builtin.html"
							}
							
							,
							
							
							{
							"title" : "Reflection - ",
							"url" : "/MyBlog/golang/2019/09/10/Reflection.html"
							}
							
							,
							
							
							{
							"title" : "Interfaces - ",
							"url" : "/MyBlog/golang/2019/09/10/Interfaces.html"
							}
							
							,
							
							
							{
							"title" : "upx - ",
							"url" : "/MyBlog/golang/2019/09/08/upx.html"
							}
							
							,
							
							
							{
							"title" : "tcpproxy - ",
							"url" : "/MyBlog/web/2019/09/08/tcpproxy.html"
							}
							
							,
							
							
							{
							"title" : "swagger php - ",
							"url" : "/MyBlog/web/2019/09/08/swaggerphp.html"
							}
							
							,
							
							
							{
							"title" : "reflect 为啥慢 - ",
							"url" : "/MyBlog/golang/2019/09/08/reflect.html"
							}
							
							,
							
							
							{
							"title" : "Swagger与postman使用 - ",
							"url" : "/MyBlog/golang/2019/09/08/postman.html"
							}
							
							,
							
							
							{
							"title" : "openfalcon - ",
							"url" : "/MyBlog/golang/2019/09/08/openfalcon.html"
							}
							
							,
							
							
							{
							"title" : "json - ",
							"url" : "/MyBlog/golang/2019/09/08/json.html"
							}
							
							,
							
							
							{
							"title" : "golang 编译压缩体积 - ",
							"url" : "/MyBlog/golang/2019/09/08/goupx.html"
							}
							
							,
							
							
							{
							"title" : "goconvey - ",
							"url" : "/MyBlog/golang/2019/09/08/goconvey.html"
							}
							
							,
							
							
							{
							"title" : "go-swagger - ",
							"url" : "/MyBlog/golang/2019/09/08/go-swagger.html"
							}
							
							,
							
							
							{
							"title" : "easy-mock - ",
							"url" : "/MyBlog/golang/2019/09/08/easy-mock.html"
							}
							
							,
							
							
							{
							"title" : "Swagger - ",
							"url" : "/MyBlog/golang/2019/09/08/Swagger.html"
							}
							
							,
							
							
							{
							"title" : "simplejson  json.Decoder vs json.Unmarshal - ",
							"url" : "/MyBlog/golang/2019/09/04/simplejson.html"
							}
							
							,
							
							
							{
							"title" : "travis ci - ",
							"url" : "/MyBlog/web/2019/09/03/travis.html"
							}
							
							,
							
							
							{
							"title" : "json - ",
							"url" : "/MyBlog/golang/2019/09/03/json.html"
							}
							
							,
							
							
							{
							"title" : "pprof 火焰图 实践 - ",
							"url" : "/MyBlog/golang/2019/08/25/torch.html"
							}
							
							,
							
							
							{
							"title" : "pprof - ",
							"url" : "/MyBlog/golang/2019/08/25/pprof.html"
							}
							
							,
							
							
							{
							"title" : "perf pprof - ",
							"url" : "/MyBlog/linux/2019/08/25/perf.html"
							}
							
							,
							
							
							{
							"title" : "gprof 原理 - ",
							"url" : "/MyBlog/linux/2019/08/25/gprof.html"
							}
							
							,
							
							
							{
							"title" : "go tool trace - ",
							"url" : "/MyBlog/golang/2019/08/25/gotrace.html"
							}
							
							,
							
							
							{
							"title" : "go-callvis 生成golang调用图 - ",
							"url" : "/MyBlog/golang/2019/08/25/go-callvis.html"
							}
							
							,
							
							
							{
							"title" : "flamegraph - ",
							"url" : "/MyBlog/linux/2019/08/25/flamegraph.html"
							}
							
							,
							
							
							{
							"title" : "空间索引 - ",
							"url" : "/MyBlog/web/2019/08/22/geoindex.html"
							}
							
							,
							
							
							{
							"title" : "wrk - ",
							"url" : "/MyBlog/golang/2019/08/18/wrk.html"
							}
							
							,
							
							
							{
							"title" : "race - ",
							"url" : "/MyBlog/golang/2019/08/18/race.html"
							}
							
							,
							
							
							{
							"title" : "make new 的区别 - ",
							"url" : "/MyBlog/golang/2019/08/18/make.html"
							}
							
							,
							
							
							{
							"title" : "interface - ",
							"url" : "/MyBlog/golang/2019/08/18/interface.html"
							}
							
							,
							
							
							{
							"title" : "flame graph - ",
							"url" : "/MyBlog/golang/2019/08/18/flamegraph.html"
							}
							
							,
							
							
							{
							"title" : "defer - ",
							"url" : "/MyBlog/golang/2019/08/18/defer.html"
							}
							
							,
							
							
							{
							"title" : "http状态码413 - ",
							"url" : "/MyBlog/web/2019/08/15/413.html"
							}
							
							,
							
							
							{
							"title" : "mark and sweep - ",
							"url" : "/MyBlog/golang/2019/08/09/sweep.html"
							}
							
							,
							
							
							{
							"title" : "phpgc - ",
							"url" : "/MyBlog/web/2019/08/09/phpgc.html"
							}
							
							,
							
							
							{
							"title" : "gc 发展 - ",
							"url" : "/MyBlog/golang/2019/08/09/gc.html"
							}
							
							,
							
							
							{
							"title" : "fpm_scoreboard - ",
							"url" : "/MyBlog/web/2019/08/09/fpm_scoreboard.html"
							}
							
							,
							
							
							{
							"title" : "sync.pool - ",
							"url" : "/MyBlog/golang/2019/08/08/pool.html"
							}
							
							,
							
							
							{
							"title" : "MVCC 、CAS 和CopyOnWrite - ",
							"url" : "/MyBlog/storage/2019/08/08/mvcc.html"
							}
							
							,
							
							
							{
							"title" : "mutex - ",
							"url" : "/MyBlog/golang/2019/08/08/mutex.html"
							}
							
							,
							
							
							{
							"title" : "fasthttp - ",
							"url" : "/MyBlog/golang/2019/08/08/fasthttp.html"
							}
							
							,
							
							
							{
							"title" : "Treap - ",
							"url" : "/MyBlog/algorithm/2019/08/08/Treap.html"
							}
							
							,
							
							
							{
							"title" : "load average - ",
							"url" : "/MyBlog/linux/2019/08/07/load.html"
							}
							
							,
							
							
							{
							"title" : "fasthttp - ",
							"url" : "/MyBlog/golang/2019/08/04/fasthttp.html"
							}
							
							,
							
							
							{
							"title" : "channel - ",
							"url" : "/MyBlog/golang/2019/08/04/channel.html"
							}
							
							,
							
							
							{
							"title" : "opentracing - ",
							"url" : "/MyBlog/golang/2019/08/03/opentracing.html"
							}
							
							,
							
							
							{
							"title" : "httptrace - ",
							"url" : "/MyBlog/golang/2019/08/03/httptrace.html"
							}
							
							,
							
							
							{
							"title" : "Memory Allocator Trace - ",
							"url" : "/MyBlog/golang/2019/07/28/trace.html"
							}
							
							,
							
							
							{
							"title" : "系统调度 - ",
							"url" : "/MyBlog/golang/2019/07/28/scheduler.html"
							}
							
							,
							
							
							{
							"title" : "hey - ",
							"url" : "/MyBlog/golang/2019/07/28/hey.html"
							}
							
							,
							
							
							{
							"title" : "gostub - ",
							"url" : "/MyBlog/golang/2019/07/28/gostub.html"
							}
							
							,
							
							
							{
							"title" : "goMonkey - ",
							"url" : "/MyBlog/golang/2019/07/28/goMonkey.html"
							}
							
							,
							
							
							{
							"title" : "GoConvey - ",
							"url" : "/MyBlog/golang/2019/07/28/GoConvey.html"
							}
							
							,
							
							
							{
							"title" : "mock - ",
							"url" : "/MyBlog/golang/2019/07/27/mock.html"
							}
							
							,
							
							
							{
							"title" : "tty stdin stdout stderr - ",
							"url" : "/MyBlog/linux/2019/07/21/tty.html"
							}
							
							,
							
							
							{
							"title" : "tiny compiler - ",
							"url" : "/MyBlog/golang/2019/07/21/tiny.html"
							}
							
							,
							
							
							{
							"title" : "compile link - ",
							"url" : "/MyBlog/golang/2019/07/21/link.html"
							}
							
							,
							
							
							{
							"title" : "elf - ",
							"url" : "/MyBlog/linux/2019/07/21/elf.html"
							}
							
							,
							
							
							{
							"title" : "tscan - ",
							"url" : "/MyBlog/golang/2019/07/20/tscan.html"
							}
							
							,
							
							
							{
							"title" : "race - ",
							"url" : "/MyBlog/golang/2019/07/20/race.html"
							}
							
							,
							
							
							{
							"title" : "Memory Sanitizer - ",
							"url" : "/MyBlog/golang/2019/07/20/goroutine.html"
							}
							
							,
							
							
							{
							"title" : "go 编译器指示 - ",
							"url" : "/MyBlog/golang/2019/07/20/go.html"
							}
							
							,
							
							
							{
							"title" : "编译优化 - ",
							"url" : "/MyBlog/golang/2019/07/20/gc.html"
							}
							
							,
							
							
							{
							"title" : "调试golang编译器,增加自定义声明 - ",
							"url" : "/MyBlog/golang/2019/07/20/compile.html"
							}
							
							,
							
							
							{
							"title" : "语法树与抽象语法树（parse tree & abstract syntax tree） - ",
							"url" : "/MyBlog/golang/2019/07/20/ast.html"
							}
							
							,
							
							
							{
							"title" : "静态单赋值（SSA,Static Single-Assignment) - ",
							"url" : "/MyBlog/golang/2019/07/19/ssa.html"
							}
							
							,
							
							
							{
							"title" : "502 504 - ",
							"url" : "/MyBlog/web/2019/07/18/502.html"
							}
							
							,
							
							
							{
							"title" : "slice - ",
							"url" : "/MyBlog/golang/2019/07/16/slice.html"
							}
							
							,
							
							
							{
							"title" : "plan9 - ",
							"url" : "/MyBlog/golang/2019/07/16/plan9.html"
							}
							
							,
							
							
							{
							"title" : "goasm - ",
							"url" : "/MyBlog/golang/2019/07/16/goasm.html"
							}
							
							,
							
							
							{
							"title" : "asm - ",
							"url" : "/MyBlog/golang/2019/07/16/asm.html"
							}
							
							,
							
							
							{
							"title" : "binaryen - ",
							"url" : "/MyBlog/golang/2019/07/15/binaryen.html"
							}
							
							,
							
							
							{
							"title" : "WebAssembly - ",
							"url" : "/MyBlog/golang/2019/07/15/WebAssembly.html"
							}
							
							,
							
							
							{
							"title" : "tty 及其在远程登录（SSH，telnet等）中的应用 - ",
							"url" : "/MyBlog/linux/2019/07/14/tty.html"
							}
							
							,
							
							
							{
							"title" : "go tool trace - ",
							"url" : "/MyBlog/golang/2019/07/14/trace.html"
							}
							
							,
							
							
							{
							"title" : "ssl ssh - ",
							"url" : "/MyBlog/web/2019/07/14/ssl.html"
							}
							
							,
							
							
							{
							"title" : "ssh 原理 - ",
							"url" : "/MyBlog/linux/2019/07/14/ssh_keygen.html"
							}
							
							,
							
							
							{
							"title" : "Linux中tty、pty、pts的概念区别 - ",
							"url" : "/MyBlog/linux/2019/07/14/pty.html"
							}
							
							,
							
							
							{
							"title" : "cAdvisor - ",
							"url" : "/MyBlog/docker/2019/07/14/cAdvisor.html"
							}
							
							,
							
							
							{
							"title" : "SSH - ",
							"url" : "/MyBlog/linux/2019/07/14/SSH.html"
							}
							
							,
							
							
							{
							"title" : "Quagga - ",
							"url" : "/MyBlog/linux/2019/07/14/Quagga.html"
							}
							
							,
							
							
							{
							"title" : "Pipework、Weave、Flannel - ",
							"url" : "/MyBlog/docker/2019/07/14/Pipework.html"
							}
							
							,
							
							
							{
							"title" : "Flannel - ",
							"url" : "/MyBlog/2019/07/14/Flannel.html"
							}
							
							,
							
							
							{
							"title" : "sdn - ",
							"url" : "/MyBlog/docker/2019/07/11/sdn.html"
							}
							
							,
							
							
							{
							"title" : "php - ",
							"url" : "/MyBlog/web/2019/07/11/php.html"
							}
							
							,
							
							
							{
							"title" : "Macvlan与ipvlan - ",
							"url" : "/MyBlog/docker/2019/07/11/ipvlan.html"
							}
							
							,
							
							
							{
							"title" : "hypervisor - ",
							"url" : "/MyBlog/docker/2019/07/11/hypervisor.html"
							}
							
							,
							
							
							{
							"title" : "go get  go install - ",
							"url" : "/MyBlog/golang/2019/07/11/goget.html"
							}
							
							,
							
							
							{
							"title" : "Docker与Hypervisor - ",
							"url" : "/MyBlog/docker/2019/07/11/docker.html"
							}
							
							,
							
							
							{
							"title" : "cobra - ",
							"url" : "/MyBlog/golang/2019/07/11/cobra.html"
							}
							
							,
							
							
							{
							"title" : "prctl - ",
							"url" : "/MyBlog/linux/2019/07/09/prctl.html"
							}
							
							,
							
							
							{
							"title" : "type aliases - ",
							"url" : "/MyBlog/golang/2019/07/09/alias.html"
							}
							
							,
							
							
							{
							"title" : "union mount - ",
							"url" : "/MyBlog/docker/2019/07/07/union.html"
							}
							
							,
							
							
							{
							"title" : "Linux内核namespace机制 - ",
							"url" : "/MyBlog/docker/2019/07/07/namespace.html"
							}
							
							,
							
							
							{
							"title" : "Namespace 资源隔离 - ",
							"url" : "/MyBlog/linux/2019/07/07/linux_ns.html"
							}
							
							,
							
							
							{
							"title" : "ioctl 网桥管理 - ",
							"url" : "/MyBlog/linux/2019/07/07/ioctl.html"
							}
							
							,
							
							
							{
							"title" : "clone - ",
							"url" : "/MyBlog/linux/2019/07/07/clone.html"
							}
							
							,
							
							
							{
							"title" : "cidr - ",
							"url" : "/MyBlog/linux/2019/07/07/cidr.html"
							}
							
							,
							
							
							{
							"title" : "Libcontainer - ",
							"url" : "/MyBlog/docker/2019/07/07/Libcontainer.html"
							}
							
							,
							
							
							{
							"title" : "AppArmor - ",
							"url" : "/MyBlog/docker/2019/07/07/AppArmor.html"
							}
							
							,
							
							
							{
							"title" : "namespace - ",
							"url" : "/MyBlog/docker/2019/07/06/namespace.html"
							}
							
							,
							
							
							{
							"title" : "lxc - ",
							"url" : "/MyBlog/docker/2019/07/06/lxc.html"
							}
							
							,
							
							
							{
							"title" : "lxc-start 源码分析 - ",
							"url" : "/MyBlog/docker/2019/07/06/lxc-start.html"
							}
							
							,
							
							
							{
							"title" : "hijack - ",
							"url" : "/MyBlog/golang/2019/07/05/hijack.html"
							}
							
							,
							
							
							{
							"title" : "gotty 把你的 Linux 终端放到浏览器里面 - ",
							"url" : "/MyBlog/golang/2019/07/05/gotty.html"
							}
							
							,
							
							
							{
							"title" : "fcgi - ",
							"url" : "/MyBlog/golang/2019/07/04/fcgi.html"
							}
							
							,
							
							
							{
							"title" : "fastcgi_client - ",
							"url" : "/MyBlog/web/2019/07/04/fastcgi_client.html"
							}
							
							,
							
							
							{
							"title" : "RequestID fastcgi - ",
							"url" : "/MyBlog/web/2019/07/04/RequestID.html"
							}
							
							,
							
							
							{
							"title" : "FastCGI MIT 文档 - ",
							"url" : "/MyBlog/web/2019/07/04/FastCGI.html"
							}
							
							,
							
							
							{
							"title" : "setfacl - ",
							"url" : "/MyBlog/linux/2019/07/03/setfacl.html"
							}
							
							,
							
							
							{
							"title" : "go-web + go-cgi + go-cgi-script - ",
							"url" : "/MyBlog/golang/2019/07/03/gocgi.html"
							}
							
							,
							
							
							{
							"title" : "aufs、Btrfs、Device mapper、OverlayFS、ZFS - ",
							"url" : "/MyBlog/docker/2019/07/03/aufs.html"
							}
							
							,
							
							
							{
							"title" : "netListener.File - ",
							"url" : "/MyBlog/golang/2019/07/02/netListener.html"
							}
							
							,
							
							
							{
							"title" : "lantern mac编译 Proxy SwitchyOmega - ",
							"url" : "/MyBlog/golang/2019/06/30/lantern.html"
							}
							
							,
							
							
							{
							"title" : "shell $(( ))、$( )、``与${ }的区别 - ",
							"url" : "/MyBlog/linux/2019/06/29/shell.html"
							}
							
							,
							
							
							{
							"title" : "shutdown 源码分析 - ",
							"url" : "/MyBlog/golang/2019/06/29/graceful.html"
							}
							
							,
							
							
							{
							"title" : "git彻底删除提交历史 - ",
							"url" : "/MyBlog/web/2019/06/29/git.html"
							}
							
							,
							
							
							{
							"title" : "fpm graceful - ",
							"url" : "/MyBlog/web/2019/06/29/fpm.html"
							}
							
							,
							
							
							{
							"title" : "graceful Shutdown - ",
							"url" : "/MyBlog/golang/2019/06/29/Shutdown.html"
							}
							
							,
							
							
							{
							"title" : "interface 和nil - ",
							"url" : "/MyBlog/golang/2019/06/28/nil.html"
							}
							
							,
							
							
							{
							"title" : "martini inject - ",
							"url" : "/MyBlog/golang/2019/06/28/invoke.html"
							}
							
							,
							
							
							{
							"title" : "Martini之inject源码 - ",
							"url" : "/MyBlog/golang/2019/06/28/inject.html"
							}
							
							,
							
							
							{
							"title" : "gcflags - ",
							"url" : "/MyBlog/golang/2019/06/28/gcflags.html"
							}
							
							,
							
							
							{
							"title" : "Martini - ",
							"url" : "/MyBlog/golang/2019/06/28/Martini.html"
							}
							
							,
							
							
							{
							"title" : "vmnetd - ",
							"url" : "/MyBlog/docker/2019/06/27/vmnetd.html"
							}
							
							,
							
							
							{
							"title" : "godoc doc.go - ",
							"url" : "/MyBlog/golang/2019/06/27/godoc.html"
							}
							
							,
							
							
							{
							"title" : "docker for mac k8s - ",
							"url" : "/MyBlog/docker/2019/06/26/dockerformak.html"
							}
							
							,
							
							
							{
							"title" : "ssh端口转发 - ",
							"url" : "/MyBlog/docker/2019/06/25/ssh.html"
							}
							
							,
							
							
							{
							"title" : "docker for mac k8s - ",
							"url" : "/MyBlog/docker/2019/06/25/dockerformack8s.html"
							}
							
							,
							
							
							{
							"title" : "docker for mac - ",
							"url" : "/MyBlog/docker/2019/06/25/dockerformac.html"
							}
							
							,
							
							
							{
							"title" : "boot2docker - ",
							"url" : "/MyBlog/docker/2019/06/25/boot2docker.html"
							}
							
							,
							
							
							{
							"title" : "VBoxManage - ",
							"url" : "/MyBlog/docker/2019/06/25/VBoxManage.html"
							}
							
							,
							
							
							{
							"title" : "Docker Machine - ",
							"url" : "/MyBlog/docker/2019/06/25/Machine.html"
							}
							
							,
							
							
							{
							"title" : "Borg - ",
							"url" : "/MyBlog/docker/2019/06/25/Borg.html"
							}
							
							,
							
							
							{
							"title" : "validator - ",
							"url" : "/MyBlog/golang/2019/06/19/validator.html"
							}
							
							,
							
							
							{
							"title" : "Redis 源码阅读顺序 - ",
							"url" : "/MyBlog/storage/2019/06/19/redis.html"
							}
							
							,
							
							
							{
							"title" : "ptmalloc、tcmalloc和jemalloc - ",
							"url" : "/MyBlog/storage/2019/06/19/ptmalloc.html"
							}
							
							,
							
							
							{
							"title" : "SystemTap - ",
							"url" : "/MyBlog/linux/2019/06/19/SystemTap.html"
							}
							
							,
							
							
							{
							"title" : "phpcs phpcbf PHP_CodeSniffer - ",
							"url" : "/MyBlog/web/2019/06/17/phpcs.html"
							}
							
							,
							
							
							{
							"title" : "goroutine 状态机扭转 - ",
							"url" : "/MyBlog/golang/2019/06/17/goroutine.html"
							}
							
							,
							
							
							{
							"title" : "m p g schedt sudog - ",
							"url" : "/MyBlog/golang/2019/06/16/mpg.html"
							}
							
							,
							
							
							{
							"title" : "sync.Pool 设计思路与原理 - ",
							"url" : "/MyBlog/golang/2019/06/15/sync.Pool.html"
							}
							
							,
							
							
							{
							"title" : "sync.Map - ",
							"url" : "/MyBlog/golang/2019/06/15/sync.Map.html"
							}
							
							,
							
							
							{
							"title" : "xargs - ",
							"url" : "/MyBlog/linux/2019/06/14/xargs.html"
							}
							
							,
							
							
							{
							"title" : "rwmutex - ",
							"url" : "/MyBlog/golang/2019/06/14/rwmutex.html"
							}
							
							,
							
							
							{
							"title" : "onece - ",
							"url" : "/MyBlog/golang/2019/06/14/onece.html"
							}
							
							,
							
							
							{
							"title" : "mutex - ",
							"url" : "/MyBlog/golang/2019/06/14/mutex.html"
							}
							
							,
							
							
							{
							"title" : "awk完成两个文件的关联Join 高级用法 - ",
							"url" : "/MyBlog/linux/2019/06/14/awk.html"
							}
							
							,
							
							
							{
							"title" : "thrift transport - ",
							"url" : "/MyBlog/web/2019/06/12/transport.html"
							}
							
							,
							
							
							{
							"title" : "TProtocol 协议和编解码 - ",
							"url" : "/MyBlog/web/2019/06/12/Tprotocal.html"
							}
							
							,
							
							
							{
							"title" : "thrift 源码 - ",
							"url" : "/MyBlog/web/2019/06/12/IDL.html"
							}
							
							,
							
							
							{
							"title" : "pollfd - ",
							"url" : "/MyBlog/linux/2019/06/11/pollfd.html"
							}
							
							,
							
							
							{
							"title" : "libevent 编译安装 - ",
							"url" : "/MyBlog/linux/2019/06/11/libevent.html"
							}
							
							,
							
							
							{
							"title" : "fd_set - ",
							"url" : "/MyBlog/linux/2019/06/11/fd_set.html"
							}
							
							,
							
							
							{
							"title" : "epoll_event - ",
							"url" : "/MyBlog/linux/2019/06/11/epoll_event.html"
							}
							
							,
							
							
							{
							"title" : "configure.ac - ",
							"url" : "/MyBlog/linux/2019/06/11/configure.ac.html"
							}
							
							,
							
							
							{
							"title" : "Makefile/Makefile.am/Makefile.in三者关系 - ",
							"url" : "/MyBlog/linux/2019/06/11/Makefile.html"
							}
							
							,
							
							
							{
							"title" : "Golang网络库中socket阻塞调度源码剖析 - ",
							"url" : "/MyBlog/golang/2019/06/10/socket_go.html"
							}
							
							,
							
							
							{
							"title" : "gopark goready - ",
							"url" : "/MyBlog/golang/2019/06/10/gopark.html"
							}
							
							,
							
							
							{
							"title" : "eagain accept - ",
							"url" : "/MyBlog/linux/2019/06/10/eagain.html"
							}
							
							,
							
							
							{
							"title" : "Socket 源码 - ",
							"url" : "/MyBlog/linux/2019/06/10/Socket.html"
							}
							
							,
							
							
							{
							"title" : "SIGIO - ",
							"url" : "/MyBlog/linux/2019/06/10/SIGIO.html"
							}
							
							,
							
							
							{
							"title" : "golang syscall原理 - ",
							"url" : "/MyBlog/golang/2019/06/09/SYSCALL.html"
							}
							
							,
							
							
							{
							"title" : "gdb_codesign - ",
							"url" : "/MyBlog/linux/2019/06/08/gdb_codesign.html"
							}
							
							,
							
							
							{
							"title" : "fcntl函数设置阻塞与非阻塞 - ",
							"url" : "/MyBlog/linux/2019/06/08/fcntl.html"
							}
							
							,
							
							
							{
							"title" : "swoole - ",
							"url" : "/MyBlog/linux/2019/06/07/swoole.html"
							}
							
							,
							
							
							{
							"title" : "进程池，线程池 - ",
							"url" : "/MyBlog/linux/2019/06/07/pool.html"
							}
							
							,
							
							
							{
							"title" : "getuid、geteuid和setuid函数 - ",
							"url" : "/MyBlog/linux/2019/06/07/geteuid.html"
							}
							
							,
							
							
							{
							"title" : "fpm 源码阅读 - ",
							"url" : "/MyBlog/linux/2019/06/07/fpm.html"
							}
							
							,
							
							
							{
							"title" : "socketpair nginx 通信机制 - ",
							"url" : "/MyBlog/web/2019/06/06/socketpair.html"
							}
							
							,
							
							
							{
							"title" : "goroutine 泄露 - ",
							"url" : "/MyBlog/golang/2019/06/04/goroutine.html"
							}
							
							,
							
							
							{
							"title" : "umask umask(0) - ",
							"url" : "/MyBlog/linux/2019/06/02/umask.html"
							}
							
							,
							
							
							{
							"title" : "sigsuspend 进程阻塞 与 pause 区别 - ",
							"url" : "/MyBlog/linux/2019/06/02/sigsuspend.html"
							}
							
							,
							
							
							{
							"title" : "sigaction - ",
							"url" : "/MyBlog/linux/2019/06/02/sigaction.html"
							}
							
							,
							
							
							{
							"title" : "信号(sigaction,sigaddset,sigprocmask) - ",
							"url" : "/MyBlog/linux/2019/06/02/sig.html"
							}
							
							,
							
							
							{
							"title" : "三种时间结构及定时器setitimer() - ",
							"url" : "/MyBlog/linux/2019/06/02/settimer.html"
							}
							
							,
							
							
							{
							"title" : "setsid & 后台进程 - ",
							"url" : "/MyBlog/linux/2019/06/02/setsid.html"
							}
							
							,
							
							
							{
							"title" : "getsockname getpeername - ",
							"url" : "/MyBlog/linux/2019/06/02/getsockname.html"
							}
							
							,
							
							
							{
							"title" : "yaf - ",
							"url" : "/MyBlog/web/2019/06/01/yaf.html"
							}
							
							,
							
							
							{
							"title" : "waitpid wait - ",
							"url" : "/MyBlog/linux/2019/05/31/waitpid.html"
							}
							
							,
							
							
							{
							"title" : "socketpair  popen - ",
							"url" : "/MyBlog/linux/2019/05/31/socketpair.html"
							}
							
							,
							
							
							{
							"title" : "ngx_cycle_s - ",
							"url" : "/MyBlog/web/2019/05/31/ngx_cycle_s.html"
							}
							
							,
							
							
							{
							"title" : "linux 信号系统调用 - ",
							"url" : "/MyBlog/linux/2019/05/31/kill.html"
							}
							
							,
							
							
							{
							"title" : "fpm worker 进程的生命周期 - ",
							"url" : "/MyBlog/web/2019/05/31/fpm.html"
							}
							
							,
							
							
							{
							"title" : "ext_skel php-x php扩展开发工具 - ",
							"url" : "/MyBlog/web/2019/05/31/ext_skel.html"
							}
							
							,
							
							
							{
							"title" : "sockt编程中的文件句柄 select poll epoll - ",
							"url" : "/MyBlog/linux/2019/05/30/sockfd.html"
							}
							
							,
							
							
							{
							"title" : "clion 支持跳转配置 - ",
							"url" : "/MyBlog/web/2019/05/30/clion.html"
							}
							
							,
							
							
							{
							"title" : "How TCP Sockets Work - ",
							"url" : "/MyBlog/linux/2019/05/29/o.html"
							}
							
							,
							
							
							{
							"title" : "io 模型 - ",
							"url" : "/MyBlog/linux/2019/05/29/io.html"
							}
							
							,
							
							
							{
							"title" : "SO_REUSEPORT 惊群 - ",
							"url" : "/MyBlog/linux/2019/05/29/SO_REUSEPORT.html"
							}
							
							,
							
							
							{
							"title" : "pprof - ",
							"url" : "/MyBlog/golang/2019/05/28/pprof.html"
							}
							
							,
							
							
							{
							"title" : "kedis - ",
							"url" : "/MyBlog/storage/2019/05/28/kedis.html"
							}
							
							,
							
							
							{
							"title" : "php-fpm - ",
							"url" : "/MyBlog/web/2019/05/28/fpm.html"
							}
							
							,
							
							
							{
							"title" : "codis - ",
							"url" : "/MyBlog/storage/2019/05/28/codis.html"
							}
							
							,
							
							
							{
							"title" : "SO_REUSEPORT 多个server进程同时监听一个unix socket文件 - ",
							"url" : "/MyBlog/linux/2019/05/28/SO_REUSEPORT.html"
							}
							
							,
							
							
							{
							"title" : "多个进程绑定相同端口的实现分析[Google Patch] - ",
							"url" : "/MyBlog/linux/2019/05/28/REUSEPORT.html"
							}
							
							,
							
							
							{
							"title" : "PrintStack - ",
							"url" : "/MyBlog/golang/2019/05/28/PrintStack.html"
							}
							
							,
							
							
							{
							"title" : "redis HashTags - ",
							"url" : "/MyBlog/storage/2019/05/28/HashTags.html"
							}
							
							,
							
							
							{
							"title" : "GEODNS GeoIP - ",
							"url" : "/MyBlog/web/2019/05/28/GEODNS.html"
							}
							
							,
							
							
							{
							"title" : "Benchmark - ",
							"url" : "/MyBlog/golang/2019/05/27/Benchmark.html"
							}
							
							,
							
							
							{
							"title" : "TCP_CORK tcp_push TCP_NODELAY 和 TCP_NOPUSH - ",
							"url" : "/MyBlog/linux/2019/05/26/tcp.html"
							}
							
							,
							
							
							{
							"title" : "pid 文件作用 - ",
							"url" : "/MyBlog/linux/2019/05/26/pid.html"
							}
							
							,
							
							
							{
							"title" : "limit_rate_after nginx限速配置 - ",
							"url" : "/MyBlog/web/2019/05/26/limit_rate_after.html"
							}
							
							,
							
							
							{
							"title" : "libevent - ",
							"url" : "/MyBlog/linux/2019/05/26/libevent.html"
							}
							
							,
							
							
							{
							"title" : "爱拉托逊斯筛选法 - ",
							"url" : "/MyBlog/algorithm/2019/05/26/Eratosthees.html"
							}
							
							,
							
							
							{
							"title" : "thread local storage Goroutine Local Storage - ",
							"url" : "/MyBlog/golang/2019/05/24/tls.html"
							}
							
							,
							
							
							{
							"title" : "获取 goroutine id - ",
							"url" : "/MyBlog/golang/2019/05/24/getg.html"
							}
							
							,
							
							
							{
							"title" : "backlog - ",
							"url" : "/MyBlog/linux/2019/05/24/backlog.html"
							}
							
							,
							
							
							{
							"title" : "method 接收者 - ",
							"url" : "/MyBlog/golang/2019/05/23/method.html"
							}
							
							,
							
							
							{
							"title" : "SYN-Cookie - ",
							"url" : "/MyBlog/linux/2019/05/23/SYN-Cookie.html"
							}
							
							,
							
							
							{
							"title" : "SO_REUSEADDR SO_REUSEPORT - ",
							"url" : "/MyBlog/linux/2019/05/23/SO_REUSEADDR.html"
							}
							
							,
							
							
							{
							"title" : "lsof netstat - ",
							"url" : "/MyBlog/linux/2019/05/22/lsof.html"
							}
							
							,
							
							
							{
							"title" : "nginx request_time - ",
							"url" : "/MyBlog/web/2019/05/21/request_time.html"
							}
							
							,
							
							
							{
							"title" : "mysql instant add colum - ",
							"url" : "/MyBlog/storage/2019/05/21/instantaddcolum.html"
							}
							
							,
							
							
							{
							"title" : "mysql ddl-ghost - ",
							"url" : "/MyBlog/storage/2019/05/21/ddl-ghost.html"
							}
							
							,
							
							
							{
							"title" : "TIME_WAIT和CLOSE_WAIT - ",
							"url" : "/MyBlog/golang/2019/05/09/time_wait.html"
							}
							
							,
							
							
							{
							"title" : "netpoller - ",
							"url" : "/MyBlog/golang/2019/05/09/netpoller.html"
							}
							
							,
							
							
							{
							"title" : "TCP序列号欺骗 - ",
							"url" : "/MyBlog/linux/2019/05/09/isns.html"
							}
							
							,
							
							
							{
							"title" : "gopsutil - ",
							"url" : "/MyBlog/golang/2019/05/09/gopsutil.html"
							}
							
							,
							
							
							{
							"title" : "goprof - ",
							"url" : "/MyBlog/golang/2019/04/26/goprof.html"
							}
							
							,
							
							
							{
							"title" : "CAS:Compare and Swap - ",
							"url" : "/MyBlog/algorithm/2019/04/26/cas.html"
							}
							
							,
							
							
							{
							"title" : "Context - ",
							"url" : "/MyBlog/golang/2019/04/26/Context.html"
							}
							
							,
							
							
							{
							"title" : "tideways + xhgui（+toolkit） php 性能分析 - ",
							"url" : "/MyBlog/web/2019/04/24/tideways.html"
							}
							
							,
							
							
							{
							"title" : "aqs - ",
							"url" : "/MyBlog/algorithm/2019/04/24/aqs.html"
							}
							
							,
							
							
							{
							"title" : "treemap HashMap和LinkedHashMap的区别 - ",
							"url" : "/MyBlog/algorithm/2019/04/23/treemap.html"
							}
							
							,
							
							
							{
							"title" : "gctrace - ",
							"url" : "/MyBlog/golang/2019/04/23/gctrace.html"
							}
							
							,
							
							
							{
							"title" : "BitTorrent协议分析 - ",
							"url" : "/MyBlog/web/2019/04/23/BitTorrent%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E4%B8%80.html"
							}
							
							,
							
							
							{
							"title" : "mutex - ",
							"url" : "/MyBlog/golang/2019/04/22/mutex.html"
							}
							
							,
							
							
							{
							"title" : "WaitGroup - ",
							"url" : "/MyBlog/golang/2019/04/22/WaitGroup.html"
							}
							
							,
							
							
							{
							"title" : "TCMalloc - ",
							"url" : "/MyBlog/golang/2019/04/22/TCMalloc.html"
							}
							
							,
							
							
							{
							"title" : "SESSION 保存在服务器的哪里 - ",
							"url" : "/MyBlog/web/2019/04/21/SESSION.html"
							}
							
							,
							
							
							{
							"title" : "go schedule - ",
							"url" : "/MyBlog/golang/2019/04/20/schedule.html"
							}
							
							,
							
							
							{
							"title" : "gc - ",
							"url" : "/MyBlog/golang/2019/04/20/gc.html"
							}
							
							,
							
							
							{
							"title" : "channel - ",
							"url" : "/MyBlog/golang/2019/04/20/channel.html"
							}
							
							,
							
							
							{
							"title" : "lldb - ",
							"url" : "/MyBlog/golang/2019/04/18/lldb.html"
							}
							
							,
							
							
							{
							"title" : "goroutine实现原理 - ",
							"url" : "/MyBlog/golang/2019/04/18/goroutine.html"
							}
							
							,
							
							
							{
							"title" : "go Vet - ",
							"url" : "/MyBlog/golang/2019/04/18/Vet.html"
							}
							
							,
							
							
							{
							"title" : "runtime - ",
							"url" : "/MyBlog/golang/2019/04/17/runtime.html"
							}
							
							,
							
							
							{
							"title" : "go:linkname go:nosplit - ",
							"url" : "/MyBlog/golang/2019/04/17/linkname.html"
							}
							
							,
							
							
							{
							"title" : "Go 语言编译指示 - ",
							"url" : "/MyBlog/golang/2019/04/17/go.html"
							}
							
							,
							
							
							{
							"title" : "Cond - ",
							"url" : "/MyBlog/golang/2019/04/17/Cond.html"
							}
							
							,
							
							
							{
							"title" : "reflection - ",
							"url" : "/MyBlog/golang/2019/04/14/reflection.html"
							}
							
							,
							
							
							{
							"title" : "Tcp Keepalive和HTTP Keep-alive - ",
							"url" : "/MyBlog/linux/2019/04/13/tcphttp.html"
							}
							
							,
							
							
							{
							"title" : "keepalive 连接池 - ",
							"url" : "/MyBlog/linux/2019/04/13/keepalive.html"
							}
							
							,
							
							
							{
							"title" : "发送接收缓冲区滑动窗口 - ",
							"url" : "/MyBlog/linux/2019/04/13/cwnd.html"
							}
							
							,
							
							
							{
							"title" : "dnsmasq - ",
							"url" : "/MyBlog/algorithm/2019/04/12/dnsmasq.html"
							}
							
							,
							
							
							{
							"title" : "Zabbix 监控组件及流程 - ",
							"url" : "/MyBlog/web/2019/04/12/Zabbix.html"
							}
							
							,
							
							
							{
							"title" : "FULLTEXT 全文索引 - ",
							"url" : "/MyBlog/storage/2019/04/12/FULLTEXT.html"
							}
							
							,
							
							
							{
							"title" : "vrrp keepalived - ",
							"url" : "/MyBlog/web/2019/04/09/vrrp.html"
							}
							
							,
							
							
							{
							"title" : "lvs - ",
							"url" : "/MyBlog/algorithm/2019/04/09/lvs.html"
							}
							
							,
							
							
							{
							"title" : "dig - ",
							"url" : "/MyBlog/web/2019/04/09/dig.html"
							}
							
							,
							
							
							{
							"title" : "高qps接入层方案 - ",
							"url" : "/MyBlog/web/2019/04/08/qps.html"
							}
							
							,
							
							
							{
							"title" : "for update - ",
							"url" : "/MyBlog/storage/2019/04/08/forupdate.html"
							}
							
							,
							
							
							{
							"title" : "inode 与文件块 block 对应关系 - ",
							"url" : "/MyBlog/linux/2019/04/07/inode.html"
							}
							
							,
							
							
							{
							"title" : "socket 虚拟文件系统 - ",
							"url" : "/MyBlog/linux/2019/04/06/socket.html"
							}
							
							,
							
							
							{
							"title" : "screen nohup session - ",
							"url" : "/MyBlog/linux/2019/04/06/screen.html"
							}
							
							,
							
							
							{
							"title" : "Golang服务器的网络层实现--总结对比常用epoll模型 - ",
							"url" : "/MyBlog/golang/2019/04/06/net.html"
							}
							
							,
							
							
							{
							"title" : "堆组织表(HOT)和索引组织表(IOT) - ",
							"url" : "/MyBlog/storage/2019/04/06/iot.html"
							}
							
							,
							
							
							{
							"title" : "fork cahe - ",
							"url" : "/MyBlog/linux/2019/04/06/fork_cahe.html"
							}
							
							,
							
							
							{
							"title" : "文件锁 - ",
							"url" : "/MyBlog/linux/2019/04/06/file_lock.html"
							}
							
							,
							
							
							{
							"title" : "fd 文件描述符 - ",
							"url" : "/MyBlog/linux/2019/04/06/fd.html"
							}
							
							,
							
							
							{
							"title" : "fork() execve() - ",
							"url" : "/MyBlog/linux/2019/04/06/exec.html"
							}
							
							,
							
							
							{
							"title" : "snowflake - ",
							"url" : "/MyBlog/algorithm/2019/03/31/snowflake.html"
							}
							
							,
							
							
							{
							"title" : "Consul vs Zookeeper vs Etcd vs Eureka - ",
							"url" : "/MyBlog/algorithm/2019/03/31/eureka.html"
							}
							
							,
							
							
							{
							"title" : "maxmemory - ",
							"url" : "/MyBlog/algorithm/2019/03/27/maxmemory.html"
							}
							
							,
							
							
							{
							"title" : "页、磁盘块与扇区 - ",
							"url" : "/MyBlog/linux/2019/03/27/disk.html"
							}
							
							,
							
							
							{
							"title" : "GeoHash - ",
							"url" : "/MyBlog/algorithm/2019/03/27/GeoHash.html"
							}
							
							,
							
							
							{
							"title" : "SkipList跳表基本原理 - ",
							"url" : "/MyBlog/algorithm/2019/03/26/skip_table.html"
							}
							
							,
							
							
							{
							"title" : "Bash 带有特殊含义的退出码 - ",
							"url" : "/MyBlog/linux/2019/03/25/exit.html"
							}
							
							,
							
							
							{
							"title" : "FUNCNAME - ",
							"url" : "/MyBlog/linux/2019/03/25/FUNCNAME.html"
							}
							
							,
							
							
							{
							"title" : "乐观锁悲观锁 - ",
							"url" : "/MyBlog/linux/2019/03/24/lock.html"
							}
							
							,
							
							
							{
							"title" : "redis zset 延迟队列 - ",
							"url" : "/MyBlog/storage/2019/03/23/zset.html"
							}
							
							,
							
							
							{
							"title" : "redis keys scan - ",
							"url" : "/MyBlog/storage/2019/03/23/scan.html"
							}
							
							,
							
							
							{
							"title" : "lru - ",
							"url" : "/MyBlog/storage/2019/03/23/lru.html"
							}
							
							,
							
							
							{
							"title" : "lfu - ",
							"url" : "/MyBlog/storage/2019/03/23/lfu.html"
							}
							
							,
							
							
							{
							"title" : "Codis Twemproxy redis集群 - ",
							"url" : "/MyBlog/storage/2019/03/23/codis.html"
							}
							
							,
							
							
							{
							"title" : "gap Lock 间隙锁 - ",
							"url" : "/MyBlog/storage/2019/03/19/gapLock.html"
							}
							
							,
							
							
							{
							"title" : "strace - ",
							"url" : "/MyBlog/linux/2019/03/17/strace.html"
							}
							
							,
							
							
							{
							"title" : "pstack 原理 - ",
							"url" : "/MyBlog/linux/2019/03/17/pstack.html"
							}
							
							,
							
							
							{
							"title" : "Linux进程间通信-消息队列（mqueue） - ",
							"url" : "/MyBlog/linux/2019/03/17/mqueue.html"
							}
							
							,
							
							
							{
							"title" : "kill - ",
							"url" : "/MyBlog/linux/2019/03/17/kill.html"
							}
							
							,
							
							
							{
							"title" : "interface - ",
							"url" : "/MyBlog/golang/2019/03/17/interface.html"
							}
							
							,
							
							
							{
							"title" : "gc - ",
							"url" : "/MyBlog/golang/2019/03/17/gc.html"
							}
							
							,
							
							
							{
							"title" : "火焰图（flame graph) - ",
							"url" : "/MyBlog/linux/2019/03/17/flame.html"
							}
							
							,
							
							
							{
							"title" : "escape 逃逸分析 - ",
							"url" : "/MyBlog/golang/2019/03/17/escape.html"
							}
							
							,
							
							
							{
							"title" : "core dump - ",
							"url" : "/MyBlog/linux/2019/03/17/core.html"
							}
							
							,
							
							
							{
							"title" : "thread apply all bt - ",
							"url" : "/MyBlog/linux/2019/03/17/bt.html"
							}
							
							,
							
							
							{
							"title" : "尾递归、尾调用 - ",
							"url" : "/MyBlog/lang/2019/03/10/tail.html"
							}
							
							,
							
							
							{
							"title" : "golang slice append 陷阱 - ",
							"url" : "/MyBlog/golang/2019/03/10/slice.html"
							}
							
							,
							
							
							{
							"title" : "函数式编程、闭包 - ",
							"url" : "/MyBlog/lang/2019/03/10/functional.html"
							}
							
							,
							
							
							{
							"title" : "通配符与正则表达式 - ",
							"url" : "/MyBlog/linux/2019/03/09/regx.html"
							}
							
							,
							
							
							{
							"title" : "awk 用法总结 - ",
							"url" : "/MyBlog/linux/2019/03/03/awk.html"
							}
							
							,
							
							
							{
							"title" : "线程技术(Hyper-Threading Technology) - ",
							"url" : "/MyBlog/web/2019/03/02/ht.html"
							}
							
							,
							
							
							{
							"title" : "ConcurrentHashMap 分段锁 - ",
							"url" : "/MyBlog/algorithm/2019/03/02/ConcurrentHashMap.html"
							}
							
							,
							
							
							{
							"title" : "锁 - ",
							"url" : "/MyBlog/web/2019/02/27/lock.html"
							}
							
							,
							
							
							{
							"title" : "futex 快速用户空间互斥体 - ",
							"url" : "/MyBlog/linux/2019/02/27/futex.html"
							}
							
							,
							
							
							{
							"title" : "Test And Set Lock - ",
							"url" : "/MyBlog/linux/2019/02/27/Test_And_Set_Lock.html"
							}
							
							,
							
							
							{
							"title" : "分布式事务 xa/tcc - ",
							"url" : "/MyBlog/web/2019/02/26/xa.html"
							}
							
							,
							
							
							{
							"title" : "分布式缓存redis - ",
							"url" : "/MyBlog/storage/2019/02/26/redis.html"
							}
							
							,
							
							
							{
							"title" : "elasticsearch - ",
							"url" : "/MyBlog/elasticsearch/2019/02/26/elasticsearch.html"
							}
							
							,
							
							
							{
							"title" : "异地多活 - ",
							"url" : "/MyBlog/algorithm/2019/02/26/cap.html"
							}
							
							,
							
							
							{
							"title" : "go语言sync包的学习(Mutex、WaitGroup、Cond) - ",
							"url" : "/MyBlog/golang/2019/02/24/sync.html"
							}
							
							,
							
							
							{
							"title" : "golang 的栈 - ",
							"url" : "/MyBlog/golang/2019/02/24/stack.html"
							}
							
							,
							
							
							{
							"title" : "Go语言汇编 - ",
							"url" : "/MyBlog/golang/2019/02/24/goasm.html"
							}
							
							,
							
							
							{
							"title" : "Actor模型和CSP模型的区别 - ",
							"url" : "/MyBlog/golang/2019/02/24/csp_actor.html"
							}
							
							,
							
							
							{
							"title" : "CSP(Communicating Sequential Processes)模型 - ",
							"url" : "/MyBlog/golang/2019/02/24/csp.html"
							}
							
							,
							
							
							{
							"title" : "application binary interface - ",
							"url" : "/MyBlog/web/2019/02/24/abi.html"
							}
							
							,
							
							
							{
							"title" : "Context - ",
							"url" : "/MyBlog/golang/2019/02/24/Context.html"
							}
							
							,
							
							
							{
							"title" : "Go unsafe Pointer - ",
							"url" : "/MyBlog/golang/2019/02/23/unsafepointer.html"
							}
							
							,
							
							
							{
							"title" : "ilp 整数线性规划 - ",
							"url" : "/MyBlog/algorithm/2019/02/22/ilp.html"
							}
							
							,
							
							
							{
							"title" : "php json_encode 的坑 - ",
							"url" : "/MyBlog/web/2019/01/28/json_encode.html"
							}
							
							,
							
							
							{
							"title" : "traps - ",
							"url" : "/MyBlog/golang/2019/01/26/traps.html"
							}
							
							,
							
							
							{
							"title" : "golang 内存分配 - ",
							"url" : "/MyBlog/golang/2019/01/26/stack.html"
							}
							
							,
							
							
							{
							"title" : "Server Name Indication - ",
							"url" : "/MyBlog/web/2019/01/26/sni.html"
							}
							
							,
							
							
							{
							"title" : "golang  nil 总结 - ",
							"url" : "/MyBlog/golang/2019/01/26/nil.html"
							}
							
							,
							
							
							{
							"title" : "checkstyle - ",
							"url" : "/MyBlog/web/2019/01/16/checkstyle.html"
							}
							
							,
							
							
							{
							"title" : "timer - ",
							"url" : "/MyBlog/linux/2019/01/15/timer.html"
							}
							
							,
							
							
							{
							"title" : "timekeeper - ",
							"url" : "/MyBlog/linux/2019/01/15/timekeeper.html"
							}
							
							,
							
							
							{
							"title" : "jiffies - ",
							"url" : "/MyBlog/linux/2019/01/15/jiffies.html"
							}
							
							,
							
							
							{
							"title" : "clock_event_device - ",
							"url" : "/MyBlog/linux/2019/01/15/clock_event_device.html"
							}
							
							,
							
							
							{
							"title" : "时间轮算法 - ",
							"url" : "/MyBlog/linux/2019/01/15/callout.html"
							}
							
							,
							
							
							{
							"title" : "ddd - ",
							"url" : "/MyBlog/web/2019/01/13/ddd.html"
							}
							
							,
							
							
							{
							"title" : "4色图 - ",
							"url" : "/MyBlog/web/2019/01/13/4color.html"
							}
							
							,
							
							
							{
							"title" : "www-authenticate - ",
							"url" : "/MyBlog/web/2019/01/12/www-authenticate.html"
							}
							
							,
							
							
							{
							"title" : "rstp - ",
							"url" : "/MyBlog/web/2019/01/12/rstp.html"
							}
							
							,
							
							
							{
							"title" : "WebDAV - ",
							"url" : "/MyBlog/web/2019/01/12/WebDAV.html"
							}
							
							,
							
							
							{
							"title" : "TCP_NODELAY - ",
							"url" : "/MyBlog/web/2019/01/12/TCP_NODELAY.html"
							}
							
							,
							
							
							{
							"title" : "reflect golang 反射 - ",
							"url" : "/MyBlog/golang/2019/01/04/reflect.html"
							}
							
							,
							
							
							{
							"title" : "llvm - ",
							"url" : "/MyBlog/lang/2019/01/02/llvm.html"
							}
							
							,
							
							
							{
							"title" : "recover panic defer - ",
							"url" : "/MyBlog/golang/2018/12/29/recover.html"
							}
							
							,
							
							
							{
							"title" : "golang debug dlv - ",
							"url" : "/MyBlog/golang/2018/12/25/godebug.html"
							}
							
							,
							
							
							{
							"title" : "gdb dlv 对比 - ",
							"url" : "/MyBlog/golang/2018/12/25/gdbdlv.html"
							}
							
							,
							
							
							{
							"title" : "gdb 工作原理和内核实现 - ",
							"url" : "/MyBlog/golang/2018/12/25/gdb_.html"
							}
							
							,
							
							
							{
							"title" : "gdb 调试golang - ",
							"url" : "/MyBlog/golang/2018/12/25/gdb.html"
							}
							
							,
							
							
							{
							"title" : "go-bindata Go 语言打包静态文件 - ",
							"url" : "/MyBlog/golang/2018/12/24/go-bindata.html"
							}
							
							,
							
							
							{
							"title" : "esc - ",
							"url" : "/MyBlog/golang/2018/12/24/esc.html"
							}
							
							,
							
							
							{
							"title" : "go Generate - ",
							"url" : "/MyBlog/golang/2018/12/24/Generate.html"
							}
							
							,
							
							
							{
							"title" : "subline text3 插件编写 - ",
							"url" : "/MyBlog/web/2018/12/23/subline.html"
							}
							
							,
							
							
							{
							"title" : "bom - ",
							"url" : "/MyBlog/web/2018/12/23/bom.html"
							}
							
							,
							
							
							{
							"title" : "newSQL - ",
							"url" : "/MyBlog/storage/2018/12/22/newSQL.html"
							}
							
							,
							
							
							{
							"title" : "subline text3 自动生成测试代码 - ",
							"url" : "/MyBlog/golang/2018/12/22/gotest_subline.html"
							}
							
							,
							
							
							{
							"title" : "ghost - ",
							"url" : "/MyBlog/storage/2018/12/22/ghost.html"
							}
							
							,
							
							
							{
							"title" : "go test - ",
							"url" : "/MyBlog/golang/2018/12/21/gotest.html"
							}
							
							,
							
							
							{
							"title" : "golang strcut 初始化 - ",
							"url" : "/MyBlog/golang/2018/12/20/strcut.html"
							}
							
							,
							
							
							{
							"title" : "docker mac 镜像清理 - ",
							"url" : "/MyBlog/docker/2018/12/18/docker_clean.html"
							}
							
							,
							
							
							{
							"title" : "golang 传值传引用 - ",
							"url" : "/MyBlog/golang/2018/12/14/reference.html"
							}
							
							,
							
							
							{
							"title" : "ntp 网络时间协议 - ",
							"url" : "/MyBlog/algorithm/2018/12/13/ntp.html"
							}
							
							,
							
							
							{
							"title" : "hive 表与hdfs关系 - ",
							"url" : "/MyBlog/storage/2018/12/08/hive.html"
							}
							
							,
							
							
							{
							"title" : "Shell 脚本中调用另一个 Shell 脚本 - ",
							"url" : "/MyBlog/web/2018/11/28/shell.html"
							}
							
							,
							
							
							{
							"title" : "Multipart File Upload - ",
							"url" : "/MyBlog/golang/2018/11/26/postfile.html"
							}
							
							,
							
							
							{
							"title" : "golang 的坑 - ",
							"url" : "/MyBlog/golang/2018/11/26/float64.html"
							}
							
							,
							
							
							{
							"title" : "http basic authentication - ",
							"url" : "/MyBlog/golang/2018/11/26/authentication.html"
							}
							
							,
							
							
							{
							"title" : "索引原理分析 - ",
							"url" : "/MyBlog/elasticsearch/2018/11/18/stor.html"
							}
							
							,
							
							
							{
							"title" : "正排索引vs倒排索引 - ",
							"url" : "/MyBlog/elasticsearch/2018/11/18/index.html"
							}
							
							,
							
							
							{
							"title" : "hive 和 elasticsearch 的整合 - ",
							"url" : "/MyBlog/elasticsearch/2018/11/18/hive.html"
							}
							
							,
							
							
							{
							"title" : "elasticsearch 文件的存储 - ",
							"url" : "/MyBlog/elasticsearch/2018/11/18/elasticsearch.html"
							}
							
							,
							
							
							{
							"title" : "curl get 发送post数据 - ",
							"url" : "/MyBlog/web/2018/11/16/curl.html"
							}
							
							,
							
							
							{
							"title" : "地理坐标的六边形编码(PHXIS) - ",
							"url" : "/MyBlog/algorithm/2018/11/15/PHXIS.html"
							}
							
							,
							
							
							{
							"title" : "大数据系统的Lambda架构 - ",
							"url" : "/MyBlog/storage/2018/11/11/lambda.html"
							}
							
							,
							
							
							{
							"title" : "B树、B-树、B+树、B*树介绍 - ",
							"url" : "/MyBlog/storage/2018/11/11/b.html"
							}
							
							,
							
							
							{
							"title" : "Phoenix - ",
							"url" : "/MyBlog/storage/2018/11/11/Phoenix.html"
							}
							
							,
							
							
							{
							"title" : "MHA的搭建 - ",
							"url" : "/MyBlog/storage/2018/11/09/mha_setup.html"
							}
							
							,
							
							
							{
							"title" : "Xtrabackup - ",
							"url" : "/MyBlog/storage/2018/11/09/Xtrabackup.html"
							}
							
							,
							
							
							{
							"title" : "R_tree - ",
							"url" : "/MyBlog/algorithm/2018/11/09/R_tree.html"
							}
							
							,
							
							
							{
							"title" : "MySql GIS 空间数据库使用体验 - ",
							"url" : "/MyBlog/storage/2018/11/09/MySql.html"
							}
							
							,
							
							
							{
							"title" : "MySQL高可用架构之MHA - ",
							"url" : "/MyBlog/storage/2018/11/09/MHA.html"
							}
							
							,
							
							
							{
							"title" : "ArcSDE 是ArcGIS的空间数据引擎 - ",
							"url" : "/MyBlog/storage/2018/11/09/ArcSDE.html"
							}
							
							,
							
							
							{
							"title" : "kafka shell - ",
							"url" : "/MyBlog/storage/2018/11/07/kafka.html"
							}
							
							,
							
							
							{
							"title" : "presto - ",
							"url" : "/MyBlog/storage/2018/11/02/presto.html"
							}
							
							,
							
							
							{
							"title" : "alibaba Druid - ",
							"url" : "/MyBlog/storage/2018/11/02/Druid.html"
							}
							
							,
							
							
							{
							"title" : "Calcite - ",
							"url" : "/MyBlog/storage/2018/11/02/Calcite.html"
							}
							
							,
							
							
							{
							"title" : "binlog同步kafka方案 - ",
							"url" : "/MyBlog/storage/2018/10/31/binlog_kafka.html"
							}
							
							,
							
							
							{
							"title" : "maxwell+kafka+Spark Streaming构建MySQL Binlog日志采集实时处理方案 - ",
							"url" : "/MyBlog/storage/2018/10/29/maxwell.html"
							}
							
							,
							
							
							{
							"title" : "samza - ",
							"url" : "/MyBlog/algorithm/2018/10/28/smaza.html"
							}
							
							,
							
							
							{
							"title" : "flume - ",
							"url" : "/MyBlog/storage/2018/10/28/flume.html"
							}
							
							,
							
							
							{
							"title" : "csrf token - ",
							"url" : "/MyBlog/web/2018/10/28/csrftoken.html"
							}
							
							,
							
							
							{
							"title" : "show processlist - ",
							"url" : "/MyBlog/storage/2018/10/22/processlist.html"
							}
							
							,
							
							
							{
							"title" : "ptmalloc、tcmalloc和jemalloc - ",
							"url" : "/MyBlog/storage/2018/10/21/tcmalloc.html"
							}
							
							,
							
							
							{
							"title" : "列式存储 - ",
							"url" : "/MyBlog/storage/2018/10/21/rowstorage.html"
							}
							
							,
							
							
							{
							"title" : "mysql-proxy-lua - ",
							"url" : "/MyBlog/storage/2018/10/21/mysql-proxy-lua.html"
							}
							
							,
							
							
							{
							"title" : "mvcc - ",
							"url" : "/MyBlog/storage/2018/10/21/mvcc.html"
							}
							
							,
							
							
							{
							"title" : "LSM树由来、设计思想 - ",
							"url" : "/MyBlog/storage/2018/10/21/lsmwal.html"
							}
							
							,
							
							
							{
							"title" : "文件读取流程 - ",
							"url" : "/MyBlog/linux/2018/10/21/fileread.html"
							}
							
							,
							
							
							{
							"title" : "zookeeper在hadoop和hbase中的作用 - ",
							"url" : "/MyBlog/zookeeper/2018/10/18/zk_hdfs_hbase.html"
							}
							
							,
							
							
							{
							"title" : "ssh config - ",
							"url" : "/MyBlog/web/2018/10/18/sshconfig.html"
							}
							
							,
							
							
							{
							"title" : "google authenticator 工作原理 - ",
							"url" : "/MyBlog/web/2018/10/12/authenticator.html"
							}
							
							,
							
							
							{
							"title" : "Zookeeper 在 Kafka 中的作用 - ",
							"url" : "/MyBlog/zookeeper/2018/10/11/zkkafka.html"
							}
							
							,
							
							
							{
							"title" : "redis-lua 事物 - ",
							"url" : "/MyBlog/storage/2018/10/10/redis-lua.html"
							}
							
							,
							
							
							{
							"title" : "explain mysql  执行计划 - ",
							"url" : "/MyBlog/storage/2018/10/10/explain.html"
							}
							
							,
							
							
							{
							"title" : "mysql的隐式类型转换 - ",
							"url" : "/MyBlog/storage/2018/10/09/type.html"
							}
							
							,
							
							
							{
							"title" : "zookeeper 实现配置同步 服务发现 - ",
							"url" : "/MyBlog/zookeeper/2018/10/08/zkconf.html"
							}
							
							,
							
							
							{
							"title" : "zk 实现分布式锁 - ",
							"url" : "/MyBlog/zookeeper/2018/09/29/zklock.html"
							}
							
							,
							
							
							{
							"title" : "基于数据库的分布式锁 - ",
							"url" : "/MyBlog/storage/2018/09/29/dblock.html"
							}
							
							,
							
							
							{
							"title" : "mysqlbinlog 格式解析 - ",
							"url" : "/MyBlog/storage/2018/09/28/mysqlbinlog.html"
							}
							
							,
							
							
							{
							"title" : "sublime for mac 实现 ctrl+左键 跳转函数 - ",
							"url" : "/MyBlog/web/2018/09/27/subline.html"
							}
							
							,
							
							
							{
							"title" : "sql-parser - ",
							"url" : "/MyBlog/storage/2018/09/27/sql-parser.html"
							}
							
							,
							
							
							{
							"title" : "Redis分布式锁 - ",
							"url" : "/MyBlog/algorithm/2018/09/27/redis-lock.html"
							}
							
							,
							
							
							{
							"title" : "go 原子操作 - ",
							"url" : "/MyBlog/golang/2018/09/27/goautomic.html"
							}
							
							,
							
							
							{
							"title" : "cmakelist - ",
							"url" : "/MyBlog/algorithm/2018/09/27/cmakelist.html"
							}
							
							,
							
							
							{
							"title" : "mac mysql 开启binlog - ",
							"url" : "/MyBlog/storage/2018/09/27/binlog.html"
							}
							
							,
							
							
							{
							"title" : "autoconf和automake - ",
							"url" : "/MyBlog/linux/2018/09/27/automake.html"
							}
							
							,
							
							
							{
							"title" : "bash  2>&1 - ",
							"url" : "/MyBlog/linux/2018/09/26/bash.html"
							}
							
							,
							
							
							{
							"title" : "uninterruptible D 状态 - ",
							"url" : "/MyBlog/linux/2018/09/23/uninterruptible.html"
							}
							
							,
							
							
							{
							"title" : "LSF、BPF、eBPF - ",
							"url" : "/MyBlog/linux/2018/09/23/bpf.html"
							}
							
							,
							
							
							{
							"title" : "UNIX Domain Socket - ",
							"url" : "/MyBlog/linux/2018/09/21/unix_socket.html"
							}
							
							,
							
							
							{
							"title" : "ptrace - ",
							"url" : "/MyBlog/linux/2018/09/21/ptrace.html"
							}
							
							,
							
							
							{
							"title" : "LD_PRELOAD/DYLD_INSERT_LIBRARIES libc hook - ",
							"url" : "/MyBlog/linux/2018/09/21/LD_PRELOAD.html"
							}
							
							,
							
							
							{
							"title" : "nginx php-fpm unix-socket - ",
							"url" : "/MyBlog/web/2018/09/20/php-fpm-unix-socket.html"
							}
							
							,
							
							
							{
							"title" : "cachetool 非php环境操作apcu - ",
							"url" : "/MyBlog/web/2018/09/20/cachetool.html"
							}
							
							,
							
							
							{
							"title" : "git rebase - ",
							"url" : "/MyBlog/web/2018/09/19/rebase.html"
							}
							
							,
							
							
							{
							"title" : "futex - ",
							"url" : "/MyBlog/linux/2018/09/15/futex.html"
							}
							
							,
							
							
							{
							"title" : "strace 原理 - ",
							"url" : "/MyBlog/linux/2018/09/14/strace.html"
							}
							
							,
							
							
							{
							"title" : "libiop - ",
							"url" : "/MyBlog/web/2018/09/14/libiop.html"
							}
							
							,
							
							
							{
							"title" : "libevent - ",
							"url" : "/MyBlog/linux/2018/09/14/libevent.html"
							}
							
							,
							
							
							{
							"title" : "dbpool 数据库连接池 - ",
							"url" : "/MyBlog/algorithm/2018/09/14/dbpool.html"
							}
							
							,
							
							
							{
							"title" : "c-ares  dns 异步请求库 - ",
							"url" : "/MyBlog/linux/2018/09/14/c-ares.html"
							}
							
							,
							
							
							{
							"title" : "HttpClient - ",
							"url" : "/MyBlog/web/2018/09/14/HttpClient.html"
							}
							
							,
							
							
							{
							"title" : "Eureka 服务发现 - ",
							"url" : "/MyBlog/algorithm/2018/09/14/Eureka.html"
							}
							
							,
							
							
							{
							"title" : "makefile 及其工作原理 - ",
							"url" : "/MyBlog/linux/2018/09/13/makefile.html"
							}
							
							,
							
							
							{
							"title" : "php 内置的 web 服务器 - ",
							"url" : "/MyBlog/web/2018/09/11/oho.html"
							}
							
							,
							
							
							{
							"title" : "php 的定界符 <<<eof - ",
							"url" : "/MyBlog/web/2018/09/10/php.html"
							}
							
							,
							
							
							{
							"title" : "http_proxy - ",
							"url" : "/MyBlog/web/2018/09/10/http_proxy.html"
							}
							
							,
							
							
							{
							"title" : "thrift_golang - ",
							"url" : "/MyBlog/web/2018/09/09/thrift_golang.html"
							}
							
							,
							
							
							{
							"title" : "thrift 遇到的坑 - ",
							"url" : "/MyBlog/web/2018/09/09/thrift.html"
							}
							
							,
							
							
							{
							"title" : "spinlock 自旋锁 - ",
							"url" : "/MyBlog/linux/2018/09/08/spinlock.html"
							}
							
							,
							
							
							{
							"title" : "异步io - ",
							"url" : "/MyBlog/linux/2018/09/05/aio.html"
							}
							
							,
							
							
							{
							"title" : "thrift - ",
							"url" : "/MyBlog/web/2018/09/03/thrift.html"
							}
							
							,
							
							
							{
							"title" : "popen - ",
							"url" : "/MyBlog/linux/2018/09/03/popen.html"
							}
							
							,
							
							
							{
							"title" : "零拷贝之splice( )函数和tee( )函数 - ",
							"url" : "/MyBlog/linux/2018/09/02/tee.html"
							}
							
							,
							
							
							{
							"title" : "splice_sendfile - ",
							"url" : "/MyBlog/linux/2018/09/02/splice_sendfile.html"
							}
							
							,
							
							
							{
							"title" : "splice - ",
							"url" : "/MyBlog/linux/2018/09/02/splice.html"
							}
							
							,
							
							
							{
							"title" : "MySQL协议分析 - ",
							"url" : "/MyBlog/storage/2018/09/02/mysql.html"
							}
							
							,
							
							
							{
							"title" : "Nginx/LVS/HAProxy负载均衡软件的优缺点 - ",
							"url" : "/MyBlog/web/2018/09/02/lvs.html"
							}
							
							,
							
							
							{
							"title" : "haproxy_exp - ",
							"url" : "/MyBlog/web/2018/09/02/haproxy_exp.html"
							}
							
							,
							
							
							{
							"title" : "haproxy - ",
							"url" : "/MyBlog/web/2018/09/02/haproxy.html"
							}
							
							,
							
							
							{
							"title" : "haproxy+keepalived实现高可用集群搭建 - ",
							"url" : "/MyBlog/web/2018/09/02/Keepalived.html"
							}
							
							,
							
							
							{
							"title" : "expect 100 continue - ",
							"url" : "/MyBlog/web/2018/09/02/100_continue.html"
							}
							
							,
							
							
							{
							"title" : "Jenkins和SonarQube集成 - ",
							"url" : "/MyBlog/web/2018/08/31/sonarQubeJenkins.html"
							}
							
							,
							
							
							{
							"title" : "sonarQube之平台搭建及sonar-scanner扫描 - ",
							"url" : "/MyBlog/web/2018/08/31/sonarQube.html"
							}
							
							,
							
							
							{
							"title" : "sendfile - ",
							"url" : "/MyBlog/linux/2018/08/30/sendfile.html"
							}
							
							,
							
							
							{
							"title" : "php流Streams、包装器wrapper - ",
							"url" : "/MyBlog/web/2018/08/30/phpwrapper.html"
							}
							
							,
							
							
							{
							"title" : "phar - ",
							"url" : "/MyBlog/web/2018/08/30/phar.html"
							}
							
							,
							
							
							{
							"title" : "httpdns - ",
							"url" : "/MyBlog/algorithm/2018/08/30/httpdns.html"
							}
							
							,
							
							
							{
							"title" : "PHP 资源大全 - ",
							"url" : "/MyBlog/algorithm/2018/08/30/.html"
							}
							
							,
							
							
							{
							"title" : "oneProxy - ",
							"url" : "/MyBlog/storage/2018/08/28/oneProxy.html"
							}
							
							,
							
							
							{
							"title" : "自适应hash - ",
							"url" : "/MyBlog/algorithm/2018/08/28/hash.html"
							}
							
							,
							
							
							{
							"title" : "cgroup - ",
							"url" : "/MyBlog/linux/2018/08/28/cgroup.html"
							}
							
							,
							
							
							{
							"title" : "Php-fpm运行原理 - ",
							"url" : "/MyBlog/web/2018/08/27/fpm.html"
							}
							
							,
							
							
							{
							"title" : "sds - ",
							"url" : "/MyBlog/algorithm/2018/08/23/sds.html"
							}
							
							,
							
							
							{
							"title" : "SkipList - ",
							"url" : "/MyBlog/algorithm/2018/08/23/SkipList.html"
							}
							
							,
							
							
							{
							"title" : "MurmurHash - ",
							"url" : "/MyBlog/algorithm/2018/08/23/MurmurHash.html"
							}
							
							,
							
							
							{
							"title" : "PHP的Realpath Cache - ",
							"url" : "/MyBlog/web/2018/08/22/realpath.html"
							}
							
							,
							
							
							{
							"title" : "SQL Hints (SQL 优化器) - ",
							"url" : "/MyBlog/storage/2018/08/22/php_mysql.html"
							}
							
							,
							
							
							{
							"title" : "percona-toolkit  Maatkit - ",
							"url" : "/MyBlog/storage/2018/08/22/percona-toolkit.html"
							}
							
							,
							
							
							{
							"title" : "oracle_hint - ",
							"url" : "/MyBlog/storage/2018/08/22/oracle_hint.html"
							}
							
							,
							
							
							{
							"title" : "读写分离导致主库从库数据不一致问题 - ",
							"url" : "/MyBlog/storage/2018/08/22/master_slave_diff.html"
							}
							
							,
							
							
							{
							"title" : "主从一致性架构优化4种方法 - ",
							"url" : "/MyBlog/storage/2018/08/22/constency.html"
							}
							
							,
							
							
							{
							"title" : "opcache缓存的操作小工具cachetool - ",
							"url" : "/MyBlog/algorithm/2018/08/22/cachetool.html"
							}
							
							,
							
							
							{
							"title" : "Linux系统调用--access - ",
							"url" : "/MyBlog/linux/2018/08/22/access.html"
							}
							
							,
							
							
							{
							"title" : "Mysqlnd 主从复制和负载均衡插件 mysqlnd_qc - ",
							"url" : "/MyBlog/storage/2018/08/22/Mysqlnd.html"
							}
							
							,
							
							
							{
							"title" : "Dapper - ",
							"url" : "/MyBlog/algorithm/2018/08/22/Dapper.html"
							}
							
							,
							
							
							{
							"title" : "mysql-proxy - ",
							"url" : "/MyBlog/storage/2018/08/20/mysql-proxy.html"
							}
							
							,
							
							
							{
							"title" : "influxdb - ",
							"url" : "/MyBlog/algorithm/2018/08/20/influxdb.html"
							}
							
							,
							
							
							{
							"title" : "hint - ",
							"url" : "/MyBlog/storage/2018/08/20/hint.html"
							}
							
							,
							
							
							{
							"title" : "ifconfig - ",
							"url" : "/MyBlog/linux/2018/08/14/ifconfig.html"
							}
							
							,
							
							
							{
							"title" : "launchctl - ",
							"url" : "/MyBlog/web/2018/08/13/launchctl.html"
							}
							
							,
							
							
							{
							"title" : "time_wait - ",
							"url" : "/MyBlog/linux/2018/08/11/time_wait.html"
							}
							
							,
							
							
							{
							"title" : "OpenStack - ",
							"url" : "/MyBlog/algorithm/2018/08/11/OpenStack.html"
							}
							
							,
							
							
							{
							"title" : "μJavaActors - ",
							"url" : "/MyBlog/algorithm/2018/08/10/%CE%BCJavaActors.html"
							}
							
							,
							
							
							{
							"title" : "ceph的CRUSH数据分布算法 - ",
							"url" : "/MyBlog/algorithm/2018/08/10/crush.html"
							}
							
							,
							
							
							{
							"title" : "Akka 和 μJavaActors - ",
							"url" : "/MyBlog/algorithm/2018/08/10/akka.html"
							}
							
							,
							
							
							{
							"title" : "gossip 应用 - ",
							"url" : "/MyBlog/algorithm/2018/07/30/gossip_application.html"
							}
							
							,
							
							
							{
							"title" : "Gossip协议 - ",
							"url" : "/MyBlog/algorithm/2018/07/30/gossip.html"
							}
							
							,
							
							
							{
							"title" : "分布式系统常用思想和技术总结 - ",
							"url" : "/MyBlog/algorithm/2018/07/30/consitency.html"
							}
							
							,
							
							
							{
							"title" : "Gossip_zap_raft_paxos 对比 - ",
							"url" : "/MyBlog/algorithm/2018/07/30/Gossip_zap_raft_paxos.html"
							}
							
							,
							
							
							{
							"title" : "dht 一致性hash算法 - ",
							"url" : "/MyBlog/algorithm/2018/07/28/dht.html"
							}
							
							,
							
							
							{
							"title" : "Kademlia 原理 - ",
							"url" : "/MyBlog/algorithm/2018/07/28/Kademlia.html"
							}
							
							,
							
							
							{
							"title" : "sampling 采样 - ",
							"url" : "/MyBlog/algorithm/2018/07/27/sampling.html"
							}
							
							,
							
							
							{
							"title" : "rocksdb - ",
							"url" : "/MyBlog/storage/2018/07/26/rocksdb.html"
							}
							
							,
							
							
							{
							"title" : "Tachyon - ",
							"url" : "/MyBlog/spark/2018/07/26/Tachyon.html"
							}
							
							,
							
							
							{
							"title" : "tcc  分布式事务 - ",
							"url" : "/MyBlog/web/2018/07/22/tcc.html"
							}
							
							,
							
							
							{
							"title" : "KNN与K-Means的区别 - ",
							"url" : "/MyBlog/algorithm/2018/07/16/knn.html"
							}
							
							,
							
							
							{
							"title" : "yarn - ",
							"url" : "/MyBlog/hadoop/2018/07/12/yarn.html"
							}
							
							,
							
							
							{
							"title" : "余弦夹角 和 欧氏距离 Jaccard相似系数和皮尔逊相关系数 - ",
							"url" : "/MyBlog/algorithm/2018/07/12/jacard.html"
							}
							
							,
							
							
							{
							"title" : "MapReduce - ",
							"url" : "/MyBlog/hadoop/2018/07/12/MapReduce.html"
							}
							
							,
							
							
							{
							"title" : "php_kafka - ",
							"url" : "/MyBlog/web/2018/07/11/php_kafka.html"
							}
							
							,
							
							
							{
							"title" : "KM算法 - ",
							"url" : "/MyBlog/algorithm/2018/07/10/km.html"
							}
							
							,
							
							
							{
							"title" : "Hall匹配定理 - ",
							"url" : "/MyBlog/algorithm/2018/07/10/hall.html"
							}
							
							,
							
							
							{
							"title" : "gossip 算法 redis - ",
							"url" : "/MyBlog/algorithm/2018/07/10/gossip.html"
							}
							
							,
							
							
							{
							"title" : "bipartite_graph_match - ",
							"url" : "/MyBlog/algorithm/2018/07/10/bipartite_graph_match.html"
							}
							
							,
							
							
							{
							"title" : "bipartite_graph 二分图 - ",
							"url" : "/MyBlog/algorithm/2018/07/10/bipartite_graph.html"
							}
							
							,
							
							
							{
							"title" : "agumenting_path - ",
							"url" : "/MyBlog/algorithm/2018/07/10/agumenting_path.html"
							}
							
							,
							
							
							{
							"title" : "KM（Kuhn and Munkres）算法 - ",
							"url" : "/MyBlog/algorithm/2018/07/10/Kuhn_and_Munkres.html"
							}
							
							,
							
							
							{
							"title" : "Hungarian_algorithm 匈牙利算法 - ",
							"url" : "/MyBlog/algorithm/2018/07/10/Hungarian_algorithm.html"
							}
							
							,
							
							
							{
							"title" : "Edmond-Karp 算法  网络流 增广路 - ",
							"url" : "/MyBlog/algorithm/2018/07/10/Edmond-Karp.html"
							}
							
							,
							
							
							{
							"title" : "git - ",
							"url" : "/MyBlog/web/2018/07/06/git.html"
							}
							
							,
							
							
							{
							"title" : "composer dump-atoload namespace dir - ",
							"url" : "/MyBlog/web/2018/07/06/composer.html"
							}
							
							,
							
							
							{
							"title" : "golang list jsonMarshal之后一个为null一个为[ ]问题 - ",
							"url" : "/MyBlog/golang/2018/07/04/golang_list.html"
							}
							
							,
							
							
							{
							"title" : "xterm.js tty.js 基于浏览器的终端模拟器 - ",
							"url" : "/MyBlog/web/2018/07/03/xterm.js_tty.js.html"
							}
							
							,
							
							
							{
							"title" : "mac安装gradle - ",
							"url" : "/MyBlog/java/2018/07/03/mac_gradle.html"
							}
							
							,
							
							
							{
							"title" : "gradle_eclipse - ",
							"url" : "/MyBlog/java/2018/07/03/gradle_eclipse.html"
							}
							
							,
							
							
							{
							"title" : "build.gradle - ",
							"url" : "/MyBlog/java/2018/07/03/gradle_build.html"
							}
							
							,
							
							
							{
							"title" : "Gradle - ",
							"url" : "/MyBlog/java/2018/07/03/Gradle.html"
							}
							
							,
							
							
							{
							"title" : "mysql、zookeeper、redis和elasticsearch主从同步机制 - ",
							"url" : "/MyBlog/storage/2018/06/30/slave.html"
							}
							
							,
							
							
							{
							"title" : "redis slow log - ",
							"url" : "/MyBlog/storage/2018/06/30/redis_slow_log.html"
							}
							
							,
							
							
							{
							"title" : "redis主从复制 - ",
							"url" : "/MyBlog/storage/2018/06/30/redis_slave.html"
							}
							
							,
							
							
							{
							"title" : "redis主从复制原理、断点续传、无磁盘化复制、过期key处理 - ",
							"url" : "/MyBlog/storage/2018/06/30/redis_replication.html"
							}
							
							,
							
							
							{
							"title" : "redis_mysql - ",
							"url" : "/MyBlog/storage/2018/06/30/redis_mysql.html"
							}
							
							,
							
							
							{
							"title" : "redis_memcache - ",
							"url" : "/MyBlog/storage/2018/06/30/redis_memcache.html"
							}
							
							,
							
							
							{
							"title" : "Redis原理及使用 - ",
							"url" : "/MyBlog/storage/2018/06/30/redis.html"
							}
							
							,
							
							
							{
							"title" : "nginx_redis 高并发 - ",
							"url" : "/MyBlog/linux/2018/06/30/nginx_redis.html"
							}
							
							,
							
							
							{
							"title" : "mysql slow log - ",
							"url" : "/MyBlog/storage/2018/06/30/mysql_slow_log.html"
							}
							
							,
							
							
							{
							"title" : "multiplexing IO多路复用 - ",
							"url" : "/MyBlog/linux/2018/06/30/multiplexing.html"
							}
							
							,
							
							
							{
							"title" : "select,poll,epoll，kqueue模型 - ",
							"url" : "/MyBlog/linux/2018/06/30/kqueue.html"
							}
							
							,
							
							
							{
							"title" : "grok - ",
							"url" : "/MyBlog/elasticsearch/2018/06/30/grok.html"
							}
							
							,
							
							
							{
							"title" : "epoll_server 服务端代码 - ",
							"url" : "/MyBlog/linux/2018/06/30/epoll_server.html"
							}
							
							,
							
							
							{
							"title" : "epoll - ",
							"url" : "/MyBlog/linux/2018/06/30/epoll.html"
							}
							
							,
							
							
							{
							"title" : "Sentinel - ",
							"url" : "/MyBlog/storage/2018/06/30/Sentinel.html"
							}
							
							,
							
							
							{
							"title" : "Pipeline - ",
							"url" : "/MyBlog/storage/2018/06/30/Pipeline.html"
							}
							
							,
							
							
							{
							"title" : "Logagent 日志组件对比 - ",
							"url" : "/MyBlog/elasticsearch/2018/06/30/Logagent.html"
							}
							
							,
							
							
							{
							"title" : "test - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/test.html"
							}
							
							,
							
							
							{
							"title" : "map 映射 - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/map.html"
							}
							
							,
							
							
							{
							"title" : "logstash输出到elasticsearch - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/logstash_elasticsearch.html"
							}
							
							,
							
							
							{
							"title" : "kibana - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/kibana.html"
							}
							
							,
							
							
							{
							"title" : "index - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/index.html"
							}
							
							,
							
							
							{
							"title" : "ik - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/ik.html"
							}
							
							,
							
							
							{
							"title" : "head - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/head.html"
							}
							
							,
							
							
							{
							"title" : "elasticsearch - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/elasticsearch.html"
							}
							
							,
							
							
							{
							"title" : "dsl - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/dsl.html"
							}
							
							,
							
							
							{
							"title" : "config - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/config.html"
							}
							
							,
							
							
							{
							"title" : "aggregations - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/aggregations.html"
							}
							
							,
							
							
							{
							"title" : "_search - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/_search.html"
							}
							
							,
							
							
							{
							"title" : "Logstash_example - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/Logstash_example.html"
							}
							
							,
							
							
							{
							"title" : "Logstash_elk - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/Logstash_elk.html"
							}
							
							,
							
							
							{
							"title" : "Logstash - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/Logstash.html"
							}
							
							,
							
							
							{
							"title" : "elk mac 安装 - ",
							"url" : "/MyBlog/elasticsearch/2018/06/28/elk.html"
							}
							
							,
							
							
							{
							"title" : "sysfs - ",
							"url" : "/MyBlog/linux/2018/06/27/sysfs.html"
							}
							
							,
							
							
							{
							"title" : "proc文件系统 - ",
							"url" : "/MyBlog/linux/2018/06/27/proc.html"
							}
							
							,
							
							
							{
							"title" : "lkm 可加载内核模块 - ",
							"url" : "/MyBlog/linux/2018/06/27/lkm.html"
							}
							
							,
							
							
							{
							"title" : "kobject - ",
							"url" : "/MyBlog/linux/2018/06/27/kobject.html"
							}
							
							,
							
							
							{
							"title" : "Linux各目录及每个目录的详细介绍 - ",
							"url" : "/MyBlog/linux/2018/06/27/dir.html"
							}
							
							,
							
							
							{
							"title" : "devfs sysfs - ",
							"url" : "/MyBlog/linux/2018/06/27/devfs.html"
							}
							
							,
							
							
							{
							"title" : "pool - ",
							"url" : "/MyBlog/golang/2018/06/26/pool.html"
							}
							
							,
							
							
							{
							"title" : "Linux中pam模块 - ",
							"url" : "/MyBlog/linux/2018/06/26/pam.html"
							}
							
							,
							
							
							{
							"title" : "issue 设置linux登录前后的欢迎信息 - ",
							"url" : "/MyBlog/linux/2018/06/26/issue.html"
							}
							
							,
							
							
							{
							"title" : "bash_profile等几个文件的执行过程 - ",
							"url" : "/MyBlog/linux/2018/06/26/bash_profile.html"
							}
							
							,
							
							
							{
							"title" : "gorpc - ",
							"url" : "/MyBlog/web/2018/06/24/gorpc.html"
							}
							
							,
							
							
							{
							"title" : "HAProxy - ",
							"url" : "/MyBlog/web/2018/06/24/HAProxy.html"
							}
							
							,
							
							
							{
							"title" : "Nutch - ",
							"url" : "/MyBlog/web/2018/06/23/Nutch.html"
							}
							
							,
							
							
							{
							"title" : "lsm - ",
							"url" : "/MyBlog/web/2018/06/16/lsm.html"
							}
							
							,
							
							
							{
							"title" : "logstash  日志收集 - ",
							"url" : "/MyBlog/elasticsearch/2018/06/16/logstash.html"
							}
							
							,
							
							
							{
							"title" : "ldap 轻量目录访问协议 - ",
							"url" : "/MyBlog/web/2018/06/16/ldap.html"
							}
							
							,
							
							
							{
							"title" : "查看某行代码的git修改历史 - ",
							"url" : "/MyBlog/web/2018/06/16/gitEditHistory.html"
							}
							
							,
							
							
							{
							"title" : "python中os.system、os.popen、subprocess.popen的区别 - ",
							"url" : "/MyBlog/linux/2018/06/12/subprocess.html"
							}
							
							,
							
							
							{
							"title" : "sshpass - ",
							"url" : "/MyBlog/linux/2018/06/12/sshpass.html"
							}
							
							,
							
							
							{
							"title" : "samba - ",
							"url" : "/MyBlog/linux/2018/06/12/samb.html"
							}
							
							,
							
							
							{
							"title" : "pyopen Python subprocess - ",
							"url" : "/MyBlog/linux/2018/06/12/pyopen.html"
							}
							
							,
							
							
							{
							"title" : "dns - ",
							"url" : "/MyBlog/linux/2018/06/12/dns.html"
							}
							
							,
							
							
							{
							"title" : "bind - ",
							"url" : "/MyBlog/linux/2018/06/12/bind.html"
							}
							
							,
							
							
							{
							"title" : "supervisor - ",
							"url" : "/MyBlog/linux/2018/06/10/supervisor.html"
							}
							
							,
							
							
							{
							"title" : "Paxos、Raft、Zab和VR - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/raft.html"
							}
							
							,
							
							
							{
							"title" : "quorum - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/quorum.html"
							}
							
							,
							
							
							{
							"title" : "Paxos和Quorum - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/paxos_quorum.html"
							}
							
							,
							
							
							{
							"title" : "lucence  elasticsearch - ",
							"url" : "/MyBlog/elasticsearch/2018/06/10/lucence.html"
							}
							
							,
							
							
							{
							"title" : "jndi - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/jndi.html"
							}
							
							,
							
							
							{
							"title" : "guava - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/gava.html"
							}
							
							,
							
							
							{
							"title" : "fluent 编程风格 - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/fluent.html"
							}
							
							,
							
							
							{
							"title" : "Curator - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/Curator.html"
							}
							
							,
							
							
							{
							"title" : "ZooKeeper实现配置同步 - ",
							"url" : "/MyBlog/spark/2018/06/03/zk_conf.html"
							}
							
							,
							
							
							{
							"title" : "nginx_header - ",
							"url" : "/MyBlog/web/2018/06/03/nginx_header.html"
							}
							
							,
							
							
							{
							"title" : "dtrace - ",
							"url" : "/MyBlog/linux/2018/06/03/dtrace.html"
							}
							
							,
							
							
							{
							"title" : "zebra - ",
							"url" : "/MyBlog/linux/2018/05/30/zebra.html"
							}
							
							,
							
							
							{
							"title" : "rawip - ",
							"url" : "/MyBlog/linux/2018/05/30/rawip.html"
							}
							
							,
							
							
							{
							"title" : "ospf - ",
							"url" : "/MyBlog/linux/2018/05/30/ospf.html"
							}
							
							,
							
							
							{
							"title" : "邻居子系统 - ",
							"url" : "/MyBlog/linux/2018/05/30/nabour.html"
							}
							
							,
							
							
							{
							"title" : "General Purpose Input Output - ",
							"url" : "/MyBlog/linux/2018/05/30/gpio.html"
							}
							
							,
							
							
							{
							"title" : "流量控制 - ",
							"url" : "/MyBlog/linux/2018/05/30/Traffic_ctl.html"
							}
							
							,
							
							
							{
							"title" : "透明网桥 - ",
							"url" : "/MyBlog/linux/2018/05/28/transparent.html"
							}
							
							,
							
							
							{
							"title" : "tcpdump - ",
							"url" : "/MyBlog/linux/2018/05/28/tcpdump.html"
							}
							
							,
							
							
							{
							"title" : "stp 生成树协议 - ",
							"url" : "/MyBlog/linux/2018/05/28/stp.html"
							}
							
							,
							
							
							{
							"title" : "NAPI 技术在 Linux 网络驱动上的应用 - ",
							"url" : "/MyBlog/linux/2018/05/28/napi.html"
							}
							
							,
							
							
							{
							"title" : "ethereal - ",
							"url" : "/MyBlog/linux/2018/05/28/ethereal.html"
							}
							
							,
							
							
							{
							"title" : "inotify 监控 Linux 文件系统事件 - ",
							"url" : "/MyBlog/linux/2018/05/24/inotify.html"
							}
							
							,
							
							
							{
							"title" : "golang fsnotify - ",
							"url" : "/MyBlog/golang/2018/05/24/fsnotify_go.html"
							}
							
							,
							
							
							{
							"title" : "fsnotify - ",
							"url" : "/MyBlog/linux/2018/05/24/fsnotify.html"
							}
							
							,
							
							
							{
							"title" : "PostForm - ",
							"url" : "/MyBlog/golang/2018/05/18/PostForm.html"
							}
							
							,
							
							
							{
							"title" : "template - ",
							"url" : "/MyBlog/golang/2018/05/17/template.html"
							}
							
							,
							
							
							{
							"title" : "mergely_CodeMirror_DiffMatchPatch前端文本diff - ",
							"url" : "/MyBlog/web/2018/05/12/mergeLy.html"
							}
							
							,
							
							
							{
							"title" : "pipework  为docker容器配置独立IP - ",
							"url" : "/MyBlog/docker/2018/05/09/pipework.html"
							}
							
							,
							
							
							{
							"title" : "调用namespace的API - ",
							"url" : "/MyBlog/docker/2018/05/09/namespace.html"
							}
							
							,
							
							
							{
							"title" : "ifconfig - ",
							"url" : "/MyBlog/net/2018/05/08/ifconfig.html"
							}
							
							,
							
							
							{
							"title" : "subnet_mask  子网掩码 - ",
							"url" : "/MyBlog/net/2018/05/06/subnet_mask.html"
							}
							
							,
							
							
							{
							"title" : "iptables - ",
							"url" : "/MyBlog/linux/2018/05/06/iptables.html"
							}
							
							,
							
							
							{
							"title" : "gateway - ",
							"url" : "/MyBlog/net/2018/05/06/gateway.html"
							}
							
							,
							
							
							{
							"title" : "docker_bridge 容器桥接到物理网络 - ",
							"url" : "/MyBlog/docker/2018/05/06/docker_bridge.html"
							}
							
							,
							
							
							{
							"title" : "default_gateway 默认网关 - ",
							"url" : "/MyBlog/net/2018/05/06/default_gateway.html"
							}
							
							,
							
							
							{
							"title" : "bridge 网桥 Linux下的虚拟网桥 - ",
							"url" : "/MyBlog/net/2018/05/06/bridge.html"
							}
							
							,
							
							
							{
							"title" : "wins - ",
							"url" : "/MyBlog/net/2018/05/05/wins.html"
							}
							
							,
							
							
							{
							"title" : "routing_table 路由表 - ",
							"url" : "/MyBlog/net/2018/05/05/routing_table.html"
							}
							
							,
							
							
							{
							"title" : "routing_protocol 路由协议 - ",
							"url" : "/MyBlog/net/2018/05/05/routing_protocol.html"
							}
							
							,
							
							
							{
							"title" : "router 路由协议 - ",
							"url" : "/MyBlog/net/2018/05/05/router.html"
							}
							
							,
							
							
							{
							"title" : "rip 路由信息协议 - ",
							"url" : "/MyBlog/net/2018/05/05/rip.html"
							}
							
							,
							
							
							{
							"title" : "netbios - ",
							"url" : "/MyBlog/net/2018/05/05/netbios.html"
							}
							
							,
							
							
							{
							"title" : "lmhosts - ",
							"url" : "/MyBlog/net/2018/05/05/lmhosts.html"
							}
							
							,
							
							
							{
							"title" : "dhcp - ",
							"url" : "/MyBlog/net/2018/05/05/dhcp.html"
							}
							
							,
							
							
							{
							"title" : "arc phabricator 结合 arcanist 使用 - ",
							"url" : "/MyBlog/web/2018/05/04/arc.html"
							}
							
							,
							
							
							{
							"title" : "aufs Union File System - ",
							"url" : "/MyBlog/docker/2018/05/03/aufs.html"
							}
							
							,
							
							
							{
							"title" : "veth - ",
							"url" : "/MyBlog/linux/2018/04/29/veth.html"
							}
							
							,
							
							
							{
							"title" : "linux namespace - ",
							"url" : "/MyBlog/linux/2018/04/29/namespace.html"
							}
							
							,
							
							
							{
							"title" : "docker_net - ",
							"url" : "/MyBlog/docker/2018/04/29/docker_net.html"
							}
							
							,
							
							
							{
							"title" : "Docker容器通过独立IP暴露给局域网的方法 - ",
							"url" : "/MyBlog/docker/2018/04/29/docker_ip.html"
							}
							
							,
							
							
							{
							"title" : "linux cgroup - ",
							"url" : "/MyBlog/linux/2018/04/29/cgroup.html"
							}
							
							,
							
							
							{
							"title" : "bridge - ",
							"url" : "/MyBlog/linux/2018/04/29/bridge.html"
							}
							
							,
							
							
							{
							"title" : "flag - ",
							"url" : "/MyBlog/golang/2018/04/24/flag.html"
							}
							
							,
							
							
							{
							"title" : "expect - ",
							"url" : "/MyBlog/linux/2018/04/22/expect.html"
							}
							
							,
							
							
							{
							"title" : "站群 - ",
							"url" : "/MyBlog/web/2018/04/21/zq.html"
							}
							
							,
							
							
							{
							"title" : "urlencode - ",
							"url" : "/MyBlog/cryptology/2018/04/20/urlencode.html"
							}
							
							,
							
							
							{
							"title" : "shell 运行原理 & unix 缺陷 - ",
							"url" : "/MyBlog/jekyll/2018/04/20/shell.html"
							}
							
							,
							
							
							{
							"title" : "Linux下的shell工作原理 - ",
							"url" : "/MyBlog/linux/2018/04/20/linux_shell.html"
							}
							
							,
							
							
							{
							"title" : "base64 - ",
							"url" : "/MyBlog/cryptology/2018/04/20/base64.html"
							}
							
							,
							
							
							{
							"title" : "aes 的工作模式（ECB、CBC、CFB、OFB） - ",
							"url" : "/MyBlog/cryptology/2018/04/19/aes.html"
							}
							
							,
							
							
							{
							"title" : "json - ",
							"url" : "/MyBlog/golang/2018/04/16/json.html"
							}
							
							,
							
							
							{
							"title" : "dup dup2 - ",
							"url" : "/MyBlog/linux/2018/04/16/dup.html"
							}
							
							,
							
							
							{
							"title" : "Reactor and Proactor - ",
							"url" : "/MyBlog/web/2018/04/15/proactor.html"
							}
							
							,
							
							
							{
							"title" : "fsnotify bee 热编译 - ",
							"url" : "/MyBlog/golang/2018/04/15/fsnotify.html"
							}
							
							,
							
							
							{
							"title" : "Git内部原理 blob tree commit - ",
							"url" : "/MyBlog/computer/2018/04/12/git.html"
							}
							
							,
							
							
							{
							"title" : "rsync - ",
							"url" : "/MyBlog/linux/2018/03/27/rsync.html"
							}
							
							,
							
							
							{
							"title" : "intellij 配置 - ",
							"url" : "/MyBlog/golang/2018/03/27/intellij.html"
							}
							
							,
							
							
							{
							"title" : "context - ",
							"url" : "/MyBlog/golang/2018/03/27/context.html"
							}
							
							,
							
							
							{
							"title" : "golang热编译工具 - ",
							"url" : "/MyBlog/golang/2018/03/23/online_build.html"
							}
							
							,
							
							
							{
							"title" : "glide 包依赖管理 - ",
							"url" : "/MyBlog/golang/2018/03/23/glide.html"
							}
							
							,
							
							
							{
							"title" : "utxo 比特币查询原理 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/utxo.html"
							}
							
							,
							
							
							{
							"title" : "数字时间戳 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/timestamp.html"
							}
							
							,
							
							
							{
							"title" : "stratum协议原理 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/stratum.html"
							}
							
							,
							
							
							{
							"title" : "区块链共识机制 Pow、Pos、DPos、Pool - ",
							"url" : "/MyBlog/cryptology/2018/03/18/pow.html"
							}
							
							,
							
							
							{
							"title" : "PBFT（实用拜占庭容错）、PAXOS、RAFT - ",
							"url" : "/MyBlog/cryptology/2018/03/18/pbft.html"
							}
							
							,
							
							
							{
							"title" : "hamming 码校验 汉明距离 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/hamming_code.html"
							}
							
							,
							
							
							{
							"title" : "block chain 区块链 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/block_chain.html"
							}
							
							,
							
							
							{
							"title" : "unsafe cgo - ",
							"url" : "/MyBlog/golang/2018/03/17/unsafe.html"
							}
							
							,
							
							
							{
							"title" : "数字签名及应用 - ",
							"url" : "/MyBlog/cryptology/2018/03/17/signature.html"
							}
							
							,
							
							
							{
							"title" : "reflect - ",
							"url" : "/MyBlog/golang/2018/03/17/reflect.html"
							}
							
							,
							
							
							{
							"title" : "go package - ",
							"url" : "/MyBlog/golang/2018/03/17/package.html"
							}
							
							,
							
							
							{
							"title" : "goroutine - ",
							"url" : "/MyBlog/golang/2018/03/17/goroutine.html"
							}
							
							,
							
							
							{
							"title" : "go test - ",
							"url" : "/MyBlog/golang/2018/03/17/go_test.html"
							}
							
							,
							
							
							{
							"title" : "进程和线程、协程的区别 - ",
							"url" : "/MyBlog/golang/2018/03/17/coroutine.html"
							}
							
							,
							
							
							{
							"title" : "golang 返回函数的匿名函数 vs 接收器的方法 - ",
							"url" : "/MyBlog/golang/2018/03/16/go_func.html"
							}
							
							,
							
							
							{
							"title" : "go-tour 安装 - ",
							"url" : "/MyBlog/golang/2018/03/16/go-tour.html"
							}
							
							,
							
							
							{
							"title" : "git默认不区分文件夹大小写 - ",
							"url" : "/MyBlog/computer/2018/03/16/git.html"
							}
							
							,
							
							
							{
							"title" : "栈与活动记录 - ",
							"url" : "/MyBlog/lang/2018/03/15/active_record.html"
							}
							
							,
							
							
							{
							"title" : "Lambda演算的类型 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_type.html"
							}
							
							,
							
							
							{
							"title" : "lambda 演算中的数字 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_num.html"
							}
							
							,
							
							
							{
							"title" : "Lambda演算建模 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_model.html"
							}
							
							,
							
							
							{
							"title" : "lambda 演算中的布尔值和选择 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_bool.html"
							}
							
							,
							
							
							{
							"title" : "lambda Y组合子(y-combinator) - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_Y.html"
							}
							
							,
							
							
							{
							"title" : "lambda_Evaluation - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_Evaluation.html"
							}
							
							,
							
							
							{
							"title" : "从Lambda演算到组合子演算 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_Combinator.html"
							}
							
							,
							
							
							{
							"title" : "Lambda 演算 - ",
							"url" : "/MyBlog/lang/2018/03/14/Lambda.html"
							}
							
							,
							
							
							{
							"title" : "系统调用 - ",
							"url" : "/MyBlog/linux/2018/03/13/system_call.html"
							}
							
							,
							
							
							{
							"title" : "mysql 分页 - ",
							"url" : "/MyBlog/web/2018/03/13/page.html"
							}
							
							,
							
							
							{
							"title" : "尾递归优化 - ",
							"url" : "/MyBlog/lang/2018/03/12/tco.html"
							}
							
							,
							
							
							{
							"title" : "三地址代码 - ",
							"url" : "/MyBlog/lang/2018/03/09/three-address-code.html"
							}
							
							,
							
							
							{
							"title" : "栈机 - ",
							"url" : "/MyBlog/lang/2018/03/09/Stack_machine.html"
							}
							
							,
							
							
							{
							"title" : "下推自动机 - ",
							"url" : "/MyBlog/lang/2018/03/08/pda.html"
							}
							
							,
							
							
							{
							"title" : "LR分析法 - ",
							"url" : "/MyBlog/lang/2018/03/08/lr.html"
							}
							
							,
							
							
							{
							"title" : "LL(1)文法判别之First集合、Follow集合、Select集合求法 - ",
							"url" : "/MyBlog/lang/2018/03/07/first_follow_select.html"
							}
							
							,
							
							
							{
							"title" : "thrift - ",
							"url" : "/MyBlog/lang/2018/03/02/thrift.html"
							}
							
							,
							
							
							{
							"title" : "thrift 低版本安装 - ",
							"url" : "/MyBlog/web/2018/03/01/thrift_low.html"
							}
							
							,
							
							
							{
							"title" : "jekyll paginate 分页失败原因 - ",
							"url" : "/MyBlog/jekyll/2018/03/01/paginate.html"
							}
							
							,
							
							
							{
							"title" : "git add 删除文件问题 - ",
							"url" : "/MyBlog/web/2018/03/01/git.html"
							}
							
							,
							
							
							{
							"title" : "symbol_table - ",
							"url" : "/MyBlog/lang/2018/02/28/symbol_table.html"
							}
							
							,
							
							
							{
							"title" : "re2c - ",
							"url" : "/MyBlog/lang/2018/02/28/re2c.html"
							}
							
							,
							
							
							{
							"title" : "Jekyll目录结构和运行机理 - ",
							"url" : "/MyBlog/jekyll/2018/02/28/jekyll_inside.html"
							}
							
							,
							
							
							{
							"title" : "CollectingCycles - ",
							"url" : "/MyBlog/lang/2018/02/28/CollectingCycles.html"
							}
							
							,
							
							
							{
							"title" : "type_hinting - ",
							"url" : "/MyBlog/web/2018/02/26/type_hinting.html"
							}
							
							,
							
							
							{
							"title" : "tsrm - ",
							"url" : "/MyBlog/web/2018/02/26/tsrm.html"
							}
							
							,
							
							
							{
							"title" : "create_function - ",
							"url" : "/MyBlog/web/2018/02/26/create_function.html"
							}
							
							,
							
							
							{
							"title" : "Xdebug - ",
							"url" : "/MyBlog/web/2018/02/26/Xdebug.html"
							}
							
							,
							
							
							{
							"title" : "Closure - ",
							"url" : "/MyBlog/lang/2018/02/26/Closure.html"
							}
							
							,
							
							
							{
							"title" : "lex - ",
							"url" : "/MyBlog/lang/2018/02/13/lex.html"
							}
							
							,
							
							
							{
							"title" : "vld_dot_graphviz - ",
							"url" : "/MyBlog/web/2018/02/12/vld_dot_graphviz.html"
							}
							
							,
							
							
							{
							"title" : "phpvld - ",
							"url" : "/MyBlog/jekyll/2018/02/12/phpvld.html"
							}
							
							,
							
							
							{
							"title" : "phpize - ",
							"url" : "/MyBlog/web/2018/02/12/phpize.html"
							}
							
							,
							
							
							{
							"title" : "PHP 调试利器之 PHPDBG - ",
							"url" : "/MyBlog/web/2018/02/12/phpdbg.html"
							}
							
							,
							
							
							{
							"title" : "dot - ",
							"url" : "/MyBlog/web/2018/02/12/dot.html"
							}
							
							,
							
							
							{
							"title" : "netty - ",
							"url" : "/MyBlog/web/2018/02/10/netty.html"
							}
							
							,
							
							
							{
							"title" : "Tachyon - ",
							"url" : "/MyBlog/spark/2018/02/10/Tachyon.html"
							}
							
							,
							
							
							{
							"title" : "crlf 攻击 - ",
							"url" : "/MyBlog/web/2018/02/06/crlf.html"
							}
							
							,
							
							
							{
							"title" : "iputils - ",
							"url" : "/MyBlog/linux/2018/02/05/iputils.html"
							}
							
							,
							
							
							{
							"title" : "cscope - ",
							"url" : "/MyBlog/web/2018/02/05/cscope.html"
							}
							
							,
							
							
							{
							"title" : "sklearn - ",
							"url" : "/MyBlog/spark/2018/02/03/sklearn.html"
							}
							
							,
							
							
							{
							"title" : "mathlatex - ",
							"url" : "/MyBlog/web/2018/02/02/mathlatex.html"
							}
							
							,
							
							
							{
							"title" : "二项逻辑斯蒂回归模型 - ",
							"url" : "/MyBlog/spark/2018/02/02/logistic.html"
							}
							
							,
							
							
							{
							"title" : "Duck typing - ",
							"url" : "/MyBlog/web/2018/02/02/Duck_typing.html"
							}
							
							,
							
							
							{
							"title" : "导入第三方依赖到shell - ",
							"url" : "/MyBlog/spark/2018/01/27/spark_jar.html"
							}
							
							,
							
							
							{
							"title" : "zero copy - ",
							"url" : "/MyBlog/linux/2018/01/26/zero_copy.html"
							}
							
							,
							
							
							{
							"title" : "进程在后台运行原理 - ",
							"url" : "/MyBlog/linux/2018/01/24/nohup.html"
							}
							
							,
							
							
							{
							"title" : "mongodb - ",
							"url" : "/MyBlog/web/2018/01/24/mongodb.html"
							}
							
							,
							
							
							{
							"title" : "倒排索引 - ",
							"url" : "/MyBlog/web/2018/01/24/inverted_file.html"
							}
							
							,
							
							
							{
							"title" : "npm registry - ",
							"url" : "/MyBlog/web/2018/01/16/npm.html"
							}
							
							,
							
							
							{
							"title" : "制作地图 - ",
							"url" : "/MyBlog/web/2018/01/16/map.html"
							}
							
							,
							
							
							{
							"title" : "Linux、Mac上面ln命令使用说明 - ",
							"url" : "/MyBlog/linux/2018/01/16/ln.html"
							}
							
							,
							
							
							{
							"title" : "spark on hive - ",
							"url" : "/MyBlog/spark/2018/01/13/spark_hive.html"
							}
							
							,
							
							
							{
							"title" : "scala maven 版本冲突问题解决 - ",
							"url" : "/MyBlog/spark/2018/01/12/scala_version.html"
							}
							
							,
							
							
							{
							"title" : "Eclipse中操作Hive、HDFS、spark时的jar包列表 - ",
							"url" : "/MyBlog/spark/2018/01/12/hive.html"
							}
							
							,
							
							
							{
							"title" : "Eclipse+maven+scala+spark环境搭建 - ",
							"url" : "/MyBlog/spark/2018/01/11/maven_scala_eclipse.html"
							}
							
							,
							
							
							{
							"title" : "maven - ",
							"url" : "/MyBlog/spark/2018/01/11/maven.html"
							}
							
							,
							
							
							{
							"title" : "随机森林 - ",
							"url" : "/MyBlog/spark/2018/01/09/random_foreast.html"
							}
							
							,
							
							
							{
							"title" : "svm - ",
							"url" : "/MyBlog/spark/2018/01/08/svm.html"
							}
							
							,
							
							
							{
							"title" : "virtualenv - ",
							"url" : "/MyBlog/web/2018/01/07/virtualenv.html"
							}
							
							,
							
							
							{
							"title" : "pip - ",
							"url" : "/MyBlog/web/2018/01/07/pip.html"
							}
							
							,
							
							
							{
							"title" : "信息熵 - ",
							"url" : "/MyBlog/spark/2018/01/05/shang.html"
							}
							
							,
							
							
							{
							"title" : "Zookeeper与Paxos - ",
							"url" : "/MyBlog/spark/2018/01/04/zookeeper.html"
							}
							
							,
							
							
							{
							"title" : "安全散列算法SHA256 - ",
							"url" : "/MyBlog/cryptology/2018/01/04/sha.html"
							}
							
							,
							
							
							{
							"title" : "raft - ",
							"url" : "/MyBlog/jekyll/2018/01/04/raft.html"
							}
							
							,
							
							
							{
							"title" : "比较raft ，basic paxos以及multi-paxos - ",
							"url" : "/MyBlog/spark/2018/01/04/paxos_raft.html"
							}
							
							,
							
							
							{
							"title" : "p2p - ",
							"url" : "/MyBlog/web/2018/01/04/p2p.html"
							}
							
							,
							
							
							{
							"title" : "nat - ",
							"url" : "/MyBlog/web/2018/01/04/nat.html"
							}
							
							,
							
							
							{
							"title" : "Chubby与Paxos - ",
							"url" : "/MyBlog/spark/2018/01/04/chubby.html"
							}
							
							,
							
							
							{
							"title" : "Paxos - ",
							"url" : "/MyBlog/spark/2018/01/04/Paxos.html"
							}
							
							,
							
							
							{
							"title" : "rsa 非对称加密原理 - ",
							"url" : "/MyBlog/cryptology/2018/01/03/rsa.html"
							}
							
							,
							
							
							{
							"title" : "Merkle Patricia Tree - ",
							"url" : "/MyBlog/cryptology/2018/01/03/merkle_tree.html"
							}
							
							,
							
							
							{
							"title" : "ecc 椭圆曲线加密 - ",
							"url" : "/MyBlog/cryptology/2018/01/03/ecc.html"
							}
							
							,
							
							
							{
							"title" : "单播、多播和广播 - ",
							"url" : "/MyBlog/linux/2017/12/30/broad_cast.html"
							}
							
							,
							
							
							{
							"title" : "arp - ",
							"url" : "/MyBlog/linux/2017/12/30/arp.html"
							}
							
							,
							
							
							{
							"title" : "json_shell - ",
							"url" : "/MyBlog/web/2017/12/27/json_shell.html"
							}
							
							,
							
							
							{
							"title" : "ioctl - ",
							"url" : "/MyBlog/linux/2017/12/27/ioctl.html"
							}
							
							,
							
							
							{
							"title" : "inetd - ",
							"url" : "/MyBlog/linux/2017/12/27/inetd.html"
							}
							
							,
							
							
							{
							"title" : "Django_nginx_uwsgi - ",
							"url" : "/MyBlog/web/2017/12/27/Django_nginx_uwsgi.html"
							}
							
							,
							
							
							{
							"title" : "UNIX下的5种IO模型 - ",
							"url" : "/MyBlog/linux/2017/12/24/unix_io5.html"
							}
							
							,
							
							
							{
							"title" : "用户空间实现线程 内核实现线程 线程的调度 - ",
							"url" : "/MyBlog/linux/2017/12/24/thread_namespace.html"
							}
							
							,
							
							
							{
							"title" : "进程切换 - ",
							"url" : "/MyBlog/linux/2017/12/24/thread.html"
							}
							
							,
							
							
							{
							"title" : "IO多路复用之select、poll、epoll - ",
							"url" : "/MyBlog/linux/2017/12/24/select_poll.html"
							}
							
							,
							
							
							{
							"title" : "goroutine - ",
							"url" : "/MyBlog/linux/2017/12/24/goroutine.html"
							}
							
							,
							
							
							{
							"title" : "goclipse eclipse go 开发环境搭建＋跳转支持 - ",
							"url" : "/MyBlog/web/2017/12/24/goclipse.html"
							}
							
							,
							
							
							{
							"title" : "tcp_flag - ",
							"url" : "/MyBlog/web/2017/12/22/tcp_flag.html"
							}
							
							,
							
							
							{
							"title" : "url短链 - ",
							"url" : "/MyBlog/web/2017/12/22/short_url.html"
							}
							
							,
							
							
							{
							"title" : "ID为0和ID为1的进程 - ",
							"url" : "/MyBlog/linux/2017/12/22/pid_0_1.html"
							}
							
							,
							
							
							{
							"title" : "Shell脚本经典之Fork炸弹 - ",
							"url" : "/MyBlog/linux/2017/12/22/fork_b.html"
							}
							
							,
							
							
							{
							"title" : "fork - ",
							"url" : "/MyBlog/linux/2017/12/22/fork.html"
							}
							
							,
							
							
							{
							"title" : "Linux进程控制——exec函数族 - ",
							"url" : "/MyBlog/linux/2017/12/22/exec.html"
							}
							
							,
							
							
							{
							"title" : "各种树的应用场景 - ",
							"url" : "/MyBlog/web/2017/12/13/tree.html"
							}
							
							,
							
							
							{
							"title" : "sbt - ",
							"url" : "/MyBlog/spark/2017/12/13/sbt.html"
							}
							
							,
							
							
							{
							"title" : "radix tree - ",
							"url" : "/MyBlog/linux/2017/12/13/radix_tree.html"
							}
							
							,
							
							
							{
							"title" : "maven 安装 - ",
							"url" : "/MyBlog/spark/2017/12/13/maven.html"
							}
							
							,
							
							
							{
							"title" : "figaro mac 安装 - ",
							"url" : "/MyBlog/spark/2017/12/13/figaro.html"
							}
							
							,
							
							
							{
							"title" : "大端小端 - ",
							"url" : "/MyBlog/web/2017/12/13/bigEnd.html"
							}
							
							,
							
							
							{
							"title" : "truss、strace或ltrace - ",
							"url" : "/MyBlog/linux/2017/12/10/strace.html"
							}
							
							,
							
							
							{
							"title" : "netlink - ",
							"url" : "/MyBlog/linux/2017/12/10/netlink.html"
							}
							
							,
							
							
							{
							"title" : "linux sysfs - ",
							"url" : "/MyBlog/linux/2017/12/09/sysfs.html"
							}
							
							,
							
							
							{
							"title" : "proc文件系统 - ",
							"url" : "/MyBlog/linux/2017/12/09/proc.html"
							}
							
							,
							
							
							{
							"title" : "netfliter - ",
							"url" : "/MyBlog/jekyll/2017/12/09/netfliter.html"
							}
							
							,
							
							
							{
							"title" : "namespace - ",
							"url" : "/MyBlog/linux/2017/12/08/namespace.html"
							}
							
							,
							
							
							{
							"title" : "vfs - ",
							"url" : "/MyBlog/linux/2017/12/07/vfs.html"
							}
							
							,
							
							
							{
							"title" : "mysql_index - ",
							"url" : "/MyBlog/web/2017/12/07/mysql_index.html"
							}
							
							,
							
							
							{
							"title" : "linux_rcu - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_rcu.html"
							}
							
							,
							
							
							{
							"title" : "Linux的mmap内存映射机制 - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_mmap.html"
							}
							
							,
							
							
							{
							"title" : "linux_lock - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_lock.html"
							}
							
							,
							
							
							{
							"title" : "linux_elf - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_elf.html"
							}
							
							,
							
							
							{
							"title" : "linux_cow - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_cow.html"
							}
							
							,
							
							
							{
							"title" : "Kibana - ",
							"url" : "/MyBlog/spark/2017/12/06/Kibana.html"
							}
							
							,
							
							
							{
							"title" : "linux_memory - ",
							"url" : "/MyBlog/linux/2017/12/05/linux_memory.html"
							}
							
							,
							
							
							{
							"title" : "server格式 - ",
							"url" : "/MyBlog/web/2017/12/02/server_tyrp.html"
							}
							
							,
							
							
							{
							"title" : "nginx_ssi - ",
							"url" : "/MyBlog/web/2017/12/02/nginx_ssi.html"
							}
							
							,
							
							
							{
							"title" : "go升级遇到问题及解决方案 - ",
							"url" : "/MyBlog/web/2017/11/29/go_update.html"
							}
							
							,
							
							
							{
							"title" : "go_pprof - ",
							"url" : "/MyBlog/web/2017/11/29/go_pprof.html"
							}
							
							,
							
							
							{
							"title" : "go_vs_code - ",
							"url" : "/MyBlog/web/2017/11/28/go_vs_code.html"
							}
							
							,
							
							
							{
							"title" : "scala tuple - ",
							"url" : "/MyBlog/spark/2017/11/19/scala_tuple.html"
							}
							
							,
							
							
							{
							"title" : "redis协议 - ",
							"url" : "/MyBlog/web/2017/11/18/redis_protocal.html"
							}
							
							,
							
							
							{
							"title" : "jupyter 数学公式 - ",
							"url" : "/MyBlog/spark/2017/11/18/jupyter_math.html"
							}
							
							,
							
							
							{
							"title" : "jupyter 数学公式 - ",
							"url" : "/MyBlog/spark/2017/11/18/jupyter_latex.html"
							}
							
							,
							
							
							{
							"title" : "Jupyter Notebook 添加目录 - ",
							"url" : "/MyBlog/spark/2017/11/18/jupyter_index.html"
							}
							
							,
							
							
							{
							"title" : "文字特征提取算法 - ",
							"url" : "/MyBlog/spark/2017/11/17/word_feature.html"
							}
							
							,
							
							
							{
							"title" : "sparl_ml_pipline - ",
							"url" : "/MyBlog/spark/2017/11/16/sparl_ml_pipline.html"
							}
							
							,
							
							
							{
							"title" : "mysql 的排序 - ",
							"url" : "/MyBlog/web/2017/11/16/mysql_sort.html"
							}
							
							,
							
							
							{
							"title" : "mysql_maneager - ",
							"url" : "/MyBlog/web/2017/11/16/mysql_maneager.html"
							}
							
							,
							
							
							{
							"title" : "mysql_index - ",
							"url" : "/MyBlog/web/2017/11/16/mysql_index.html"
							}
							
							,
							
							
							{
							"title" : "MySQL的表类型的（存储引擎） - ",
							"url" : "/MyBlog/web/2017/11/16/mysql_engine.html"
							}
							
							,
							
							
							{
							"title" : "mysql 原理 - ",
							"url" : "/MyBlog/web/2017/11/16/mysql.html"
							}
							
							,
							
							
							{
							"title" : "spark_memory - ",
							"url" : "/MyBlog/spark/2017/11/15/spark_memory.html"
							}
							
							,
							
							
							{
							"title" : "redis 持久化 - ",
							"url" : "/MyBlog/web/2017/11/15/redis_forever.html"
							}
							
							,
							
							
							{
							"title" : "spark toDF 失败原因总结 - ",
							"url" : "/MyBlog/spark/2017/11/14/spark_toDF.html"
							}
							
							,
							
							
							{
							"title" : "spark_start问题原因及解决办法 - ",
							"url" : "/MyBlog/spark/2017/11/14/spark_start.html"
							}
							
							,
							
							
							{
							"title" : "spark_rdd创建转换 - ",
							"url" : "/MyBlog/spark/2017/11/14/spark_rdd.html"
							}
							
							,
							
							
							{
							"title" : "spark的ML和MLLib两个包区别和联系 - ",
							"url" : "/MyBlog/spark/2017/11/14/spark_ml_mllib.html"
							}
							
							,
							
							
							{
							"title" : "RDD/Dataset/DataFrame互转 - ",
							"url" : "/MyBlog/spark/2017/11/14/rdd_dataset_dataframe.html"
							}
							
							,
							
							
							{
							"title" : "dataSet和dataFrame的创建方法 - ",
							"url" : "/MyBlog/spark/2017/11/14/dataSet_dataFrame.html"
							}
							
							,
							
							
							{
							"title" : "php_session - ",
							"url" : "/MyBlog/web/2017/11/09/php_session.html"
							}
							
							,
							
							
							{
							"title" : "jupyter_matplotlib - ",
							"url" : "/MyBlog/web/2017/11/09/jupyter_matplotlib.html"
							}
							
							,
							
							
							{
							"title" : "Jupyter_slides - ",
							"url" : "/MyBlog/web/2017/11/09/Jupyter_slides.html"
							}
							
							,
							
							
							{
							"title" : "composer - ",
							"url" : "/MyBlog/web/2017/11/03/composer.html"
							}
							
							,
							
							
							{
							"title" : "scala_partion_function - ",
							"url" : "/MyBlog/spark/2017/10/24/scala_partion_function.html"
							}
							
							,
							
							
							{
							"title" : "partion_function - ",
							"url" : "/MyBlog/web/2017/10/24/partion_function.html"
							}
							
							,
							
							
							{
							"title" : "高阶函数函数加里化(Currying)和偏函数应用(Partial Application)的比较 - ",
							"url" : "/MyBlog/web/2017/10/24/function.html"
							}
							
							,
							
							
							{
							"title" : "使用Phabricator做为Code Review工具 - ",
							"url" : "/MyBlog/web/2017/10/24/Phabricator.html"
							}
							
							,
							
							
							{
							"title" : "cut - ",
							"url" : "/MyBlog/spark/2017/10/23/cut.html"
							}
							
							,
							
							
							{
							"title" : "akka_sbt_eclipse - ",
							"url" : "/MyBlog/spark/2017/10/18/akka_sbt_eclipse.html"
							}
							
							,
							
							
							{
							"title" : "FunSuite - ",
							"url" : "/MyBlog/spark/2017/10/18/FunSuite.html"
							}
							
							,
							
							
							{
							"title" : "spark基本概念 - ",
							"url" : "/MyBlog/spark/2017/10/13/spark_concepts.html"
							}
							
							,
							
							
							{
							"title" : "Actor模型原理 - ",
							"url" : "/MyBlog/spark/2017/10/13/actor_intro.html"
							}
							
							,
							
							
							{
							"title" : "Actor系统的实体 - ",
							"url" : "/MyBlog/spark/2017/10/13/actor_detail.html"
							}
							
							,
							
							
							{
							"title" : "Actor模型和CSP模型的区别 - ",
							"url" : "/MyBlog/spark/2017/10/13/actor_csp.html"
							}
							
							,
							
							
							{
							"title" : "java_scala - ",
							"url" : "/MyBlog/spark/2017/10/12/java_scala.html"
							}
							
							,
							
							
							{
							"title" : "Scala_collection - ",
							"url" : "/MyBlog/spark/2017/10/12/Scala_collection.html"
							}
							
							,
							
							
							{
							"title" : "scala_list - ",
							"url" : "/MyBlog/spark/2017/10/11/scala_list.html"
							}
							
							,
							
							
							{
							"title" : "spark-session-context - ",
							"url" : "/MyBlog/spark/2017/10/06/spark-session-context.html"
							}
							
							,
							
							
							{
							"title" : "scala_main_class - ",
							"url" : "/MyBlog/spark/2017/09/29/scala_main_class.html"
							}
							
							,
							
							
							{
							"title" : "alibaba_fast_json - ",
							"url" : "/MyBlog/spark/2017/09/29/alibaba_fast_json.html"
							}
							
							,
							
							
							{
							"title" : "gorpc - ",
							"url" : "/MyBlog/jekyll/2017/09/25/gorpc.html"
							}
							
							,
							
							
							{
							"title" : "spark-kafka - ",
							"url" : "/MyBlog/spark/2017/09/22/spark-kafka.html"
							}
							
							,
							
							
							{
							"title" : "mysqldump - ",
							"url" : "/MyBlog/web/2017/09/20/mysqldump.html"
							}
							
							,
							
							
							{
							"title" : "mysql-time - ",
							"url" : "/MyBlog/jekyll/2017/09/20/mysql-time.html"
							}
							
							,
							
							
							{
							"title" : "mac 安装 sshfs - ",
							"url" : "/MyBlog/jekyll/2017/09/18/sshfs.html"
							}
							
							,
							
							
							{
							"title" : "jupyter - ",
							"url" : "/MyBlog/deep_learning/2017/09/17/jupyter.html"
							}
							
							,
							
							
							{
							"title" : "deep_learning - ",
							"url" : "/MyBlog/deep_learning/2017/09/17/deep_learning.html"
							}
							
							,
							
							
							{
							"title" : "spark-rdd - spark",
							"url" : "/MyBlog/spark/2017/09/15/spark-rdd.html"
							}
							
							,
							
							
							{
							"title" : "netcat - ",
							"url" : "/MyBlog/jekyll/2017/09/15/netcat.html"
							}
							
							,
							
							
							{
							"title" : "markdown-table - ",
							"url" : "/MyBlog/jekyll/2017/09/15/markdown-table.html"
							}
							
							,
							
							
							{
							"title" : "books-sites - ",
							"url" : "/MyBlog/jekyll/2017/09/15/books-sites.html"
							}
							
							,
							
							
							{
							"title" : "脚本输出带颜色文字 - ",
							"url" : "/MyBlog/jekyll/2017/09/14/%E8%84%9A%E6%9C%AC%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E6%96%87%E5%AD%97.html"
							}
							
							,
							
							
							{
							"title" : "常见SSL证书格式转换 - ",
							"url" : "/MyBlog/jekyll/2017/09/13/%E5%B8%B8%E8%A7%81SSL%E8%AF%81%E4%B9%A6%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2.html"
							}
							
							,
							
							
							{
							"title" : "php-curl-ext - ",
							"url" : "/MyBlog/jekyll/2017/09/13/php-curl-ext.html"
							}
							
							,
							
							
							{
							"title" : "curl-https-php - ",
							"url" : "/MyBlog/jekyll/2017/09/13/curl-https-php.html"
							}
							
							,
							
							
							{
							"title" : "php-spider - ",
							"url" : "/MyBlog/jekyll/2017/09/12/php-spider.html"
							}
							
							,
							
							
							{
							"title" : "php怎么判断函数，类，类方法是不是存在 - ",
							"url" : "/MyBlog/jekyll/2017/09/12/php-function.html"
							}
							
							,
							
							
							{
							"title" : "composer-source - ",
							"url" : "/MyBlog/jekyll/2017/09/12/composer-source.html"
							}
							
							,
							
							
							{
							"title" : "php-doc - ",
							"url" : "/MyBlog/jekyll/2017/09/11/php-doc.html"
							}
							
							,
							
							
							{
							"title" : "oauth-github-api - ",
							"url" : "/MyBlog/jekyll/2017/09/10/oauth-github-api.html"
							}
							
							,
							
							
							{
							"title" : "http-head 四种常见的 POST 提交数据方式 - ",
							"url" : "/MyBlog/jekyll/2017/09/10/http-head.html"
							}
							
							,
							
							
							{
							"title" : "javascript 实现客户端访问次数统计 - ",
							"url" : "/MyBlog/jekyll/2017/09/09/statics.html"
							}
							
							,
							
							
							{
							"title" : "JavaScript实现模糊匹配搜索 - ",
							"url" : "/MyBlog/jekyll/2017/09/09/search_match.html"
							}
							
							,
							
							
							{
							"title" : "search - ",
							"url" : "/MyBlog/jekyll/2017/09/09/search.html"
							}
							
							,
							
							
							{
							"title" : "robots - ",
							"url" : "/MyBlog/jekyll/2017/09/09/robots.html"
							}
							
							,
							
							
							{
							"title" : "oauth-github - ",
							"url" : "/MyBlog/jekyll/2017/09/09/oauth-github.html"
							}
							
							,
							
							
							{
							"title" : "github-openapi - ",
							"url" : "/MyBlog/jekyll/2017/09/09/github-openapi.html"
							}
							
							,
							
							
							{
							"title" : "github-api - ",
							"url" : "/MyBlog/jekyll/2017/09/09/github-api.html"
							}
							
							,
							
							
							{
							"title" : "Authorization-ajax - ",
							"url" : "/MyBlog/jekyll/2017/09/09/Authorization-ajax.html"
							}
							
							,
							
							
							{
							"title" : "自动化替换网站引用资源到本地工具 - ",
							"url" : "/MyBlog/jekyll/2017/09/08/replace-url.html"
							}
							
							,
							
							
							{
							"title" : "pygments - ",
							"url" : "/MyBlog/jekyll/2017/09/08/pygments.html"
							}
							
							,
							
							
							{
							"title" : "markdown - ",
							"url" : "/MyBlog/markdown/2017/09/07/markdown.html"
							}
							
							,
							
							
							{
							"title" : "mac-sed - ",
							"url" : "/MyBlog/jekyll/2017/09/07/mac-sed.html"
							}
							
							,
							
							
							{
							"title" : "jekyll config - ",
							"url" : "/MyBlog/jekyll/2017/09/07/jeky-env.html"
							}
							
							,
							
							
							{
							"title" : "comment - ",
							"url" : "/MyBlog/jekyll/2017/09/07/comment.html"
							}
							
							,
							
							
							{
							"title" : "Welcome to xiazemin's blog! - ",
							"url" : "/MyBlog/update/2017/09/05/welcome-to-jekyll.html"
							}
							
							,
							
							
							{
							"title" : "nginx lua - octopress_jekyll",
							"url" : "/MyBlog/web/2017/08/05/nginx-lua.html"
							}
							
							,
							
							
							{
							"title" : "jekyll layout - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-layout.html"
							}
							
							,
							
							
							{
							"title" : "jekyll dir - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-dir.html"
							}
							
							,
							
							
							{
							"title" : "jekyll macdown使用 - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-usage.html"
							}
							
							,
							
							
							{
							"title" : "jekyll 分页 - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-page.html"
							}
							
							,
							
							
							{
							"title" : "jekyll mac 安装 - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-mac-install.html"
							}
							
							,
							
							
							{
							"title" : "Eleventh post - css_html",
							"url" : "/MyBlog/technology/2016/02/11/eleventh.html"
							}
							
							,
							
							
							{
							"title" : "Tenth post - css_html",
							"url" : "/MyBlog/technology/2016/02/09/tenth.html"
							}
							
							,
							
							
							{
							"title" : "second post - holiday",
							"url" : "/MyBlog/technology/computer/news/2016/02/02/second-post.html"
							}
							
							,
							
							
							{
							"title" : "first post - css_html_hosting_openshift_wordpress",
							"url" : "/MyBlog/jekyll/technology/2016/02/01/first-post.html"
							}
							
							
							]
							};
							function handle(){  
							var word = document.getElementById('txt').value;
							var value = "";
							var data=searchIndex.data;
							for(var i = 0;i < data.length;i++){
							if(word!="" && data[i].title.match(".*"+word+".*") != null){
							value += "<a onclick=add('"+ data[i].title +"') href='"+ data[i]. url +"'>" + data[i].title + "</a><br/>";
							}
							}       
							document.getElementById('msg').innerHTML=value;
							  if(typeof(document.getElementById('msg').children[0])!="undefined"){
								document.getElementById('cse-search-box').action=document.getElementById('msg').children[0].href;
					
							   }
							} 
							function add(city){
							document.getElementById('txt').value=city;
							}
							//firefox下检测状态改变只能用oninput,且需要用addEventListener来注册事件。   
							if(/msie/i.test(navigator.userAgent))    //ie浏览器   
							{document.getElementById('txt').onpropertychange=handle   
							} else{//非ie浏览器，比如Firefox   
							document.getElementById('txt').addEventListener("input",handle,false);   
							}
						 </script> 
					  </div>
					</form>
					<!--script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script-->
				</div>
            </div>

            <!-- time -->
                    <div id="myTime" class="well">
                            <object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="/MyBlog/flash/swflash.cab" style="margin: 0;padding: 0;height: auto;width:auto;">
                                <param name="allowScriptAccess" value="always">
                                <param name="movie" value="/MyBlog/flash/honehone_clock_wh.swf">
                                <param name="quality" value="high">
                                <param name="bgcolor" value="transparent">
                                <param name="wmode" value="transparent">
                                <embed wmode="transparent" src="/MyBlog/flash/honehone_clock_wh.swf" quality="high" name="honehoneclock" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer"  style="margin: 0;padding: 0;border: 0 ;height: auto;width:100%;">
                            </object>
                    </div>
                <!-- Blog Categories Well -->
                <div class="well">
                    <h4>Blog Categories</h4>
                    <div class="row">
                        <div class="col-lg-6">
								
								
								
								
									<a class="bold" href="/MyBlog/category/jekyll">
										jekyll (41)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/technology">
										technology (4)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/computer">
										computer (3)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/news">
										news (1)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/web">
										web (183)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/update">
										update (1)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/markdown">
										markdown (1)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/spark">
										spark (51)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/deep-learning">
										deep_learning (2)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/linux">
										linux (254)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/cryptology">
										cryptology (15)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/lang">
										lang (50)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/golang">
										golang (317)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/docker">
										docker (42)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/net">
										net (13)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/zookeeper">
										zookeeper (11)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/elasticsearch">
										elasticsearch (24)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/storage">
										storage (94)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/java">
										java (4)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/algorithm">
										algorithm (67)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/hadoop">
										hadoop (2)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/elasticsearch">
										Elasticsearch (1)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
                        </div>
                    </div>
                    <!-- /.row -->
                </div>
                <!-- Side Widget Well -->

                <!-- Side Widget Well -->
                <div class="well">
                	<h4>Recent posts</h4>
                		<ul class="posts" span="recent"> 
							  
							   <li>  
								   <span>13 Dec 2019</span>
								   <a href="/MyBlog//linux/2019/12/13/tcp_tw_reuse.html">  
								   tcp_tw_reuse</a>  
							   </li>  
							  
							   <li>  
								   <span>13 Dec 2019</span>
								   <a href="/MyBlog//linux/2019/12/13/tcp_tw_recycle.html">  
								   tcp_tw_recycle</a>  
							   </li>  
							  
							   <li>  
								   <span>13 Dec 2019</span>
								   <a href="/MyBlog//linux/2019/12/13/tcp_retries.html">  
								   tcp_retries</a>  
							   </li>  
							  
							   <li>  
								   <span>13 Dec 2019</span>
								   <a href="/MyBlog//linux/2019/12/13/rto.html">  
								   MTU、MSS、MSL、RTT、TTL、RTO</a>  
							   </li>  
							  
							   <li>  
								   <span>13 Dec 2019</span>
								   <a href="/MyBlog//web/2019/12/13/chrome.html">  
								   chrome 无法打开https 网站问题解决</a>  
							   </li>  
							  
						</ul>
                </div>
                <!-- Side Widget Well -->
                <div class="well">
                    <h4>Tags</h4>
                        <ul>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/css">
                                    css (3)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/html">
                                    html (3)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/hosting">
                                    hosting (1)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/openshift">
                                    openshift (1)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/wordpress">
                                    wordpress (1)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/holiday">
                                    holiday (1)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/octopress">
                                    octopress (6)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/jekyll">
                                    jekyll (6)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/spark">
                                    spark (1)
                                </a>
                            
                        </ul>
                </div>
                <div class="well">
                    <h4>This blog is maintained by <a href="＃">夏泽民</a></h4>
                    <p>Get in touch with me at 465474307@qq.com</p>
					<ul class="list-inline">
                            <li>
								<a href="＃">
									<span class="fa-stack fa-2x">
									  <i class="fa fa-circle fa-stack-2x"></i>
									  <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
									</span>
								</a>
                            </li>
                            <li>
								<a href="#">
									<span class="fa-stack fa-2x">
									  <i class="fa fa-circle fa-stack-2x"></i>
									  <i class="fa fa-globe fa-stack-1x fa-inverse"></i>
									</span>
								</a>
                            </li>
                            <li>
								<a href="mailto:465474307@qq.com">
									<span class="fa-stack fa-2x">
									  <i class="fa fa-circle fa-stack-2x"></i>
									  <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
									</span>
								</a>
                            </li>
                            <li>
								<a href="#">
									<span class="fa-stack fa-2x">
									  <i class="fa fa-circle fa-stack-2x"></i>
									  <i class="fa fa-bitbucket fa-stack-1x fa-inverse"></i>
									</span>
								</a>
                            </li>
                    </ul>
                </div>
				 <!-- subscribe -->
                <div class="well">
					<!-- Begin MailChimp Signup Form -->
					<div id="mc_embed_signup">
					<form action="http://maplelearning.us1.list-manage.com/subscribe?u=47d56ac42a95b4295600c0e64&id=5f9ede27c9" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
						<div id="mc_embed_signup_scroll">
						<h2>Subscribe to our mailing list</h2>
					<div class="indicates-required"><span class="asterisk">*</span> indicates required</div>
					<div class="mc-field-group">
						<label for="mce-EMAIL">Email Address  <span class="asterisk">*</span>
					</label>
						<input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL">
					</div>
					<div class="mc-field-group">
						<label for="mce-FNAME">First Name </label>
						<input type="text" value="" name="FNAME" class="" id="mce-FNAME">
					</div>
					<div class="mc-field-group">
						<label for="mce-LNAME">Last Name </label>
						<input type="text" value="" name="LNAME" class="" id="mce-LNAME">
					</div>
						<div id="mce-responses" class="clear">
							<div class="response" id="mce-error-response" style="display:none"></div>
							<div class="response" id="mce-success-response" style="display:none"></div>
						</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
						<div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_47d56ac42a95b4295600c0e64_5f9ede27c9" tabindex="-1" value=""></div>
						<div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
						</div>
					</form>
					</div>

					<!--End mc_embed_signup-->
				</div>

            </div>
        </div>
        <!-- /.row -->
       <hr>


          <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

	</div>
    </body>

</html>
