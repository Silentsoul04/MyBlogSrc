<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
</head>


    <body>
	<div id="wrapper">
      <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


      
       
    <!-- Page Content -->
    <div class="container">

        <div class="row">

            <!-- Blog Post Content Column -->
            <div class="col-lg-8">
                <!-- Blog Post -->
                	<h1 style="color: #0F3C73;"><span class="outside-cats">linux</span></h1>
                    <div role="main" class="main-content">
                      

  <div class="post">

    <a href="/MyBlog/linux/2019/04/13/tcphttp.html" class="post-title-link">
      <h2>Tcp Keepalive和HTTP Keep-alive</h2>
    </a>

    <div class="post-date">Apr 13, 2019</div>
    
    <div class="post-body">
      
      <p>Tcp Keepalive的起源
         双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会，那么在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些TCP连接并未来得及正常释放，那么，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用TCP的保活报文来实现。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/04/13/tcphttp.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/04/13/keepalive.html" class="post-title-link">
      <h2>keepalive 连接池</h2>
    </a>

    <div class="post-date">Apr 13, 2019</div>
    
    <div class="post-body">
      
      <p>1 连接种类
     一般连接主要分为长连接，短连接和http的keepalive连接。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/04/13/keepalive.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/04/13/cwnd.html" class="post-title-link">
      <h2>发送接收缓冲区滑动窗口</h2>
    </a>

    <div class="post-date">Apr 13, 2019</div>
    
    <div class="post-body">
      
      <p>发送窗口与接收窗口关系</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/04/13/cwnd.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/04/07/inode.html" class="post-title-link">
      <h2>inode 与文件块 block 对应关系</h2>
    </a>

    <div class="post-date">Apr 7, 2019</div>
    
    <div class="post-body">
      
      <p>Linux文件访问流程
	<img src="https://xiazemin.github.io/MyBlog/img/inode_1.png" />
inode是文件的唯一标识，文件名和inode的对应关系存放在上一级目录的block中；inode里有指向文件block的指针和文件的属性，从而通过block获得文件数据。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/04/07/inode.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/04/06/socket.html" class="post-title-link">
      <h2>socket 虚拟文件系统</h2>
    </a>

    <div class="post-date">Apr 6, 2019</div>
    
    <div class="post-body">
      
      <p>在内核中，对socket实现了一种虚拟的文件系统（VFS）：socketfs。和其它一般文件系统不同，它不能被mount，没有挂载点，而是通过一个静态变量来引用： 
[ net/socket.c ] 
static struct vfsmount *sock_mnt __read_mostly;
 在用户空间创建了一个socket后，返回值是一个文件描述符，下面分析一下创建socket时怎么和文件描述符联系的。在SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)最后调用sock_map_fd进行关联，其中返回的retval就是用户空间获取的文件描述符fd，sock就是调用sock_create创建成功的socket.</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/04/06/socket.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/04/06/screen.html" class="post-title-link">
      <h2>screen nohup session</h2>
    </a>

    <div class="post-date">Apr 6, 2019</div>
    
    <div class="post-body">
      
      <p>nohup和&amp;的缺点是，如果你要在一个shell会话里面执行多个命令和脚本，那么要每个命令和脚本都要加nohup和&amp;非常麻烦，所以才有了screen和TMUX
Screen 命令与 Tmux 命令
另一种思路是使用 terminal multiplexer （终端复用器：在同一个终端里面，管理多个session），典型的就是 Screen 命令和 Tmux 命令。
它们可以在当前 session 里面，新建另一个 session。这样的话，当前 session 一旦结束，不影响其他 session。而且，以后重新登录，还可以再连上早先新建的 session。
<!-- more -->
kill <pid> 调用的是 SIGTERM, 此信号可以被捕获和忽略。
kill -9 <pid> 调用的是 SIGKILL, 杀掉进程，不能被捕获和忽略。
SIGHUP是在终端被断开时候调用，如果信号没有被处理，进程会终止。</pid></pid></p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/04/06/screen.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/04/06/fork_cahe.html" class="post-title-link">
      <h2>fork cahe</h2>
    </a>

    <div class="post-date">Apr 6, 2019</div>
    
    <div class="post-body">
      
      <p>题目：请问下面的程序一共输出多少个“-”？
`#include <stdio.h>
#include &lt;sys/types.h&gt;
#include <unistd.h></unistd.h></stdio.h></p>

<p>int main(void)
{
   int i;
   for(i=0; i&lt;2; i++){
      fork();
      printf(“-“);
   }</p>

<p>wait(NULL);
   wait(NULL);</p>

<p>return 0;
}`
<!-- more -->
如果你对fork()的机制比较熟悉的话，这个题并不难，输出应该是6个“-”，但是，实际上这个程序会很tricky地输出8个“-”。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/04/06/fork_cahe.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/04/06/file_lock.html" class="post-title-link">
      <h2>文件锁</h2>
    </a>

    <div class="post-date">Apr 6, 2019</div>
    
    <div class="post-body">
      
      <p>两种经常使用的文件锁：</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/04/06/file_lock.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/04/06/fd.html" class="post-title-link">
      <h2>fd 文件描述符</h2>
    </a>

    <div class="post-date">Apr 6, 2019</div>
    
    <div class="post-body">
      
      <p>每一个文件描述符会与一个打开文件相对应，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为每一个进程维护了一个文件描述符表，该表的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。具体情况要具体分析，要理解具体其概况如何，需要查看由内核维护的3个数据结构。
1.进程级的文件描述符表；
2.系统级的打开文件描述符表；
3.文件系统的i-node表。
<!-- more -->
文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。
       在编写文件操作的或者网络通信的软件时，初学者一般可能会遇到“Too many open files”的问题。这主要是因为文件描述符是系统的一个重要资源，虽然说系统内存有多少就可以打开多少的文件描述符，但是在实际实现过程中内核是会做相应的处理的，一般最大打开文件数会是系统内存的10%（以KB来计算）（称之为系统级限制），查看系统级别的最大打开文件数可以使用sysctl -a | grep fs.file-max命令查看。与此同时，内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理（称之为用户级限制），默认值一般是1024，使用ulimit -n命令可以查看。在Web服务器中，通过更改系统默认值文件描述符的最大值来优化服务器是最常见的方式之一
       ## 查看默认文件描述符的大小
[root@poe ~]# ulimit -n
1024
临时修改文件描述符的大小
[root@Gin scripts]# ulimit -SHn 65535
[root@Gin scripts]# ulimit -n
65535
永久修改文件描述符的大小：
[root@Gin ~]# echo ‘*               -       nofile          65535’ »/etc/security/limits.conf
[root@Gin ~]# tail -n1 /etc/security/limits.conf</p>
<ul>
  <li>
    <ul>
      <li>nofile          65535</li>
    </ul>
  </li>
</ul>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/04/06/fd.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/04/06/exec.html" class="post-title-link">
      <h2>fork() execve()</h2>
    </a>

    <div class="post-date">Apr 6, 2019</div>
    
    <div class="post-body">
      
      <p>①fork()系统调用：
     进程调用fork()创建一个新的进程，新进程复制了父进程的task_struct（PCB，process control block，进程控制块），以及task_struct中的各个子模块，比如内核堆栈等，然后对各个子模块做了修改。系统调用通过eax寄存器保存返回值，fork()系统调用结束后从内核态返回两次，一次是父进程返回，一次是子进程返回，区分父子进程的方法就是看返回值是否为0，若为0，说明返回的是新进程，不为0返回的是父进程。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/04/06/exec.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/03/27/disk.html" class="post-title-link">
      <h2>页、磁盘块与扇区</h2>
    </a>

    <div class="post-date">Mar 27, 2019</div>
    
    <div class="post-body">
      
      <p>扇区：磁盘的最小存储单位；
磁盘块：文件系统读写数据的最小单位；
页：内存的最小存储单位；</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/03/27/disk.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/03/25/exit.html" class="post-title-link">
      <h2>Bash 带有特殊含义的退出码</h2>
    </a>

    <div class="post-date">Mar 25, 2019</div>
    
    <div class="post-body">
      
      <p>exit命令用于退出当前shell，在shell脚本中可以终止当前脚本执行。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/03/25/exit.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/03/25/FUNCNAME.html" class="post-title-link">
      <h2>FUNCNAME</h2>
    </a>

    <div class="post-date">Mar 25, 2019</div>
    
    <div class="post-body">
      
      <p>C/C++中，__FUNCTION__常量记录当前函数的名称。有时候，在日志输出的时候包含这些信息是非常有用的。而在Bash中，同样有这样一个常量FUNCNAME，但是有一点区别是，它是一个数组而非字符串，其中数组的第一个元素为当前函数的名称。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/03/25/FUNCNAME.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/03/24/lock.html" class="post-title-link">
      <h2>乐观锁悲观锁</h2>
    </a>

    <div class="post-date">Mar 24, 2019</div>
    
    <div class="post-body">
      
      <p>乐观锁
在关系数据库管理系统里，乐观并发控制（又名”乐观锁”，Optimistic Concurrency Control，缩写”OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的 那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回 滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/03/24/lock.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/03/17/strace.html" class="post-title-link">
      <h2>strace</h2>
    </a>

    <div class="post-date">Mar 17, 2019</div>
    
    <div class="post-body">
      
      <p>strace是用来跟踪用户空间进程的系统调用和信号的
系统调用提供用户程序与操作系统之间的接口。操作系统的进程空间分为用户空间和内核空间：</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/03/17/strace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/03/17/pstack.html" class="post-title-link">
      <h2>pstack 原理</h2>
    </a>

    <div class="post-date">Mar 17, 2019</div>
    
    <div class="post-body">
      
      <p>注意和ptrace（ptrace()系统调用提供了一个方法，该方法使一个程序（追踪者）可以观察和控制另外一个程序（被追踪者）的执行，并检查和改变被追踪者的内存及寄存器。它主要用于实现断点调试和追踪系统调用。GDB的工作机制）区分</p>

<p>和jstack一样, pstack亦能展现进程的线程堆栈快照, 非常方便验证和性能评估.
 pstack的作用, 大致可以归纳如下:
　　1). 查看线程数(比pstree, 包含了详细的堆栈信息)
　　2). 能简单验证是否按照预定的调用顺序/调用栈执行
　　3). 采用高频率多次采样使用时, 能发现程序当前的阻塞在哪里, 以及性能消耗点在哪里?
　　4). 能反映出疑似的死锁现象(多个线程同时在wait lock, 具体需要进一步验证)
　　当然还能举例更多的作用, 相信使用过jstack的coder, 必然深以为然.</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/03/17/pstack.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/03/17/mqueue.html" class="post-title-link">
      <h2>Linux进程间通信-消息队列（mqueue）</h2>
    </a>

    <div class="post-date">Mar 17, 2019</div>
    
    <div class="post-body">
      
      <p>消息队列的实现分为两种，一种为System V的消息队列，一种是Posix消息队列；
消息队列可以认为是一个消息链表，某个进程往一个消息队列中写入消息之前，不需要另外某个进程在该队列上等待消息的达到，这一点与管道和FIFO相反。Posix消息队列与System V消息队列的区别如下：</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/03/17/mqueue.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/03/17/kill.html" class="post-title-link">
      <h2>kill</h2>
    </a>

    <div class="post-date">Mar 17, 2019</div>
    
    <div class="post-body">
      
      <ol>
  <li>
    <p>kill与signals
     我们这里所说的kill是指作为shell command的那个kill（相对地，linux系统中还有个叫做kill的system call, man 2 kill可查看其功能及用法），shell终端中输入man kill可以看到，kill的作用是向某个指定的进程或进程组发送指定信号，从而结束该进程/进程组。-s选项可以指定要发送的具体信号，如果没有指定，则默认发送SIGTERM信号至指定进程/进程组，若进程没有捕获该信号的逻辑，则SIGTERM的作用是终止进程。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kill支持发送的信号列表可以通过kill -l查看，而这些信号的具体含义可以通过man 7 signal查看。在我的机器上，man 7 signal输出的POSIX标准信号如下所示（kill支持的信号还有POSIX没有定义的非标准信号，这里没有摘出，感兴趣的同学可以通过man查看）。
</code></pre></div>    </div>
  </li>
</ol>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/03/17/kill.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/03/17/flame.html" class="post-title-link">
      <h2>火焰图（flame graph)</h2>
    </a>

    <div class="post-date">Mar 17, 2019</div>
    
    <div class="post-body">
      
      <p>Brendan D. Gregg 发明了火焰图，可以一针见血的指出程序的性能瓶颈，坏消息是除了OpenResty 社区，很少看到还有其他人使用火焰图。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/03/17/flame.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/03/17/core.html" class="post-title-link">
      <h2>core dump</h2>
    </a>

    <div class="post-date">Mar 17, 2019</div>
    
    <div class="post-body">
      
      <p>有的程序可以通过编译, 但在运行时会出现Segment fault(段错误). 这通常都是指针错误引起的. 但这不像编译错误一样会提示到文件某一行, 而是没有任何信息, 使得我们的调试变得困难起来.</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/03/17/core.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/03/17/bt.html" class="post-title-link">
      <h2>thread apply all bt</h2>
    </a>

    <div class="post-date">Mar 17, 2019</div>
    
    <div class="post-body">
      
      <p>Core Dump又叫核心转储, 当程序没有core文件生成怎么办呢?</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/03/17/bt.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/03/09/regx.html" class="post-title-link">
      <h2>通配符与正则表达式</h2>
    </a>

    <div class="post-date">Mar 9, 2019</div>
    
    <div class="post-body">
      
      <p>通配符适用的地方：shell命令行或者shell脚本中</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/03/09/regx.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/03/03/awk.html" class="post-title-link">
      <h2>awk 用法总结</h2>
    </a>

    <div class="post-date">Mar 3, 2019</div>
    
    <div class="post-body">
      
      <p>1，awk 大小写敏感</p>
<ol>
  <li>awk命令格式和选项
2.1. awk的语法有两种形式
awk [options] ‘script’ var=value file(s)</li>
</ol>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/03/03/awk.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/02/27/futex.html" class="post-title-link">
      <h2>futex 快速用户空间互斥体</h2>
    </a>

    <div class="post-date">Feb 27, 2019</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>版内核中出现。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/02/27/futex.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/02/27/Test_And_Set_Lock.html" class="post-title-link">
      <h2>Test And Set Lock</h2>
    </a>

    <div class="post-date">Feb 27, 2019</div>
    
    <div class="post-body">
      
      <p>1禁止中断、
2锁内存总线
3Test-and-Set指令
Swap指令
同步互斥 
. 互斥与同步的概念 
互斥和同步是两个紧密相关而又容易混淆的概念。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/02/27/Test_And_Set_Lock.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/01/15/timer.html" class="post-title-link">
      <h2>timer</h2>
    </a>

    <div class="post-date">Jan 15, 2019</div>
    
    <div class="post-body">
      
      <p>内核定时器是内核用来控制在未来某个时间点（基于jiffies）调度执行某个函数的一种机制，其实现位于 &lt;linux/timer.h&gt; 和 kernel/timer.c 文件中。
被调度的函数肯定是异步执行的，它类似于一种“软件中断”，而且是处于非进程的上下文中，所以调度函数必须遵守以下规则：
1) 没有 current 指针、不允许访问用户空间。因为没有进程上下文，相关代码和被中断的进程没有任何联系。
2) 不能执行休眠（或可能引起休眠的函数）和调度。
3) 任何被访问的数据结构都应该针对并发访问进行保护，以防止竞争条件。
内核定时器的调度函数运行过一次后就不会再被运行了（相当于自动注销），但可以通过在被调度的函数中重新调度自己来周期运行。
在SMP系统中，调度函数总是在注册它的同一CPU上运行，以尽可能获得缓存的局域性。
<!-- more -->
struct timer_list {</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/01/15/timer.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/01/15/timekeeper.html" class="post-title-link">
      <h2>timekeeper</h2>
    </a>

    <div class="post-date">Jan 15, 2019</div>
    
    <div class="post-body">
      
      <ol>
  <li> 时间的种类
内核管理着多种时间，它们分别是：</li>
</ol>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/01/15/timekeeper.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/01/15/jiffies.html" class="post-title-link">
      <h2>jiffies</h2>
    </a>

    <div class="post-date">Jan 15, 2019</div>
    
    <div class="post-body">
      
      <p>HZ
Linux核心每隔固定周期会发出timer interrupt (IRQ 0)，HZ是用来定义每一秒有几次timer interrupts。举例来说，HZ为1000，代表每秒有1000次timer interrupts。 HZ可在编译核心时设定，如下所示(以核心版本2.6.20-15为例)： 
:~$ cd /usr/src/linux 
:/usr/src/linux$ make menuconfig 
 Processor type and features —&gt; Timer frequency (250 HZ) —&gt; 
 Tick
Tick是HZ的倒数，意即timer interrupt每发生一次中断的时间。如HZ为250时，tick为4毫秒(millisecond)。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/01/15/jiffies.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/01/15/clock_event_device.html" class="post-title-link">
      <h2>clock_event_device</h2>
    </a>

    <div class="post-date">Jan 15, 2019</div>
    
    <div class="post-body">
      
      <p>早期的内核版本中，进程的调度基于一个称之为tick的时钟滴答，通常使用时钟中断来定时地产生tick信号，每次tick定时中断都会进行进程的统计和调度，并对tick进行计数，记录在一个jiffies变量中，定时器的设计也是基于jiffies。这时候的内核代码中，几乎所有关于时钟的操作都是在machine级的代码中实现，很多公共的代码要在每个平台上重复实现。随后，随着通用时钟框架的引入，内核需要支持高精度的定时器，为此，通用时间框架为定时器硬件定义了一个标准的接口：clock_event_device，machine级的代码只要按这个标准接口实现相应的硬件控制功能，剩下的与平台无关的特性则统一由通用时间框架层来实现。
<!-- more --></p>
<ol>
  <li> 时钟事件软件架构
本系列文章的第一节中，我们曾经讨论了时钟源设备：clocksource，现在又来一个时钟事件设备：clock_event_device，它们有何区别？看名字，好像都是给系统提供时钟的设备，实际上，clocksource不能被编程，没有产生事件的能力，它主要被用于timekeeper来实现对真实时间进行精确的统计，而clock_event_device则是可编程的，它可以工作在周期触发或单次触发模式，系统可以对它进行编程，以确定下一次事件触发的时间，clock_event_device主要用于实现普通定时器和高精度定时器，同时也用于产生tick事件，供给进程调度子系统使用。时钟事件设备与通用时间框架中的其他模块的关系如下图所示：
<img src="https://xiazemin.github.io/MyBlog/img/clock_event_device.png" />
与clocksource一样，系统中可以存在多个clock_event_device，系统会根据它们的精度和能力，选择合适的clock_event_device对系统提供时钟事件服务。在smp系统中，为了减少处理器间的通信开销，基本上每个cpu都会具备一个属于自己的本地clock_event_device，独立地为该cpu提供时钟事件服务，smp中的每个cpu基于本地的clock_event_device，建立自己的tick_device，普通定时器和高精度定时器。
在软件架构上看，clock_event_device被分为了两层，与硬件相关的被放在了machine层，而与硬件无关的通用代码则被集中到了通用时间框架层，这符合内核对软件的设计需求，平台的开发者只需实现平台相关的接口即可，无需关注复杂的上层时间框架。
tick_device是基于clock_event_device的进一步封装，用于代替原有的时钟滴答中断，给内核提供tick事件，以完成进程的调度和进程信息统计，负载平衡和时间更新等操作。
struct clock_event_device
时钟事件设备的核心数据结构是clock_event_device结构，它代表着一个时钟硬件设备，该设备就好像是一个具有事件触发能力（通常就是指中断）的clocksource，它不停地计数，当计数值达到预先编程设定的数值那一刻，会引发一个时钟事件中断，继而触发该设备的事件处理回调函数，以完成对时钟事件的处理。clock_event_device结构的定义如下：</li>
</ol>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/01/15/clock_event_device.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2019/01/15/callout.html" class="post-title-link">
      <h2>时间轮算法</h2>
    </a>

    <div class="post-date">Jan 15, 2019</div>
    
    <div class="post-body">
      
      <p>内核自身的正常运行也依赖于时钟系统。Linux 是一个典型的分时系统，CPU 时间被分成多个时间片，这是多任务实现的基础。Linux 内核依赖 tick，即时钟中断来进行分时。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2019/01/15/callout.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/10/21/fileread.html" class="post-title-link">
      <h2>文件读取流程</h2>
    </a>

    <div class="post-date">Oct 21, 2018</div>
    
    <div class="post-body">
      
      <p>使用df -aT命令，发现根目录/对应的文件系统为ext3
<!-- more -->
Ext3文件系统结构与Ext2相似。用工具格式化磁盘或分区时， 会选择使用什么文件系统来格式化。若选用Ext2来格式化磁盘或分区， 则磁盘或分区的大部分空间被格式化成了许多个Inode和block两个数据结构。block有3种大小选项1K，2K，4K，可在格式化之前选择。Inode的大小固定为128bytes。每个文件都仅会占用一个Inode，Inode主要用来记录文件相关属性，比如权限、文件大小、修改时间等。block用来记录文件的数据，一个Inode可以关联多个block，且Inode记录一个block号码需要4byte。如果文件非常大的话，则Inode无法直接记录文件所包含的所有block号码。所以Ext2采用12个直接、1个间接、1个双间接、和1个三间接记录区，共需60bytes。
	<img src="https://xiazemin.github.io/MyBlog/img/ext2inode.webp" />
	12个直接记录区直接指向带有文件数据的block。1个间接记录区指向一个无真实文件数据的block，此block充当Inode的扩展记录区，此block直接指向带有数据的block。若此扩展block为1K，那么它可记录256个block号码。双间接和三间接类似。</p>

<p>文件读取流程
1)通过挂载点信息找到/dev/sda2的inode号码为2，对应根目录/
2） 经过上个步骤，由于owner root有r,w,x权限，可从inode取得根目录/的block，然后再从block中取得etc/目录的inode为3303105。这里etc/相当于根目录/的数据。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/10/21/fileread.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/27/automake.html" class="post-title-link">
      <h2>autoconf和automake</h2>
    </a>

    <div class="post-date">Sep 27, 2018</div>
    
    <div class="post-body">
      
      <p>使用autoconf和automake两个工具来帮助我们自动地生成符合自由软件惯例的Makefile，这样就可以象常见的GNU程序一样，只要使用“./configure”，“make”，“make
 instal”就可以把程序安装到Linux系统中去了。这将特别适合想做开放源代码软件的程序开发人员，又或如果你只是自己写些小的Toy程序，那么这个文章对你也会有很大的帮助。
 
一、Makefile介绍
　　Makefile是用于自动编译和链接的，一个工程有很多文件组成，每一个文件的改变都会导致工程的重新链接，但是不是所有的文件都需要重新编译，Makefile中纪录有文件的信息，在make时会决定在链接的时候需要重新编译哪些文件。
　　Makefile的宗旨就是：让编译器知道要编译一个文件需要依赖其他的哪些文件。当那些依赖文件有了改变，编译器会自动的发现最终的生成文件已经过时，而重新编译相应的模块。
　　Makefile的基本结构不是很复杂，但当一个程序开发人员开始写Makefile时，经常会怀疑自己写的是否符合惯例，而且自己写的Makefile经常和自己的开发环境相关联，当系统环境变量或路径发生了变化后，Makefile可能还要跟着修改。这样就造成了手工书写Makefile的诸多问题，automake恰好能很好地帮助我们解决这些问题。
　　使用automake，程序开发人员只需要写一些简单的含有预定义宏的文件，由autoconf根据一个宏文件生成configure，由automake根据另一个宏文件生成Makefile.in，再使用configure依据Makefile.in来生成一个符合惯例的Makefile。下面我们将详细介绍Makefile的automake生成方法。
 
二、使用的环境
　　本文所提到的程序是基于Linux发行版本：Fedora Core release 1，它包含了我们要用到的autoconf，automake。
 
三、从helloworld入手
　　我们从大家最常使用的例子程序helloworld开始。
　　下面的过程如果简单地说来就是：
　　新建三个文件：　　helloworld.c　　configure.in　　Makefile.am
　　然后执行：autoscan; aclocal; autoconf; automake –add-missing; ./configure; make; ./helloworld;
　　就可以看到Makefile被产生出来，而且可以将helloworld.c编译通过。很简单吧，几条命令就可以做出一个符合惯例的Makefile，感觉如何呀。现在开始介绍详细的过程：
 
1、建目录
　　在你的工作目录下建一个helloworld目录，我们用它来存放helloworld程序及相关文件，如在/home/my/build下：
      $ mkdir helloword      $ cd helloworld</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/27/automake.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/26/bash.html" class="post-title-link">
      <h2>bash  2>&1</h2>
    </a>

    <div class="post-date">Sep 26, 2018</div>
    
    <div class="post-body">
      
      <p>“命令&gt;/dev/null 2&gt;&amp;1 ”等价于“命令 &amp;&gt;/dev/null ”
<!-- more -->
我们在Linux下经常会碰到nohup command&gt;/dev/null 2&gt;&amp;1 &amp;这样形式的命令。首先我们把这条命令大概分解下首先就是一个nohup表示当前用户和系统的回话下的进城忽略响应HUP消息。&amp;是把该命令以后台的job的形式运行。那么就剩下command&gt;/dev/null 2&gt;&amp;1,command&gt;/dev/null较好理解，/dev/null表示一个空设备，就是说吧command的执行结果重定向到空设备中，说白了就是不显示任何信息。那么2&gt;&amp;1又是什么含义?
2&gt;&amp;1
几个基本符号及其含义
/dev/null 表示空设备文件0 表示stdin标准输入1 表示stdout标准输出2 表示stderr标准错误从command&gt;/dev/null说起
其实这条命令是一个缩写版，对于一个重定向命令，肯定是a &gt; b这种形式，那么command &gt; /dev/null难道是command充当a的角色，/dev/null充当b的角色。这样看起来比较合理，其实一条命令肯定是充当不了a，肯定是command执行产生的输出来充当a，其实就是标准输出stdout。所以command &gt; /dev/null相当于执行了command 1 &gt; /dev/null。执行command产生了标准输出stdout(用1表示)，重定向到/dev/null的设备文件中。
说说2&gt;&amp;1
通过上面command &gt; /dev/null等价于command 1 &gt; /dev/null,那么对于2&gt;&amp;1也就好理解了，2就是标准错误，1是标准输出，那么这条命令不就是相当于把标准错误重定向到标准输出么。等等是&amp;1而不是1，这里&amp;是什么？这里&amp;相当于等效于标准输出。这里有点不好理解，先看下面。
command&gt;a 2&gt;a 与 command&gt;a 2&gt;&amp;1的区别
通过上面的分析，对于command&gt;a 2&gt;&amp;1这条命令，等价于command 1&gt;a 2&gt;&amp;1可以理解为执行command产生的标准输入重定向到文件a中，标准错误也重定向到文件a中。那么是否就说command 1&gt;a 2&gt;&amp;1等价于command 1&gt;a 2&gt;a呢。其实不是，command 1&gt;a 2&gt;&amp;1与command 1&gt;a 2&gt;a还是有区别的，区别就在于前者只打开一次文件a，后者会打开文件两次，并导致stdout被stderr覆盖。&amp;1的含义就可以理解为用标准输出的引用，引用的就是重定向标准输出产生打开的a。从IO效率上来讲，command
 1&gt;a 2&gt;&amp;1比command 1&gt;a 2&gt;a的效率更高。
举个栗子
来个shell
//test.sh
#!/bin/sh
t
date
chmod +x test.sh为test.sh增加执行权限。这里我们弄了两条命令，其中t指令并不存在，执行会报错，会输出到stderr。date能正常执行，执行会输出当前时间，会输出到stdout。
执行./test.sh &gt; res1.log结果为
我们发现stderr并没有被重定向到res1.log中，stderr被打印到了屏幕上。这也进一步证明了上面说的./test.sh &gt; res1.log等价于./test.sh 1&gt;res1.log
执行./test.sh&gt;res2.log 2&gt;&amp;1结果为
这次我们发现stdout和stderr都被重定向到了res2.log中了。上面我们未对stderr也就是2说明如何输出，stderr就输出到了屏 幕上，这里我们不仅对stdout进行说明，重定向到res2.log中，对标准错误也进行了说明，让其重定向到res2.log的引用即 res2.log的文件描述符中。
再思考一下
为何2&gt;&amp;1要写在command&gt;1的后面，直接用2可以么。比如ls 2&gt;a。其实这种用法也是可以的，ls命令列出当前的目录，用stdout（1）表示，由于这个时候没有stderr(2)，这个时候执行ls 2&gt;a也会正常产生一个a的文件，但是a的文件中是空的，因为这时候执行ls并没有产生stderr(2)。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/26/bash.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/23/uninterruptible.html" class="post-title-link">
      <h2>uninterruptible D 状态</h2>
    </a>

    <div class="post-date">Sep 23, 2018</div>
    
    <div class="post-body">
      
      <p>D状态即无法中断的休眠进程，是由于在等待IO，比如磁盘IO，网络IO，其他外设IO，如果进程正在等待的IO在较长的时间内都没有响应，那么就被ps看到了，同时也就意味着很有可能有IO出了问题，可能是外设本身出了故障，也可能是比如挂载的远程文件系统已经不可访问等操作时出现的问题。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/23/uninterruptible.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/23/bpf.html" class="post-title-link">
      <h2>LSF、BPF、eBPF</h2>
    </a>

    <div class="post-date">Sep 23, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>概览LSF(Linuxsocketfilter)起源于BPF(BerkeleyPacketFilter),基础从架构一致,但使用更简单。LSF内部的BPF最早是cBPF(classic),后来x86平台首先切换到eBPF(extended),但由于很多上层应用程序仍然使用cBPF(tcpdump、iptables),并且eBPF还没有支持很多平台,所以内核提供了从cBPF向eBPF转换的逻辑,并且eBPF在设计的时候也是沿用了很多cBPF的指令编码。但是在指令集合寄存器,还有
概览
LSF(Linux socket filter)起源于BPF(Berkeley Packet Filter),基础从架构一致,但使用更简单。LSF内部的BPF最早是cBPF(classic),后来x86平台首先切换到eBPF(extended),但由于很多上层应用程序仍然使用cBPF(tcpdump、iptables),并且eBPF还没有支持很多平台,所以内核提供了从cBPF向eBPF转换的逻辑,并且eBPF在设计的时候也是沿用了很多cBPF的指令编码。但是在指令集合寄存器,还有架构设计上有很大不同(例如eBPF已经可以调用C函数,并且可以跳转到另外的eBPF程序)。
但是新的eBPF一出来就被玩坏了,人们很快发现了它在内核trace方面的意义,它可以保证绝对安全的获取内核执行信息。是内核调试和开发者的不二选择,所以针对这个方面,例如kprobe、ktap、perf eBPF等优秀的工作逐渐产生。反而包过滤部门关注的人不够多。tc(traffic controll)是使用eBPF的一角优秀的用户端程序,它允许不用重新编译模块就可以动态添加删除新的流量控制算法。netfilter的xtable模块,配合xt_bpf模块,就可以实现将eBPF程序添加到hook点,来实现过滤。当然,内核中提供了从cBPF到eBPF编译的函数,所以,任何情况下想要使用cBPF都可以,内核会自动检测和编译。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/23/bpf.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/21/unix_socket.html" class="post-title-link">
      <h2>UNIX Domain Socket</h2>
    </a>

    <div class="post-date">Sep 21, 2018</div>
    
    <div class="post-body">
      
      <p>UNIX Domain Socket, 简称UDS, 
UDS的优势:</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/21/unix_socket.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/21/ptrace.html" class="post-title-link">
      <h2>ptrace</h2>
    </a>

    <div class="post-date">Sep 21, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>引子:
1.在Linux系统中，进程状态除了我们所熟知的TASK_RUNNING，TASK_INTERRUPTIBLE，TASK_STOPPED等，还有一个TASK_TRACED。这表明这个进程处于什么状态？
2.strace可以方便的帮助我们记录进程所执行的系统调用，它是如何跟踪到进程执行的？
3.gdb是我们调试程序的利器，可以设置断点，单步跟踪程序。它的实现原理又是什么？</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/21/ptrace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/21/LD_PRELOAD.html" class="post-title-link">
      <h2>LD_PRELOAD/DYLD_INSERT_LIBRARIES libc hook</h2>
    </a>

    <div class="post-date">Sep 21, 2018</div>
    
    <div class="post-body">
      
      <p>一、LD_PRELOAD是什么
LD_PRELOAD是Linux系统的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。
编译、设置指令
gcc mystrcmp.c -fPIC -shared -o libmystrcmp.so      #编译动态链接库
gcc myverifypasswd.c -L. -lmystrcmp -o myverifypasswd      #编译主程序
export LD_LIBRARY_PATH=/home/LD_PRELOAD      #指定动态链接库所在目录位置
ldd myverifypasswd      #显示、确认依赖关系
./myverifypasswd      #运行主程序myverifypasswd
二、LD_PRELOAD运用总结
定义与目标函数完全一样的函数，包括名称、变量及类型、返回值及类型等
将包含替换函数的源码编译为动态链接库
通过命令 export LD_PRELOAD=”库文件路径”，设置要优先替换动态链接库
如果找不替换库，可以通过 export LD_LIBRARY_PATH=库文件所在目录路径，设置系统查找库的目录
替换结束，要还原函数调用关系，用命令unset LD_PRELOAD 解除
想查询依赖关系，可以用ldd 程序名称
<!-- more -->
LD_PRELOAD：
在Unix操作系统的动态链接库的世界中，LD_PRELOAD就是这样一个环境变量
用以指定预先装载的一些共享库或目标文件，且无论程序是否依赖这些共享库或者文件，LD_PRELOAD指定的这些文件都会被装载
其优先级比LD_LIBRARY_PATH自定义的进程的共享库查找路径的执行还要早
全局符号介入
指在不同的共享库（对象）中存在同名符号时，一个共享对象中的全局符号被另一个共享对象的同名全局符号覆盖
因为LD_PRELOAD指定的共享库或者目标文件的装载顺序十分靠前，几乎是程序运行最先装载的，所以其中的全局符号如果和后面的库中的全局符号重名的话，就会覆盖后面装载的共享库或者目标文件中的全局符号。
因为装载顺序和全局符号介入的原理
它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。
这个功能主要就是用来有选择性的载入Unix操作系统不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/21/LD_PRELOAD.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/15/futex.html" class="post-title-link">
      <h2>futex</h2>
    </a>

    <div class="post-date">Sep 15, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>futex 设计成用户空间快速锁操作，由用户空间实现fastpath，以及内核提供锁竞争排队仲裁服务，由用户空间使用futex系统调用来实现slowpath。futex系统调用提供了三种配对的调用接口，满足不同使用场合的，分别为noraml futex，pi-futex，以及 requeue-pi。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/15/futex.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/14/strace.html" class="post-title-link">
      <h2>strace 原理</h2>
    </a>

    <div class="post-date">Sep 14, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>1.在Linux系统中，进程状态除了我们所熟知的TASK_RUNNING，TASK_INTERRUPTIBLE，TASK_STOPPED等，还有一个TASK_TRACED。这表明这个进程处于什么状态？
2.strace可以方便的帮助我们记录进程所执行的系统调用，它是如何跟踪到进程执行的？
3.gdb是我们调试程序的利器，可以设置断点，单步跟踪程序。它的实现原理又是什么？</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/14/strace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/14/libevent.html" class="post-title-link">
      <h2>libevent</h2>
    </a>

    <div class="post-date">Sep 14, 2018</div>
    
    <div class="post-body">
      
      <p>Memcached中的网络部分就是基于libevent完成的，其中的多线程模型就是典型的消息通知+同步层机制。
libevent是一个轻量级的基于事件驱动的高性能的开源网络库，并且支持多个平台，对多个平台的I/O复用技术进行了封装，当我们编译库的代码时，编译的脚本将会根据OS支持的处理事件机制，来编译相应的代码，从而在libevent接口上保持一致。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/14/libevent.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/14/c-ares.html" class="post-title-link">
      <h2>c-ares  dns 异步请求库</h2>
    </a>

    <div class="post-date">Sep 14, 2018</div>
    
    <div class="post-body">
      
      <p>https://github.com/c-ares/c-ares
是一个C语言实现的异步请求DNS的实现。很多知名 软件(curl、seastar、gevent、Nodejs等等)都使用了该软件。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/14/c-ares.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/13/makefile.html" class="post-title-link">
      <h2>makefile 及其工作原理</h2>
    </a>

    <div class="post-date">Sep 13, 2018</div>
    
    <div class="post-body">
      
      <p>Make程序最初设计是为了维护C程序文件防止不必要的重新编译。在使用命令行编译器的时候，修改了一个工程中的头文件，如何确保包含这个头文件的所有文件都得到编译？现在10机的版本生成是使用批处理程序，编译那些文件依赖于程序的维护者，在模块之间相互引用头文件的情况下，要将所有需要重新编译的文件找出来是一件痛苦的事情；在找到这些文件之后，修改批处理进行编译。实际上这些工作可以让make程序来自动完成，make工具对于维护一些具有相互依赖关系的文件特别有用，它对文件和命令的联系（在文件改变时调用来更新其它文件的程序）提供一套编码方法。Make工具的基本概念类似于Proglog语言，你告诉make需要做什么，提供一些规则，make来完成剩下的工作。
    make工作自动确定工程的哪部分需要重新编译，执行命令去编译它们。虽然make多用于C程序，然而只要提供命令行的编译器，你可以将其用于任何语言。实际上，make工具的应用范围不仅于编程，你可以描述任和一些文件改变需要自动更新另一些文件的任务来使用它。</p>

<p>规则简介
     makefile中的规则是这样的：
TARGET … : DEPENDENCIES …
COMMAND
 …
目标（TARGET）程序产生的文件，如可执行文件和目标文件；目标也可以是要执行的动作，如“clean”。
依赖（DEPENDENCIES）是用来产生目标的输入文件，一个目标通常依赖于多个文件。
命令（COMMAND）是make执行的动作，一个可以有多个命令，每个占一行。注意：每个命令行的起始字符必须为TAB字符！
    有依赖关系规则中的命令通常在依赖文件变化时负责产生target文件，make执行这些命令更新或产生target。规则可以没有依赖关系，如包含target “clean”的规则。
    规则解释如何和何时重做该规则中的文件，make根据依赖关系执行产生或更新目标；规则也说明如何和何时执行动作。有的规则看起来很复杂，但都符合上述模式。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/13/makefile.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/08/spinlock.html" class="post-title-link">
      <h2>spinlock 自旋锁</h2>
    </a>

    <div class="post-date">Sep 8, 2018</div>
    
    <div class="post-body">
      
      <p>自旋锁是专为防止多处理器并发而引入的一种锁，它在内核中大量应用于中断处理等部分（对于单处理器来说，防止中断处理中的并发可简单采用关闭中断的方式，即在标志寄存器中关闭/打开中断标志位，不需要自旋锁）。
何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。
跟互斥锁一样，一个执行单元要想访问被自旋锁保护的共享资源，必须先得到锁，在访问完共享资源后，必须释放锁。如果在获取自旋锁时，没有任何执行单元保持该锁，那么将立即得到锁；如果在获取自旋锁时锁已经有保持者，那么获取锁操作将自旋在那里，直到该自旋锁的保持者释放了锁。由此我们可以看出，自旋锁是一种比较低级的保护数据结构或代码片段的原始方式，这种锁可能存在两个问题：
死锁。试图递归地获得自旋锁必然会引起死锁：递归程序的持有实例在第二个实例循环，以试图获得相同自旋锁时，不会释放此自旋锁。在递归程序中使用自旋锁应遵守下列策略：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。此外如果一个进程已经将资源锁定，那么，即使其它申请这个资源的进程不停地疯狂“自旋”,也无法获得资源，从而进入死循环。
过多占用cpu资源。如果不加限制，由于申请者一直在循环等待，因此自旋锁在锁定的时候,如果不成功,不会睡眠,会持续的尝试,单cpu的时候自旋锁会让其它process动不了. 因此，一般自旋锁实现会有一个参数限定最多持续尝试次数. 超出后, 自旋锁放弃当前time slice. 等下一次机会。
由此可见，自旋锁比较适用于锁使用者保持锁时间比较短的情况。正是由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因此只能在进程上下文使用，而自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用。如果被保护的共享资源只在进程上下文访问，使用信号量保护该共享资源非常合适，如果对共享资源的访问时间非常短，自旋锁也可以。但是如果被保护的共享资源需要在中断上下文访问（包括底半部即中断处理句柄和顶半部即软中断），就必须使用自旋锁。自旋锁保持期间是抢占失效的，而信号量和读写信号量保持期间是可以被抢占的。自旋锁只有在内核可抢占或SMP（多处理器）的情况下才真正需要，在单CPU且不可抢占的内核下，自旋锁的所有操作都是空操作。
上面简要介绍了自旋锁的基本原理，以下将给出具体的例子，进一步阐释自旋锁在实际系统中的应用。上面我们已经讲过自旋锁只有在内核可抢占或SMP（多处理器）的情况下才真正需要，下面我们就以SMP为例，来说明为什么要使用自旋锁，以及自旋锁实现的基本算法。
实现编辑
在单处理机环境中可以使用特定的原子级汇编指令swap和test_and_set实现进程互斥，（Swap指令：交换两个内存单元的内容；test_and_set指令取出内存某一单元(位)的值，然后再给该单元(位)赋一个新值，关于为何这两条指令能实现互斥我们不在赘述，读者可以了解其算法） 这些指令涉及对同一存储单元的两次或两次以上操作，这些操作将在几个指令周期内完成，但由于中断只能发生在两条机器指令之间，而同一指令内的多个指令周期不可中断，从而保证swap指令或test_and_set指令的执行不会交叉进行.
但在多处理机环境中情况有所不同，例如test_and_set指令包括“取”、“送”两个指令周期，两个CPU执行test_and_set(lock)可能发生指令周期上的交叉，假如lock初始为0, CPU1和CPU2可能分别执行完前一个指令周期并通过检测(均为0)，然后分别执行后一个指令周期将lock设置为1，结果都取回0作为判断临界区空闲的依据，从而不能实现互斥. 如图4-3所示.
为在多CPU环境中利用test_and_set指令实现进程互斥，硬件需要提供进一步的支持，以保证test_and_set指令执行的原子性. 这种支持目前多以“锁总线”(bus locking)的形式提供的，由于test_and_set指令对内存的两次操作都需要经过总线，在执行test_and_set指令之前锁住总线，在执行test_and_set指令后开放总线，即可保证test_and_set指令执行的原子性，用法如下：
算法4-6：多处理机互斥算法（自旋锁算法）
do{
b=1;
while(b){
lock(bus);
b = test_and_set(&amp;lock);
unlock(bus);
}
临界区
lock = 0;
其余部分
}while(1)
总之，自旋锁是一种对多处理器相当有效的机制，而在单处理器非抢占式的系统中基本上没有作用。自旋锁在SMP系统中应用得相当普遍。在许多SMP系统中，允许多个处理机同时执行目态程序，而一次只允许一个处理机执行操作系统代码，利用一个自旋锁可以很容易实现这种控制．一次只允许一个CPU执行核心代码并发性不够高，若期望核心程序在多CPU之间的并行执行，将核心分为若干相对独立的部分，不同的CPU可以同时进入和执行核心中的不同部分，实现时可以为每个相对独立的区域设置一个自旋锁.
初衷编辑
事实上，自旋锁的初衷就是：在短期间内进行轻量级的锁定。一个被争用的自旋锁使得请求它的线程在等待锁重新可用的期间进行自旋(特别浪费处理器时间)，所以自旋锁不应该被持有时间过长。如果需要长时间锁定的话, 最好使用信号量。
1自旋锁实际上是忙等锁
当锁不可用时，CPU一直循环执行“测试并设置”该锁直到可用而取得该锁，CPU在等待自旋锁时不做任何有用的工作，仅仅是等待。因此，只有在占用锁的时间极短的情况下，使用自旋锁才是合理的。当临界区很大或有共享设备的时候，需要较长时间占用锁，使用自旋锁会降低系统的性能。
自旋锁可能导致系统死锁
引发这个问题最常见的情况是递归使用一个自旋锁，即如果一个已经拥有某个自旋锁的CPU 想第二次获得这个自旋锁，则该CPU 将死锁。此外，如果进程获得自旋锁之后再阻塞，也有可能导致死锁的发生。copy_from_user()、copy_to_user()和kmalloc()等函数都有可能引起阻塞，因此在自旋锁的占用期间不能调用这些函数。代码清单7.2 给出了自旋锁的使用实例，它被用于实现使得设备只能被最多一个进程打开。
基本形式编辑
自旋锁的基本形式如下：
spin_lock(&amp;mr_lock);
//临界区
spin_unlock(&amp;mr_lock);
因为自旋锁在同一时刻只能被最多一个内核任务持有，所以一个时刻只有一个线程允许存在于临界区中。这点很好地满足了对称多处理机器需要的锁定服务。在单处理器上，自旋锁仅仅当作一个设置内核抢占的开关。如果内核抢占也不存在，那么自旋锁会在编译时被完全剔除出内核。
简单的说，自旋锁在内核中主要用来防止多处理器中并发访问临界区，防止内核抢占造成的竞争。另外自旋锁不允许任务睡眠(持有自旋锁的任务睡眠会造成自死锁——因为睡眠有可能造成持有锁的内核任务被重新调度，而再次申请自己已持有的锁)，它能够在中断上下文中使用。
死锁：假设有一个或多个内核任务和一个或多个资源，每个内核都在等待其中的一个资源，但所有的资源都已经被占用了。这便会发生所有内核任务都在相互等待，但它们永远不会释放已经占有的资源，于是任何内核任务都无法获得所需要的资源，无法继续运行，这便意味着死锁发生了。自死琐是说自己占有了某个资源，然后自己又申请自己已占有的资源，显然不可能再获得该资源，因此就自缚手脚了。
<!-- more -->
自旋锁
    Linux的的内核最常见的锁是自旋锁。自旋锁最多只能被一个可执行线程持有。如果一个执行线程试图获得一个被已经持有（争用）的自旋锁，那么该线程就会一直进行忙循环-旋转-等待锁重新可用要是锁未被争用，请求锁的执行线程就可以立即得到它，继续执行。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/08/spinlock.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/05/aio.html" class="post-title-link">
      <h2>异步io</h2>
    </a>

    <div class="post-date">Sep 5, 2018</div>
    
    <div class="post-body">
      
      <p>linux下主要有两套异步IO，一套是由glibc实现的（以下称之为glibc版本）、一套是由linux内核实现，并由libaio来封装调用接口（以下称之为linux版本）。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/05/aio.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/03/popen.html" class="post-title-link">
      <h2>popen</h2>
    </a>

    <div class="post-date">Sep 3, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>popen()可以执行shell命令，并读取此命令的返回值；　　</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/03/popen.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/02/tee.html" class="post-title-link">
      <h2>零拷贝之splice( )函数和tee( )函数</h2>
    </a>

    <div class="post-date">Sep 2, 2018</div>
    
    <div class="post-body">
      
      <p>splice( )函数
在两个文件描述符之间移动数据，同sendfile( )函数一样，也是零拷贝。 
函数原型：</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/02/tee.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/02/splice_sendfile.html" class="post-title-link">
      <h2>splice_sendfile</h2>
    </a>

    <div class="post-date">Sep 2, 2018</div>
    
    <div class="post-body">
      
      <p>Linux传统I/O操作是一种缓冲I/O，在数据传输中，操作系统会将 I/O 的数据缓存在文件系统的页缓存中，即操作系统内核缓冲区中。 
比如：在网络中传输一个文件时，发送端应用程序会先检查内核缓冲区中有没有需要发送的这个文件的数据，如果没有，则会将这个文件从磁盘拷贝到内核缓冲区中，然后再从内核缓冲区拷贝到应用程序的用户缓冲区，如果应用程序不对数据进行处理或处理完毕之后，再将文件拷贝到内核中的socket发送缓冲区（比如TCP发送缓冲区），待内核socket缓冲区中有足够的数据时，就会把数据发送到网卡上，然后在网络上进行传输
其过程至少发生了四次数据的拷贝，其频繁的读写对CPU的使用和内存的带宽开销是非常大的。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/02/splice_sendfile.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/09/02/splice.html" class="post-title-link">
      <h2>splice</h2>
    </a>

    <div class="post-date">Sep 2, 2018</div>
    
    <div class="post-body">
      
      <ol>
  <li>splice函数
 #include <fcntl.h>
ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);</fcntl.h></li>
</ol>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/09/02/splice.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/08/30/sendfile.html" class="post-title-link">
      <h2>sendfile</h2>
    </a>

    <div class="post-date">Aug 30, 2018</div>
    
    <div class="post-body">
      
      <p>如今几乎每个人都听说过Linux中所谓的”零拷贝”特性，然而我经常碰到没有充分理解这个问题的人们。因此，我决定写一些文章略微深入的讲述这个问题，希望能将这个有用的特性解释清楚。在本文中，将从用户空间应用程序的角度来阐述这个问题，因此有意忽略了复杂的内核实现。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/08/30/sendfile.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/08/28/cgroup.html" class="post-title-link">
      <h2>cgroup</h2>
    </a>

    <div class="post-date">Aug 28, 2018</div>
    
    <div class="post-body">
      
      <p>1 什么是cgroup?</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/08/28/cgroup.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/08/22/access.html" class="post-title-link">
      <h2>Linux系统调用--access</h2>
    </a>

    <div class="post-date">Aug 22, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>【access系统调用】</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/08/22/access.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/08/14/ifconfig.html" class="post-title-link">
      <h2>ifconfig</h2>
    </a>

    <div class="post-date">Aug 14, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/08/14/ifconfig.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/08/11/time_wait.html" class="post-title-link">
      <h2>time_wait</h2>
    </a>

    <div class="post-date">Aug 11, 2018</div>
    
    <div class="post-body">
      
      <p>在服务器的日常维护过程中，会经常用到下面的命令：
netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’  <br />
它会显示例如下面的信息：
TIME_WAIT 814
CLOSE_WAIT 1
FIN_WAIT1 1
ESTABLISHED 634
SYN_RECV 2
LAST_ACK 1</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/08/11/time_wait.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/30/nginx_redis.html" class="post-title-link">
      <h2>nginx_redis 高并发</h2>
    </a>

    <div class="post-date">Jun 30, 2018</div>
    
    <div class="post-body">
      
      <p>Apache与Nginx：
Apache与Nginx的性能谁更高效，取决于其服务器的并发策略以及其面对的场景：</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/30/nginx_redis.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/30/multiplexing.html" class="post-title-link">
      <h2>multiplexing IO多路复用</h2>
    </a>

    <div class="post-date">Jun 30, 2018</div>
    
    <div class="post-body">
      
      <p>1 基础知识回顾
注意：咱们下面说的都是Linux环境下，跟Windows不一样哈~~~</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/30/multiplexing.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/30/kqueue.html" class="post-title-link">
      <h2>select,poll,epoll，kqueue模型</h2>
    </a>

    <div class="post-date">Jun 30, 2018</div>
    
    <div class="post-body">
      
      <p>概况: select()
select()和poll()的工作方式非常类似。让我们先快速看一下select()函数</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/30/kqueue.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/30/epoll_server.html" class="post-title-link">
      <h2>epoll_server 服务端代码</h2>
    </a>

    <div class="post-date">Jun 30, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>#include <iostream>
#include &lt;sys/socket.h&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h></errno.h></stdio.h></unistd.h></fcntl.h></iostream></p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/30/epoll_server.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/30/epoll.html" class="post-title-link">
      <h2>epoll</h2>
    </a>

    <div class="post-date">Jun 30, 2018</div>
    
    <div class="post-body">
      
      <p>epoll的核心是3个API，核心数据结构是：1个红黑树 和 1个链表</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/30/epoll.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/27/sysfs.html" class="post-title-link">
      <h2>sysfs</h2>
    </a>

    <div class="post-date">Jun 27, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>sysfs 文件系统总是被挂载在 /sys 挂载点上。虽然在较早期的2.6内核系统上并没有规定 sysfs 的标准挂载位置，可以把 sysfs 挂载在任何位置，但较近的2.6内核修正了这一规则，要求 sysfs 总是挂载在 /sys 目录上；针对以前的 sysfs 挂载位置不固定或没有标准被挂载，有些程序从 /proc/mounts 中解析出 sysfs 是否被挂载以及具体的挂载点，这个步骤现在已经不需要了。请参考附录给出的 sysfs-rules.txt 文件链接。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/27/sysfs.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/27/proc.html" class="post-title-link">
      <h2>proc文件系统</h2>
    </a>

    <div class="post-date">Jun 27, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>Linux系统上的/proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，/proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/27/proc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/27/lkm.html" class="post-title-link">
      <h2>lkm 可加载内核模块</h2>
    </a>

    <div class="post-date">Jun 27, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>最初开发 /proc 文件系统是为了提供有关系统中进程的信息。但是由于这个文件系统非常有用，因此内核中的很多元素也开始使用它来报告信息，或启用动态运行时配置。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/27/lkm.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/27/kobject.html" class="post-title-link">
      <h2>kobject</h2>
    </a>

    <div class="post-date">Jun 27, 2018</div>
    
    <div class="post-body">
      
      <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="https://xiazemin.github.io/MyBlog/img/kobject.jpeg"/&gt; &lt;!-- more --&gt; 1. kobject
</code></pre></div></div>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/27/kobject.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/27/dir.html" class="post-title-link">
      <h2>Linux各目录及每个目录的详细介绍</h2>
    </a>

    <div class="post-date">Jun 27, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/27/dir.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/27/devfs.html" class="post-title-link">
      <h2>devfs sysfs</h2>
    </a>

    <div class="post-date">Jun 27, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>linux下有专门的文件系统用来对设备进行管理，devfs和sysfs就是其中两种。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/27/devfs.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/26/pam.html" class="post-title-link">
      <h2>Linux中pam模块</h2>
    </a>

    <div class="post-date">Jun 26, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>Linux-PAM(linux可插入认证模块)是一套共享库，使本地系统管理员可以随意选择程序的认证方式。换句话说，不用重新编译一个包含PAM功能的应用程序，就可以改变它使用的认证机制。这种方式下,就算升级本地认证机制,也不用修改程序. PAM使用配置/etc/pam.d/下的文件,来管理对程序的认证方式.应用程序 调用相应的配置文件,从而调用本地的认证模块.模块放置在/lib/security下,以加载动态库的形式进，像我们使用su命令时,系统会提示你输入root用户的密码.这就是su命令通过调用PAM模块实现的。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/26/pam.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/26/issue.html" class="post-title-link">
      <h2>issue 设置linux登录前后的欢迎信息</h2>
    </a>

    <div class="post-date">Jun 26, 2018</div>
    
    <div class="post-body">
      
      <p>实现登录消息的功能，可以修改3个文件。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/26/issue.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/26/bash_profile.html" class="post-title-link">
      <h2>bash_profile等几个文件的执行过程</h2>
    </a>

    <div class="post-date">Jun 26, 2018</div>
    
    <div class="post-body">
      
      <p>利用~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次可以实现登录公告
$~/.bash_profile
if [ -f ～/.greeting ]; then . ～/.greeting; fi
$vi ～/.greeting
echo -e “^[[1m^[[4;37;32m公    告:^[[0m”
<!-- more --></p>
<ol>
  <li>在登录Linux时要执行文件的过程如下：</li>
</ol>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/26/bash_profile.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/12/subprocess.html" class="post-title-link">
      <h2>python中os.system、os.popen、subprocess.popen的区别</h2>
    </a>

    <div class="post-date">Jun 12, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>1.os.system
该函数返回命令执行结果的返回值，system()函数在执行过程中进行了以下三步操作： 
1.fork一个子进程； 
2.在子进程中调用exec函数去执行命令； 
3.在父进程中调用wait（阻塞）去等待子进程结束。 
对于fork失败，system()函数返回-1。 
由于使用该函数经常会莫名其妙地出现错误，但是直接执行命令并没有问题，所以一般建议不要使用。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/12/subprocess.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/12/sshpass.html" class="post-title-link">
      <h2>sshpass</h2>
    </a>

    <div class="post-date">Jun 12, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>　在使用ssh登录远程服务器的时候，在执行完ssh user@ip后，要输入登录密码，有时候登录密码记不住，这样以来Ian带来的很多的麻烦，有没有一种在ssh的参数中直接加入密码的方法呢？查看ssh的帮助我们发现ssh命令并不能在参数中制定密码。
usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]
           [-D [bind_address:]port] [-E log_file] [-e escape_char]
           [-F configfile] [-I pkcs11] [-i identity_file] [-L address]
           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]
           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]
           [-w local_tun[:remote_tun]] [user@]hostname</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/12/sshpass.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/12/samb.html" class="post-title-link">
      <h2>samba</h2>
    </a>

    <div class="post-date">Jun 12, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>利用samba解决。  在mac机上直接远程连接这个开发机（可以略过跳板机的限制）：Finder中，command+k，添加服务器地址，协议使用smb://hostname。
然后在phpstorm上，打开这个远程开发机上的项目。
直接在mac的IDE上搞运行环境上的代码，不用vi，不用再手动上传到开发机，甚至不用保存（ctrl+s等操作不必，因为更改的直接就是远程机器的代码），效率很不错。
分享一段samba配置文件中，怎么分享某个文件夹。
[myshare]
   ;comment = my share directory
   path = /home/work/xxx
   valid users = work
   write list = work
   force user = work
   force group = work
   public = yes
   writable = yes
   printable = no
   create mask = 0644
当然可以配置多个分享文件夹[xxx] ，只要复制这段配置即可。
值得一提的是，force user 和 force group这个选项比较重要，如果你很在意更改文件后，这个文件的owner和group的话。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/12/samb.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/12/pyopen.html" class="post-title-link">
      <h2>pyopen Python subprocess</h2>
    </a>

    <div class="post-date">Jun 12, 2018</div>
    
    <div class="post-body">
      
      <p>shkex 模块最常见的用法就是其中的split 函数，split 函数提供了和shell 处理命令行参数时一致的分隔方式</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/12/pyopen.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/12/dns.html" class="post-title-link">
      <h2>dns</h2>
    </a>

    <div class="post-date">Jun 12, 2018</div>
    
    <div class="post-body">
      
      <p>114.114.114.114和8.8.8.8，这两个IP地址都属于公共域名解析服务DNS其中的一部分，而且由于不是用于商业用途的，这两个DNS都很纯净，不用担心因ISP运营商导致的DNS劫持等问题，而且都是免费提供给用户使用的。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/12/dns.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/12/bind.html" class="post-title-link">
      <h2>bind</h2>
    </a>

    <div class="post-date">Jun 12, 2018</div>
    
    <div class="post-body">
      
      <p>你可以考虑使用bind，使用BIND作为服务器软件的DNS服务器约占所有DNS服务器的九成。这是官网：https://www.isc.org/downloads/bind/</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/12/bind.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/10/supervisor.html" class="post-title-link">
      <h2>supervisor</h2>
    </a>

    <div class="post-date">Jun 10, 2018</div>
    
    <div class="post-body">
      
      <p>后台需要持续运行这个二进制文件，保证服务的持续运行。
方案 1：
直接采用 nohup ./app_admin &amp;后台运行方式，该方式存在一个缺点，如果服务器重启后，或者程序运行出错的话，服务就会终止，这种方式不稳定。
方案 2：
采用supervisor进程管理方式守护go语言的二进制文件运行，保证程序的持续运行。
Supervisor（http://supervisord.org/）是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具，不支持Windows系统。它可以很方便的监听、启动、停止、重启一个或多个进程。用Supervisor管理的进程，当一个进程意外被杀死，supervisort监听到进程死后，会自动将它重新拉起，很方便的做到进程自动恢复的功能，不再需要自己写shell脚本来控制。
因为Supervisor是Python开发的，安装前先检查一下系统否安装了Python2.4以上版本
superviosr是一个Linux/Unix系统上的进程监控工具，他/她upervisor是一个Python开发的通用的进程管理程序，可以管理和监控Linux上面的进程，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。不过同daemontools一样，它不能监控daemon进程
supervisor管理进程，是通过fork/exec的方式将这些被管理的进程当作supervisor的子进程来启动，所以我们只需要将要管理进程的可执行文件的路径添加到supervisor的配置文件中就好了。此时被管理进程被视为supervisor的子进程，若该子进程异常中断，则父进程可以准确的获取子进程异常中断的信息，通过在配置文件中设置autostart=ture，可以实现对异常中断的子进程的自动重启。
安装supervisor
$ sudo apt-get install supervisor
配置文件
安装完supervisor后，输入以下命令可得到配置文件：
$ echo supervisord.conf
或者：
$ cat /etc/supervisord/supervisord.conf
<!-- more -->
配置文件用到几个部分：</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/10/supervisor.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/06/03/dtrace.html" class="post-title-link">
      <h2>dtrace</h2>
    </a>

    <div class="post-date">Jun 3, 2018</div>
    
    <div class="post-body">
      
      <p>我们在分析各种系统异常和故障的时候，通常会用到 pstack(jstack) /pldd/ lsof/ tcpdump/ gdb(jdb)/ netstat/vmstat/ mpstat/truss(strace)/iostat/sar/nmon(top)等系列工具，这些工具从某个方面为我们提供了诊断信息。但这些工具常常带有各类“副作用”，比如 truss(见于 AIX/Solaris) 或者 strace(见于 Linux) 能够让我们检测我们应用的系统调用情况，包括调用参数和返回值，但是却会导致应用程序的性能下降；这对于诊断毫秒级响应的计费生产系统来说，影响巨大。
有没有一个工具，能够兼得上述所有工具的优点，又没有副作用呢？答案是有！对于 Solaris/BSD/OS X 系统来说，那就是 DTrace 工具（后来，Linux 也终于有了自己类似的工具，stap）。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/06/03/dtrace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/30/zebra.html" class="post-title-link">
      <h2>zebra</h2>
    </a>

    <div class="post-date">May 30, 2018</div>
    
    <div class="post-body">
      
      <p>Zebra是一个路由软件包，提供基于TCP/IP路由服务，支持RIPv1, RIPv2, RIPng, OSPFv2, OSPFv3, BGP- 4,</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/30/zebra.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/30/rawip.html" class="post-title-link">
      <h2>rawip</h2>
    </a>

    <div class="post-date">May 30, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>一、INET协议族说明</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/30/rawip.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/30/ospf.html" class="post-title-link">
      <h2>ospf</h2>
    </a>

    <div class="post-date">May 30, 2018</div>
    
    <div class="post-body">
      
      <p>OSPF(Open Shortest Path First开放式最短路径优先）是一个内部网关协议(Interior Gateway Protocol，简称IGP），用于在单一自治系统（autonomous system,AS）内决策路由。是对链路状态路由协议的一种实现，隶属内部网关协议（IGP），故运作于自治系统内部。著名的迪克斯加算法(Dijkstra)被用来计算最短路径树。OSPF分为OSPFv2和OSPFv3两个版本,其中OSPFv2用在IPv4网络，OSPFv3用在IPv6网络。OSPFv2是由RFC 2328定义的，OSPFv3是由RFC 5340定义的。与RIP相比，OSPF是链路状态协议，而RIP是距离矢量协议。
<!-- more -->
1.OSPF协议的基本原理：</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/30/ospf.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/30/nabour.html" class="post-title-link">
      <h2>邻居子系统</h2>
    </a>

    <div class="post-date">May 30, 2018</div>
    
    <div class="post-body">
      
      <p>一：邻居子系统概述
邻居子系统是从物理来说是指在同一个局域网内的终端。从网络拓扑的结构来说，是指他们之间相隔的距离仅为一跳，他们属于同一个突冲域 邻居子系统的作用:它为第三层协议与第二层协议提供地址映射关系。提供邻居头部缓存，加速发包的速度
二：邻居子系统在整个协议栈的地位
发送数据的时候，要在本机进行路由查找，如果有到目的地地址的路径，查看arp缓存中是否存在相应的映射关系，如果没有，则新建邻居项。判断邻居项是否为可用状态。如果不可用。把skb 存至邻居发送对列中，然后将发送arp请求。如果接收到arp应答。则将对应邻居项置为可用。如果在指定时间内末收到响应包，则将对应邻居项置为无效状态。如果邻居更改为可用状态，则把邻居项对应的skb对列中的数据包发送出去
三：流程概述；
发包流程。下面以包送udp数据为例，看看是怎么与邻居子系统相关联的Sendmsg()  à  ip_route_output()(到路由缓存中查找目的出口)à  ip_route_output_slow( 如果缓存中不存在目的项，则到路由表中查找)     à         ip_build_xmit() à output_maybe_reroute à skb-&gt;dst-&gt;output()如果至时找到了路由，则根据路由信息分配个dst_entry，并调用arp_bind_neighbour为之绑定邻居 output指针赋值为ip_output 转到执行ip_output ip_output à __ip_finish_output() -à ip_finish_output2() à dst-&gt;neighbour-&gt;output()现在就转至邻居项的出口函数了。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/30/nabour.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/30/gpio.html" class="post-title-link">
      <h2>General Purpose Input Output</h2>
    </a>

    <div class="post-date">May 30, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>控制GPIO的目录/sys/class/gpio
/sys/class/gpio/export文件用于通知系统需要导出控制的GPIO引脚编号
/sys/class/gpio/unexport 用于通知系统取消导出
/sys/class/gpio/gpiochipX目录保存系统中GPIO寄存器的信息，包括每个寄存器控制引脚的起始编号base，寄存器名称，引脚总数 导出一个引脚的操作步骤
direction文件，定义输入输入方向，可以通过下面命令定义为输出。direction接受的参数：in, out, high, low。high/low同时设置方向为输出，并将value设置为相应的1/0
value文件是端口的数值，为1或0</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/30/gpio.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/30/Traffic_ctl.html" class="post-title-link">
      <h2>流量控制</h2>
    </a>

    <div class="post-date">May 30, 2018</div>
    
    <div class="post-body">
      
      <p>Traffic Control ,简称TC，主要是在输出端口处建立一个队列进行流量控制，控制的方式是基于路由，亦即基于目的IP地址或目的子网的网络号的流量控制。流量控制器TC， 其基本的功能模块为队列、分类和过滤器。Linux内核中支持的队列有，Class Based Queue ，Token Bucket Flow ，CSZ ，First In First Out ，Priority ，TEQL ，SFQ ，ATM ，RED。这里我们讨论的队列与分类都是基于CBQ(Class Based Queue)的，而过滤器是基于路由(Route)的。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/30/Traffic_ctl.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/28/transparent.html" class="post-title-link">
      <h2>透明网桥</h2>
    </a>

    <div class="post-date">May 28, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>透明网桥是一种即插即用设备，只要把网桥接入局域网，不需要改动硬件和软件，无需设置地址开关，无需装入路由表或参数，网桥就能工作。
透明网桥以混杂方式工作，它接收与之连接的所有LAN传送的每一帧。当一帧到达时，网桥必须决定将其丢弃还是转发。如果要转发，则必须决定发往哪个LAN。这需要通过查询网桥中一张大型散列表里的目的地址而作出决定。该表可列出每个可能的目的地，以及它属于哪一条输出线路(LAN)。在插入网桥之初，所有的散列表均为空。这时若网桥受到一个帧，会采用自学习（self-learning）算法处理收到的帧（这样就逐渐建立起转发表），并且按照转发表把帧转发出去。这种自学习算法的原理并不复杂，若从某个站A发出的帧从接口x进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到A。所以网桥只要每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。在建立转发表时是把帧首部中的源地址写在“地址”这一栏的下面。在转发帧时，则是根据收到的帧首部中的目的地址来转发的。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。
如果网络上的每一个站都发送过帧，那么每一个帧的地址最终都会记录在两个网桥的转发表上。
实际上，在网桥的转发表中写入的信息除了地址和接口外，还有帧进入该网桥的时间要登记进入网桥的时间是因为以太网的拓扑可能会经常发生变化，站点也会更换适配器。另外，以太网上的工作站并非总是接通电源的。把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的最新状态信息。具体方法是，网桥中的接口管理软件周期性地扫描转发表中的项目。只要在一定时间以前登记的都要删除。这样就使得网桥中的转发表能反映当前网络的最新拓扑状态。
由此可见，网桥中的转发信息表并非总是包含所有站点的信息。只要某个站点从来都不发送数据，那么在网桥的转发表中就没有这个站点的项目。如果站点A在一段时间内不发送数据，那么在转发表中地址为A的项目就被删除了。
下面是网桥的自学习和转发帧的一般步骤。
网桥收到一帧后先进行自学习。查找转发表中与收到帧的源地址有无相匹配的项目。如果没有，就在转发表中增加一个项目。如果有，则把原有的项目进行更新。
转发帧。查找转发表中与收到帧的源地址有无相匹配的项目。如果没有，则通过所有其他接口进行转发。如果有，则按转发表中给出的接口进行转发。但应注意，若转发表中给出的接口就是该帧进入网桥的接口，则应丢弃这个帧。
逆向学习法
透明网桥采用的算法是逆向学习法(backward learning)。网桥按混杂的方式工作，故它能看见所连接的任一LAN上传送的帧。查看源地址即可知道在哪个LAN上可访问哪台机器，于是在散列表中添上一项。
当计算机和网桥加电、断电或迁移时，网络的拓扑结构会随之改变。为了处理动态拓扑问题，每当增加散列表项时，均在该项中注明帧的到达时间。每当目的地已在表中的帧到达时，将以当前时间更新该项。这样，从表中每项的时间即可知道该机器最后帧到来的时间。网桥中有一个进程定期地扫描散列表，清除时间早于当前时间若干分钟的全部表项。于是，如果从LAN上取下一台计算机，并在别处重新连到LAN上的话，那么在几分钟内，它即可重新开始正常工作而无须人工干预。这个算法同时也意味着，如果机器在几分钟内无动作，那么发给它的帧将不得不散发，一直到它自己发送出一帧为止。
到达帧的路由选择过程取决于发送的LAN(源LAN)和目的地所在的LAN(目的LAN)，如下所示：
1、如果源LAN和目的LAN相同，则丢弃该帧。
2、如果源LAN和目的LAN不同，则转发该帧。
3、如果目的LAN未知，则进行扩散。
为了提高可靠性，有人在LAN之间设置了并行的两个或多个网桥，但是，这种配置引起了另外一些问题，因为在拓扑结构中产生了回路，可能引发无限循环。
生成树算法
透明网桥还使用了一个生成树（spanning tree）算法，即互连在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集。在这个子集里，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。
为了得能够反映网络拓扑发生变化时的生成树，在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新。
透明网桥的路径选择算法归纳
（1）若目的局域网和源局域网一样，则网桥将该帧删除。
（2）若源局域网和目的局域网是不同的网，则将该帧转发到目的局域网。
（3）若目的局域网不知道，则采用扩散法处理。</p>

    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/28/transparent.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/28/tcpdump.html" class="post-title-link">
      <h2>tcpdump</h2>
    </a>

    <div class="post-date">May 28, 2018</div>
    
    <div class="post-body">
      
      <p>tcpdump采用命令行方式对接口的数据包进行筛选抓取，其丰富特性表现在灵活的表达式上。
不带任何选项的tcpdump，默认会抓取第一个网络接口，且只有将tcpdump进程终止才会停止抓包。
例如：
shell&gt; tcpdump -nn -i eth0 icmp
下面是详细的tcpdump用法。
1.1 tcpdump选项
它的命令格式为：
tcpdump [ -DenNqvX ] [ -c count ] [ -F file ] [ -i interface ] [ -r file ]
        [ -s snaplen ] [ -w file ] [ expression ]</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/28/tcpdump.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/28/stp.html" class="post-title-link">
      <h2>stp 生成树协议</h2>
    </a>

    <div class="post-date">May 28, 2018</div>
    
    <div class="post-body">
      
      <p>生成树协议是一种二层管理协议，它通过有选择性地阻塞网络冗余链路来达到消除网络二层环路的目的，同时具备链路的备份功能。
由于生成树协议本身比较小，所以并不像路由协议那样广为人知。但是它却掌管着端口的转发大权—“小树枝抖一抖，上层协议就得另谋生路”。真实情况也确实如此，特别是在和别的协议一起运行的时候，生成树就有可能断了其他协议的报文通路，造成种种奇怪的现象。
生成树协议和其他协议一样，是随着网络的不断发展而不断更新换代的。本文标题中的“生成树协议”是一个广义的概念，并不是特指IEEE 802.1D中定义的STP协议，而是包括STP以及各种在STP基础上经过改进了的生成树协议。
在生成树协议发展过程中，老的缺陷不断被克服，新的特性不断被开发出来。按照大功能点的改进情况，我们可以粗略地把生成树协议的发展过程划分成三代，下面一一道来。
开天辟地的第一代生成树协议：
STP/RSTP
在网络发展初期，透明网桥是一个不得不提的重要角色。它比只会放大和广播信号的集线器聪明得多。它会悄悄把发向它的数据帧的源MAC地址和端口号记录下来，下次碰到这个目的MAC地址的报文就只从记录中的端口号发送出去，除非目的MAC地址没有记录在案或者目的MAC地址本身就是多播地址才会向所有端口发送。通过透明网桥，不同的局域网之间可以实现互通，网络可操作的范围得以扩大，而且由于透明网桥具备MAC地址学习功能而不会像Hub那样造成网络报文冲撞泛滥。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/28/stp.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/28/napi.html" class="post-title-link">
      <h2>NAPI 技术在 Linux 网络驱动上的应用</h2>
    </a>

    <div class="post-date">May 28, 2018</div>
    
    <div class="post-body">
      
      <p>NAPI是Linux新的网卡数据处理API，据说是由于找不到更好的名字，所以就叫NAPI(New API)，在2.5之后引入。简单来说，NAPI是综合中断方式与轮询方式的技术。中断的好处是响应及时，如果数据量较小，则不会占用太多的CPU事件；缺点是数据量大时，会产生过多中断，而每个中断都要消耗不少的CPU时间，从而导致效率反而不如轮询高。轮询方式与中断方式相反，它更适合处理大量数据，因为每次轮询不需要消耗过多的CPU时间；缺点是即使只接收很少数据或不接收数据时，也要占用CPU时间。
NAPI是两者的结合，数据量低时采用中断，数据量高时采用轮询。平时是中断方式，当有数据到达时，会触发中断
处理函数执行，中断处理函数关闭中断开始处理。如果此时有数据到达，则没必要再触发中断了，因为中断处理函
数中会轮询处理数据，直到没有新数据时才打开中断。
很明显，数据量很低与很高时，NAPI可以发挥中断与轮询方式的优点，性能较好。如果数据量不稳定，且说高不高
说低不低，则NAPI则会在两种方式切换上消耗不少时间，效率反而较低一些。
来看下NAPI和非NAPI的区别：
(1) 支持NAPI的网卡驱动必须提供轮询方法poll()。
(2) 非NAPI的内核接口为netif_rx()，NAPI的内核接口为napi_schedule()。
(3) 非NAPI使用共享的CPU队列softnet_data-&gt;input_pkt_queue，NAPI使用设备内存(或者
设备驱动程序的接收环)。
(1) NAPI设备结构
/* Structure for NAPI scheduling similar to tasklet but with weighting */</p>

<p>struct napi_struct {<br />
    /* The poll_list must only be managed by the entity which changes the 
     * state of the NAPI_STATE_SCHED bit. This means whoever atomically 
     * sets that bit can add this napi_struct to the per-cpu poll_list, and 
     * whoever clears that bit can remove from the list right before clearing the bit. 
     <em>/<br />
    struct list_head poll_list; /</em> 用于加入处于轮询状态的设备队列 <em>/<br />
    unsigned long state; /</em> 设备的状态 <em>/<br />
    int weight; /</em> 每次处理的最大数量，非NAPI默认为64 <em>/<br />
    int (</em>poll) (struct napi_struct <em>, int); /</em> 此设备的轮询方法，非NAPI为process_backlog() <em>/ <br />
 #ifdef CONFIG_NETPOLL<br />
    …<br />
 #endif<br />
    unsigned int gro_count;<br />
    struct net_device *dev;<br />
    struct list_head dev_list;<br />
    struct sk_buff *gro_list;<br />
    struct sk_buff *skb;<br />
};<br />
(2) 初始化
初始napi_struct实例。
void netif_napi_add(struct net_device *dev, struct napi_struct *napi,<br />
        int (</em>poll) (struct napi_struct <em>, int), int weight)<br />
{<br />
    INIT_LIST_HEAD(&amp;napi-&gt;poll_list);<br />
    napi-&gt;gro_count = 0;<br />
    napi-&gt;gro_list = NULL;<br />
    napi-&gt;skb = NULL;<br />
    napi-&gt;poll = poll; /</em> 设备的poll函数 <em>/<br />
    napi-&gt;weight = weight; /</em> 设备每次poll能处理的数据包个数上限 */</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>list_add(&amp;napi-&gt;dev_list, &amp;dev-&gt;napi_list); /* 加入设备的napi_list */  
napi-&gt;dev = dev; /* 所属设备 */     #ifdef CONFIG_NETPOLL  
spin_lock_init(&amp;napi-&gt;poll_lock);  
napi-&gt;poll_owner = -1;    #endif  
set_bit(NAPI_STATE_SCHED, &amp;napi-&gt;state); /* 设置NAPI标志位 */   }   (3) 调度 在网卡驱动的中断处理函数中调用napi_schedule()来使用NAPI。 /**   * napi_schedule - schedule NAPI poll   * @n: napi context   * Schedule NAPI poll routine to be called if it is not already running.   */    static inline void napi_schedule(struct napi_struct *n)   {  
/* 判断是否可以调度NAPI */  
if (napi_schedule_prep(n))  
    __napi_schedule(n);   }   判断NAPI是否可以调度。如果NAPI没有被禁止，且不存在已被调度的NAPI， 则允许调度NAPI，因为同一时刻只允许有一个NAPI poll instance。 /**   * napi_schedule_prep - check if napi can be scheduled   * @n: napi context   * Test if NAPI routine is already running, and if not mark it as running.   * This is used as a condition variable insure only one NAPI poll instance runs.   * We also make sure there is no pending NAPI disable.   */  
</code></pre></div></div>

<p>static inline int napi_schedule_prep(struct napi_struct *n)<br />
{<br />
    return !napi_disable_pending(n) &amp;&amp; !test_and_set_bit(NAPI_STATE_SCHED, &amp;n-&gt;state);<br />
}</p>

<p>static inline int napi_disable_pending(struct napi_struct *n)<br />
{<br />
    return test_bit(NAPI_STATE_DISABLE, &amp;n-&gt;state);<br />
}</p>

<p>enum {<br />
    NAPI_STATE_SCHED, /* Poll is scheduled <em>/<br />
    NAPI_STATE_DISABLE, /</em> Disable pending <em>/<br />
    NAPI_STATE_NPSVC, /</em> Netpoll - don’t dequeue from poll_list */<br />
};<br />
NAPI的调度函数。把设备的napi_struct实例添加到当前CPU的softnet_data的poll_list中，</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/28/napi.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/28/ethereal.html" class="post-title-link">
      <h2>ethereal</h2>
    </a>

    <div class="post-date">May 28, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>Ethereal （Ethereal：A Network Packet Sniffing Tool）是当前较为流行的一种计算机网络调试和数据包嗅探软件。Ethereal 基本类似于tcpdump，但Ethereal 还具有设计完美的 GUI 和众多分类信息及过滤选项。用户通过 Ethereal，同时将网卡插入混合模式，可以查看到网络中发送的所有通信流量。 Ethereal 应用于故障修复、分析、软件和协议开发以及教育领域。它具有用户对协议分析器所期望的所有标准特征，并具有其它同类产品所不具备的有关特征。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/28/ethereal.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/24/inotify.html" class="post-title-link">
      <h2>inotify 监控 Linux 文件系统事件</h2>
    </a>

    <div class="post-date">May 24, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>从文件管理器到安全工具，文件系统监控对于的许多程序来说都是必不可少的。从 Linux 2.6.13 内核开始，Linux 就推出了 inotify，允许监控程序打开一个独立文件描述符，并针对事件集监控一个或者多个文件，例如打开、关闭、移动/重命名、删除、创建或者改变属性。在后期的内核中有了很多增强，因此在依赖这些特性之前，请先检查您的内核版本。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/24/inotify.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/24/fsnotify.html" class="post-title-link">
      <h2>fsnotify</h2>
    </a>

    <div class="post-date">May 24, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>linux的2.6.11内核之后有了inotify，这个特性确实很不错，使得很多用户策略得以实现，但是这个特性的代码实现却不是那么好，说实话很乱，很难扩展，很多链表，抽象出的dev结构也不是那么符合逻辑，只不过是为了将各种杂乱的数据结合在一起的勉强罢了。近期由于换工作一直没有关注kernel方面的更新，今天在新工作敲定以后终于有时间看看kernel最新的进展了，发现2.6.31版本的内核中对notify进行了一番大的改动，将原来的inotify和dnotify这两个不想关的特性进行了抽象，将它们的共同的点抽象成了一个基础设施，这个基础设施就是fsnotify.</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/24/fsnotify.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/05/06/iptables.html" class="post-title-link">
      <h2>iptables</h2>
    </a>

    <div class="post-date">May 6, 2018</div>
    
    <div class="post-body">
      
      <p>ptables是linux自带的一款开源的内核级基于数据包过滤的防火墙。利用iptables可以实现诸如数据包过滤、转发等功能。
iptables包含表，表中包含链，链中包含规则。（规则指的是一条条用于过滤数据包的语句）
iptables共有四个表五个链，简称四表五链。
四表指的是filter, nat, mangle, raw。其中前2个是用的最多的，后面2个用的较少，raw可以说基本不怎么使用。
五链指的是INPUT, OUTPUT, FORWARD, PREROUTING, POSTROUTING。（注意，链名用大写。）
<!-- more -->
filter表
过滤数据包，用于本机防火墙，这是默认表。
包含的三个链，
INPUT 链：用于过滤所有目标地址是本机的数据包
OUTPUT 链：用于过滤所有本机产生的数据包
FORWARD链：用于过滤所有路过本机的数据包</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/05/06/iptables.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/29/veth.html" class="post-title-link">
      <h2>veth</h2>
    </a>

    <div class="post-date">Apr 29, 2018</div>
    
    <div class="post-body">
      
      <p>Linux container 中用到一个叫做veth的东西，这是一种新的设备，专门为 container 所建。veth 从名字上来看是 Virtual ETHernet 的缩写，它的作用很简单，就是要把从一个 network namespace 发出的数据包转发到另一个 namespace。veth 设备是成对的，一个是 container 之中，另一个在 container 之外，即在真实机器上能看到的。 
  VETH设备总是成对出现，送到一端请求发送的数据总是从另一端以请求接受的形式出现。创建并配置正确后，向其一端输入数据，VETH会改变数据的方向并将其送入内核网络子系统，完成数据的注入，而在另一端则能读到此数据。（Namespace，其中往veth设备上任意一端上RX到的数据，都会在另一端上以TX的方式发送出去）veth工作在L2数据链路层，veth-pair设备在转发数据包过程中并不串改数据包内容。 
<!-- more -->
  显然，仅有veth-pair设备，容器是无法访问网络的。因为容器发出的数据包，实质上直接进入了veth1设备的协议栈里。如果容器需要访问网络，需要使用bridge等技术，将veth1接收到的数据包通过某种方式转发出去 
创建veth的命令如下：
ip link add name veth0 type veth0 peer name veth1
veth设备特点
veth和其它的网络设备都一样，一端连接的是内核协议栈
veth设备是成对出现的，另一端两个设备彼此相连
一个设备收到协议栈的数据发送请求后，会将数据发送到另一个设备上去
常用命令
创建network namespace
 # ip netns add sunldnamespace01
 # ip netns list
sunldnamespace01
创建veth
 # ip link add sunldveth01 type veth peer name sunldveth02
 # ip link list
显示信息如下：
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:2d:d4:23 brd ff:ff:ff:ff:ff:ff
20: sunldveth02: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether c6:bb:c0:d0:54:71 brd ff:ff:ff:ff:ff:ff
21: sunldveth01: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether da:a1:36:d1:3b:36 brd ff:ff:ff:ff:ff:ff
添加网卡到namespace
 # ip link set sunldveth01 netns sunldnamespace01
查看当前namespace中的veth，只有sunldveth02
 # ip link list
显示信息如下
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:2d:d4:23 brd ff:ff:ff:ff:ff:ff
3: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default 
    link/ether ba:d9:d4:48:55:65 brd ff:ff:ff:ff:ff:ff
20: sunldveth02: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether c6:bb:c0:d0:54:71 brd ff:ff:ff:ff:ff:ff
通过命令查看sunldnamespace01中的veth
 # ip netns exec sunldnamespace01 ip link list
显示信息如下
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
21: sunldveth01: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether da:a1:36:d1:3b:36 brd ff:ff:ff:ff:ff:ff
配置network namespace的网口
 # ip netns exec sunldnamespace01 ifconfig sunldveth01 100.2.96.2/16 up
 # ip netns exec sunldnamespace01 ip addr list
显示信息如下
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
21: sunldveth01: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000
    link/ether da:a1:36:d1:3b:36 brd ff:ff:ff:ff:ff:ff
    inet 100.2.96.2/16 brd 100.2.255.255 scope global sunldveth01
       valid_lft forever preferred_lft forever
开启空间脚本
 #可以使用这条命令开启一个 ns0 的 shell 
ip netns exec ns0 sh
network namespace
创建network namespace
 # ip netns add blue
 # ip netns list
blue
添加网口到namespace
先创建veth
 # ip link add veth0 type veth peer name veth1
在当前namespace可以看到veth0和veth1
 # ip link list
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:b2:cf:72 brd ff:ff:ff:ff:ff:ff
3: veth1: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 1000
    link/ether ae:0d:00:e1:11:38 brd ff:ff:ff:ff:ff:ff
4: veth0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 1000
    link/ether 42:e7:50:d4:bb:c5 brd ff:ff:ff:ff:ff:ff
将veth1加到namespace “blue”
 # ip link set veth1 netns blue
此时，当前namepapce只能看到veth0。
通过如下命令可以查看blue namespace的网口
 # ip netns exec blue ip link list
配置network namespace的网口
通过ip netns exec可以配置namespace的网口
 # ip netns exec blue ifconfig veth1 172.17.42.2/16 up
network namespace的网口与物理网卡的通信通过bridge来实现。
 # add the namespaces
ip netns add ns1
ip netns add ns2
 # create the veth pair
ip link add tap1 type veth peer name tap2
 # move the interfaces to the namespaces
ip link set tap1 netns ns1
ip link set tap2 netns ns2
 # bring up the links
ip netns exec ns1 ip link set dev tap1 up
ip netns exec ns2 ip link set dev tap2 up</LOOPBACK></LOOPBACK></p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/29/veth.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/29/namespace.html" class="post-title-link">
      <h2>linux namespace</h2>
    </a>

    <div class="post-date">Apr 29, 2018</div>
    
    <div class="post-body">
      
      <p>Linux Namespace是Linux提供的一种内核级别环境隔离的方法。不知道你是否还记得很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。
举个例子，我们都知道，Linux下的超级父亲进程的PID是1，所以，同chroot一样，如果我们可以把用户的进程空间jail到某个进程分支下，并像chroot那样让其下面的进程 看到的那个超级父进程的PID为1，于是就可以达到资源隔离的效果了（不同的PID namespace中的进程无法看到彼此）
Linux Namespace 有如下种类，官方文档在这里《Namespace in Operation》
分类	系统调用参数	相关内核版本
Mount namespaces	CLONE_NEWNS	Linux 2.4.19
UTS namespaces	CLONE_NEWUTS	Linux 2.6.19
IPC namespaces	CLONE_NEWIPC	Linux 2.6.19
PID namespaces	CLONE_NEWPID	Linux 2.6.24
Network namespaces	CLONE_NEWNET	始于Linux 2.6.24 完成于 Linux 2.6.29
User namespaces	CLONE_NEWUSER	始于 Linux 2.6.23 完成于 Linux 3.8)
主要是三个系统调用
clone() – 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。
unshare() – 使某进程脱离某个namespace
setns() – 把某进程加入到某个namespace
User Namespace主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。
要把容器中的uid和真实系统的uid给映射在一起，需要修改 /proc/<pid>/uid_map 和 /proc/<pid>/gid_map 这两个文件。这两个文件的格式为：
ID-inside-ns ID-outside-ns length
其中：
第一个字段ID-inside-ns表示在容器显示的UID或GID，
第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。
第三个字段表示映射的范围，一般填1，表示一一对应。
比如，把真实的uid=1000映射成容器内的uid=0
$ cat /proc/2465/uid_map
         0       1000          1
再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形
$ cat /proc/$$/uid_map
         0          0          4294967295
另外，需要注意的是：
写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限（可参看Capabilities）
写入的进程必须是此user namespace的父或子的user namespace进程。
另外需要满如下条件之一：1）父进程将effective uid/gid映射到子进程的user namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。
<!-- more -->
当你启动一个Docker容器后，你可以使用ip link show或ip addr show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的） 
 # 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）
ip netns exec ns1  ip link set dev veth-ns1 name eth0 
 # 为容器中的网卡分配一个IP地址，并激活它
ip netns exec ns1 ifconfig eth0 192.168.10.11/24 up
 # 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上
brctl addif lxcbr0 lxcbr0.1
 # 为容器增加一个路由规则，让容器可以访问外面的网络
ip netns exec ns1     ip route add default via 192.168.10.1
 # 在/etc/netns下创建network namespce名称为ns1的目录，
 # 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了
mkdir -p /etc/netns/ns1
echo "nameserver 8.8.8.8" &gt; /etc/netns/ns1/resolv.conf
上面基本上就是docker网络的原理了，只不过，
Docker的resolv.conf没有用这样的方式，而是用了Mount Namesapce的那种方式
另外，docker是用进程的PID来做Network Namespace的名称的。</pid></pid></p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/29/namespace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/29/cgroup.html" class="post-title-link">
      <h2>linux cgroup</h2>
    </a>

    <div class="post-date">Apr 29, 2018</div>
    
    <div class="post-body">
      
      <p>Namespace解决的问题主要是环境隔离的问题，这只是虚拟化中最最基础的一步，我们还需要解决对计算机资源使用上的隔离。也就是说，虽然你通过Namespace把我Jail到一个特定的环境中去了，但是我在其中的进程使用用CPU、内存、磁盘等这些计算资源其实还是可以随心所欲的。所以，我们希望对进程进行资源利用上的限制或控制。这就是Linux CGroup出来了的原因。
Linux CGroup全称Linux Control Group， 是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。这个项目最早是由Google的工程师在2006年发起（主要是Paul Menage和Rohit Seth），最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。然后，其它开始了他的发展。
Linux CGroupCgroup 可​​​让​​​您​​​为​​​系​​​统​​​中​​​所​​​运​​​行​​​任​​​务​​​（进​​​程​​​）的​​​用​​​户​​​定​​​义​​​组​​​群​​​分​​​配​​​资​​​源​​​ — 比​​​如​​​ CPU 时​​​间​​​、​​​系​​​统​​​内​​​存​​​、​​​网​​​络​​​带​​​宽​​​或​​​者​​​这​​​些​​​资​​​源​​​的​​​组​​​合​​​。​​​您​​​可​​​以​​​监​​​控​​​您​​​配​​​置​​​的​​​ cgroup，拒​​​绝​​​ cgroup 访​​​问​​​某​​​些​​​资​​​源​​​，甚​​​至​​​在​​​运​​​行​​​的​​​系​​​统​​​中​​​动​​​态​​​配​​​置​​​您​​​的​​​ cgroup。
主要提供了如下功能：
Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。
Prioritization: 优先级控制，比如：CPU利用和磁盘IO吞吐。
Accounting: 一些审计或一些统计，主要目的是为了计费。
Control: 挂起进程，恢复执行进程。
使​​​用​​​ cgroup，系​​​统​​​管​​​理​​​员​​​可​​​更​​​具​​​体​​​地​​​控​​​制​​​对​​​系​​​统​​​资​​​源​​​的​​​分​​​配​​​、​​​优​​​先​​​顺​​​序​​​、​​​拒​​​绝​​​、​​​管​​​理​​​和​​​监​​​控​​​。​​​可​​​更​​​好​​​地​​​根​​​据​​​任​​​务​​​和​​​用​​​户​​​分​​​配​​​硬​​​件​​​资​​​源​​​，提​​​高​​​总​​​体​​​效​​​率​​​。
在实践中，系统管理员一般会利用CGroup做下面这些事（有点像为某个虚拟机分配资源似的）：
隔离一个进程集合（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。
为这组进程 分配其足够使用的内存
为这组进程分配相应的网络带宽和磁盘存储限制
限制访问某些设备（通过设置设备的白名单）
<!-- more -->
Linux把CGroup这个事实现成了一个file system，你可以mount。在我的Ubuntu 14.04下，你输入以下命令你就可以看到cgroup已为你mount好了。
 $ mount -t cgroup
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset)
cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu)
cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio)
cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio)
cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb)
或者使用lssubsys命令：
$ lssubsys  -m
cpuset /sys/fs/cgroup/cpuset
cpu /sys/fs/cgroup/cpu
cpuacct /sys/fs/cgroup/cpuacct
memory /sys/fs/cgroup/memory
devices /sys/fs/cgroup/devices
freezer /sys/fs/cgroup/freezer
blkio /sys/fs/cgroup/blkio
net_cls /sys/fs/cgroup/net_cls
net_prio /sys/fs/cgroup/net_prio
perf_event /sys/fs/cgroup/perf_event
hugetlb /sys/fs/cgroup/hugetlb
我们可以看到，在/sys/fs下有一个cgroup的目录，这个目录下还有很多子目录，比如： cpu，cpuset，memory，blkio……这些，这些都是cgroup的子系统。分别用于干不同的事的。
如果你没有看到上述的目录，你可以自己mount，下面给了一个示例：
mkdir cgroup
mount -t tmpfs cgroup_root ./cgroup
mkdir cgroup/cpuset
mount -t cgroup -ocpuset cpuset ./cgroup/cpuset/
mkdir cgroup/cpu
mount -t cgroup -ocpu cpu ./cgroup/cpu/
mkdir cgroup/memory
mount -t cgroup -omemory memory ./cgroup/memory/
一旦mount成功，你就会看到这些目录下就有好文件了，比如，如下所示的cpu和cpuset的子系统：
 $ ls /sys/fs/cgroup/cpu /sys/fs/cgroup/cpuset/
/sys/fs/cgroup/cpu:
cgroup.clone_children  cgroup.sane_behavior  cpu.shares         release_agent
cgroup.event_control   cpu.cfs_period_us     cpu.stat           tasks
cgroup.procs           cpu.cfs_quota_us      notify_on_release  user
/sys/fs/cgroup/cpuset/:
cgroup.clone_children  cpuset.mem_hardwall             cpuset.sched_load_balance
cgroup.event_control   cpuset.memory_migrate           cpuset.sched_relax_domain_level
cgroup.procs           cpuset.memory_pressure          notify_on_release
cgroup.sane_behavior   cpuset.memory_pressure_enabled  release_agent
cpuset.cpu_exclusive   cpuset.memory_spread_page       tasks
cpuset.cpus            cpuset.memory_spread_slab       user
cpuset.mem_exclusive   cpuset.mems
你可以到/sys/fs/cgroup的各个子目录下去make个dir，你会发现，一旦你创建了一个子目录，这个子目录里又有很多文件了。
hchen@ubuntu:/sys/fs/cgroup/cpu$ sudo mkdir haoel
[sudo] password for hchen: 
~:/sys/fs/cgroup/cpu$ ls ./haoel
cgroup.clone_children  cgroup.procs       cpu.cfs_quota_us  cpu.stat           tasks
cgroup.event_control   cpu.cfs_period_us  cpu.shares        notify_on_release
好了，我们来看几个示例。
CPU 限制
假设，我们有一个非常吃CPU的程序，叫deadloop，其源码如下：
DEADLOOP.C
int main(void)
{
    int i = 0;
    for(;;) i++;
    return 0;
}
用sudo执行起来后，毫无疑问，CPU被干到了100%（下面是top命令的输出）
PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND   <br />
3529 root      20   0    4196    736    656 R 99.6  0.1   0:23.13 deadloop
然后，我们这前不是在/sys/fs/cgroup/cpu下创建了一个haoel的group。我们先设置一下这个group的cpu利用的限制：
 # cat /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us 
-1
 # echo 20000 &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us
我们看到，这个进程的PID是3529，我们把这个进程加到这个cgroup中：</p>
<h1 id="echo-3529-sysfscgroupcpuhaoeltasks">echo 3529 » /sys/fs/cgroup/cpu/haoel/tasks</h1>
<p>然后，就会在top中看到CPU的利用立马下降成20%了。（前面我们设置的20000就是20%的意思）
PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND   <br />
3529 root      20   0    4196    736    656 R 19.9  0.1   8:06.11 deadloop
然后，在我们另外一边：</p>
<h1 id="创建memory-cgroup">创建memory cgroup</h1>
<p>$ mkdir /sys/fs/cgroup/memory/haoel
$ echo 64k &gt; /sys/fs/cgroup/memory/haoel/memory.limit_in_bytes</p>
<h1 id="把上面的进程的pid加入这个cgroup">把上面的进程的pid加入这个cgroup</h1>
<p>$ echo [pid] &gt; /sys/fs/cgroup/memory/haoel/tasks
你会看到，一会上面的进程就会因为内存问题被kill掉了。
磁盘I/O限制
我们先看一下我们的硬盘IO，我们的模拟命令如下：（从/dev/sda1上读入数据，输出到/dev/null上）
sudo dd if=/dev/sda1 of=/dev/null
我们通过iotop命令我们可以看到相关的IO速度是55MB/s（虚拟机内）：
TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND        <br />
8128 be/4 root       55.74 M/s    0.00 B/s  0.00 % 85.65 % dd if=/de~=/dev/null…
然后，我们先创建一个blkio（块设备IO）的cgroup
mkdir /sys/fs/cgroup/blkio/haoel
并把读IO限制到1MB/s，并把前面那个dd命令的pid放进去（注：8:0 是设备号，你可以通过ls -l /dev/sda1获得）：
 # echo ‘8:0 1048576’  &gt; /sys/fs/cgroup/blkio/haoel/blkio.throttle.read_bps_device 
 # echo 8128 &gt; /sys/fs/cgroup/blkio/haoel/tasks
再用iotop命令，你马上就能看到读速度被限制到了1MB/s左右。
TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND        <br />
8128 be/4 root      973.20 K/s    0.00 B/s  0.00 % 94.41 % dd if=/de~=/dev/null…
CGroup的子系统
好了，有了以上的感性认识我们来，我们来看看control group有哪些子系统：
blkio — 这​​​个​​​子​​​系​​​统​​​为​​​块​​​设​​​备​​​设​​​定​​​输​​​入​​​/输​​​出​​​限​​​制​​​，比​​​如​​​物​​​理​​​设​​​备​​​（磁​​​盘​​​，固​​​态​​​硬​​​盘​​​，USB 等​​​等​​​）。
cpu — 这​​​个​​​子​​​系​​​统​​​使​​​用​​​调​​​度​​​程​​​序​​​提​​​供​​​对​​​ CPU 的​​​ cgroup 任​​​务​​​访​​​问​​​。​​​
cpuacct — 这​​​个​​​子​​​系​​​统​​​自​​​动​​​生​​​成​​​ cgroup 中​​​任​​​务​​​所​​​使​​​用​​​的​​​ CPU 报​​​告​​​。​​​
cpuset — 这​​​个​​​子​​​系​​​统​​​为​​​ cgroup 中​​​的​​​任​​​务​​​分​​​配​​​独​​​立​​​ CPU（在​​​多​​​核​​​系​​​统​​​）和​​​内​​​存​​​节​​​点​​​。​​​
devices — 这​​​个​​​子​​​系​​​统​​​可​​​允​​​许​​​或​​​者​​​拒​​​绝​​​ cgroup 中​​​的​​​任​​​务​​​访​​​问​​​设​​​备​​​。​​​
freezer — 这​​​个​​​子​​​系​​​统​​​挂​​​起​​​或​​​者​​​恢​​​复​​​ cgroup 中​​​的​​​任​​​务​​​。​​​
memory — 这​​​个​​​子​​​系​​​统​​​设​​​定​​​ cgroup 中​​​任​​​务​​​使​​​用​​​的​​​内​​​存​​​限​​​制​​​，并​​​自​​​动​​​生​​​成​​​​​内​​​存​​​资​​​源使用​​​报​​​告​​​。​​​
net_cls — 这​​​个​​​子​​​系​​​统​​​使​​​用​​​等​​​级​​​识​​​别​​​符​​​（classid）标​​​记​​​网​​​络​​​数​​​据​​​包​​​，可​​​允​​​许​​​ Linux 流​​​量​​​控​​​制​​​程​​​序​​​（tc）识​​​别​​​从​​​具​​​体​​​ cgroup 中​​​生​​​成​​​的​​​数​​​据​​​包​​​。​​​
net_prio — 这个子系统用来设计网络流量的优先级
hugetlb — 这个子系统主要针对于HugeTLB系统进行限制，这是一个大页文件系统。
注意，你可能在Ubuntu 14.04下看不到net_cls和net_prio这两个cgroup，你需要手动mount一下：
$ sudo modprobe cls_cgroup
$ sudo mkdir /sys/fs/cgroup/net_cls
$ sudo mount -t cgroup -o net_cls none /sys/fs/cgroup/net_cls 
$ sudo modprobe netprio_cgroup
$ sudo mkdir /sys/fs/cgroup/net_prio
$ sudo mount -t cgroup -o net_prio none /sys/fs/cgroup/net_prio
关于各个子系统的参数细节，以及更多的Linux CGroup的文档，你可以看看下面的文档：
Linux Kernel的官方文档
Redhat的官方文档
CGroup的术语
CGroup有下述术语：
任务（Tasks）：就是系统的一个进程。
控制组（Control Group）：一组按照某种标准划分的进程，比如官方文档中的Professor和Student，或是WWW和System之类的，其表示了某进程组。Cgroups中的资源控制都是以控制组为单位实现。一个进程可以加入到某个控制组。而资源的限制是定义在这个组上，就像上面示例中我用的haoel一样。简单点说，cgroup的呈现就是一个目录带一系列的可配置文件。
层级（Hierarchy）：控制组可以组织成hierarchical的形式，既一颗控制组的树（目录结构）。控制组树上的子节点继承父结点的属性。简单点说，hierarchy就是在一个或多个子系统上的cgroups目录树。
子系统（Subsystem）：一个子系统就是一个资源控制器，比如CPU子系统就是控制CPU时间分配的一个控制器。子系统必须附加到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。Cgroup的子系统可以有很多，也在不断增加中。
下一代的CGroup
上面，我们可以看到，CGroup的一些常用方法和相关的术语。一般来说，这样的设计在一般情况下还是没什么问题的，除了操作上的用户体验不是很好，但基本满足我们的一般需求了。
不过，对此，有个叫Tejun Heo的同学非常不爽，他在Linux社区里对cgroup吐了一把槽，还引发了内核组的各种讨论。
对于Tejun Heo同学来说，cgroup设计的相当糟糕。他给出了些例子，大意就是说，如果有多种层级关系，也就是说有多种对进程的分类方式，比如，我们可以按用户来分，分成Professor和Student，同时，也有按应用类似来分的，比如WWW和NFS等。那么，当一个进程即是Professor的，也是WWW的，那么就会出现多层级正交的情况，从而出现对进程上管理的混乱。另外，一个case是，如果有一个层级A绑定cpu，而层级B绑定memory，还有一个层级C绑定cputset，而有一些进程有的需要AB，有的需要AC，有的需要ABC，管理起来就相当不易。
层级操作起来比较麻烦，而且如果层级变多，更不易于操作和管理，虽然那种方式很好实现，但是在使用上有很多的复杂度。你可以想像一个图书馆的图书分类问题，你可以有各种不同的分类，分类和图书就是一种多对多的关系。
所以，在Kernel 3.16后，引入了unified hierarchy的新的设计，这个东西引入了一个叫__DEVEL__sane_behavior的特性（这个名字很明显意味目前还在开发试验阶段），它可以把所有子系统都挂载到根层级下，只有叶子节点可以存在tasks，非叶子节点只进行资源控制。
我们mount一下看看：
$ sudo mount -t cgroup -o __DEVEL__sane_behavior cgroup ./cgroup
$ ls ./cgroup
cgroup.controllers  cgroup.procs  cgroup.sane_behavior  cgroup.subtree_control 
$ cat ./cgroup/cgroup.controllers
cpuset cpu cpuacct memory devices freezer net_cls blkio perf_event net_prio hugetlb
我们可以看到有四个文件，然后，你在这里mkdir一个子目录，里面也会有这四个文件。上级的cgroup.subtree_control控制下级的cgroup.controllers。
cgroup只有上线控制下级，无法传递到下下级。所以，C和D中没有memory的限制，E中没有blkio和memory的限制。而本层的cgroup.controllers文件是个只读的，其中的内容就看上级的subtree_control里有什么了。
任何被配置过subtree_control的目录都不能绑定进程，根结点除外。所以，A,C,D,E可以绑上进程，但是B不行。
我们可以看到，这种方式干净的区分开了两个事，一个是进程的分组，一个是对分组的资源控制（以前这两个事完全混在一起），在目录继承上增加了些限制，这样可以避免一些模棱两可的情况。
当然，这个事还在演化中，cgroup的这些问题这个事目前由cgroup的吐槽人Tejun Heo和华为的Li Zefan同学负责解决中。总之，这是一个系统管理上的问题，而且改变会影响很多东西，但一旦方案确定，老的cgroup方式将一去不复返。
Cgroup是进行分组化管理的Linux内核功能，具体的资源管理是通过子系统来完成的。可以理解为子系统就是资源控制器，每种子系统就是一个资源的分配器，比如cpu子系统是控制cpu时间分配的，使用方式如下
安装（ubuntu）
#apt-get install cgroup-bin
基本命令
cgclassify – cgclassify命令是用来将运行的任务移动到一个或者多个cgroup。
cgclear – cgclear 命令是用来删除层级中的所有cgroup。
cgconfig.conf – 在cgconfig.conf文件中定义cgroup。
cgconfigparser – cgconfigparser命令解析cgconfig.conf文件和并挂载层级。
cgcreate – cgcreate在层级中创建新cgroup。
cgdelete – cgdelete命令删除指定的cgroup。
cgexec – cgexec命令在指定的cgroup中运行任务。
cgget – cgget命令显示cgroup参数。
cgred.conf – cgred.conf是cgred服务的配置文件。
cgrules.conf – cgrules.conf 包含用来决定何时任务术语某些 cgroup的规则。
cgrulesengd – cgrulesengd 在 cgroup 中发布任务。
cgset – cgset 命令为 cgroup 设定参数。
lscgroup – lscgroup 命令列出层级中的 cgroup。
lssubsys – lssubsys 命令列出包含指定子系统的层级
子系统说明
可以使用lssubsys -a来列出系统支持多少种子系统，和：比如cpu是控制cpu时间片的，memory是控制内存使用的
#lssubsys -a
cpuset
cpu,cpuacct
memory
devices
freezer
net_cls,net_prio
blkio
perf_event
hugetlb
主要的几种子系统说明如下：
blkio 这个子系统设置限制每个块设备的输入输出控制。例如:磁盘，光盘以及usb等等。
cpu 这个子系统使用调度程序为cgroup任务提供cpu的访问。
cpuacct 产生cgroup任务的cpu资源报告。
cpuset 如果是多核心的cpu，这个子系统会为cgroup任务分配单独的cpu和内存。
devices 允许或拒绝cgroup任务对设备的访问。
freezer 暂停和恢复cgroup任务。
memory 设置每个cgroup的内存限制以及产生内存资源报告。
net_cls 标记每个网络包以供cgroup方便使用。
ns 名称空间子系统
perf_event: 增加了对每group的监测跟踪的能力，即可以监测属于某个特定的group的所有线程以及运行在特定CPU上的线程
要为Cgroup分配限制的资源,首先要挂载子系统，然后才有控制组，比如想要对目标程序进行内存限制，那就需要挂载memory子系统
使用lssubsys -am来显示已经挂载的子系统
#lssubsys -am
cpuset /sys/fs/cgroup/cpuset
cpu,cpuacct /sys/fs/cgroup/cpu,cpuacct
memory /sys/fs/cgroup/memory
devices /sys/fs/cgroup/devices
freezer /sys/fs/cgroup/freezer
net_cls,net_prio /sys/fs/cgroup/net_cls,net_prio
blkio /sys/fs/cgroup/blkio
perf_event /sys/fs/cgroup/perf_event
hugetlb /sys/fs/cgroup/hugetlb
可以手动挂载或者卸载子系统，如执行umount /sys/fs/cgroup/memory，memory子系统就被卸载了，这时候手动执行# mount -t cgroup -o memory memory /sys/fs/cgroup/memory就又挂载上了。 
要确保需要的子系统都挂上了，不然创建控制组的时候会报错 is not mounted
#cgcreate -g memory,cpu:/hzmali_test
cgcreate: can’t create cgroup /hzmali_test: Cgroup one of the needed subsystems is not mounted
如何创建control group（即需要资源管理的组）呢, 这里用cgcreate命令，当然也有其他方法, 如cgconfig.conf等
#cgcreate -g memory,cpu:/hzmali_test
这里有个重要特性：一个组可以同时做多个资源的限制，如这里我同时限制了memory和cpu，然后memory和cpu子系统目录下会自动生成这个组的目录和些文件，如memory
#/sys/fs/cgroup/memory/hzmali_test$ ls -lrt
文件很多，选几个重要的讲下：
tasks 可以将想要限制资源的进程都加到这个文件中
memory.max_usage_in_bytes内存的最大使用量，用来限制资源 
-memory.soft_limit_in_bytes 和 memory.limit_in_bytes 的差异是，这个限制并不会阻止进程使用超过限额的内存，只是在系统内存不足时，会优先回收超过限额的进程占用的内存，使之向限定值靠拢。
memory.oom_control 
包含一个标志（0或1）来开启或者关闭cgroup的OOM killer。如果开启（1），任务如果尝试申请内存超过允许，就会被系统OOM killer终止。OOM killer在每个使用cgroup内存子系统中都是默认开启的。如果需要关闭，则可以向memory.oom_control文件写入1：
 # echo 1 &gt; /sys/fs/cgroup/memory.oom_control 
如果OOM killer关闭，那么进程尝试申请的内存超过允许，那么它就会被暂停，直到额外的内存被释放
memory.mem.usage_in_bytes 当前进程内存用量，因为现在还没有进程加到组里，就是0了
memory.mem.failcnt显示内存达到限制值的次数
Cgroup文档
Cgroup的使用细节，子系统和参数设置都可以可以在https://www.kernel.org/doc/Documentation/cgroups/中找到，继承等特性由于篇幅所限，可以看下文档
Cgroup实战
内存限制测试
用控制组限制目标程序内存使用为1000000 byte，当然，需要root执行 
echo “1000000” &gt;memory.limit_in_bytes
一般更推荐用cgset来设置数值
cgset -r memory.limit_in_bytes=1000000 hzmali_test
然后构造一个吃内存的程序，每运行一次内存使用就大幅增加
如果我不想把机器跑死，这里想要限制组里的进程的CPU使用，有2种做法 
1.在cpu子系统中控制cpu调度的配额 
先看下当前cpu分配情况
cat /sys/fs/cgroup/cpu/hzmali_test/cpu.cfs_quota_us
-1
cat /sys/fs/cgroup/cpu/hzmali_test/cpu.cfs_period_us
100000
-1表示无限制，这里改为50000，即相对于cpu.cfs_period_us 来说为50000/100000约占1个核50%的cpu时间
 #./cpu_test.sh &amp;
[1] 17709
 # echo 17709 &gt;/sys/fs/cgroup/cpu/hzmali_test/tasks
或者直接使用命令cgexec执行
cgexec -g cpu:hzmali_test ./cpu_test.sh
top了下基本上就是在50%的cpu占用
%Cpu0 : 50.5 us, 0.0 sy, 0.0 ni, 49.5 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
%Cpu1 : 0.0 us, 0.3 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 17709 root 20 0 25368 2020 1764 R 50.2 0.1 1:14.74 bash
2.在cpuset控制物理cpu的分配 
当前使用了上面的方法后，我们发现进程的CPU使用都在Cpu0上，这次希望只用Cpu1来跑这个小程序 
所以把控制组也加到cpuset
 # cgcreate -g cpuset:/hzmali_test
看一下现在使用的cpu的设置
 # cat /sys/fs/cgroup/cpuset/hzmali_test/cpuset.cpus
0-1
改为只用Cpu1，输入以下命令
 # echo 1 &gt; /sys/fs/cgroup/cpuset/hzmali_test/cpuset.cpus
 # echo 17709 &gt; /sys/fs/cgroup/cpuset/hzmali_test/tasks
或用命令
 # cgset -r cpuset.cpus=’1’ hzmali_test
 # cgclassify -g cpu,cpuset:hzmali_test 17709
top一下，内存的使用从CPU0到CPU1了
%Cpu0 : 0.0 us, 0.0 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.3 si, 0.0 st
%Cpu1 : 50.3 us, 0.0 sy, 0.0 ni, 49.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
17709 root 20 0 25368 2108 2076 R 50.1 0.1 8:56.78 bash
IO限制测试
用dd对硬盘进行写操作
 # dd if=/dev/sda of=/dev/null &amp;
打开iotop看下IO速度
Total DISK READ : 100.37 M/s | Total DISK WRITE : 0.00 B/s
Actual DISK READ: 100.37 M/s | Actual DISK WRITE: 0.00 B/s
TID PRIO USER DISK READ DISK WRITE SWAPIN IO&gt; COMMAND
18081 be/4 root 100.37 M/s 0.00 B/s 0.00 % 1.34 % dd if=/dev/sda of=/dev/null
为了控制IO速度，在blkio上创建控制组
 # cgcreate -g blkio:/hzmali_test
查看下硬盘号
 # ls -l /dev/sda
brw-rw—- 1 root disk 8, 0 Jul 25 22:46 /dev/sda
设置硬盘号和对应的读取速度限制，然后执行同样的命令
 # cgset -r blkio.throttle.read_bps_device=”8:0 1000000” hzmali_test
 # cgexec -g blkio:hzmali_test “dd if=/dev/sda of=/dev/null”
用iotop查看下，速度果然就降到1M以下</p>

    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/29/cgroup.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/29/bridge.html" class="post-title-link">
      <h2>bridge</h2>
    </a>

    <div class="post-date">Apr 29, 2018</div>
    
    <div class="post-body">
      
      <p>网桥设备作为一个虚拟设备，用于连接多个端口，可以构建一个局域网。与之相似的是vlan设备，在linux中，vlan设备是为了处理802.1q的添加和去除TAG的问题，这和传统交换机中vlan的功能—划分局域网，不太一样，在这里仅仅是处理了消息头，只是实现了隔离功能，并未实现交换功能，如果需要vlan内的数据转发，可以把vlan子接口挂接在网桥设备下。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/29/bridge.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/22/expect.html" class="post-title-link">
      <h2>expect</h2>
    </a>

    <div class="post-date">Apr 22, 2018</div>
    
    <div class="post-body">
      
      <p>expect是一个自动交互功能的工具。expect是开了一个子进程，通过spawn来执行shell脚本，监测到脚本的返回结果，通过expect判断要进行的交互输入内容（send）
1.安装expect 
需要先安装tcl：apt-get install tcl
apt-get install expect
2.expect使用
2.1一个简单的输入密码操作</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre> <span class="c">#！/usr/bin/expect</span>
<span class="nb">set </span>timeout 100
<span class="nb">set </span>password <span class="s2">"123456"</span>
spawn <span class="nb">sudo </span>rm <span class="nt">-rf</span> zzlogic
expect <span class="s2">"root123456"</span>
send <span class="s2">"</span><span class="nv">$password</span><span class="se">\n</span><span class="s2">"</span>
interact</pre></td></tr></tbody></table></code></pre></figure>

<p>说明：
第一行#！/usr/bin/expect表示使用expect的shell交互模式
set是对变量password赋值
set timeout 100：设置超时时间为100秒，如果要执行的shell命令很长可以设置超时时间长一些。expect超过超时时间没有监测到要找的字符串，则不执行，默认timeout为10秒
spawn在expect下执行shell脚本
expect对通过spawn执行的shell脚本的返回进行判断，是否包含“”中的字段
send：如果expect监测到了包含的字符串，将输入send中的内容，\n相当于回车
interact：退出expect返回终端，可以继续输入，否则将一直在expect不能退出到终端
2.2expect的命令行参数
[lindex $argv n]获得index为n的参数（index从0开始计算）
$argc为命令行参数的个数
[lrange $argv 0 0]表示第一个参数
[lrange $argv 0 3]表示第1到第3个参数
例如scp_service.sh文件，可以./scp_service.sh -rm来执行，这时是赋值了一个参数
set option  [lindex $argv 0]（获得第一个参数存到变量option中，参数是的index是从0开始计算的）
2.3if…elif…else…
expect支持if语句，
if {条件1} {
     条件1执行语句
} elif {条件2} {
     条件2执行语句
} else {
     其他情况执行语句
}
说明：
1.if的条件用{}来包含条件
2.if和后面的{}必须有空格隔开
3.两个花括号之间必须有空格隔开，比如if {} {}，否则会报错 expect:extra characters after close-brace
3.使用{来衔接下一行，所以if的条件后需要加左花括号{
4.else不能单独放一行，所以else要跟在}后面
2.4 expect {}，多行期望，匹配到哪条执行哪条
背景：有时执行shell后预期结果是不固定的，有可能是询问是yes/no，有可能是去输入密码，所以可以用expect{}
花括号内放多行语句，从上至下匹配，匹配到哪个expect执行哪句。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/22/expect.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/20/linux_shell.html" class="post-title-link">
      <h2>Linux下的shell工作原理</h2>
    </a>

    <div class="post-date">Apr 20, 2018</div>
    
    <div class="post-body">
      
      <p>Linux系统提供给用户的最重要的系统程序是Shell命令语言解释程序。它不属于内核部分，而是在核心之外，以用户态方式运行。其基本功能是解释并执行用户打入的各种命令，实现用户与Linux核心的接口。系统初启后，核心为每个终端用户建立一个进程去执行Shell解释程序。它的执行过程基本上按如下步骤： 
(1)读取用户由键盘输入的命令行。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/20/linux_shell.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/16/dup.html" class="post-title-link">
      <h2>dup dup2</h2>
    </a>

    <div class="post-date">Apr 16, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>有时我们希望把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接。
dup()与dup2()能对输入文件描述符进行重定向。
int dup(int oldfd);
int dup2(int oldfd, intnewfd);
dup函数创建一个新的文件描述符，该新文件描述符和原有文件描述符oldfd指向相同的文件、管道或者网络连接。
并且dup返回的文件描述符总是取系统当前可用的最小整数值。dup2和dup类似，不过它将返回第一个不小于oldfd的整数值。dup和dup2失败时返回-1并设置errno。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/16/dup.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/03/27/rsync.html" class="post-title-link">
      <h2>rsync</h2>
    </a>

    <div class="post-date">Mar 27, 2018</div>
    
    <div class="post-body">
      
      <p>它比scp更强大，支持“不覆盖”原目录
例子：
rsync -avz –progress /root/client/   root@202.112.23.12:/home/work/</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/03/27/rsync.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/03/13/system_call.html" class="post-title-link">
      <h2>系统调用</h2>
    </a>

    <div class="post-date">Mar 13, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>为什么需要系统调用
   现代的操作系统通常都具有多任务处理的功能，通常靠进程来实现。由于操作系统快速的在每个进程间切换执行，所以一切看起来就会像是同时的。同时这也带来了很多安全问题，例如，一个进程可以轻易的修改进程的内存空间中的数据来使另一个进程异常或达到一些目的，因此操作系统必须保证每一个进程都能安全的执行。这一问题的解决方法是在处理器中加入基址寄存器和界限寄存器。这两个寄存器中的内容用硬件限制了对储存器的存取指令所访问的储存器的地址。这样就可以在系统切换进程时写入这两个寄存器的内容到该进程被分配的地址范围，从而避免恶意软件。
   为了防止用户程序修改基址寄存器和界限寄存器中的内容来达到访问其他内存空间的目的，这两个寄存器必须通过一些特殊的指令来访问。通常，处理器设有两种模式：“用户模式”与“内核模式”，通过一个标签位来鉴别当前正处于什么模式。一些诸如修改基址寄存器内容的指令只有在内核模式中可以执行，而处于用户模式的时候硬件会直接跳过这个指令并继续执行下一个。
   当操作系统接收到系统调用请求后，会让处理器进入内核模式，从而执行诸如I/O操作，修改基址寄存器内容等指令，而当处理完系统调用内容后，操作系统会让处理器返回用户模式，来执行用户代码。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/03/13/system_call.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/02/05/iputils.html" class="post-title-link">
      <h2>iputils</h2>
    </a>

    <div class="post-date">Feb 5, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>1.1       iputils软件包简介
    iputils软件包是linux环境下一些实用的网络工具的集合。一开始由Alexey Kuznetsov维护。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/02/05/iputils.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/01/26/zero_copy.html" class="post-title-link">
      <h2>zero copy</h2>
    </a>

    <div class="post-date">Jan 26, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>许多web应用都会向用户提供大量的静态内容，这意味着有很多data从硬盘读出之后，会原封不动的通过socket传输给用户。这种操作看起来可能不会怎么消耗CPU，但是实际上它是低效的：kernal把数据从disk读出来，然后把它传输给user级的application，然后application再次把同样的内容再传回给处于kernal级的socket。这种场景下，application实际上只是作为一种低效的中间介质，用来把disk file的data传给socket。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/01/26/zero_copy.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/01/24/nohup.html" class="post-title-link">
      <h2>进程在后台运行原理</h2>
    </a>

    <div class="post-date">Jan 24, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>nohup/setsid/&amp;
场景：
如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/01/24/nohup.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/01/16/ln.html" class="post-title-link">
      <h2>Linux、Mac上面ln命令使用说明</h2>
    </a>

    <div class="post-date">Jan 16, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同不的链接，这个命令最常用的参数是 -s，具体用法是：ln –s 源文件 目标文件。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/01/16/ln.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/30/broad_cast.html" class="post-title-link">
      <h2>单播、多播和广播</h2>
    </a>

    <div class="post-date">Dec 30, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>　　单播在网络中得到了广泛的应用，网络上绝大部分的数据都是以单播的形式传输的，只是一般网络用户不知道而已。例如，你在收发电子邮件、浏览网页时，必须与邮件服务器、Web服务器建立连接，此时使用的就是单播数据传输方式。但是通常使用“点对点通信”（Point to Point）代替“单播”，因为“单播”一般与“多播”和“广播”相对应使用
　　　“多播”也可以称为“组播”，在网络技术的应用并不是很多，网上视频会议、网上视频点播特别适合采用多播方式。因为如果采用单播方式，逐个节点传输，有多少个目标节点，就会有多少次传送过程，这种方式显然效率极低，是不可取的；如果采用不区分目标、全部发送的广播方式，虽然一次可以传送完数据，但是显然达不到区分特定数据接收对象的目的。采用多播方式，既可以实现一次传送所有目标节点的数据，也可以达到只对特定对象传送数据的目的。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/30/broad_cast.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/30/arp.html" class="post-title-link">
      <h2>arp</h2>
    </a>

    <div class="post-date">Dec 30, 2017</div>
    
    <div class="post-body">
      
      <p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。
<!-- more -->
工作过程
主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；
主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；
当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：
第1步：根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。
第2步：如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。
第3步：主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。
第4步：主机B将包含其MAC地址的ARP回复消息直接发送回主机A。
第5步：当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。
ARP缓存是个用来储存IP地址和MAC地址的缓冲区，其本质就是一个IP地址–&gt;MAC地址的对应表，表中每一个条目分别记录了网络上其他主机的IP地址和对应的MAC地址。每一个以太网或令牌环网络适配器都有自己单独的表。当地址解析协议被询问一个已知IP地址节点的MAC地址时，先在ARP缓存中查看，若存在，就直接返回与之对应的MAC地址，若不存在，才发送ARP请求向局域网查询。
为使广播量最小，ARP维护IP地址到MAC地址映射的缓存以便将来使用。ARP缓存可以包含动态和静态项目。动态项目随时间推移自动添加和删除。每个动态ARP缓存项的潜在生命周期是10分钟。新加到缓存中的项目带有时间戳，如果某个项目添加后2分钟内没有再使用，则此项目过期并从ARP缓存中删除；如果某个项目已在使用，则又收到2分钟的生命周期；如果某个项目始终在使用，则会另外收到2分钟的生命周期，一直到10分钟的最长生命周期。静态项目一直保留在缓存中，直到重新启动计算机为止。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/30/arp.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/27/ioctl.html" class="post-title-link">
      <h2>ioctl</h2>
    </a>

    <div class="post-date">Dec 27, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>ioctl函数详细说明（网络）
ioctl 函数
本函数影响由fd 参数引用的一个打开的文件。
 #include<unistd.h></unistd.h></p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/27/ioctl.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/27/inetd.html" class="post-title-link">
      <h2>inetd</h2>
    </a>

    <div class="post-date">Dec 27, 2017</div>
    
    <div class="post-body">
      
      <p>inetd是监视一些网络请求的守护进程，其根据网络请求来调用相应的服务进程来处理连接请求。它可以为多种服务管理连接，当 inetd 接到连接时，它能够确定连接所需的程序，启动相应的进程，并把 socket 交给它 （服务 socket 会作为程序的标准输入、 输出和错误输出描述符）。 使用 inetd 来运行那些负载不重的服务有助于降低系统负载，因为它不需要为每个服务都启动独立的服务程序。
<!-- more -->
inetd是通过rc系统启动的。inetd_enable选项默认设为NO，但可以在安装系统时，由用户根据需要sysinstall通过来打开。
inetd.conf则是inetd的配置文件。inetd.conf文件告诉inetd监听哪些网络端口，为每个端口启动哪个服务。在任何的网络环境中使用Linux系统，第一件要做的事就是了解一下服务器到底要提供哪些服务。不需要的那些服务应该被禁止掉，最好卸载掉，这样黑客就少了一些攻击系统的机会。查看“/etc/inetd.conf”文件，了解一下inetd提供哪些服务。用加上注释的方法（在一行的开头加上#号），禁止任何不需要的服务，再给inetd进程发一个SIGHUP信号。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/27/inetd.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/24/unix_io5.html" class="post-title-link">
      <h2>UNIX下的5种IO模型</h2>
    </a>

    <div class="post-date">Dec 24, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>套接字的IO操作，如recvfrom，分为两个阶段：</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/24/unix_io5.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/24/thread_namespace.html" class="post-title-link">
      <h2>用户空间实现线程 内核实现线程 线程的调度</h2>
    </a>

    <div class="post-date">Dec 24, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>1、在用户空间中实现线程</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/24/thread_namespace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/24/thread.html" class="post-title-link">
      <h2>进程切换</h2>
    </a>

    <div class="post-date">Dec 24, 2017</div>
    
    <div class="post-body">
      
      <p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（process switch）、任务切换（task switch）或上下文切换（content switch）。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/24/thread.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/24/select_poll.html" class="post-title-link">
      <h2>IO多路复用之select、poll、epoll</h2>
    </a>

    <div class="post-date">Dec 24, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 目前支持I/O多路复用的系统调用有 select，pselect，poll，epoll，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，pselect，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。
 与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。
</code></pre></div></div>

<p>一、使用场景
IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：
　　1）当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。
　　2）当一个客户同时处理多个套接口时，这种情况是可能的，但很少出现。
　　3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。
　　4）如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。
　　5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p>

<p>二、select、poll、epoll简介
　　epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现。
1、select
基本原理：select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>

<p>基本流程，如图所示：
	<img src="https://xiazemin.github.io/MyBlog/img/ioMutex.png" /></p>

<p>　　select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p>

<p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：
1、select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。
　　一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.
2、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。
　　当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。
3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</p>

<p>2、poll
基本原理：poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>

<p>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：
1）大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。
2）poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>

<p>注意：从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>

<p>3、epoll
　　epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>

<p>基本原理：epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p>

<p>epoll的优点：
1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。
2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。
　　只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。
3、内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p>

<p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：
LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。
ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。
1、LT模式
　　LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。
2、ET模式
　　ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。
　　ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。
3、在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)
注意：如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll。</p>

<p>三、select、poll、epoll区别
1、支持一个进程所能打开的最大连接数
 	<img src="https://xiazemin.github.io/MyBlog/img/selectPoolConnect.png" />
2、FD剧增后带来的IO效率问题
 	<img src="https://xiazemin.github.io/MyBlog/img/selectPollFd.png" />
3、消息传递方式
 	<img src="https://xiazemin.github.io/MyBlog/img/selectPollMmap.png" /></p>

<p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：
1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/24/select_poll.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/24/goroutine.html" class="post-title-link">
      <h2>goroutine</h2>
    </a>

    <div class="post-date">Dec 24, 2017</div>
    
    <div class="post-body">
      
      <p>Go runtime的调度器：在了解Go的运行时的scheduler之前，需要先了解为什么需要它，因为我们可能会想，OS内核不是已经有一个线程scheduler了嘛？熟悉POSIX API的人都知道，POSIX的方案在很大程度上是对Unix process进场模型的一个逻辑描述和扩展，两者有很多相似的地方。 Thread有自己的信号掩码，CPU affinity等。但是很多特征对于Go程序来说都是累赘。 尤其是context上下文切换的耗时。另一个原因是Go的垃圾回收需要所有的goroutine停止，使得内存在一个一致的状态。垃圾回收的时间点是不确定的，如果依靠OS自身的scheduler来调度，那么会有大量的线程需要停止工作。 单独的开发一个GO得调度器，可以是其知道在什么时候内存状态是一致的，也就是说，当开始垃圾回收时，运行时只需要为当时正在CPU核上运行的那个线程等待即可，而不是等待所有的线程。用户空间线程和内核空间线程之间的映射关系有：N:1,1:1和M:NN:1是说，多个（N）用户线程始终在一个内核线程上跑，context上下文切换确实很快，但是无法真正的利用多核。1：1是说，一个用户线程就只在一个内核线程上跑，这时可以利用多核，但是上下文switch很慢。M:N是说， 多个goroutine在多个内核线程上跑，这个看似可以集齐上面两者的优势，但是无疑增加了调度的难度。
Go的调度器内部有三个重要的结构：M，P，G
M:代表真正的内核OS线程，和POSIX里的thread差不多，真正干活的人G:代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度。P:代表调度的上下文，可以把它看做一个局部的调度器，使go代码在一个线程上跑，它是实现从N:1到N:M映射的关键。
有2个物理线程M，每一个M都拥有一个context（P），每一个也都有一个正在运行的goroutine。P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。图中灰色的那些goroutine并没有运行，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为runqueue），Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个goroutine，在下一个调度点，就从runqueue中取出（如何决定取哪个goroutine？）一个goroutine执行。为何要维护多个上下文P？因为当一个OS线程被阻塞时，P可以转而投奔另一个OS线程！图中看到，当一个OS线程M0陷入阻塞时，P转而在OS线程M1上运行。调度器保证有足够的线程来运行所以的context P。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/24/goroutine.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/22/pid_0_1.html" class="post-title-link">
      <h2>ID为0和ID为1的进程</h2>
    </a>

    <div class="post-date">Dec 22, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>ID为0的进程通常是调度进程，常常被称为交换进程（swapper）。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。
ID为1的进程，通常是init进程，在自举过程结束时由内核调用。该进程的程序文件，在UNIX早起版本中是/etc/init，在较新的版本中是/sbin/init。该进程负责在自举内核后启动一个UNIX系统。init通常读与系统有关的初始化文件（/etc/rc*文件或/etc/inittab文件，以及/etc/init.d中的文件），并将系统引导到一个状态。init 进程绝不会终止，它是一个普通的用户进程（与交换进程不同，它不是内核的系统进程）但是它以超级用户特权运行。 ——摘自APUE
父进程ID为0的进程通常是内核进程，它们作为系统自举过程的一部分而启动，但init进程是个例外，它的父进程是0，但是它是用户进程。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/22/pid_0_1.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/22/fork_b.html" class="post-title-link">
      <h2>Shell脚本经典之Fork炸弹</h2>
    </a>

    <div class="post-date">Dec 22, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>众所周知，bash是一款极其强大的shell，提供了强大的交互与编程功能。这样的一款shell中自然不会缺少“函数”这个元素来帮助程序进行模块化的高效开发与管理。于是产生了由于其特殊的特性，bash拥有了fork炸弹。Jaromil在2002年设计了最为精简的一个fork炸弹的实现。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/22/fork_b.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/22/fork.html" class="post-title-link">
      <h2>fork</h2>
    </a>

    <div class="post-date">Dec 22, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>一、fork入门知识</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/22/fork.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/22/exec.html" class="post-title-link">
      <h2>Linux进程控制——exec函数族</h2>
    </a>

    <div class="post-date">Dec 22, 2017</div>
    
    <div class="post-body">
      
      <p>在Linux中，并不存在exec()函数，exec指的是一组函数，一共有6个，分别是：
 #include <unistd.h>
extern char **environ;
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
其中只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。
exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。
函数名与参数的关系：
细看一下，这6个函数都是以exec开头（表示属于exec函数组），前3个函数接着字母l的，后3个接着字母v的，我的理解是l表示list（列举参数），v表示vector（参数向量表）
。它们的区别在于，execv开头的函数是以"char *argv[]"(vector)形式传递命令行参数，而execl开头的函数采用了罗列(list)的方式，把参数一个一个列出来，然后以一个NULL表示结束。这里的NULL的作用和argv数组里的NULL作用是一样的。
字母p是指在环境变量PATH的目录里去查找要执行的可执行文件。2个以p结尾的函数execlp和execvp，看起来，和execl与execv的差别很小，事实也如此，它们的区别从第一个参数名可以看出：除 execlp和execvp之外的4个函数都要求，它们的第1个参数path必须是一个完整的路径，如"/bin/ls"；而execlp和execvp 的第1个参数file可以仅仅只是一个文件名，如"ls"，这两个函数可以自动到环境变量PATH指定的目录里去查找。
字母e是指给可执行文件指定环境变量。在全部6个函数中，只有execle和execve使用了char *envp[]传递环境变量，其它的4个函数都没有这个参数，这并不意味着它们不传递环境变量，这4个函数将把默认的环境变量不做任何修改地传给被执行的应用程序。而execle和execve用指定的环境变量去替代默认的那些。
返回值
与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只有进程ID等一些表面上的信息仍保持原样。调用失败时，会设置errno并返回-1，然后从原程序的调用点接着往下执行。
与其他系统调用比起来，exec很容易失败，被执行文件的位置，权限等很多因素都能导致调用失败。因此，使用exec函数族时，一定要加错误判断语句。最常见的错误：
找不到文件或路径，此时errno被设置为ENOENT；
数组argv和envp忘记用NULL结束，此时errno被设置为EFAULT；
没有对要执行文件的运行权限，此时errno被设置为EACCES。
2、应用
如果一个进程想执行另一个程序，它就可以fork或vfork出一个新进程，然后调用任何一个exec函数。
为此，Linux还专门对fork作了优化：通常fork会将调用进程的所有内容原封不动的拷贝到新产生的子进程中去，这些拷贝的动作很消耗时 间，而如果fork完之后我们马上就调用exec，那这些辛辛苦苦拷贝来的东西就会被立刻抹掉，这看起来非常不划算，于是人们设计了一种"写时复制（copy-on-write）" 技术，使得fork结束后并不立刻复制父进程的内容到子进程，而是到了真正使用时才复制，这样如果下一条语句是exec，它就不会作无用功了。其实"写时 复制"还是有复制，进程的mm结构、页表都还是被复制了（"写时复制"也必须由这些信息来支撑。否则内核捕捉到CPU访存异常，怎么区分 这是“写时复制”引起的，还是真正的越权访问呢？）。
而vfork就把事情做绝了，所有有关于内存的东西都不复制了，父子进程的内存是完全共享的。 但是这样一来又有问题了，虽然用户程序可以设计很多方法来避免父子进程间的访存冲突。但是关键的一点，父子进程共用着栈，这可不由用户程序控制的。一个进 程进行了关于函数调用或返回的操作，则另一个进程的调用栈 （实际上就是同一个栈）也被影响了。这样的程序没法运行下去。所以，vfork有个限制，子进程生成后，父进程在vfork中被内核挂起，直到子进程有了 自己的内存空间（exec**）或退出(_exit)。并且， 在此之前，子进程不能从调用vfork的函数中返回（同时，不能修改栈上变量、不能继续调用除_exit或exec系列之外的函数，否则父进程的数据可能 被改写）。
尽管限制很多，vfork后马上exec效率会比fork高不少。
<!-- more -->
fork函数是用于创建一个子进程，该子进程几乎是父进程的副本，而有时我们希望子进程去执行另外的程序，exec函数族就提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。
（2）在Linux中使用exec函数族主要有以下两种情况
a. 当进程认为自己不能再为系统和用户做出任何贡献时，就可以调用任何exec 函数族让自己重生。
b. 如果一个进程想执行另一个程序，那么它就可以调用fork函数新建一个进程，然后调用任何一个exec函数使子进程重生。
（3）exec函数族语法
实际上，在Linux中并没有exec函数，而是有6个以exec开头的函数族，下表列举了exec函数族的6个成员函数的语法。
所需头文件： #include <unistd.h>
函数说明： 执行文件
函数原型：
[plain] view plain copy
int execl(const char *path, const char *arg, ...)  
int execv(const char *path, char *const argv[])  
int execle(const char *path, const char *arg, ..., char *const envp[])  
int execve(const char *path, char *const argv[], char *const envp[])  
int execlp(const char *file, const char *arg, ...)  
int execvp(const char *file, char *const argv[])</unistd.h></unistd.h></p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/22/exec.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/13/radix_tree.html" class="post-title-link">
      <h2>radix tree</h2>
    </a>

    <div class="post-date">Dec 13, 2017</div>
    
    <div class="post-body">
      
      <p>基数树</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/13/radix_tree.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/10/strace.html" class="post-title-link">
      <h2>truss、strace或ltrace</h2>
    </a>

    <div class="post-date">Dec 10, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>truss和strace用来 跟踪一个进程的系统调用或信号产生的情况，而 ltrace用来 跟踪进程调用库函数的情况。truss是早期为System V R4开发的调试程序，包括Aix、FreeBSD在内的大部分Unix系统都自带了这个工具；而strace最初是为SunOS系统编写的，ltrace最早出现在GNU/Debian Linux中。这两个工具现在也已被移植到了大部分Unix系统中，大多数Linux发行版都自带了strace和ltrace，而FreeBSD也可通过Ports安装它们。
你不仅可以从命令行调试一个新开始的程序，也可以把truss、strace或ltrace绑定到一个已有的PID上来调试一个正在运行的程序。三个调试工具的基本使用方法大体相同，下面仅介绍三者共有，而且是最常用的三个命令行参数：
-f ：除了跟踪当前进程外，还跟踪其子进程。
-o file ：将输出信息写到文件file中，而不是显示到标准错误输出（stderr）。
-p pid ：绑定到一个由pid对应的正在运行的进程。此参数常用来调试后台进程。
使用上述三个参数基本上就可以完成大多数调试任务了，下面举几个命令行例子：
truss -o ls.truss ls -al： 跟踪ls -al的运行，将输出信息写到文件/tmp/ls.truss中。
strace -f -o vim.strace vim： 跟踪vim及其子进程的运行，将输出信息写到文件vim.strace。
ltrace -p 234： 跟踪一个pid为234的已经在运行的进程。
三个调试工具的输出结果格式也很相似，以strace为例：
brk(0)                                  = 0x8062aa8
brk(0x8063000)                          = 0x8063000
mmap2(NULL, 4096, PROT_READ, MAP_PRIVATE, 3, 0x92f) = 0x40016000
每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。 truss、strace和ltrace的工作原理大同小异，都是使用ptrace系统调用跟踪调试运行中的进程，详细原理不在本文讨论范围内，有兴趣可以参考它们的源代码。
每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。
strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。
-c 统计每一系统调用的所执行的时间,次数和出错的次数等. 
-d 输出strace关于标准错误的调试信息. 
-f 跟踪由fork调用所产生的子进程. 
-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号. 
-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪. 
-h 输出简要的帮助信息. 
-i 输出系统调用的入口指针. 
-q 禁止输出关于脱离的消息. 
-r 打印出相对时间关于,,每一个系统调用. 
-t 在输出中的每一行前加上时间信息. 
-tt 在输出中的每一行前加上时间信息,微秒级. 
-ttt 微秒级输出,以秒了表示时间. 
-T 显示每一调用所耗的时间. 
-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出. 
-V 输出strace的版本信息. 
-x 以十六进制形式输出非标准字符串 
-xx 所有字符串以十六进制形式输出. 
-a column 
设置返回值的输出位置.默认 为40. 
-e expr 
指定一个表达式,用来控制如何跟踪.格式如下: 
[qualifier=][!]value1[,value2]… 
qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如: 
-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. 
注意有些shell使用!来执行历史记录里的命令,所以要使用\. 
-e trace=set 
只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all. 
-e trace=file 
只跟踪有关文件操作的系统调用. 
-e trace=process 
只跟踪有关进程控制的系统调用. 
-e trace=network 
跟踪与网络有关的所有系统调用. 
-e strace=signal 
跟踪所有与系统信号有关的 系统调用 
-e trace=ipc 
跟踪所有与进程通讯有关的系统调用 
-e abbrev=set 
设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all. 
-e raw=set 
将指 定的系统调用的参数以十六进制显示. 
-e signal=set 
指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号. 
-e read=set 
输出从指定文件中读出 的数据.例如: 
-e read=3,5 
-e write=set 
输出写入到指定文件中的数据. 
-o filename 
将strace的输出写入文件filename 
-p pid 
跟踪指定的进程pid. 
-s strsize 
指定输出的字符串的最大长度.默认为32.文件名一直全部输出. 
-u username 
以username 的UID和GID执行被跟踪的命令
通用的完整用法：</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/10/strace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/10/netlink.html" class="post-title-link">
      <h2>netlink</h2>
    </a>

    <div class="post-date">Dec 10, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>Linux中的进程间通信机制源自于Unix平台上的进程通信机制。Unix的两大分支AT&amp;T Unix和BSD Unix在进程通信实现机制上的各有所不同，前者形成了运行在单个计算机上的System V IPC，后者则实现了基于socket的进程间通信机制。同时Linux也遵循IEEE制定的Posix IPC标准，在三者的基础之上实现了以下几种主要的IPC机制：管道(Pipe)及命名管道(Named Pipe)，信号(Signal)，消息队列(Message queue)，共享内存(Shared Memory)，信号量(Semaphore)，套接字(Socket)。通过这些IPC机制，用户空间进程之间可以完成互相通信。为了完成内核空间与用户空间通信，Linux提供了基于socket的Netlink通信机制，可以实现内核与用户空间数据的及时交换。
本文第2节概述相关研究工作，第3节与其他IPC机制对比，详细介绍Netlink机制及其关键技术，第4节使用KGDB+GDB组合调试，通过一个示例程序演示Netlink通信过程。第5节做总结并指出Netlink通信机制的不足之处。
2 相关研究
到目前Linux提供了9种机制完成内核与用户空间的数据交换，分别是内核启动参数、模块参数与 sysfs、sysctl、系统调用、netlink、procfs、seq_file、debugfs和relayfs，其中模块参数与sysfs、procfs、debugfs、relayfs是基于文件系统的通信机制，用于内核空间向用户控件输出信息；sysctl、系统调用是由用户空间发起的通信机制。由此可见，以上均为单工通信机制，在内核空间与用户空间的双向互动数据交换上略显不足。Netlink是基于socket的通信机制，由于socket本身的双共性、突发性、不阻塞特点，因此能够很好的满足内核与用户空间小量数据的及时交互，因此在Linux 2.6内核中广泛使用，例如SELinux，Linux系统的防火墙分为内核态的netfilter和用户态的iptables，netfilter与iptables的数据交换就是通过Netlink机制完成。 
3 Netlink机制及其关键技术
3.1 Netlink机制</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/10/netlink.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/09/sysfs.html" class="post-title-link">
      <h2>linux sysfs</h2>
    </a>

    <div class="post-date">Dec 9, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>在调试驱动，或驱动涉及一些参数的输入输出时，难免需要对驱动里的某些变量或内核参数进行读写，或函数调用。此时sysfs接口就很有用了，它可以使得可以在用户空间直接对驱动的这些变量读写或调用驱动的某些函数。sysfs接口与proc文件系统很相似，有人将proc文件系统形容为Windows XP，而将sysfs接口形容为Windows 7。
而在Android系统中，振动器、背光、电源系统等往往使用sysfs接口作为内核空间和用户空间的接口，驱动程序需要提供这些接口内容。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/09/sysfs.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/09/proc.html" class="post-title-link">
      <h2>proc文件系统</h2>
    </a>

    <div class="post-date">Dec 9, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>proc文件系统是一种无存储的文件系统，当读其中的文件时，其内容动态生成，当写文件时，文件所关联的写函数被调用。每个proc文件都关联的字节特定的读写函数，因而它提供了另外的一种和内核通信的机制：内核部件可以通过该文件系统向用户空间提供接口来提供查询信息、修改软件行为，因而它是一种比较重要的特殊文件系统。
由于proc文件系统以文件的形式向用户空间提供了访问接口，这些接口可以用于在运行时获取相关部件的信息或者修改部件的行为，因而它是非常方便的一个接口。内核中大量使用了该文件系统。proc文件系统就是一个文件系统，它可以挂载在目录树的任意位置，不过通常挂载在/proc下，它大致包含了如下信息：
内存管理
每个进程的相关信息
文件系统
设备驱动程序
系统总线
电源管理
终端
系统控制参数
网络
使用proc文件系统之前必须将其初始化并且挂载到系统中。proc文件系统的的初始化主要完成：
调用proc_init_inodecache创建proc文件系统所使用的专用缓冲区
调用register_filesystem注册proc文件系统，这里会提供proc文件系统自己的file_system_type，其中包括了用于mount的函数指针。在执行mount的时候会用到这些信息，并最终找到mount函数进行挂载操作
调用proc_mkdir创建一些proc文件目录
在sys文件系统下注册proc文件系统的相关信息
在proc的mount函数中会调用proc_fill_super，它会给出proc文件系统超级块所需要的信息（比如文件系统的超级块操作函数指针，超级块大小等），并且会创建proc文件系统的根目录，在创建根目录时也会指定与之对应的inode_operations和file_operations，有了这些信息后，VFS就可以在该文件系统上进行各种操作了（创建、删除、查找文件）。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/09/proc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/08/namespace.html" class="post-title-link">
      <h2>namespace</h2>
    </a>

    <div class="post-date">Dec 8, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>Linux Namespace</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/08/namespace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/07/vfs.html" class="post-title-link">
      <h2>vfs</h2>
    </a>

    <div class="post-date">Dec 7, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>在Linux中，文件系统主要分为下面3种：
（1）基于磁盘的文件系统（Disk-based Filesystem) 是在非易失介质上存储文件的经典方法，用以在多次会话之间保持文件的内容。如Ext2/3/4， Reiserfs, FAT等。
（2）虚拟文件系统（Virtual Filesystem） 在内核中生成，是一种用户应用程序与内核通信的方法。如proc，它不许要在任何类的硬件设备上分配存储空间，所有的信息都是动态在内存中开辟和存储。
（3）网络文件系统（Network Filesystem） 是基于磁盘的文件系统和虚拟文件系统之间的折中。这种文件系统允许访问另一台计算机上的数据，该计算机通过网络连接到本地计算机。在这种情况下，数据实际上存储在一个不同系统的硬件设备上。
由于VFS抽象层的存在，用户空间进程不会看到本地文件系统与网络文件系统之间的区别。</p>
<ol>
  <li>VFS的模型与结构
VFS不仅为文件系统提供了方法和抽象，还支持文件系统中对象（或文件）的统一视图。并非每一种文件系统都支持VFS中的所有抽象，如FAT，因为其设计没有考虑到此类对象。定义一个最小的通用模型，来支持内核中所有文件系统都实现的那些功能，这是不实际的。因为这样会损失许多本质性的功能特性，或者导致这些特性只能通过特定文件系统的路径访问。
VFS的方案完全相反：提供一种结构模型，包含了一个强大文件系统所具备的所有组件。但该模型只存在于虚拟中，必须使用各种对象和函数指针与每种文件系统适配。所有文件系统的实现都必须提供与VFS定义的结构配合的例程，以弥合两种视图之间的差异。
VFS是由基于经典文件系统的结构衍化而来，所以VFS与Ext类文件系统类似，从而在处理Ext类文件系统的时候，Ext和VFS之间的转换，几乎不会损失时间。</li>
</ol>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/07/vfs.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/06/linux_rcu.html" class="post-title-link">
      <h2>linux_rcu</h2>
    </a>

    <div class="post-date">Dec 6, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>1:RCU使用在读者多而写者少的情况.RCU和读写锁相似.但RCU的读者占锁没有任何的系统开销.写者与写写者之间必须要保持同步,且写者必须要等它之前的读者全部都退出之后才能释放之前的资源.
2:RCU保护的是指针.这一点尤其重要.因为指针赋值是一条单指令.也就是说是一个原子操作.因它更改指针指向没必要考虑它的同步.只需要考虑cache的影响. 
3:读者是可以嵌套的.也就是说rcu_read_lock()可以嵌套调用. 
4:读者在持有rcu_read_lock()的时候,不能发生进程上下文切换.否则,因为写者需要要等待读者完成,写者进程也会一直被阻塞.</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/06/linux_rcu.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/06/linux_mmap.html" class="post-title-link">
      <h2>Linux的mmap内存映射机制</h2>
    </a>

    <div class="post-date">Dec 6, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>一个进程应该包括一个mm_struct(memory manage struct), 该结构是进程虚拟地址空间的抽象描述,里面包括了进程虚拟空间的一些管理信息: start_code, end_code, start_data, end_data, start_brk, end_brk等等信息.另外,也有一个指向进程虚存区表(vm_area_struct: virtual memory area)的指针,该链是按照虚拟地址的增长顺序排列的.在Linux进程的地址空间被分作许多区(vma),每个区(vma)都对应虚拟地址空间上一段连续的区域, vma是可以被共享和保护的独立实体,这里的vma就是前面提到的内存对象.</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/06/linux_mmap.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/06/linux_lock.html" class="post-title-link">
      <h2>linux_lock</h2>
    </a>

    <div class="post-date">Dec 6, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实象多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。在主流的Linux内核中包含了几乎所有现代的操作系统具有的同步机制，这些同步机制包括：原子操作、信号量（semaphore）、读写信号量（rw_semaphore）、spinlock、 BKL(Big Kernel Lock)、rwlock、brlock（只包含在2.4内核中）、RCU（只包含在2.6内核中）和seqlock（只包含在2.6内核中）。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/06/linux_lock.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/06/linux_elf.html" class="post-title-link">
      <h2>linux_elf</h2>
    </a>

    <div class="post-date">Dec 6, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>可执行连接格式是UNIX系统实验室(USL)作为应用程序二进制接口
(Application Binary Interface(ABI)而开发和发布的。工具接口标准委
员会(TIS)选择了正在发展中的ELF标准作为工作在32位INTEL体系上不同操
作系统之间可移植的二进制文件格式。
假定开发者定义了一个二进制接口集合，ELF标准用它来支持流线型的软件
发展。 应该减少不同执行接口的数量。因此可以减少重新编程重新编译的
代码。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/06/linux_elf.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/06/linux_cow.html" class="post-title-link">
      <h2>linux_cow</h2>
    </a>

    <div class="post-date">Dec 6, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/06/linux_cow.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/05/linux_memory.html" class="post-title-link">
      <h2>linux_memory</h2>
    </a>

    <div class="post-date">Dec 5, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>TLB(Translation Lookaside Buffer)转换检测缓冲区是一个内存管理单元,用于改进虚拟地址到物理地址转换速度的缓存。
TLB是一个小的，虚拟寻址的缓存，其中每一行都保存着一个由单个PTE(Page Table Entry,页表项)组成的块。如果没有TLB，则每次取数据都需要两次访问内存，即查页表获得物理地址和取数据。
当cpu要访问一个虚拟地址/线性地址时，CPU会首先根据虚拟地址的高20位（20是x86特定的，不同架构有不同的值）在TLB中查找。如果是表中没有相应的表项，称为TLB miss，需要通过访问慢速RAM中的页表计算出相应的物理地址。同时，物理地址被存放在一个TLB表项中，以后对同一线性地址的访问，直接从TLB表项中获取物理地址即可，称为TLB hit。
Linux把物理内存划分为三个层次来管理
存储节点(Node)	CPU被划分为多个节点(node), 内存则被分簇, 每个CPU对应一个本地物理内存, 即一个CPU-node对应一个内存簇bank，即每个内存簇被认为是一个节点
管理区(Zone)	每个物理内存节点node被划分为多个内存管理区域, 用于表示不同范围的内存, 内核可以使用不同的映射方式映射物理内存
页面(Page)	内存被细分为多个页面帧, 页面是最基本的页面分配的单位　
为了支持NUMA模型，也即CPU对不同内存单元的访问时间可能不同，此时系统的物理内存被划分为几个节点(node), 一个node对应一个内存簇bank，即每个内存簇被认为是一个节点</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/05/linux_memory.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>



                    </div>
					<hr>
            </div>

            <!-- Blog Sidebar Widgets Column -->
            <div class="col-md-4">

            	 <div class="well">
            	 	<span id='statics' ></span>
            	 </div>

                <!-- Blog Search Well -->
                <div class="well">
                    <h4>Search</h4>
                    <div class="input-group">
					<form action="#" id="cse-search-box">
					  <div>
					    <input type="hidden" name="cx" value="" />
					    <input type="hidden" name="ie" value="UTF-8" />
					    <!-- 搜索框 -->   
					    <input type="text" name="q" size="20" id='txt' />
					    <input type="submit" name="sa" value="Search" />
						<!-- 模糊查询结果显示框 -->
						<div id="msg"></div>
							<script type="text/javascript">  
							var searchIndex={
							"code" : 0 ,
							"data" : [
							
							{
							"title" : "tideways + xhgui（+toolkit） php 性能分析 - ",
							"url" : "/MyBlog/web/2019/04/24/tideways.html"
							}
							
							,
							
							
							{
							"title" : "treemap HashMap和LinkedHashMap的区别 - ",
							"url" : "/MyBlog/algorithm/2019/04/23/treemap.html"
							}
							
							,
							
							
							{
							"title" : "gctrace - ",
							"url" : "/MyBlog/golang/2019/04/23/gctrace.html"
							}
							
							,
							
							
							{
							"title" : "BitTorrent协议分析 - ",
							"url" : "/MyBlog/web/2019/04/23/BitTorrent%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E4%B8%80.html"
							}
							
							,
							
							
							{
							"title" : "mutex - ",
							"url" : "/MyBlog/golang/2019/04/22/mutex.html"
							}
							
							,
							
							
							{
							"title" : "WaitGroup - ",
							"url" : "/MyBlog/golang/2019/04/22/WaitGroup.html"
							}
							
							,
							
							
							{
							"title" : "TCMalloc - ",
							"url" : "/MyBlog/golang/2019/04/22/TCMalloc.html"
							}
							
							,
							
							
							{
							"title" : "SESSION 保存在服务器的哪里 - ",
							"url" : "/MyBlog/web/2019/04/21/SESSION.html"
							}
							
							,
							
							
							{
							"title" : "go schedule - ",
							"url" : "/MyBlog/golang/2019/04/20/schedule.html"
							}
							
							,
							
							
							{
							"title" : "gc - ",
							"url" : "/MyBlog/golang/2019/04/20/gc.html"
							}
							
							,
							
							
							{
							"title" : "channel - ",
							"url" : "/MyBlog/golang/2019/04/20/channel.html"
							}
							
							,
							
							
							{
							"title" : "lldb - ",
							"url" : "/MyBlog/golang/2019/04/18/lldb.html"
							}
							
							,
							
							
							{
							"title" : "goroutine实现原理 - ",
							"url" : "/MyBlog/golang/2019/04/18/goroutine.html"
							}
							
							,
							
							
							{
							"title" : "go Vet - ",
							"url" : "/MyBlog/golang/2019/04/18/Vet.html"
							}
							
							,
							
							
							{
							"title" : "runtime - ",
							"url" : "/MyBlog/golang/2019/04/17/runtime.html"
							}
							
							,
							
							
							{
							"title" : "go:linkname go:nosplit - ",
							"url" : "/MyBlog/golang/2019/04/17/linkname.html"
							}
							
							,
							
							
							{
							"title" : "Go 语言编译指示 - ",
							"url" : "/MyBlog/golang/2019/04/17/go.html"
							}
							
							,
							
							
							{
							"title" : "Cond - ",
							"url" : "/MyBlog/golang/2019/04/17/Cond.html"
							}
							
							,
							
							
							{
							"title" : "reflection - ",
							"url" : "/MyBlog/golang/2019/04/14/reflection.html"
							}
							
							,
							
							
							{
							"title" : "Tcp Keepalive和HTTP Keep-alive - ",
							"url" : "/MyBlog/linux/2019/04/13/tcphttp.html"
							}
							
							,
							
							
							{
							"title" : "keepalive 连接池 - ",
							"url" : "/MyBlog/linux/2019/04/13/keepalive.html"
							}
							
							,
							
							
							{
							"title" : "发送接收缓冲区滑动窗口 - ",
							"url" : "/MyBlog/linux/2019/04/13/cwnd.html"
							}
							
							,
							
							
							{
							"title" : "dnsmasq - ",
							"url" : "/MyBlog/algorithm/2019/04/12/dnsmasq.html"
							}
							
							,
							
							
							{
							"title" : "Zabbix 监控组件及流程 - ",
							"url" : "/MyBlog/web/2019/04/12/Zabbix.html"
							}
							
							,
							
							
							{
							"title" : "FULLTEXT 全文索引 - ",
							"url" : "/MyBlog/storage/2019/04/12/FULLTEXT.html"
							}
							
							,
							
							
							{
							"title" : "vrrp keepalived - ",
							"url" : "/MyBlog/web/2019/04/09/vrrp.html"
							}
							
							,
							
							
							{
							"title" : "lvs - ",
							"url" : "/MyBlog/algorithm/2019/04/09/lvs.html"
							}
							
							,
							
							
							{
							"title" : "dig - ",
							"url" : "/MyBlog/web/2019/04/09/dig.html"
							}
							
							,
							
							
							{
							"title" : "高qps接入层方案 - ",
							"url" : "/MyBlog/web/2019/04/08/qps.html"
							}
							
							,
							
							
							{
							"title" : "for update - ",
							"url" : "/MyBlog/storage/2019/04/08/forupdate.html"
							}
							
							,
							
							
							{
							"title" : "inode 与文件块 block 对应关系 - ",
							"url" : "/MyBlog/linux/2019/04/07/inode.html"
							}
							
							,
							
							
							{
							"title" : "socket 虚拟文件系统 - ",
							"url" : "/MyBlog/linux/2019/04/06/socket.html"
							}
							
							,
							
							
							{
							"title" : "screen nohup session - ",
							"url" : "/MyBlog/linux/2019/04/06/screen.html"
							}
							
							,
							
							
							{
							"title" : "Golang服务器的网络层实现--总结对比常用epoll模型 - ",
							"url" : "/MyBlog/golang/2019/04/06/net.html"
							}
							
							,
							
							
							{
							"title" : "堆组织表(HOT)和索引组织表(IOT) - ",
							"url" : "/MyBlog/storage/2019/04/06/iot.html"
							}
							
							,
							
							
							{
							"title" : "fork cahe - ",
							"url" : "/MyBlog/linux/2019/04/06/fork_cahe.html"
							}
							
							,
							
							
							{
							"title" : "文件锁 - ",
							"url" : "/MyBlog/linux/2019/04/06/file_lock.html"
							}
							
							,
							
							
							{
							"title" : "fd 文件描述符 - ",
							"url" : "/MyBlog/linux/2019/04/06/fd.html"
							}
							
							,
							
							
							{
							"title" : "fork() execve() - ",
							"url" : "/MyBlog/linux/2019/04/06/exec.html"
							}
							
							,
							
							
							{
							"title" : "snowflake - ",
							"url" : "/MyBlog/algorithm/2019/03/31/snowflake.html"
							}
							
							,
							
							
							{
							"title" : "Consul vs Zookeeper vs Etcd vs Eureka - ",
							"url" : "/MyBlog/algorithm/2019/03/31/eureka.html"
							}
							
							,
							
							
							{
							"title" : "maxmemory - ",
							"url" : "/MyBlog/algorithm/2019/03/27/maxmemory.html"
							}
							
							,
							
							
							{
							"title" : "页、磁盘块与扇区 - ",
							"url" : "/MyBlog/linux/2019/03/27/disk.html"
							}
							
							,
							
							
							{
							"title" : "GeoHash - ",
							"url" : "/MyBlog/algorithm/2019/03/27/GeoHash.html"
							}
							
							,
							
							
							{
							"title" : "SkipList跳表基本原理 - ",
							"url" : "/MyBlog/algorithm/2019/03/26/skip_table.html"
							}
							
							,
							
							
							{
							"title" : "Bash 带有特殊含义的退出码 - ",
							"url" : "/MyBlog/linux/2019/03/25/exit.html"
							}
							
							,
							
							
							{
							"title" : "FUNCNAME - ",
							"url" : "/MyBlog/linux/2019/03/25/FUNCNAME.html"
							}
							
							,
							
							
							{
							"title" : "乐观锁悲观锁 - ",
							"url" : "/MyBlog/linux/2019/03/24/lock.html"
							}
							
							,
							
							
							{
							"title" : "redis zset 延迟队列 - ",
							"url" : "/MyBlog/storage/2019/03/23/zset.html"
							}
							
							,
							
							
							{
							"title" : "redis keys scan - ",
							"url" : "/MyBlog/storage/2019/03/23/scan.html"
							}
							
							,
							
							
							{
							"title" : "lru - ",
							"url" : "/MyBlog/storage/2019/03/23/lru.html"
							}
							
							,
							
							
							{
							"title" : "lfu - ",
							"url" : "/MyBlog/storage/2019/03/23/lfu.html"
							}
							
							,
							
							
							{
							"title" : "Codis Twemproxy redis集群 - ",
							"url" : "/MyBlog/storage/2019/03/23/codis.html"
							}
							
							,
							
							
							{
							"title" : "gap Lock 间隙锁 - ",
							"url" : "/MyBlog/storage/2019/03/19/gapLock.html"
							}
							
							,
							
							
							{
							"title" : "strace - ",
							"url" : "/MyBlog/linux/2019/03/17/strace.html"
							}
							
							,
							
							
							{
							"title" : "pstack 原理 - ",
							"url" : "/MyBlog/linux/2019/03/17/pstack.html"
							}
							
							,
							
							
							{
							"title" : "Linux进程间通信-消息队列（mqueue） - ",
							"url" : "/MyBlog/linux/2019/03/17/mqueue.html"
							}
							
							,
							
							
							{
							"title" : "kill - ",
							"url" : "/MyBlog/linux/2019/03/17/kill.html"
							}
							
							,
							
							
							{
							"title" : "interface - ",
							"url" : "/MyBlog/golang/2019/03/17/interface.html"
							}
							
							,
							
							
							{
							"title" : "gc - ",
							"url" : "/MyBlog/golang/2019/03/17/gc.html"
							}
							
							,
							
							
							{
							"title" : "火焰图（flame graph) - ",
							"url" : "/MyBlog/linux/2019/03/17/flame.html"
							}
							
							,
							
							
							{
							"title" : "escape 逃逸分析 - ",
							"url" : "/MyBlog/golang/2019/03/17/escape.html"
							}
							
							,
							
							
							{
							"title" : "core dump - ",
							"url" : "/MyBlog/linux/2019/03/17/core.html"
							}
							
							,
							
							
							{
							"title" : "thread apply all bt - ",
							"url" : "/MyBlog/linux/2019/03/17/bt.html"
							}
							
							,
							
							
							{
							"title" : "尾递归、尾调用 - ",
							"url" : "/MyBlog/lang/2019/03/10/tail.html"
							}
							
							,
							
							
							{
							"title" : "golang slice append 陷阱 - ",
							"url" : "/MyBlog/golang/2019/03/10/slice.html"
							}
							
							,
							
							
							{
							"title" : "函数式编程、闭包 - ",
							"url" : "/MyBlog/lang/2019/03/10/functional.html"
							}
							
							,
							
							
							{
							"title" : "通配符与正则表达式 - ",
							"url" : "/MyBlog/linux/2019/03/09/regx.html"
							}
							
							,
							
							
							{
							"title" : "awk 用法总结 - ",
							"url" : "/MyBlog/linux/2019/03/03/awk.html"
							}
							
							,
							
							
							{
							"title" : "线程技术(Hyper-Threading Technology) - ",
							"url" : "/MyBlog/web/2019/03/02/ht.html"
							}
							
							,
							
							
							{
							"title" : "ConcurrentHashMap 分段锁 - ",
							"url" : "/MyBlog/algorithm/2019/03/02/ConcurrentHashMap.html"
							}
							
							,
							
							
							{
							"title" : "锁 - ",
							"url" : "/MyBlog/web/2019/02/27/lock.html"
							}
							
							,
							
							
							{
							"title" : "futex 快速用户空间互斥体 - ",
							"url" : "/MyBlog/linux/2019/02/27/futex.html"
							}
							
							,
							
							
							{
							"title" : "Test And Set Lock - ",
							"url" : "/MyBlog/linux/2019/02/27/Test_And_Set_Lock.html"
							}
							
							,
							
							
							{
							"title" : "分布式事务 xa/tcc - ",
							"url" : "/MyBlog/web/2019/02/26/xa.html"
							}
							
							,
							
							
							{
							"title" : "分布式缓存redis - ",
							"url" : "/MyBlog/storage/2019/02/26/redis.html"
							}
							
							,
							
							
							{
							"title" : "elasticsearch - ",
							"url" : "/MyBlog/elasticsearch/2019/02/26/elasticsearch.html"
							}
							
							,
							
							
							{
							"title" : "异地多活 - ",
							"url" : "/MyBlog/algorithm/2019/02/26/cap.html"
							}
							
							,
							
							
							{
							"title" : "go语言sync包的学习(Mutex、WaitGroup、Cond) - ",
							"url" : "/MyBlog/golang/2019/02/24/sync.html"
							}
							
							,
							
							
							{
							"title" : "golang 的栈 - ",
							"url" : "/MyBlog/golang/2019/02/24/stack.html"
							}
							
							,
							
							
							{
							"title" : "Go语言汇编 - ",
							"url" : "/MyBlog/golang/2019/02/24/goasm.html"
							}
							
							,
							
							
							{
							"title" : "Actor模型和CSP模型的区别 - ",
							"url" : "/MyBlog/golang/2019/02/24/csp_actor.html"
							}
							
							,
							
							
							{
							"title" : "CSP(Communicating Sequential Processes)模型 - ",
							"url" : "/MyBlog/golang/2019/02/24/csp.html"
							}
							
							,
							
							
							{
							"title" : "application binary interface - ",
							"url" : "/MyBlog/web/2019/02/24/abi.html"
							}
							
							,
							
							
							{
							"title" : "Context - ",
							"url" : "/MyBlog/golang/2019/02/24/Context.html"
							}
							
							,
							
							
							{
							"title" : "Go unsafe Pointer - ",
							"url" : "/MyBlog/golang/2019/02/23/unsafepointer.html"
							}
							
							,
							
							
							{
							"title" : "ilp 整数线性规划 - ",
							"url" : "/MyBlog/algorithm/2019/02/22/ilp.html"
							}
							
							,
							
							
							{
							"title" : "php json_encode 的坑 - ",
							"url" : "/MyBlog/web/2019/01/28/json_encode.html"
							}
							
							,
							
							
							{
							"title" : "traps - ",
							"url" : "/MyBlog/golang/2019/01/26/traps.html"
							}
							
							,
							
							
							{
							"title" : "golang 内存分配 - ",
							"url" : "/MyBlog/golang/2019/01/26/stack.html"
							}
							
							,
							
							
							{
							"title" : "Server Name Indication - ",
							"url" : "/MyBlog/web/2019/01/26/sni.html"
							}
							
							,
							
							
							{
							"title" : "golang  nil 总结 - ",
							"url" : "/MyBlog/golang/2019/01/26/nil.html"
							}
							
							,
							
							
							{
							"title" : "checkstyle - ",
							"url" : "/MyBlog/web/2019/01/16/checkstyle.html"
							}
							
							,
							
							
							{
							"title" : "timer - ",
							"url" : "/MyBlog/linux/2019/01/15/timer.html"
							}
							
							,
							
							
							{
							"title" : "timekeeper - ",
							"url" : "/MyBlog/linux/2019/01/15/timekeeper.html"
							}
							
							,
							
							
							{
							"title" : "jiffies - ",
							"url" : "/MyBlog/linux/2019/01/15/jiffies.html"
							}
							
							,
							
							
							{
							"title" : "clock_event_device - ",
							"url" : "/MyBlog/linux/2019/01/15/clock_event_device.html"
							}
							
							,
							
							
							{
							"title" : "时间轮算法 - ",
							"url" : "/MyBlog/linux/2019/01/15/callout.html"
							}
							
							,
							
							
							{
							"title" : "ddd - ",
							"url" : "/MyBlog/web/2019/01/13/ddd.html"
							}
							
							,
							
							
							{
							"title" : "4色图 - ",
							"url" : "/MyBlog/web/2019/01/13/4color.html"
							}
							
							,
							
							
							{
							"title" : "www-authenticate - ",
							"url" : "/MyBlog/web/2019/01/12/www-authenticate.html"
							}
							
							,
							
							
							{
							"title" : "rstp - ",
							"url" : "/MyBlog/web/2019/01/12/rstp.html"
							}
							
							,
							
							
							{
							"title" : "WebDAV - ",
							"url" : "/MyBlog/web/2019/01/12/WebDAV.html"
							}
							
							,
							
							
							{
							"title" : "TCP_NODELAY - ",
							"url" : "/MyBlog/web/2019/01/12/TCP_NODELAY.html"
							}
							
							,
							
							
							{
							"title" : "reflect golang 反射 - ",
							"url" : "/MyBlog/golang/2019/01/04/reflect.html"
							}
							
							,
							
							
							{
							"title" : "llvm - ",
							"url" : "/MyBlog/lang/2019/01/02/llvm.html"
							}
							
							,
							
							
							{
							"title" : "recover panic defer - ",
							"url" : "/MyBlog/golang/2018/12/29/recover.html"
							}
							
							,
							
							
							{
							"title" : "golang debug dlv - ",
							"url" : "/MyBlog/golang/2018/12/25/godebug.html"
							}
							
							,
							
							
							{
							"title" : "gdb dlv 对比 - ",
							"url" : "/MyBlog/golang/2018/12/25/gdbdlv.html"
							}
							
							,
							
							
							{
							"title" : "gdb 工作原理和内核实现 - ",
							"url" : "/MyBlog/golang/2018/12/25/gdb_.html"
							}
							
							,
							
							
							{
							"title" : "gdb 调试golang - ",
							"url" : "/MyBlog/golang/2018/12/25/gdb.html"
							}
							
							,
							
							
							{
							"title" : "go-bindata Go 语言打包静态文件 - ",
							"url" : "/MyBlog/golang/2018/12/24/go-bindata.html"
							}
							
							,
							
							
							{
							"title" : "esc - ",
							"url" : "/MyBlog/golang/2018/12/24/esc.html"
							}
							
							,
							
							
							{
							"title" : "go Generate - ",
							"url" : "/MyBlog/golang/2018/12/24/Generate.html"
							}
							
							,
							
							
							{
							"title" : "subline text3 插件编写 - ",
							"url" : "/MyBlog/web/2018/12/23/subline.html"
							}
							
							,
							
							
							{
							"title" : "bom - ",
							"url" : "/MyBlog/web/2018/12/23/bom.html"
							}
							
							,
							
							
							{
							"title" : "newSQL - ",
							"url" : "/MyBlog/storage/2018/12/22/newSQL.html"
							}
							
							,
							
							
							{
							"title" : "subline text3 自动生成测试代码 - ",
							"url" : "/MyBlog/golang/2018/12/22/gotest_subline.html"
							}
							
							,
							
							
							{
							"title" : "ghost - ",
							"url" : "/MyBlog/storage/2018/12/22/ghost.html"
							}
							
							,
							
							
							{
							"title" : "go test - ",
							"url" : "/MyBlog/golang/2018/12/21/gotest.html"
							}
							
							,
							
							
							{
							"title" : "golang strcut 初始化 - ",
							"url" : "/MyBlog/golang/2018/12/20/strcut.html"
							}
							
							,
							
							
							{
							"title" : "docker mac 镜像清理 - ",
							"url" : "/MyBlog/docker/2018/12/18/docker_clean.html"
							}
							
							,
							
							
							{
							"title" : "golang 传值传引用 - ",
							"url" : "/MyBlog/golang/2018/12/14/reference.html"
							}
							
							,
							
							
							{
							"title" : "ntp 网络时间协议 - ",
							"url" : "/MyBlog/algorithm/2018/12/13/ntp.html"
							}
							
							,
							
							
							{
							"title" : "hive 表与hdfs关系 - ",
							"url" : "/MyBlog/storage/2018/12/08/hive.html"
							}
							
							,
							
							
							{
							"title" : "Shell 脚本中调用另一个 Shell 脚本 - ",
							"url" : "/MyBlog/web/2018/11/28/shell.html"
							}
							
							,
							
							
							{
							"title" : "Multipart File Upload - ",
							"url" : "/MyBlog/golang/2018/11/26/postfile.html"
							}
							
							,
							
							
							{
							"title" : "golang 的坑 - ",
							"url" : "/MyBlog/golang/2018/11/26/float64.html"
							}
							
							,
							
							
							{
							"title" : "http basic authentication - ",
							"url" : "/MyBlog/golang/2018/11/26/authentication.html"
							}
							
							,
							
							
							{
							"title" : "索引原理分析 - ",
							"url" : "/MyBlog/elasticsearch/2018/11/18/stor.html"
							}
							
							,
							
							
							{
							"title" : "正排索引vs倒排索引 - ",
							"url" : "/MyBlog/elasticsearch/2018/11/18/index.html"
							}
							
							,
							
							
							{
							"title" : "hive 和 elasticsearch 的整合 - ",
							"url" : "/MyBlog/elasticsearch/2018/11/18/hive.html"
							}
							
							,
							
							
							{
							"title" : "elasticsearch 文件的存储 - ",
							"url" : "/MyBlog/elasticsearch/2018/11/18/elasticsearch.html"
							}
							
							,
							
							
							{
							"title" : "curl get 发送post数据 - ",
							"url" : "/MyBlog/web/2018/11/16/curl.html"
							}
							
							,
							
							
							{
							"title" : "地理坐标的六边形编码(PHXIS) - ",
							"url" : "/MyBlog/algorithm/2018/11/15/PHXIS.html"
							}
							
							,
							
							
							{
							"title" : "大数据系统的Lambda架构 - ",
							"url" : "/MyBlog/storage/2018/11/11/lambda.html"
							}
							
							,
							
							
							{
							"title" : "B树、B-树、B+树、B*树介绍 - ",
							"url" : "/MyBlog/storage/2018/11/11/b.html"
							}
							
							,
							
							
							{
							"title" : "Phoenix - ",
							"url" : "/MyBlog/storage/2018/11/11/Phoenix.html"
							}
							
							,
							
							
							{
							"title" : "MHA的搭建 - ",
							"url" : "/MyBlog/storage/2018/11/09/mha_setup.html"
							}
							
							,
							
							
							{
							"title" : "Xtrabackup - ",
							"url" : "/MyBlog/storage/2018/11/09/Xtrabackup.html"
							}
							
							,
							
							
							{
							"title" : "R_tree - ",
							"url" : "/MyBlog/algorithm/2018/11/09/R_tree.html"
							}
							
							,
							
							
							{
							"title" : "MySql GIS 空间数据库使用体验 - ",
							"url" : "/MyBlog/storage/2018/11/09/MySql.html"
							}
							
							,
							
							
							{
							"title" : "MySQL高可用架构之MHA - ",
							"url" : "/MyBlog/storage/2018/11/09/MHA.html"
							}
							
							,
							
							
							{
							"title" : "ArcSDE 是ArcGIS的空间数据引擎 - ",
							"url" : "/MyBlog/storage/2018/11/09/ArcSDE.html"
							}
							
							,
							
							
							{
							"title" : "kafka shell - ",
							"url" : "/MyBlog/storage/2018/11/07/kafka.html"
							}
							
							,
							
							
							{
							"title" : "presto - ",
							"url" : "/MyBlog/storage/2018/11/02/presto.html"
							}
							
							,
							
							
							{
							"title" : "alibaba Druid - ",
							"url" : "/MyBlog/storage/2018/11/02/Druid.html"
							}
							
							,
							
							
							{
							"title" : "Calcite - ",
							"url" : "/MyBlog/storage/2018/11/02/Calcite.html"
							}
							
							,
							
							
							{
							"title" : "binlog同步kafka方案 - ",
							"url" : "/MyBlog/storage/2018/10/31/binlog_kafka.html"
							}
							
							,
							
							
							{
							"title" : "maxwell+kafka+Spark Streaming构建MySQL Binlog日志采集实时处理方案 - ",
							"url" : "/MyBlog/storage/2018/10/29/maxwell.html"
							}
							
							,
							
							
							{
							"title" : "samza - ",
							"url" : "/MyBlog/algorithm/2018/10/28/smaza.html"
							}
							
							,
							
							
							{
							"title" : "flume - ",
							"url" : "/MyBlog/storage/2018/10/28/flume.html"
							}
							
							,
							
							
							{
							"title" : "csrf token - ",
							"url" : "/MyBlog/web/2018/10/28/csrftoken.html"
							}
							
							,
							
							
							{
							"title" : "show processlist - ",
							"url" : "/MyBlog/storage/2018/10/22/processlist.html"
							}
							
							,
							
							
							{
							"title" : "ptmalloc、tcmalloc和jemalloc - ",
							"url" : "/MyBlog/storage/2018/10/21/tcmalloc.html"
							}
							
							,
							
							
							{
							"title" : "列式存储 - ",
							"url" : "/MyBlog/storage/2018/10/21/rowstorage.html"
							}
							
							,
							
							
							{
							"title" : "mysql-proxy-lua - ",
							"url" : "/MyBlog/storage/2018/10/21/mysql-proxy-lua.html"
							}
							
							,
							
							
							{
							"title" : "mvcc - ",
							"url" : "/MyBlog/storage/2018/10/21/mvcc.html"
							}
							
							,
							
							
							{
							"title" : "LSM树由来、设计思想 - ",
							"url" : "/MyBlog/storage/2018/10/21/lsmwal.html"
							}
							
							,
							
							
							{
							"title" : "文件读取流程 - ",
							"url" : "/MyBlog/linux/2018/10/21/fileread.html"
							}
							
							,
							
							
							{
							"title" : "zookeeper在hadoop和hbase中的作用 - ",
							"url" : "/MyBlog/zookeeper/2018/10/18/zk_hdfs_hbase.html"
							}
							
							,
							
							
							{
							"title" : "ssh config - ",
							"url" : "/MyBlog/web/2018/10/18/sshconfig.html"
							}
							
							,
							
							
							{
							"title" : "google authenticator 工作原理 - ",
							"url" : "/MyBlog/web/2018/10/12/authenticator.html"
							}
							
							,
							
							
							{
							"title" : "Zookeeper 在 Kafka 中的作用 - ",
							"url" : "/MyBlog/zookeeper/2018/10/11/zkkafka.html"
							}
							
							,
							
							
							{
							"title" : "redis-lua 事物 - ",
							"url" : "/MyBlog/storage/2018/10/10/redis-lua.html"
							}
							
							,
							
							
							{
							"title" : "explain mysql  执行计划 - ",
							"url" : "/MyBlog/storage/2018/10/10/explain.html"
							}
							
							,
							
							
							{
							"title" : "mysql的隐式类型转换 - ",
							"url" : "/MyBlog/storage/2018/10/09/type.html"
							}
							
							,
							
							
							{
							"title" : "zookeeper 实现配置同步 服务发现 - ",
							"url" : "/MyBlog/zookeeper/2018/10/08/zkconf.html"
							}
							
							,
							
							
							{
							"title" : "zk 实现分布式锁 - ",
							"url" : "/MyBlog/zookeeper/2018/09/29/zklock.html"
							}
							
							,
							
							
							{
							"title" : "基于数据库的分布式锁 - ",
							"url" : "/MyBlog/storage/2018/09/29/dblock.html"
							}
							
							,
							
							
							{
							"title" : "mysqlbinlog 格式解析 - ",
							"url" : "/MyBlog/storage/2018/09/28/mysqlbinlog.html"
							}
							
							,
							
							
							{
							"title" : "sublime for mac 实现 ctrl+左键 跳转函数 - ",
							"url" : "/MyBlog/web/2018/09/27/subline.html"
							}
							
							,
							
							
							{
							"title" : "sql-parser - ",
							"url" : "/MyBlog/storage/2018/09/27/sql-parser.html"
							}
							
							,
							
							
							{
							"title" : "Redis分布式锁 - ",
							"url" : "/MyBlog/algorithm/2018/09/27/redis-lock.html"
							}
							
							,
							
							
							{
							"title" : "go 原子操作 - ",
							"url" : "/MyBlog/golang/2018/09/27/goautomic.html"
							}
							
							,
							
							
							{
							"title" : "cmakelist - ",
							"url" : "/MyBlog/algorithm/2018/09/27/cmakelist.html"
							}
							
							,
							
							
							{
							"title" : "mac mysql 开启binlog - ",
							"url" : "/MyBlog/storage/2018/09/27/binlog.html"
							}
							
							,
							
							
							{
							"title" : "autoconf和automake - ",
							"url" : "/MyBlog/linux/2018/09/27/automake.html"
							}
							
							,
							
							
							{
							"title" : "bash  2>&1 - ",
							"url" : "/MyBlog/linux/2018/09/26/bash.html"
							}
							
							,
							
							
							{
							"title" : "uninterruptible D 状态 - ",
							"url" : "/MyBlog/linux/2018/09/23/uninterruptible.html"
							}
							
							,
							
							
							{
							"title" : "LSF、BPF、eBPF - ",
							"url" : "/MyBlog/linux/2018/09/23/bpf.html"
							}
							
							,
							
							
							{
							"title" : "UNIX Domain Socket - ",
							"url" : "/MyBlog/linux/2018/09/21/unix_socket.html"
							}
							
							,
							
							
							{
							"title" : "ptrace - ",
							"url" : "/MyBlog/linux/2018/09/21/ptrace.html"
							}
							
							,
							
							
							{
							"title" : "LD_PRELOAD/DYLD_INSERT_LIBRARIES libc hook - ",
							"url" : "/MyBlog/linux/2018/09/21/LD_PRELOAD.html"
							}
							
							,
							
							
							{
							"title" : "nginx php-fpm unix-socket - ",
							"url" : "/MyBlog/web/2018/09/20/php-fpm-unix-socket.html"
							}
							
							,
							
							
							{
							"title" : "cachetool 非php环境操作apcu - ",
							"url" : "/MyBlog/web/2018/09/20/cachetool.html"
							}
							
							,
							
							
							{
							"title" : "git rebase - ",
							"url" : "/MyBlog/web/2018/09/19/rebase.html"
							}
							
							,
							
							
							{
							"title" : "futex - ",
							"url" : "/MyBlog/linux/2018/09/15/futex.html"
							}
							
							,
							
							
							{
							"title" : "strace 原理 - ",
							"url" : "/MyBlog/linux/2018/09/14/strace.html"
							}
							
							,
							
							
							{
							"title" : "libiop - ",
							"url" : "/MyBlog/web/2018/09/14/libiop.html"
							}
							
							,
							
							
							{
							"title" : "libevent - ",
							"url" : "/MyBlog/linux/2018/09/14/libevent.html"
							}
							
							,
							
							
							{
							"title" : "dbpool 数据库连接池 - ",
							"url" : "/MyBlog/algorithm/2018/09/14/dbpool.html"
							}
							
							,
							
							
							{
							"title" : "c-ares  dns 异步请求库 - ",
							"url" : "/MyBlog/linux/2018/09/14/c-ares.html"
							}
							
							,
							
							
							{
							"title" : "HttpClient - ",
							"url" : "/MyBlog/web/2018/09/14/HttpClient.html"
							}
							
							,
							
							
							{
							"title" : "Eureka 服务发现 - ",
							"url" : "/MyBlog/algorithm/2018/09/14/Eureka.html"
							}
							
							,
							
							
							{
							"title" : "makefile 及其工作原理 - ",
							"url" : "/MyBlog/linux/2018/09/13/makefile.html"
							}
							
							,
							
							
							{
							"title" : "php 内置的 web 服务器 - ",
							"url" : "/MyBlog/web/2018/09/11/oho.html"
							}
							
							,
							
							
							{
							"title" : "php 的定界符 <<<eof - ",
							"url" : "/MyBlog/web/2018/09/10/php.html"
							}
							
							,
							
							
							{
							"title" : "http_proxy - ",
							"url" : "/MyBlog/web/2018/09/10/http_proxy.html"
							}
							
							,
							
							
							{
							"title" : "thrift_golang - ",
							"url" : "/MyBlog/web/2018/09/09/thrift_golang.html"
							}
							
							,
							
							
							{
							"title" : "thrift 遇到的坑 - ",
							"url" : "/MyBlog/web/2018/09/09/thrift.html"
							}
							
							,
							
							
							{
							"title" : "spinlock 自旋锁 - ",
							"url" : "/MyBlog/linux/2018/09/08/spinlock.html"
							}
							
							,
							
							
							{
							"title" : "异步io - ",
							"url" : "/MyBlog/linux/2018/09/05/aio.html"
							}
							
							,
							
							
							{
							"title" : "thrift - ",
							"url" : "/MyBlog/web/2018/09/03/thrift.html"
							}
							
							,
							
							
							{
							"title" : "popen - ",
							"url" : "/MyBlog/linux/2018/09/03/popen.html"
							}
							
							,
							
							
							{
							"title" : "零拷贝之splice( )函数和tee( )函数 - ",
							"url" : "/MyBlog/linux/2018/09/02/tee.html"
							}
							
							,
							
							
							{
							"title" : "splice_sendfile - ",
							"url" : "/MyBlog/linux/2018/09/02/splice_sendfile.html"
							}
							
							,
							
							
							{
							"title" : "splice - ",
							"url" : "/MyBlog/linux/2018/09/02/splice.html"
							}
							
							,
							
							
							{
							"title" : "MySQL协议分析 - ",
							"url" : "/MyBlog/storage/2018/09/02/mysql.html"
							}
							
							,
							
							
							{
							"title" : "Nginx/LVS/HAProxy负载均衡软件的优缺点 - ",
							"url" : "/MyBlog/web/2018/09/02/lvs.html"
							}
							
							,
							
							
							{
							"title" : "haproxy_exp - ",
							"url" : "/MyBlog/web/2018/09/02/haproxy_exp.html"
							}
							
							,
							
							
							{
							"title" : "haproxy - ",
							"url" : "/MyBlog/web/2018/09/02/haproxy.html"
							}
							
							,
							
							
							{
							"title" : "haproxy+keepalived实现高可用集群搭建 - ",
							"url" : "/MyBlog/web/2018/09/02/Keepalived.html"
							}
							
							,
							
							
							{
							"title" : "expect 100 continue - ",
							"url" : "/MyBlog/web/2018/09/02/100_continue.html"
							}
							
							,
							
							
							{
							"title" : "Jenkins和SonarQube集成 - ",
							"url" : "/MyBlog/web/2018/08/31/sonarQubeJenkins.html"
							}
							
							,
							
							
							{
							"title" : "sonarQube之平台搭建及sonar-scanner扫描 - ",
							"url" : "/MyBlog/web/2018/08/31/sonarQube.html"
							}
							
							,
							
							
							{
							"title" : "sendfile - ",
							"url" : "/MyBlog/linux/2018/08/30/sendfile.html"
							}
							
							,
							
							
							{
							"title" : "php流Streams、包装器wrapper - ",
							"url" : "/MyBlog/web/2018/08/30/phpwrapper.html"
							}
							
							,
							
							
							{
							"title" : "phar - ",
							"url" : "/MyBlog/web/2018/08/30/phar.html"
							}
							
							,
							
							
							{
							"title" : "httpdns - ",
							"url" : "/MyBlog/algorithm/2018/08/30/httpdns.html"
							}
							
							,
							
							
							{
							"title" : "PHP 资源大全 - ",
							"url" : "/MyBlog/algorithm/2018/08/30/.html"
							}
							
							,
							
							
							{
							"title" : "oneProxy - ",
							"url" : "/MyBlog/storage/2018/08/28/oneProxy.html"
							}
							
							,
							
							
							{
							"title" : "自适应hash - ",
							"url" : "/MyBlog/algorithm/2018/08/28/hash.html"
							}
							
							,
							
							
							{
							"title" : "cgroup - ",
							"url" : "/MyBlog/linux/2018/08/28/cgroup.html"
							}
							
							,
							
							
							{
							"title" : "Php-fpm运行原理 - ",
							"url" : "/MyBlog/web/2018/08/27/fpm.html"
							}
							
							,
							
							
							{
							"title" : "sds - ",
							"url" : "/MyBlog/algorithm/2018/08/23/sds.html"
							}
							
							,
							
							
							{
							"title" : "SkipList - ",
							"url" : "/MyBlog/algorithm/2018/08/23/SkipList.html"
							}
							
							,
							
							
							{
							"title" : "MurmurHash - ",
							"url" : "/MyBlog/algorithm/2018/08/23/MurmurHash.html"
							}
							
							,
							
							
							{
							"title" : "PHP的Realpath Cache - ",
							"url" : "/MyBlog/web/2018/08/22/realpath.html"
							}
							
							,
							
							
							{
							"title" : "SQL Hints (SQL 优化器) - ",
							"url" : "/MyBlog/storage/2018/08/22/php_mysql.html"
							}
							
							,
							
							
							{
							"title" : "percona-toolkit  Maatkit - ",
							"url" : "/MyBlog/storage/2018/08/22/percona-toolkit.html"
							}
							
							,
							
							
							{
							"title" : "oracle_hint - ",
							"url" : "/MyBlog/storage/2018/08/22/oracle_hint.html"
							}
							
							,
							
							
							{
							"title" : "读写分离导致主库从库数据不一致问题 - ",
							"url" : "/MyBlog/storage/2018/08/22/master_slave_diff.html"
							}
							
							,
							
							
							{
							"title" : "主从一致性架构优化4种方法 - ",
							"url" : "/MyBlog/storage/2018/08/22/constency.html"
							}
							
							,
							
							
							{
							"title" : "opcache缓存的操作小工具cachetool - ",
							"url" : "/MyBlog/algorithm/2018/08/22/cachetool.html"
							}
							
							,
							
							
							{
							"title" : "Linux系统调用--access - ",
							"url" : "/MyBlog/linux/2018/08/22/access.html"
							}
							
							,
							
							
							{
							"title" : "Mysqlnd 主从复制和负载均衡插件 mysqlnd_qc - ",
							"url" : "/MyBlog/storage/2018/08/22/Mysqlnd.html"
							}
							
							,
							
							
							{
							"title" : "Dapper - ",
							"url" : "/MyBlog/algorithm/2018/08/22/Dapper.html"
							}
							
							,
							
							
							{
							"title" : "mysql-proxy - ",
							"url" : "/MyBlog/storage/2018/08/20/mysql-proxy.html"
							}
							
							,
							
							
							{
							"title" : "influxdb - ",
							"url" : "/MyBlog/algorithm/2018/08/20/influxdb.html"
							}
							
							,
							
							
							{
							"title" : "hint - ",
							"url" : "/MyBlog/storage/2018/08/20/hint.html"
							}
							
							,
							
							
							{
							"title" : "ifconfig - ",
							"url" : "/MyBlog/linux/2018/08/14/ifconfig.html"
							}
							
							,
							
							
							{
							"title" : "launchctl - ",
							"url" : "/MyBlog/web/2018/08/13/launchctl.html"
							}
							
							,
							
							
							{
							"title" : "time_wait - ",
							"url" : "/MyBlog/linux/2018/08/11/time_wait.html"
							}
							
							,
							
							
							{
							"title" : "OpenStack - ",
							"url" : "/MyBlog/algorithm/2018/08/11/OpenStack.html"
							}
							
							,
							
							
							{
							"title" : "μJavaActors - ",
							"url" : "/MyBlog/algorithm/2018/08/10/%CE%BCJavaActors.html"
							}
							
							,
							
							
							{
							"title" : "ceph的CRUSH数据分布算法 - ",
							"url" : "/MyBlog/algorithm/2018/08/10/crush.html"
							}
							
							,
							
							
							{
							"title" : "Akka 和 μJavaActors - ",
							"url" : "/MyBlog/algorithm/2018/08/10/akka.html"
							}
							
							,
							
							
							{
							"title" : "gossip 应用 - ",
							"url" : "/MyBlog/algorithm/2018/07/30/gossip_application.html"
							}
							
							,
							
							
							{
							"title" : "Gossip协议 - ",
							"url" : "/MyBlog/algorithm/2018/07/30/gossip.html"
							}
							
							,
							
							
							{
							"title" : "分布式系统常用思想和技术总结 - ",
							"url" : "/MyBlog/algorithm/2018/07/30/consitency.html"
							}
							
							,
							
							
							{
							"title" : "Gossip_zap_raft_paxos 对比 - ",
							"url" : "/MyBlog/algorithm/2018/07/30/Gossip_zap_raft_paxos.html"
							}
							
							,
							
							
							{
							"title" : "dht 一致性hash算法 - ",
							"url" : "/MyBlog/algorithm/2018/07/28/dht.html"
							}
							
							,
							
							
							{
							"title" : "Kademlia 原理 - ",
							"url" : "/MyBlog/algorithm/2018/07/28/Kademlia.html"
							}
							
							,
							
							
							{
							"title" : "sampling 采样 - ",
							"url" : "/MyBlog/algorithm/2018/07/27/sampling.html"
							}
							
							,
							
							
							{
							"title" : "rocksdb - ",
							"url" : "/MyBlog/storage/2018/07/26/rocksdb.html"
							}
							
							,
							
							
							{
							"title" : "Tachyon - ",
							"url" : "/MyBlog/spark/2018/07/26/Tachyon.html"
							}
							
							,
							
							
							{
							"title" : "tcc  分布式事务 - ",
							"url" : "/MyBlog/web/2018/07/22/tcc.html"
							}
							
							,
							
							
							{
							"title" : "KNN与K-Means的区别 - ",
							"url" : "/MyBlog/algorithm/2018/07/16/knn.html"
							}
							
							,
							
							
							{
							"title" : "yarn - ",
							"url" : "/MyBlog/hadoop/2018/07/12/yarn.html"
							}
							
							,
							
							
							{
							"title" : "余弦夹角 和 欧氏距离 Jaccard相似系数和皮尔逊相关系数 - ",
							"url" : "/MyBlog/algorithm/2018/07/12/jacard.html"
							}
							
							,
							
							
							{
							"title" : "MapReduce - ",
							"url" : "/MyBlog/hadoop/2018/07/12/MapReduce.html"
							}
							
							,
							
							
							{
							"title" : "php_kafka - ",
							"url" : "/MyBlog/web/2018/07/11/php_kafka.html"
							}
							
							,
							
							
							{
							"title" : "KM算法 - ",
							"url" : "/MyBlog/algorithm/2018/07/10/km.html"
							}
							
							,
							
							
							{
							"title" : "Hall匹配定理 - ",
							"url" : "/MyBlog/algorithm/2018/07/10/hall.html"
							}
							
							,
							
							
							{
							"title" : "gossip 算法 redis - ",
							"url" : "/MyBlog/algorithm/2018/07/10/gossip.html"
							}
							
							,
							
							
							{
							"title" : "bipartite_graph_match - ",
							"url" : "/MyBlog/algorithm/2018/07/10/bipartite_graph_match.html"
							}
							
							,
							
							
							{
							"title" : "bipartite_graph 二分图 - ",
							"url" : "/MyBlog/algorithm/2018/07/10/bipartite_graph.html"
							}
							
							,
							
							
							{
							"title" : "agumenting_path - ",
							"url" : "/MyBlog/algorithm/2018/07/10/agumenting_path.html"
							}
							
							,
							
							
							{
							"title" : "KM（Kuhn and Munkres）算法 - ",
							"url" : "/MyBlog/algorithm/2018/07/10/Kuhn_and_Munkres.html"
							}
							
							,
							
							
							{
							"title" : "Hungarian_algorithm 匈牙利算法 - ",
							"url" : "/MyBlog/algorithm/2018/07/10/Hungarian_algorithm.html"
							}
							
							,
							
							
							{
							"title" : "Edmond-Karp 算法  网络流 增广路 - ",
							"url" : "/MyBlog/algorithm/2018/07/10/Edmond-Karp.html"
							}
							
							,
							
							
							{
							"title" : "git - ",
							"url" : "/MyBlog/web/2018/07/06/git.html"
							}
							
							,
							
							
							{
							"title" : "composer dump-atoload namespace dir - ",
							"url" : "/MyBlog/web/2018/07/06/composer.html"
							}
							
							,
							
							
							{
							"title" : "golang list jsonMarshal之后一个为null一个为[ ]问题 - ",
							"url" : "/MyBlog/golang/2018/07/04/golang_list.html"
							}
							
							,
							
							
							{
							"title" : "xterm.js tty.js 基于浏览器的终端模拟器 - ",
							"url" : "/MyBlog/web/2018/07/03/xterm.js_tty.js.html"
							}
							
							,
							
							
							{
							"title" : "mac安装gradle - ",
							"url" : "/MyBlog/java/2018/07/03/mac_gradle.html"
							}
							
							,
							
							
							{
							"title" : "gradle_eclipse - ",
							"url" : "/MyBlog/java/2018/07/03/gradle_eclipse.html"
							}
							
							,
							
							
							{
							"title" : "build.gradle - ",
							"url" : "/MyBlog/java/2018/07/03/gradle_build.html"
							}
							
							,
							
							
							{
							"title" : "Gradle - ",
							"url" : "/MyBlog/java/2018/07/03/Gradle.html"
							}
							
							,
							
							
							{
							"title" : "mysql、zookeeper、redis和elasticsearch主从同步机制 - ",
							"url" : "/MyBlog/storage/2018/06/30/slave.html"
							}
							
							,
							
							
							{
							"title" : "redis slow log - ",
							"url" : "/MyBlog/storage/2018/06/30/redis_slow_log.html"
							}
							
							,
							
							
							{
							"title" : "redis主从复制 - ",
							"url" : "/MyBlog/storage/2018/06/30/redis_slave.html"
							}
							
							,
							
							
							{
							"title" : "redis主从复制原理、断点续传、无磁盘化复制、过期key处理 - ",
							"url" : "/MyBlog/storage/2018/06/30/redis_replication.html"
							}
							
							,
							
							
							{
							"title" : "redis_mysql - ",
							"url" : "/MyBlog/storage/2018/06/30/redis_mysql.html"
							}
							
							,
							
							
							{
							"title" : "redis_memcache - ",
							"url" : "/MyBlog/storage/2018/06/30/redis_memcache.html"
							}
							
							,
							
							
							{
							"title" : "Redis原理及使用 - ",
							"url" : "/MyBlog/storage/2018/06/30/redis.html"
							}
							
							,
							
							
							{
							"title" : "nginx_redis 高并发 - ",
							"url" : "/MyBlog/linux/2018/06/30/nginx_redis.html"
							}
							
							,
							
							
							{
							"title" : "mysql slow log - ",
							"url" : "/MyBlog/storage/2018/06/30/mysql_slow_log.html"
							}
							
							,
							
							
							{
							"title" : "multiplexing IO多路复用 - ",
							"url" : "/MyBlog/linux/2018/06/30/multiplexing.html"
							}
							
							,
							
							
							{
							"title" : "select,poll,epoll，kqueue模型 - ",
							"url" : "/MyBlog/linux/2018/06/30/kqueue.html"
							}
							
							,
							
							
							{
							"title" : "grok - ",
							"url" : "/MyBlog/elasticsearch/2018/06/30/grok.html"
							}
							
							,
							
							
							{
							"title" : "epoll_server 服务端代码 - ",
							"url" : "/MyBlog/linux/2018/06/30/epoll_server.html"
							}
							
							,
							
							
							{
							"title" : "epoll - ",
							"url" : "/MyBlog/linux/2018/06/30/epoll.html"
							}
							
							,
							
							
							{
							"title" : "Sentinel - ",
							"url" : "/MyBlog/storage/2018/06/30/Sentinel.html"
							}
							
							,
							
							
							{
							"title" : "Pipeline - ",
							"url" : "/MyBlog/storage/2018/06/30/Pipeline.html"
							}
							
							,
							
							
							{
							"title" : "Logagent 日志组件对比 - ",
							"url" : "/MyBlog/elasticsearch/2018/06/30/Logagent.html"
							}
							
							,
							
							
							{
							"title" : "test - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/test.html"
							}
							
							,
							
							
							{
							"title" : "map 映射 - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/map.html"
							}
							
							,
							
							
							{
							"title" : "logstash输出到elasticsearch - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/logstash_elasticsearch.html"
							}
							
							,
							
							
							{
							"title" : "kibana - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/kibana.html"
							}
							
							,
							
							
							{
							"title" : "index - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/index.html"
							}
							
							,
							
							
							{
							"title" : "ik - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/ik.html"
							}
							
							,
							
							
							{
							"title" : "head - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/head.html"
							}
							
							,
							
							
							{
							"title" : "elasticsearch - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/elasticsearch.html"
							}
							
							,
							
							
							{
							"title" : "dsl - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/dsl.html"
							}
							
							,
							
							
							{
							"title" : "config - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/config.html"
							}
							
							,
							
							
							{
							"title" : "aggregations - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/aggregations.html"
							}
							
							,
							
							
							{
							"title" : "_search - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/_search.html"
							}
							
							,
							
							
							{
							"title" : "Logstash_example - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/Logstash_example.html"
							}
							
							,
							
							
							{
							"title" : "Logstash_elk - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/Logstash_elk.html"
							}
							
							,
							
							
							{
							"title" : "Logstash - ",
							"url" : "/MyBlog/elasticsearch/2018/06/29/Logstash.html"
							}
							
							,
							
							
							{
							"title" : "elk mac 安装 - ",
							"url" : "/MyBlog/elasticsearch/2018/06/28/elk.html"
							}
							
							,
							
							
							{
							"title" : "sysfs - ",
							"url" : "/MyBlog/linux/2018/06/27/sysfs.html"
							}
							
							,
							
							
							{
							"title" : "proc文件系统 - ",
							"url" : "/MyBlog/linux/2018/06/27/proc.html"
							}
							
							,
							
							
							{
							"title" : "lkm 可加载内核模块 - ",
							"url" : "/MyBlog/linux/2018/06/27/lkm.html"
							}
							
							,
							
							
							{
							"title" : "kobject - ",
							"url" : "/MyBlog/linux/2018/06/27/kobject.html"
							}
							
							,
							
							
							{
							"title" : "Linux各目录及每个目录的详细介绍 - ",
							"url" : "/MyBlog/linux/2018/06/27/dir.html"
							}
							
							,
							
							
							{
							"title" : "devfs sysfs - ",
							"url" : "/MyBlog/linux/2018/06/27/devfs.html"
							}
							
							,
							
							
							{
							"title" : "pool - ",
							"url" : "/MyBlog/golang/2018/06/26/pool.html"
							}
							
							,
							
							
							{
							"title" : "Linux中pam模块 - ",
							"url" : "/MyBlog/linux/2018/06/26/pam.html"
							}
							
							,
							
							
							{
							"title" : "issue 设置linux登录前后的欢迎信息 - ",
							"url" : "/MyBlog/linux/2018/06/26/issue.html"
							}
							
							,
							
							
							{
							"title" : "bash_profile等几个文件的执行过程 - ",
							"url" : "/MyBlog/linux/2018/06/26/bash_profile.html"
							}
							
							,
							
							
							{
							"title" : "gorpc - ",
							"url" : "/MyBlog/web/2018/06/24/gorpc.html"
							}
							
							,
							
							
							{
							"title" : "HAProxy - ",
							"url" : "/MyBlog/web/2018/06/24/HAProxy.html"
							}
							
							,
							
							
							{
							"title" : "Nutch - ",
							"url" : "/MyBlog/web/2018/06/23/Nutch.html"
							}
							
							,
							
							
							{
							"title" : "lsm - ",
							"url" : "/MyBlog/web/2018/06/16/lsm.html"
							}
							
							,
							
							
							{
							"title" : "logstash  日志收集 - ",
							"url" : "/MyBlog/elasticsearch/2018/06/16/logstash.html"
							}
							
							,
							
							
							{
							"title" : "ldap 轻量目录访问协议 - ",
							"url" : "/MyBlog/web/2018/06/16/ldap.html"
							}
							
							,
							
							
							{
							"title" : "查看某行代码的git修改历史 - ",
							"url" : "/MyBlog/web/2018/06/16/gitEditHistory.html"
							}
							
							,
							
							
							{
							"title" : "python中os.system、os.popen、subprocess.popen的区别 - ",
							"url" : "/MyBlog/linux/2018/06/12/subprocess.html"
							}
							
							,
							
							
							{
							"title" : "sshpass - ",
							"url" : "/MyBlog/linux/2018/06/12/sshpass.html"
							}
							
							,
							
							
							{
							"title" : "samba - ",
							"url" : "/MyBlog/linux/2018/06/12/samb.html"
							}
							
							,
							
							
							{
							"title" : "pyopen Python subprocess - ",
							"url" : "/MyBlog/linux/2018/06/12/pyopen.html"
							}
							
							,
							
							
							{
							"title" : "dns - ",
							"url" : "/MyBlog/linux/2018/06/12/dns.html"
							}
							
							,
							
							
							{
							"title" : "bind - ",
							"url" : "/MyBlog/linux/2018/06/12/bind.html"
							}
							
							,
							
							
							{
							"title" : "supervisor - ",
							"url" : "/MyBlog/linux/2018/06/10/supervisor.html"
							}
							
							,
							
							
							{
							"title" : "Paxos、Raft、Zab和VR - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/raft.html"
							}
							
							,
							
							
							{
							"title" : "quorum - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/quorum.html"
							}
							
							,
							
							
							{
							"title" : "Paxos和Quorum - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/paxos_quorum.html"
							}
							
							,
							
							
							{
							"title" : "lucence  elasticsearch - ",
							"url" : "/MyBlog/elasticsearch/2018/06/10/lucence.html"
							}
							
							,
							
							
							{
							"title" : "jndi - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/jndi.html"
							}
							
							,
							
							
							{
							"title" : "guava - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/gava.html"
							}
							
							,
							
							
							{
							"title" : "fluent 编程风格 - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/fluent.html"
							}
							
							,
							
							
							{
							"title" : "Curator - ",
							"url" : "/MyBlog/zookeeper/2018/06/10/Curator.html"
							}
							
							,
							
							
							{
							"title" : "ZooKeeper实现配置同步 - ",
							"url" : "/MyBlog/spark/2018/06/03/zk_conf.html"
							}
							
							,
							
							
							{
							"title" : "nginx_header - ",
							"url" : "/MyBlog/web/2018/06/03/nginx_header.html"
							}
							
							,
							
							
							{
							"title" : "dtrace - ",
							"url" : "/MyBlog/linux/2018/06/03/dtrace.html"
							}
							
							,
							
							
							{
							"title" : "zebra - ",
							"url" : "/MyBlog/linux/2018/05/30/zebra.html"
							}
							
							,
							
							
							{
							"title" : "rawip - ",
							"url" : "/MyBlog/linux/2018/05/30/rawip.html"
							}
							
							,
							
							
							{
							"title" : "ospf - ",
							"url" : "/MyBlog/linux/2018/05/30/ospf.html"
							}
							
							,
							
							
							{
							"title" : "邻居子系统 - ",
							"url" : "/MyBlog/linux/2018/05/30/nabour.html"
							}
							
							,
							
							
							{
							"title" : "General Purpose Input Output - ",
							"url" : "/MyBlog/linux/2018/05/30/gpio.html"
							}
							
							,
							
							
							{
							"title" : "流量控制 - ",
							"url" : "/MyBlog/linux/2018/05/30/Traffic_ctl.html"
							}
							
							,
							
							
							{
							"title" : "透明网桥 - ",
							"url" : "/MyBlog/linux/2018/05/28/transparent.html"
							}
							
							,
							
							
							{
							"title" : "tcpdump - ",
							"url" : "/MyBlog/linux/2018/05/28/tcpdump.html"
							}
							
							,
							
							
							{
							"title" : "stp 生成树协议 - ",
							"url" : "/MyBlog/linux/2018/05/28/stp.html"
							}
							
							,
							
							
							{
							"title" : "NAPI 技术在 Linux 网络驱动上的应用 - ",
							"url" : "/MyBlog/linux/2018/05/28/napi.html"
							}
							
							,
							
							
							{
							"title" : "ethereal - ",
							"url" : "/MyBlog/linux/2018/05/28/ethereal.html"
							}
							
							,
							
							
							{
							"title" : "inotify 监控 Linux 文件系统事件 - ",
							"url" : "/MyBlog/linux/2018/05/24/inotify.html"
							}
							
							,
							
							
							{
							"title" : "golang fsnotify - ",
							"url" : "/MyBlog/golang/2018/05/24/fsnotify_go.html"
							}
							
							,
							
							
							{
							"title" : "fsnotify - ",
							"url" : "/MyBlog/linux/2018/05/24/fsnotify.html"
							}
							
							,
							
							
							{
							"title" : "PostForm - ",
							"url" : "/MyBlog/golang/2018/05/18/PostForm.html"
							}
							
							,
							
							
							{
							"title" : "template - ",
							"url" : "/MyBlog/golang/2018/05/17/template.html"
							}
							
							,
							
							
							{
							"title" : "mergely_CodeMirror_DiffMatchPatch前端文本diff - ",
							"url" : "/MyBlog/web/2018/05/12/mergeLy.html"
							}
							
							,
							
							
							{
							"title" : "pipework  为docker容器配置独立IP - ",
							"url" : "/MyBlog/docker/2018/05/09/pipework.html"
							}
							
							,
							
							
							{
							"title" : "调用namespace的API - ",
							"url" : "/MyBlog/docker/2018/05/09/namespace.html"
							}
							
							,
							
							
							{
							"title" : "ifconfig - ",
							"url" : "/MyBlog/net/2018/05/08/ifconfig.html"
							}
							
							,
							
							
							{
							"title" : "subnet_mask  子网掩码 - ",
							"url" : "/MyBlog/net/2018/05/06/subnet_mask.html"
							}
							
							,
							
							
							{
							"title" : "iptables - ",
							"url" : "/MyBlog/linux/2018/05/06/iptables.html"
							}
							
							,
							
							
							{
							"title" : "gateway - ",
							"url" : "/MyBlog/net/2018/05/06/gateway.html"
							}
							
							,
							
							
							{
							"title" : "docker_bridge 容器桥接到物理网络 - ",
							"url" : "/MyBlog/docker/2018/05/06/docker_bridge.html"
							}
							
							,
							
							
							{
							"title" : "default_gateway 默认网关 - ",
							"url" : "/MyBlog/net/2018/05/06/default_gateway.html"
							}
							
							,
							
							
							{
							"title" : "bridge 网桥 Linux下的虚拟网桥 - ",
							"url" : "/MyBlog/net/2018/05/06/bridge.html"
							}
							
							,
							
							
							{
							"title" : "wins - ",
							"url" : "/MyBlog/net/2018/05/05/wins.html"
							}
							
							,
							
							
							{
							"title" : "routing_table 路由表 - ",
							"url" : "/MyBlog/net/2018/05/05/routing_table.html"
							}
							
							,
							
							
							{
							"title" : "routing_protocol 路由协议 - ",
							"url" : "/MyBlog/net/2018/05/05/routing_protocol.html"
							}
							
							,
							
							
							{
							"title" : "router 路由协议 - ",
							"url" : "/MyBlog/net/2018/05/05/router.html"
							}
							
							,
							
							
							{
							"title" : "rip 路由信息协议 - ",
							"url" : "/MyBlog/net/2018/05/05/rip.html"
							}
							
							,
							
							
							{
							"title" : "netbios - ",
							"url" : "/MyBlog/net/2018/05/05/netbios.html"
							}
							
							,
							
							
							{
							"title" : "lmhosts - ",
							"url" : "/MyBlog/net/2018/05/05/lmhosts.html"
							}
							
							,
							
							
							{
							"title" : "dhcp - ",
							"url" : "/MyBlog/net/2018/05/05/dhcp.html"
							}
							
							,
							
							
							{
							"title" : "arc phabricator 结合 arcanist 使用 - ",
							"url" : "/MyBlog/web/2018/05/04/arc.html"
							}
							
							,
							
							
							{
							"title" : "aufs Union File System - ",
							"url" : "/MyBlog/docker/2018/05/03/aufs.html"
							}
							
							,
							
							
							{
							"title" : "veth - ",
							"url" : "/MyBlog/linux/2018/04/29/veth.html"
							}
							
							,
							
							
							{
							"title" : "linux namespace - ",
							"url" : "/MyBlog/linux/2018/04/29/namespace.html"
							}
							
							,
							
							
							{
							"title" : "docker_net - ",
							"url" : "/MyBlog/docker/2018/04/29/docker_net.html"
							}
							
							,
							
							
							{
							"title" : "Docker容器通过独立IP暴露给局域网的方法 - ",
							"url" : "/MyBlog/docker/2018/04/29/docker_ip.html"
							}
							
							,
							
							
							{
							"title" : "linux cgroup - ",
							"url" : "/MyBlog/linux/2018/04/29/cgroup.html"
							}
							
							,
							
							
							{
							"title" : "bridge - ",
							"url" : "/MyBlog/linux/2018/04/29/bridge.html"
							}
							
							,
							
							
							{
							"title" : "flag - ",
							"url" : "/MyBlog/golang/2018/04/24/flag.html"
							}
							
							,
							
							
							{
							"title" : "expect - ",
							"url" : "/MyBlog/linux/2018/04/22/expect.html"
							}
							
							,
							
							
							{
							"title" : "站群 - ",
							"url" : "/MyBlog/web/2018/04/21/zq.html"
							}
							
							,
							
							
							{
							"title" : "urlencode - ",
							"url" : "/MyBlog/cryptology/2018/04/20/urlencode.html"
							}
							
							,
							
							
							{
							"title" : "shell 运行原理 & unix 缺陷 - ",
							"url" : "/MyBlog/jekyll/2018/04/20/shell.html"
							}
							
							,
							
							
							{
							"title" : "Linux下的shell工作原理 - ",
							"url" : "/MyBlog/linux/2018/04/20/linux_shell.html"
							}
							
							,
							
							
							{
							"title" : "base64 - ",
							"url" : "/MyBlog/cryptology/2018/04/20/base64.html"
							}
							
							,
							
							
							{
							"title" : "aes 的工作模式（ECB、CBC、CFB、OFB） - ",
							"url" : "/MyBlog/cryptology/2018/04/19/aes.html"
							}
							
							,
							
							
							{
							"title" : "json - ",
							"url" : "/MyBlog/golang/2018/04/16/json.html"
							}
							
							,
							
							
							{
							"title" : "dup dup2 - ",
							"url" : "/MyBlog/linux/2018/04/16/dup.html"
							}
							
							,
							
							
							{
							"title" : "Reactor and Proactor - ",
							"url" : "/MyBlog/web/2018/04/15/proactor.html"
							}
							
							,
							
							
							{
							"title" : "fsnotify bee 热编译 - ",
							"url" : "/MyBlog/golang/2018/04/15/fsnotify.html"
							}
							
							,
							
							
							{
							"title" : "Git内部原理 blob tree commit - ",
							"url" : "/MyBlog/computer/2018/04/12/git.html"
							}
							
							,
							
							
							{
							"title" : "rsync - ",
							"url" : "/MyBlog/linux/2018/03/27/rsync.html"
							}
							
							,
							
							
							{
							"title" : "intellij 配置 - ",
							"url" : "/MyBlog/golang/2018/03/27/intellij.html"
							}
							
							,
							
							
							{
							"title" : "context - ",
							"url" : "/MyBlog/golang/2018/03/27/context.html"
							}
							
							,
							
							
							{
							"title" : "golang热编译工具 - ",
							"url" : "/MyBlog/golang/2018/03/23/online_build.html"
							}
							
							,
							
							
							{
							"title" : "glide 包依赖管理 - ",
							"url" : "/MyBlog/golang/2018/03/23/glide.html"
							}
							
							,
							
							
							{
							"title" : "utxo 比特币查询原理 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/utxo.html"
							}
							
							,
							
							
							{
							"title" : "数字时间戳 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/timestamp.html"
							}
							
							,
							
							
							{
							"title" : "stratum协议原理 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/stratum.html"
							}
							
							,
							
							
							{
							"title" : "区块链共识机制 Pow、Pos、DPos、Pool - ",
							"url" : "/MyBlog/cryptology/2018/03/18/pow.html"
							}
							
							,
							
							
							{
							"title" : "PBFT（实用拜占庭容错）、PAXOS、RAFT - ",
							"url" : "/MyBlog/cryptology/2018/03/18/pbft.html"
							}
							
							,
							
							
							{
							"title" : "hamming 码校验 汉明距离 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/hamming_code.html"
							}
							
							,
							
							
							{
							"title" : "block chain 区块链 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/block_chain.html"
							}
							
							,
							
							
							{
							"title" : "unsafe cgo - ",
							"url" : "/MyBlog/golang/2018/03/17/unsafe.html"
							}
							
							,
							
							
							{
							"title" : "数字签名及应用 - ",
							"url" : "/MyBlog/cryptology/2018/03/17/signature.html"
							}
							
							,
							
							
							{
							"title" : "reflect - ",
							"url" : "/MyBlog/golang/2018/03/17/reflect.html"
							}
							
							,
							
							
							{
							"title" : "go package - ",
							"url" : "/MyBlog/golang/2018/03/17/package.html"
							}
							
							,
							
							
							{
							"title" : "goroutine - ",
							"url" : "/MyBlog/golang/2018/03/17/goroutine.html"
							}
							
							,
							
							
							{
							"title" : "go test - ",
							"url" : "/MyBlog/golang/2018/03/17/go_test.html"
							}
							
							,
							
							
							{
							"title" : "进程和线程、协程的区别 - ",
							"url" : "/MyBlog/golang/2018/03/17/coroutine.html"
							}
							
							,
							
							
							{
							"title" : "golang 返回函数的匿名函数 vs 接收器的方法 - ",
							"url" : "/MyBlog/golang/2018/03/16/go_func.html"
							}
							
							,
							
							
							{
							"title" : "go-tour 安装 - ",
							"url" : "/MyBlog/golang/2018/03/16/go-tour.html"
							}
							
							,
							
							
							{
							"title" : "git默认不区分文件夹大小写 - ",
							"url" : "/MyBlog/computer/2018/03/16/git.html"
							}
							
							,
							
							
							{
							"title" : "栈与活动记录 - ",
							"url" : "/MyBlog/lang/2018/03/15/active_record.html"
							}
							
							,
							
							
							{
							"title" : "Lambda演算的类型 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_type.html"
							}
							
							,
							
							
							{
							"title" : "lambda 演算中的数字 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_num.html"
							}
							
							,
							
							
							{
							"title" : "Lambda演算建模 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_model.html"
							}
							
							,
							
							
							{
							"title" : "lambda 演算中的布尔值和选择 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_bool.html"
							}
							
							,
							
							
							{
							"title" : "lambda Y组合子(y-combinator) - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_Y.html"
							}
							
							,
							
							
							{
							"title" : "lambda_Evaluation - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_Evaluation.html"
							}
							
							,
							
							
							{
							"title" : "从Lambda演算到组合子演算 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_Combinator.html"
							}
							
							,
							
							
							{
							"title" : "Lambda 演算 - ",
							"url" : "/MyBlog/lang/2018/03/14/Lambda.html"
							}
							
							,
							
							
							{
							"title" : "系统调用 - ",
							"url" : "/MyBlog/linux/2018/03/13/system_call.html"
							}
							
							,
							
							
							{
							"title" : "mysql 分页 - ",
							"url" : "/MyBlog/web/2018/03/13/page.html"
							}
							
							,
							
							
							{
							"title" : "尾递归优化 - ",
							"url" : "/MyBlog/lang/2018/03/12/tco.html"
							}
							
							,
							
							
							{
							"title" : "三地址代码 - ",
							"url" : "/MyBlog/lang/2018/03/09/three-address-code.html"
							}
							
							,
							
							
							{
							"title" : "栈机 - ",
							"url" : "/MyBlog/lang/2018/03/09/Stack_machine.html"
							}
							
							,
							
							
							{
							"title" : "下推自动机 - ",
							"url" : "/MyBlog/lang/2018/03/08/pda.html"
							}
							
							,
							
							
							{
							"title" : "LR分析法 - ",
							"url" : "/MyBlog/lang/2018/03/08/lr.html"
							}
							
							,
							
							
							{
							"title" : "LL(1)文法判别之First集合、Follow集合、Select集合求法 - ",
							"url" : "/MyBlog/lang/2018/03/07/first_follow_select.html"
							}
							
							,
							
							
							{
							"title" : "thrift - ",
							"url" : "/MyBlog/lang/2018/03/02/thrift.html"
							}
							
							,
							
							
							{
							"title" : "thrift 低版本安装 - ",
							"url" : "/MyBlog/web/2018/03/01/thrift_low.html"
							}
							
							,
							
							
							{
							"title" : "jekyll paginate 分页失败原因 - ",
							"url" : "/MyBlog/jekyll/2018/03/01/paginate.html"
							}
							
							,
							
							
							{
							"title" : "git add 删除文件问题 - ",
							"url" : "/MyBlog/web/2018/03/01/git.html"
							}
							
							,
							
							
							{
							"title" : "symbol_table - ",
							"url" : "/MyBlog/lang/2018/02/28/symbol_table.html"
							}
							
							,
							
							
							{
							"title" : "re2c - ",
							"url" : "/MyBlog/lang/2018/02/28/re2c.html"
							}
							
							,
							
							
							{
							"title" : "Jekyll目录结构和运行机理 - ",
							"url" : "/MyBlog/jekyll/2018/02/28/jekyll_inside.html"
							}
							
							,
							
							
							{
							"title" : "CollectingCycles - ",
							"url" : "/MyBlog/lang/2018/02/28/CollectingCycles.html"
							}
							
							,
							
							
							{
							"title" : "type_hinting - ",
							"url" : "/MyBlog/web/2018/02/26/type_hinting.html"
							}
							
							,
							
							
							{
							"title" : "tsrm - ",
							"url" : "/MyBlog/web/2018/02/26/tsrm.html"
							}
							
							,
							
							
							{
							"title" : "create_function - ",
							"url" : "/MyBlog/web/2018/02/26/create_function.html"
							}
							
							,
							
							
							{
							"title" : "Xdebug - ",
							"url" : "/MyBlog/web/2018/02/26/Xdebug.html"
							}
							
							,
							
							
							{
							"title" : "Closure - ",
							"url" : "/MyBlog/lang/2018/02/26/Closure.html"
							}
							
							,
							
							
							{
							"title" : "lex - ",
							"url" : "/MyBlog/lang/2018/02/13/lex.html"
							}
							
							,
							
							
							{
							"title" : "vld_dot_graphviz - ",
							"url" : "/MyBlog/web/2018/02/12/vld_dot_graphviz.html"
							}
							
							,
							
							
							{
							"title" : "phpvld - ",
							"url" : "/MyBlog/jekyll/2018/02/12/phpvld.html"
							}
							
							,
							
							
							{
							"title" : "phpize - ",
							"url" : "/MyBlog/web/2018/02/12/phpize.html"
							}
							
							,
							
							
							{
							"title" : "PHP 调试利器之 PHPDBG - ",
							"url" : "/MyBlog/web/2018/02/12/phpdbg.html"
							}
							
							,
							
							
							{
							"title" : "dot - ",
							"url" : "/MyBlog/web/2018/02/12/dot.html"
							}
							
							,
							
							
							{
							"title" : "netty - ",
							"url" : "/MyBlog/web/2018/02/10/netty.html"
							}
							
							,
							
							
							{
							"title" : "Tachyon - ",
							"url" : "/MyBlog/spark/2018/02/10/Tachyon.html"
							}
							
							,
							
							
							{
							"title" : "crlf 攻击 - ",
							"url" : "/MyBlog/web/2018/02/06/crlf.html"
							}
							
							,
							
							
							{
							"title" : "iputils - ",
							"url" : "/MyBlog/linux/2018/02/05/iputils.html"
							}
							
							,
							
							
							{
							"title" : "cscope - ",
							"url" : "/MyBlog/web/2018/02/05/cscope.html"
							}
							
							,
							
							
							{
							"title" : "sklearn - ",
							"url" : "/MyBlog/spark/2018/02/03/sklearn.html"
							}
							
							,
							
							
							{
							"title" : "mathlatex - ",
							"url" : "/MyBlog/web/2018/02/02/mathlatex.html"
							}
							
							,
							
							
							{
							"title" : "二项逻辑斯蒂回归模型 - ",
							"url" : "/MyBlog/spark/2018/02/02/logistic.html"
							}
							
							,
							
							
							{
							"title" : "Duck typing - ",
							"url" : "/MyBlog/web/2018/02/02/Duck_typing.html"
							}
							
							,
							
							
							{
							"title" : "导入第三方依赖到shell - ",
							"url" : "/MyBlog/spark/2018/01/27/spark_jar.html"
							}
							
							,
							
							
							{
							"title" : "zero copy - ",
							"url" : "/MyBlog/linux/2018/01/26/zero_copy.html"
							}
							
							,
							
							
							{
							"title" : "进程在后台运行原理 - ",
							"url" : "/MyBlog/linux/2018/01/24/nohup.html"
							}
							
							,
							
							
							{
							"title" : "mongodb - ",
							"url" : "/MyBlog/web/2018/01/24/mongodb.html"
							}
							
							,
							
							
							{
							"title" : "倒排索引 - ",
							"url" : "/MyBlog/web/2018/01/24/inverted_file.html"
							}
							
							,
							
							
							{
							"title" : "npm registry - ",
							"url" : "/MyBlog/web/2018/01/16/npm.html"
							}
							
							,
							
							
							{
							"title" : "制作地图 - ",
							"url" : "/MyBlog/web/2018/01/16/map.html"
							}
							
							,
							
							
							{
							"title" : "Linux、Mac上面ln命令使用说明 - ",
							"url" : "/MyBlog/linux/2018/01/16/ln.html"
							}
							
							,
							
							
							{
							"title" : "spark on hive - ",
							"url" : "/MyBlog/spark/2018/01/13/spark_hive.html"
							}
							
							,
							
							
							{
							"title" : "scala maven 版本冲突问题解决 - ",
							"url" : "/MyBlog/spark/2018/01/12/scala_version.html"
							}
							
							,
							
							
							{
							"title" : "Eclipse中操作Hive、HDFS、spark时的jar包列表 - ",
							"url" : "/MyBlog/spark/2018/01/12/hive.html"
							}
							
							,
							
							
							{
							"title" : "Eclipse+maven+scala+spark环境搭建 - ",
							"url" : "/MyBlog/spark/2018/01/11/maven_scala_eclipse.html"
							}
							
							,
							
							
							{
							"title" : "maven - ",
							"url" : "/MyBlog/spark/2018/01/11/maven.html"
							}
							
							,
							
							
							{
							"title" : "随机森林 - ",
							"url" : "/MyBlog/spark/2018/01/09/random_foreast.html"
							}
							
							,
							
							
							{
							"title" : "svm - ",
							"url" : "/MyBlog/spark/2018/01/08/svm.html"
							}
							
							,
							
							
							{
							"title" : "virtualenv - ",
							"url" : "/MyBlog/web/2018/01/07/virtualenv.html"
							}
							
							,
							
							
							{
							"title" : "pip - ",
							"url" : "/MyBlog/web/2018/01/07/pip.html"
							}
							
							,
							
							
							{
							"title" : "信息熵 - ",
							"url" : "/MyBlog/spark/2018/01/05/shang.html"
							}
							
							,
							
							
							{
							"title" : "Zookeeper与Paxos - ",
							"url" : "/MyBlog/spark/2018/01/04/zookeeper.html"
							}
							
							,
							
							
							{
							"title" : "安全散列算法SHA256 - ",
							"url" : "/MyBlog/cryptology/2018/01/04/sha.html"
							}
							
							,
							
							
							{
							"title" : "raft - ",
							"url" : "/MyBlog/jekyll/2018/01/04/raft.html"
							}
							
							,
							
							
							{
							"title" : "比较raft ，basic paxos以及multi-paxos - ",
							"url" : "/MyBlog/spark/2018/01/04/paxos_raft.html"
							}
							
							,
							
							
							{
							"title" : "p2p - ",
							"url" : "/MyBlog/web/2018/01/04/p2p.html"
							}
							
							,
							
							
							{
							"title" : "nat - ",
							"url" : "/MyBlog/web/2018/01/04/nat.html"
							}
							
							,
							
							
							{
							"title" : "Chubby与Paxos - ",
							"url" : "/MyBlog/spark/2018/01/04/chubby.html"
							}
							
							,
							
							
							{
							"title" : "Paxos - ",
							"url" : "/MyBlog/spark/2018/01/04/Paxos.html"
							}
							
							,
							
							
							{
							"title" : "rsa 非对称加密原理 - ",
							"url" : "/MyBlog/cryptology/2018/01/03/rsa.html"
							}
							
							,
							
							
							{
							"title" : "Merkle Patricia Tree - ",
							"url" : "/MyBlog/cryptology/2018/01/03/merkle_tree.html"
							}
							
							,
							
							
							{
							"title" : "ecc 椭圆曲线加密 - ",
							"url" : "/MyBlog/cryptology/2018/01/03/ecc.html"
							}
							
							,
							
							
							{
							"title" : "单播、多播和广播 - ",
							"url" : "/MyBlog/linux/2017/12/30/broad_cast.html"
							}
							
							,
							
							
							{
							"title" : "arp - ",
							"url" : "/MyBlog/linux/2017/12/30/arp.html"
							}
							
							,
							
							
							{
							"title" : "json_shell - ",
							"url" : "/MyBlog/web/2017/12/27/json_shell.html"
							}
							
							,
							
							
							{
							"title" : "ioctl - ",
							"url" : "/MyBlog/linux/2017/12/27/ioctl.html"
							}
							
							,
							
							
							{
							"title" : "inetd - ",
							"url" : "/MyBlog/linux/2017/12/27/inetd.html"
							}
							
							,
							
							
							{
							"title" : "Django_nginx_uwsgi - ",
							"url" : "/MyBlog/web/2017/12/27/Django_nginx_uwsgi.html"
							}
							
							,
							
							
							{
							"title" : "UNIX下的5种IO模型 - ",
							"url" : "/MyBlog/linux/2017/12/24/unix_io5.html"
							}
							
							,
							
							
							{
							"title" : "用户空间实现线程 内核实现线程 线程的调度 - ",
							"url" : "/MyBlog/linux/2017/12/24/thread_namespace.html"
							}
							
							,
							
							
							{
							"title" : "进程切换 - ",
							"url" : "/MyBlog/linux/2017/12/24/thread.html"
							}
							
							,
							
							
							{
							"title" : "IO多路复用之select、poll、epoll - ",
							"url" : "/MyBlog/linux/2017/12/24/select_poll.html"
							}
							
							,
							
							
							{
							"title" : "goroutine - ",
							"url" : "/MyBlog/linux/2017/12/24/goroutine.html"
							}
							
							,
							
							
							{
							"title" : "goclipse eclipse go 开发环境搭建＋跳转支持 - ",
							"url" : "/MyBlog/web/2017/12/24/goclipse.html"
							}
							
							,
							
							
							{
							"title" : "tcp_flag - ",
							"url" : "/MyBlog/web/2017/12/22/tcp_flag.html"
							}
							
							,
							
							
							{
							"title" : "url短链 - ",
							"url" : "/MyBlog/web/2017/12/22/short_url.html"
							}
							
							,
							
							
							{
							"title" : "ID为0和ID为1的进程 - ",
							"url" : "/MyBlog/linux/2017/12/22/pid_0_1.html"
							}
							
							,
							
							
							{
							"title" : "Shell脚本经典之Fork炸弹 - ",
							"url" : "/MyBlog/linux/2017/12/22/fork_b.html"
							}
							
							,
							
							
							{
							"title" : "fork - ",
							"url" : "/MyBlog/linux/2017/12/22/fork.html"
							}
							
							,
							
							
							{
							"title" : "Linux进程控制——exec函数族 - ",
							"url" : "/MyBlog/linux/2017/12/22/exec.html"
							}
							
							,
							
							
							{
							"title" : "各种树的应用场景 - ",
							"url" : "/MyBlog/web/2017/12/13/tree.html"
							}
							
							,
							
							
							{
							"title" : "sbt - ",
							"url" : "/MyBlog/spark/2017/12/13/sbt.html"
							}
							
							,
							
							
							{
							"title" : "radix tree - ",
							"url" : "/MyBlog/linux/2017/12/13/radix_tree.html"
							}
							
							,
							
							
							{
							"title" : "maven 安装 - ",
							"url" : "/MyBlog/spark/2017/12/13/maven.html"
							}
							
							,
							
							
							{
							"title" : "figaro mac 安装 - ",
							"url" : "/MyBlog/spark/2017/12/13/figaro.html"
							}
							
							,
							
							
							{
							"title" : "大端小端 - ",
							"url" : "/MyBlog/web/2017/12/13/bigEnd.html"
							}
							
							,
							
							
							{
							"title" : "truss、strace或ltrace - ",
							"url" : "/MyBlog/linux/2017/12/10/strace.html"
							}
							
							,
							
							
							{
							"title" : "netlink - ",
							"url" : "/MyBlog/linux/2017/12/10/netlink.html"
							}
							
							,
							
							
							{
							"title" : "linux sysfs - ",
							"url" : "/MyBlog/linux/2017/12/09/sysfs.html"
							}
							
							,
							
							
							{
							"title" : "proc文件系统 - ",
							"url" : "/MyBlog/linux/2017/12/09/proc.html"
							}
							
							,
							
							
							{
							"title" : "netfliter - ",
							"url" : "/MyBlog/jekyll/2017/12/09/netfliter.html"
							}
							
							,
							
							
							{
							"title" : "namespace - ",
							"url" : "/MyBlog/linux/2017/12/08/namespace.html"
							}
							
							,
							
							
							{
							"title" : "vfs - ",
							"url" : "/MyBlog/linux/2017/12/07/vfs.html"
							}
							
							,
							
							
							{
							"title" : "mysql_index - ",
							"url" : "/MyBlog/web/2017/12/07/mysql_index.html"
							}
							
							,
							
							
							{
							"title" : "linux_rcu - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_rcu.html"
							}
							
							,
							
							
							{
							"title" : "Linux的mmap内存映射机制 - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_mmap.html"
							}
							
							,
							
							
							{
							"title" : "linux_lock - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_lock.html"
							}
							
							,
							
							
							{
							"title" : "linux_elf - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_elf.html"
							}
							
							,
							
							
							{
							"title" : "linux_cow - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_cow.html"
							}
							
							,
							
							
							{
							"title" : "Kibana - ",
							"url" : "/MyBlog/spark/2017/12/06/Kibana.html"
							}
							
							,
							
							
							{
							"title" : "linux_memory - ",
							"url" : "/MyBlog/linux/2017/12/05/linux_memory.html"
							}
							
							,
							
							
							{
							"title" : "server格式 - ",
							"url" : "/MyBlog/web/2017/12/02/server_tyrp.html"
							}
							
							,
							
							
							{
							"title" : "nginx_ssi - ",
							"url" : "/MyBlog/web/2017/12/02/nginx_ssi.html"
							}
							
							,
							
							
							{
							"title" : "go升级遇到问题及解决方案 - ",
							"url" : "/MyBlog/web/2017/11/29/go_update.html"
							}
							
							,
							
							
							{
							"title" : "go_pprof - ",
							"url" : "/MyBlog/web/2017/11/29/go_pprof.html"
							}
							
							,
							
							
							{
							"title" : "go_vs_code - ",
							"url" : "/MyBlog/web/2017/11/28/go_vs_code.html"
							}
							
							,
							
							
							{
							"title" : "scala tuple - ",
							"url" : "/MyBlog/spark/2017/11/19/scala_tuple.html"
							}
							
							,
							
							
							{
							"title" : "redis协议 - ",
							"url" : "/MyBlog/web/2017/11/18/redis_protocal.html"
							}
							
							,
							
							
							{
							"title" : "jupyter 数学公式 - ",
							"url" : "/MyBlog/spark/2017/11/18/jupyter_math.html"
							}
							
							,
							
							
							{
							"title" : "jupyter 数学公式 - ",
							"url" : "/MyBlog/spark/2017/11/18/jupyter_latex.html"
							}
							
							,
							
							
							{
							"title" : "Jupyter Notebook 添加目录 - ",
							"url" : "/MyBlog/spark/2017/11/18/jupyter_index.html"
							}
							
							,
							
							
							{
							"title" : "文字特征提取算法 - ",
							"url" : "/MyBlog/spark/2017/11/17/word_feature.html"
							}
							
							,
							
							
							{
							"title" : "sparl_ml_pipline - ",
							"url" : "/MyBlog/spark/2017/11/16/sparl_ml_pipline.html"
							}
							
							,
							
							
							{
							"title" : "mysql 的排序 - ",
							"url" : "/MyBlog/web/2017/11/16/mysql_sort.html"
							}
							
							,
							
							
							{
							"title" : "mysql_maneager - ",
							"url" : "/MyBlog/web/2017/11/16/mysql_maneager.html"
							}
							
							,
							
							
							{
							"title" : "mysql_index - ",
							"url" : "/MyBlog/web/2017/11/16/mysql_index.html"
							}
							
							,
							
							
							{
							"title" : "MySQL的表类型的（存储引擎） - ",
							"url" : "/MyBlog/web/2017/11/16/mysql_engine.html"
							}
							
							,
							
							
							{
							"title" : "mysql 原理 - ",
							"url" : "/MyBlog/web/2017/11/16/mysql.html"
							}
							
							,
							
							
							{
							"title" : "spark_memory - ",
							"url" : "/MyBlog/spark/2017/11/15/spark_memory.html"
							}
							
							,
							
							
							{
							"title" : "redis 持久化 - ",
							"url" : "/MyBlog/web/2017/11/15/redis_forever.html"
							}
							
							,
							
							
							{
							"title" : "spark toDF 失败原因总结 - ",
							"url" : "/MyBlog/spark/2017/11/14/spark_toDF.html"
							}
							
							,
							
							
							{
							"title" : "spark_start问题原因及解决办法 - ",
							"url" : "/MyBlog/spark/2017/11/14/spark_start.html"
							}
							
							,
							
							
							{
							"title" : "spark_rdd创建转换 - ",
							"url" : "/MyBlog/spark/2017/11/14/spark_rdd.html"
							}
							
							,
							
							
							{
							"title" : "spark的ML和MLLib两个包区别和联系 - ",
							"url" : "/MyBlog/spark/2017/11/14/spark_ml_mllib.html"
							}
							
							,
							
							
							{
							"title" : "RDD/Dataset/DataFrame互转 - ",
							"url" : "/MyBlog/spark/2017/11/14/rdd_dataset_dataframe.html"
							}
							
							,
							
							
							{
							"title" : "dataSet和dataFrame的创建方法 - ",
							"url" : "/MyBlog/spark/2017/11/14/dataSet_dataFrame.html"
							}
							
							,
							
							
							{
							"title" : "php_session - ",
							"url" : "/MyBlog/web/2017/11/09/php_session.html"
							}
							
							,
							
							
							{
							"title" : "jupyter_matplotlib - ",
							"url" : "/MyBlog/web/2017/11/09/jupyter_matplotlib.html"
							}
							
							,
							
							
							{
							"title" : "Jupyter_slides - ",
							"url" : "/MyBlog/web/2017/11/09/Jupyter_slides.html"
							}
							
							,
							
							
							{
							"title" : "composer - ",
							"url" : "/MyBlog/web/2017/11/03/composer.html"
							}
							
							,
							
							
							{
							"title" : "scala_partion_function - ",
							"url" : "/MyBlog/spark/2017/10/24/scala_partion_function.html"
							}
							
							,
							
							
							{
							"title" : "partion_function - ",
							"url" : "/MyBlog/web/2017/10/24/partion_function.html"
							}
							
							,
							
							
							{
							"title" : "高阶函数函数加里化(Currying)和偏函数应用(Partial Application)的比较 - ",
							"url" : "/MyBlog/web/2017/10/24/function.html"
							}
							
							,
							
							
							{
							"title" : "使用Phabricator做为Code Review工具 - ",
							"url" : "/MyBlog/web/2017/10/24/Phabricator.html"
							}
							
							,
							
							
							{
							"title" : "cut - ",
							"url" : "/MyBlog/spark/2017/10/23/cut.html"
							}
							
							,
							
							
							{
							"title" : "akka_sbt_eclipse - ",
							"url" : "/MyBlog/spark/2017/10/18/akka_sbt_eclipse.html"
							}
							
							,
							
							
							{
							"title" : "FunSuite - ",
							"url" : "/MyBlog/spark/2017/10/18/FunSuite.html"
							}
							
							,
							
							
							{
							"title" : "spark基本概念 - ",
							"url" : "/MyBlog/spark/2017/10/13/spark_concepts.html"
							}
							
							,
							
							
							{
							"title" : "Actor模型原理 - ",
							"url" : "/MyBlog/spark/2017/10/13/actor_intro.html"
							}
							
							,
							
							
							{
							"title" : "Actor系统的实体 - ",
							"url" : "/MyBlog/spark/2017/10/13/actor_detail.html"
							}
							
							,
							
							
							{
							"title" : "Actor模型和CSP模型的区别 - ",
							"url" : "/MyBlog/spark/2017/10/13/actor_csp.html"
							}
							
							,
							
							
							{
							"title" : "java_scala - ",
							"url" : "/MyBlog/spark/2017/10/12/java_scala.html"
							}
							
							,
							
							
							{
							"title" : "Scala_collection - ",
							"url" : "/MyBlog/spark/2017/10/12/Scala_collection.html"
							}
							
							,
							
							
							{
							"title" : "scala_list - ",
							"url" : "/MyBlog/spark/2017/10/11/scala_list.html"
							}
							
							,
							
							
							{
							"title" : "spark-session-context - ",
							"url" : "/MyBlog/spark/2017/10/06/spark-session-context.html"
							}
							
							,
							
							
							{
							"title" : "scala_main_class - ",
							"url" : "/MyBlog/spark/2017/09/29/scala_main_class.html"
							}
							
							,
							
							
							{
							"title" : "alibaba_fast_json - ",
							"url" : "/MyBlog/spark/2017/09/29/alibaba_fast_json.html"
							}
							
							,
							
							
							{
							"title" : "gorpc - ",
							"url" : "/MyBlog/jekyll/2017/09/25/gorpc.html"
							}
							
							,
							
							
							{
							"title" : "spark-kafka - ",
							"url" : "/MyBlog/spark/2017/09/22/spark-kafka.html"
							}
							
							,
							
							
							{
							"title" : "mysqldump - ",
							"url" : "/MyBlog/web/2017/09/20/mysqldump.html"
							}
							
							,
							
							
							{
							"title" : "mysql-time - ",
							"url" : "/MyBlog/jekyll/2017/09/20/mysql-time.html"
							}
							
							,
							
							
							{
							"title" : "mac 安装 sshfs - ",
							"url" : "/MyBlog/jekyll/2017/09/18/sshfs.html"
							}
							
							,
							
							
							{
							"title" : "jupyter - ",
							"url" : "/MyBlog/deep_learning/2017/09/17/jupyter.html"
							}
							
							,
							
							
							{
							"title" : "deep_learning - ",
							"url" : "/MyBlog/deep_learning/2017/09/17/deep_learning.html"
							}
							
							,
							
							
							{
							"title" : "spark-rdd - spark",
							"url" : "/MyBlog/spark/2017/09/15/spark-rdd.html"
							}
							
							,
							
							
							{
							"title" : "netcat - ",
							"url" : "/MyBlog/jekyll/2017/09/15/netcat.html"
							}
							
							,
							
							
							{
							"title" : "markdown-table - ",
							"url" : "/MyBlog/jekyll/2017/09/15/markdown-table.html"
							}
							
							,
							
							
							{
							"title" : "books-sites - ",
							"url" : "/MyBlog/jekyll/2017/09/15/books-sites.html"
							}
							
							,
							
							
							{
							"title" : "脚本输出带颜色文字 - ",
							"url" : "/MyBlog/jekyll/2017/09/14/%E8%84%9A%E6%9C%AC%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E6%96%87%E5%AD%97.html"
							}
							
							,
							
							
							{
							"title" : "常见SSL证书格式转换 - ",
							"url" : "/MyBlog/jekyll/2017/09/13/%E5%B8%B8%E8%A7%81SSL%E8%AF%81%E4%B9%A6%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2.html"
							}
							
							,
							
							
							{
							"title" : "php-curl-ext - ",
							"url" : "/MyBlog/jekyll/2017/09/13/php-curl-ext.html"
							}
							
							,
							
							
							{
							"title" : "curl-https-php - ",
							"url" : "/MyBlog/jekyll/2017/09/13/curl-https-php.html"
							}
							
							,
							
							
							{
							"title" : "php-spider - ",
							"url" : "/MyBlog/jekyll/2017/09/12/php-spider.html"
							}
							
							,
							
							
							{
							"title" : "php怎么判断函数，类，类方法是不是存在 - ",
							"url" : "/MyBlog/jekyll/2017/09/12/php-function.html"
							}
							
							,
							
							
							{
							"title" : "composer-source - ",
							"url" : "/MyBlog/jekyll/2017/09/12/composer-source.html"
							}
							
							,
							
							
							{
							"title" : "php-doc - ",
							"url" : "/MyBlog/jekyll/2017/09/11/php-doc.html"
							}
							
							,
							
							
							{
							"title" : "oauth-github-api - ",
							"url" : "/MyBlog/jekyll/2017/09/10/oauth-github-api.html"
							}
							
							,
							
							
							{
							"title" : "http-head 四种常见的 POST 提交数据方式 - ",
							"url" : "/MyBlog/jekyll/2017/09/10/http-head.html"
							}
							
							,
							
							
							{
							"title" : "javascript 实现客户端访问次数统计 - ",
							"url" : "/MyBlog/jekyll/2017/09/09/statics.html"
							}
							
							,
							
							
							{
							"title" : "JavaScript实现模糊匹配搜索 - ",
							"url" : "/MyBlog/jekyll/2017/09/09/search_match.html"
							}
							
							,
							
							
							{
							"title" : "search - ",
							"url" : "/MyBlog/jekyll/2017/09/09/search.html"
							}
							
							,
							
							
							{
							"title" : "robots - ",
							"url" : "/MyBlog/jekyll/2017/09/09/robots.html"
							}
							
							,
							
							
							{
							"title" : "oauth-github - ",
							"url" : "/MyBlog/jekyll/2017/09/09/oauth-github.html"
							}
							
							,
							
							
							{
							"title" : "github-openapi - ",
							"url" : "/MyBlog/jekyll/2017/09/09/github-openapi.html"
							}
							
							,
							
							
							{
							"title" : "github-api - ",
							"url" : "/MyBlog/jekyll/2017/09/09/github-api.html"
							}
							
							,
							
							
							{
							"title" : "Authorization-ajax - ",
							"url" : "/MyBlog/jekyll/2017/09/09/Authorization-ajax.html"
							}
							
							,
							
							
							{
							"title" : "自动化替换网站引用资源到本地工具 - ",
							"url" : "/MyBlog/jekyll/2017/09/08/replace-url.html"
							}
							
							,
							
							
							{
							"title" : "pygments - ",
							"url" : "/MyBlog/jekyll/2017/09/08/pygments.html"
							}
							
							,
							
							
							{
							"title" : "markdown - ",
							"url" : "/MyBlog/markdown/2017/09/07/markdown.html"
							}
							
							,
							
							
							{
							"title" : "mac-sed - ",
							"url" : "/MyBlog/jekyll/2017/09/07/mac-sed.html"
							}
							
							,
							
							
							{
							"title" : "jekyll config - ",
							"url" : "/MyBlog/jekyll/2017/09/07/jeky-env.html"
							}
							
							,
							
							
							{
							"title" : "comment - ",
							"url" : "/MyBlog/jekyll/2017/09/07/comment.html"
							}
							
							,
							
							
							{
							"title" : "Welcome to xiazemin's blog! - ",
							"url" : "/MyBlog/update/2017/09/05/welcome-to-jekyll.html"
							}
							
							,
							
							
							{
							"title" : "nginx lua - octopress_jekyll",
							"url" : "/MyBlog/web/2017/08/05/nginx-lua.html"
							}
							
							,
							
							
							{
							"title" : "jekyll layout - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-layout.html"
							}
							
							,
							
							
							{
							"title" : "jekyll dir - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-dir.html"
							}
							
							,
							
							
							{
							"title" : "jekyll macdown使用 - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-usage.html"
							}
							
							,
							
							
							{
							"title" : "jekyll 分页 - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-page.html"
							}
							
							,
							
							
							{
							"title" : "jekyll mac 安装 - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-mac-install.html"
							}
							
							,
							
							
							{
							"title" : "Eleventh post - css_html",
							"url" : "/MyBlog/technology/2016/02/11/eleventh.html"
							}
							
							,
							
							
							{
							"title" : "Tenth post - css_html",
							"url" : "/MyBlog/technology/2016/02/09/tenth.html"
							}
							
							,
							
							
							{
							"title" : "second post - holiday",
							"url" : "/MyBlog/technology/computer/news/2016/02/02/second-post.html"
							}
							
							,
							
							
							{
							"title" : "first post - css_html_hosting_openshift_wordpress",
							"url" : "/MyBlog/jekyll/technology/2016/02/01/first-post.html"
							}
							
							
							]
							};
							function handle(){  
							var word = document.getElementById('txt').value;
							var value = "";
							var data=searchIndex.data;
							for(var i = 0;i < data.length;i++){
							if(word!="" && data[i].title.match(".*"+word+".*") != null){
							value += "<a onclick=add('"+ data[i].title +"') href='"+ data[i]. url +"'>" + data[i].title + "</a><br/>";
							}
							}       
							document.getElementById('msg').innerHTML=value;
							  if(typeof(document.getElementById('msg').children[0])!="undefined"){
								document.getElementById('cse-search-box').action=document.getElementById('msg').children[0].href;
					
							   }
							} 
							function add(city){
							document.getElementById('txt').value=city;
							}
							//firefox下检测状态改变只能用oninput,且需要用addEventListener来注册事件。   
							if(/msie/i.test(navigator.userAgent))    //ie浏览器   
							{document.getElementById('txt').onpropertychange=handle   
							} else{//非ie浏览器，比如Firefox   
							document.getElementById('txt').addEventListener("input",handle,false);   
							}
						 </script> 
					  </div>
					</form>
					<!--script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script-->
				</div>
            </div>

            <!-- time -->
                    <div id="myTime" class="well">
                            <object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="/MyBlog/flash/swflash.cab" style="margin: 0;padding: 0;height: auto;width:auto;">
                                <param name="allowScriptAccess" value="always">
                                <param name="movie" value="/MyBlog/flash/honehone_clock_wh.swf">
                                <param name="quality" value="high">
                                <param name="bgcolor" value="transparent">
                                <param name="wmode" value="transparent">
                                <embed wmode="transparent" src="/MyBlog/flash/honehone_clock_wh.swf" quality="high" name="honehoneclock" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer"  style="margin: 0;padding: 0;border: 0 ;height: auto;width:100%;">
                            </object>
                    </div>
                <!-- Blog Categories Well -->
                <div class="well">
                    <h4>Blog Categories</h4>
                    <div class="row">
                        <div class="col-lg-6">
								
								
								
								
									<a class="bold" href="/MyBlog/category/jekyll">
										jekyll (41)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/technology">
										technology (4)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/computer">
										computer (3)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/news">
										news (1)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/web">
										web (120)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/update">
										update (1)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/markdown">
										markdown (1)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/spark">
										spark (51)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/deep-learning">
										deep_learning (2)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/linux">
										linux (129)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/cryptology">
										cryptology (15)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/lang">
										lang (24)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/golang">
										golang (67)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/docker">
										docker (7)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/net">
										net (13)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/zookeeper">
										zookeeper (11)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/elasticsearch">
										elasticsearch (24)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/storage">
										storage (62)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/java">
										java (4)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/algorithm">
										algorithm (50)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/hadoop">
										hadoop (2)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/elasticsearch">
										Elasticsearch (1)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
                        </div>
                    </div>
                    <!-- /.row -->
                </div>
                <!-- Side Widget Well -->

                <!-- Side Widget Well -->
                <div class="well">
                	<h4>Recent posts</h4>
                		<ul class="posts" span="recent"> 
							  
							   <li>  
								   <span>24 Apr 2019</span>
								   <a href="/MyBlog//web/2019/04/24/tideways.html">  
								   tideways + xhgui（+toolkit） php 性能分析</a>  
							   </li>  
							  
							   <li>  
								   <span>23 Apr 2019</span>
								   <a href="/MyBlog//algorithm/2019/04/23/treemap.html">  
								   treemap HashMap和LinkedHashMap的区别</a>  
							   </li>  
							  
							   <li>  
								   <span>23 Apr 2019</span>
								   <a href="/MyBlog//golang/2019/04/23/gctrace.html">  
								   gctrace</a>  
							   </li>  
							  
							   <li>  
								   <span>23 Apr 2019</span>
								   <a href="/MyBlog//web/2019/04/23/BitTorrent%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E4%B8%80.html">  
								   BitTorrent协议分析</a>  
							   </li>  
							  
							   <li>  
								   <span>22 Apr 2019</span>
								   <a href="/MyBlog//golang/2019/04/22/mutex.html">  
								   mutex</a>  
							   </li>  
							  
						</ul>
                </div>
                <!-- Side Widget Well -->
                <div class="well">
                    <h4>Tags</h4>
                        <ul>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/css">
                                    css (3)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/html">
                                    html (3)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/hosting">
                                    hosting (1)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/openshift">
                                    openshift (1)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/wordpress">
                                    wordpress (1)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/holiday">
                                    holiday (1)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/octopress">
                                    octopress (6)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/jekyll">
                                    jekyll (6)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/spark">
                                    spark (1)
                                </a>
                            
                        </ul>
                </div>
                <div class="well">
                    <h4>This blog is maintained by <a href="＃">夏泽民</a></h4>
                    <p>Get in touch with me at 465474307@qq.com</p>
					<ul class="list-inline">
                            <li>
								<a href="＃">
									<span class="fa-stack fa-2x">
									  <i class="fa fa-circle fa-stack-2x"></i>
									  <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
									</span>
								</a>
                            </li>
                            <li>
								<a href="#">
									<span class="fa-stack fa-2x">
									  <i class="fa fa-circle fa-stack-2x"></i>
									  <i class="fa fa-globe fa-stack-1x fa-inverse"></i>
									</span>
								</a>
                            </li>
                            <li>
								<a href="mailto:465474307@qq.com">
									<span class="fa-stack fa-2x">
									  <i class="fa fa-circle fa-stack-2x"></i>
									  <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
									</span>
								</a>
                            </li>
                            <li>
								<a href="#">
									<span class="fa-stack fa-2x">
									  <i class="fa fa-circle fa-stack-2x"></i>
									  <i class="fa fa-bitbucket fa-stack-1x fa-inverse"></i>
									</span>
								</a>
                            </li>
                    </ul>
                </div>
				 <!-- subscribe -->
                <div class="well">
					<!-- Begin MailChimp Signup Form -->
					<div id="mc_embed_signup">
					<form action="http://maplelearning.us1.list-manage.com/subscribe?u=47d56ac42a95b4295600c0e64&id=5f9ede27c9" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
						<div id="mc_embed_signup_scroll">
						<h2>Subscribe to our mailing list</h2>
					<div class="indicates-required"><span class="asterisk">*</span> indicates required</div>
					<div class="mc-field-group">
						<label for="mce-EMAIL">Email Address  <span class="asterisk">*</span>
					</label>
						<input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL">
					</div>
					<div class="mc-field-group">
						<label for="mce-FNAME">First Name </label>
						<input type="text" value="" name="FNAME" class="" id="mce-FNAME">
					</div>
					<div class="mc-field-group">
						<label for="mce-LNAME">Last Name </label>
						<input type="text" value="" name="LNAME" class="" id="mce-LNAME">
					</div>
						<div id="mce-responses" class="clear">
							<div class="response" id="mce-error-response" style="display:none"></div>
							<div class="response" id="mce-success-response" style="display:none"></div>
						</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
						<div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_47d56ac42a95b4295600c0e64_5f9ede27c9" tabindex="-1" value=""></div>
						<div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
						</div>
					</form>
					</div>

					<!--End mc_embed_signup-->
				</div>

            </div>
        </div>
        <!-- /.row -->
       <hr>


          <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>

    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

	</div>
    </body>

</html>
