<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
</head>


    <body>
	<div id="wrapper">
      <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


      
       
    <!-- Page Content -->
    <div class="container">

        <div class="row">

            <!-- Blog Post Content Column -->
            <div class="col-lg-8">
                <!-- Blog Post -->
                	<h1 style="color: #0F3C73;"><span class="outside-cats">linux</span></h1>
                    <div role="main" class="main-content">
                      

  <div class="post">

    <a href="/MyBlog/linux/2018/04/29/veth.html" class="post-title-link">
      <h2>veth</h2>
    </a>

    <div class="post-date">Apr 29, 2018</div>
    
    <div class="post-body">
      
      <p>Linux container 中用到一个叫做veth的东西，这是一种新的设备，专门为 container 所建。veth 从名字上来看是 Virtual ETHernet 的缩写，它的作用很简单，就是要把从一个 network namespace 发出的数据包转发到另一个 namespace。veth 设备是成对的，一个是 container 之中，另一个在 container 之外，即在真实机器上能看到的。 
  VETH设备总是成对出现，送到一端请求发送的数据总是从另一端以请求接受的形式出现。创建并配置正确后，向其一端输入数据，VETH会改变数据的方向并将其送入内核网络子系统，完成数据的注入，而在另一端则能读到此数据。（Namespace，其中往veth设备上任意一端上RX到的数据，都会在另一端上以TX的方式发送出去）veth工作在L2数据链路层，veth-pair设备在转发数据包过程中并不串改数据包内容。 
<!-- more -->
  显然，仅有veth-pair设备，容器是无法访问网络的。因为容器发出的数据包，实质上直接进入了veth1设备的协议栈里。如果容器需要访问网络，需要使用bridge等技术，将veth1接收到的数据包通过某种方式转发出去 
创建veth的命令如下：
ip link add name veth0 type veth0 peer name veth1
veth设备特点
veth和其它的网络设备都一样，一端连接的是内核协议栈
veth设备是成对出现的，另一端两个设备彼此相连
一个设备收到协议栈的数据发送请求后，会将数据发送到另一个设备上去
常用命令
创建network namespace
 # ip netns add sunldnamespace01
 # ip netns list
sunldnamespace01
创建veth
 # ip link add sunldveth01 type veth peer name sunldveth02
 # ip link list
显示信息如下：
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:2d:d4:23 brd ff:ff:ff:ff:ff:ff
20: sunldveth02: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether c6:bb:c0:d0:54:71 brd ff:ff:ff:ff:ff:ff
21: sunldveth01: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether da:a1:36:d1:3b:36 brd ff:ff:ff:ff:ff:ff
添加网卡到namespace
 # ip link set sunldveth01 netns sunldnamespace01
查看当前namespace中的veth，只有sunldveth02
 # ip link list
显示信息如下
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:2d:d4:23 brd ff:ff:ff:ff:ff:ff
3: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default 
    link/ether ba:d9:d4:48:55:65 brd ff:ff:ff:ff:ff:ff
20: sunldveth02: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether c6:bb:c0:d0:54:71 brd ff:ff:ff:ff:ff:ff
通过命令查看sunldnamespace01中的veth
 # ip netns exec sunldnamespace01 ip link list
显示信息如下
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
21: sunldveth01: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether da:a1:36:d1:3b:36 brd ff:ff:ff:ff:ff:ff
配置network namespace的网口
 # ip netns exec sunldnamespace01 ifconfig sunldveth01 100.2.96.2/16 up
 # ip netns exec sunldnamespace01 ip addr list
显示信息如下
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
21: sunldveth01: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000
    link/ether da:a1:36:d1:3b:36 brd ff:ff:ff:ff:ff:ff
    inet 100.2.96.2/16 brd 100.2.255.255 scope global sunldveth01
       valid_lft forever preferred_lft forever
开启空间脚本
 #可以使用这条命令开启一个 ns0 的 shell 
ip netns exec ns0 sh
network namespace
创建network namespace
 # ip netns add blue
 # ip netns list
blue
添加网口到namespace
先创建veth
 # ip link add veth0 type veth peer name veth1
在当前namespace可以看到veth0和veth1
 # ip link list
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:b2:cf:72 brd ff:ff:ff:ff:ff:ff
3: veth1: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 1000
    link/ether ae:0d:00:e1:11:38 brd ff:ff:ff:ff:ff:ff
4: veth0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 1000
    link/ether 42:e7:50:d4:bb:c5 brd ff:ff:ff:ff:ff:ff
将veth1加到namespace “blue”
 # ip link set veth1 netns blue
此时，当前namepapce只能看到veth0。
通过如下命令可以查看blue namespace的网口
 # ip netns exec blue ip link list
配置network namespace的网口
通过ip netns exec可以配置namespace的网口
 # ip netns exec blue ifconfig veth1 172.17.42.2/16 up
network namespace的网口与物理网卡的通信通过bridge来实现。
 # add the namespaces
ip netns add ns1
ip netns add ns2
 # create the veth pair
ip link add tap1 type veth peer name tap2
 # move the interfaces to the namespaces
ip link set tap1 netns ns1
ip link set tap2 netns ns2
 # bring up the links
ip netns exec ns1 ip link set dev tap1 up
ip netns exec ns2 ip link set dev tap2 up</LOOPBACK></LOOPBACK></p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/29/veth.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/29/docker_net.html" class="post-title-link">
      <h2>docker_net</h2>
    </a>

    <div class="post-date">Apr 29, 2018</div>
    
    <div class="post-body">
      
      <p>由于Boot2Docker的存在，造成了三层Mac-&gt;VirtualBox-&gt;Docker网络,由VirtualBox到Docker的映射可以通过run容器的时候指定-p参数实现，而从宿主机到VirtualBox端口映射需要通过下述方法实现:
查询虚拟机网络： 
VBoxManagelistvms查询虚拟机网络状态，默认虚拟机名为′default′ VBoxManage showvminfo “default” | grep NIC 
2.关闭运行中的虚拟机 
由于Boot2Docker会自动运行VirtualBox中的虚拟机，所以在设置网络映射时必须先关闭运行中的虚拟机。否则，将出现The machine ‘boot2docker’ is already locked for a session (or being unlocked)的错误提示
$ VBoxManage controlvm “default” poweroff
修改虚拟机与Mac系统的网络映射 
根据实际需要进行网络映射，其中
rulename: 自定义规则名称
hostip: Mac访问地址，可不填
hostport: Mac映射端口
guestip: 虚拟机访问地址，可不填
guestport: 虚拟机映射端口
$ VBoxManage modifyvm “dufault” –natpf1 “,</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/29/docker_net.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/29/docker_ip.html" class="post-title-link">
      <h2>Docker容器通过独立IP暴露给局域网的方法</h2>
    </a>

    <div class="post-date">Apr 29, 2018</div>
    
    <div class="post-body">
      
      <p>Docker容器非常轻量，系统开销非常少，比VMware或者VirtualBox用起来方便，部署起来也非常容易。官方推荐我们通过端口映射的方式把Docker容器的服务提供给宿主机或者局域网其他容器使用。一般过程是：
1、Docker进程通过监听宿主机的某个端口，将该端口的数据包发送给Docker容器
2、宿主机可以打开防火墙让局域网其他设备通过访问宿主机的端口进而访问docker的端口</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/29/docker_ip.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/29/cgroup.html" class="post-title-link">
      <h2>linux cgroup</h2>
    </a>

    <div class="post-date">Apr 29, 2018</div>
    
    <div class="post-body">
      
      <p>Namespace解决的问题主要是环境隔离的问题，这只是虚拟化中最最基础的一步，我们还需要解决对计算机资源使用上的隔离。也就是说，虽然你通过Namespace把我Jail到一个特定的环境中去了，但是我在其中的进程使用用CPU、内存、磁盘等这些计算资源其实还是可以随心所欲的。所以，我们希望对进程进行资源利用上的限制或控制。这就是Linux CGroup出来了的原因。
Linux CGroup全称Linux Control Group， 是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。这个项目最早是由Google的工程师在2006年发起（主要是Paul Menage和Rohit Seth），最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。然后，其它开始了他的发展。
Linux CGroupCgroup 可​​​让​​​您​​​为​​​系​​​统​​​中​​​所​​​运​​​行​​​任​​​务​​​（进​​​程​​​）的​​​用​​​户​​​定​​​义​​​组​​​群​​​分​​​配​​​资​​​源​​​ — 比​​​如​​​ CPU 时​​​间​​​、​​​系​​​统​​​内​​​存​​​、​​​网​​​络​​​带​​​宽​​​或​​​者​​​这​​​些​​​资​​​源​​​的​​​组​​​合​​​。​​​您​​​可​​​以​​​监​​​控​​​您​​​配​​​置​​​的​​​ cgroup，拒​​​绝​​​ cgroup 访​​​问​​​某​​​些​​​资​​​源​​​，甚​​​至​​​在​​​运​​​行​​​的​​​系​​​统​​​中​​​动​​​态​​​配​​​置​​​您​​​的​​​ cgroup。
主要提供了如下功能：
Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。
Prioritization: 优先级控制，比如：CPU利用和磁盘IO吞吐。
Accounting: 一些审计或一些统计，主要目的是为了计费。
Control: 挂起进程，恢复执行进程。
使​​​用​​​ cgroup，系​​​统​​​管​​​理​​​员​​​可​​​更​​​具​​​体​​​地​​​控​​​制​​​对​​​系​​​统​​​资​​​源​​​的​​​分​​​配​​​、​​​优​​​先​​​顺​​​序​​​、​​​拒​​​绝​​​、​​​管​​​理​​​和​​​监​​​控​​​。​​​可​​​更​​​好​​​地​​​根​​​据​​​任​​​务​​​和​​​用​​​户​​​分​​​配​​​硬​​​件​​​资​​​源​​​，提​​​高​​​总​​​体​​​效​​​率​​​。
在实践中，系统管理员一般会利用CGroup做下面这些事（有点像为某个虚拟机分配资源似的）：
隔离一个进程集合（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。
为这组进程 分配其足够使用的内存
为这组进程分配相应的网络带宽和磁盘存储限制
限制访问某些设备（通过设置设备的白名单）
<!-- more -->
Linux把CGroup这个事实现成了一个file system，你可以mount。在我的Ubuntu 14.04下，你输入以下命令你就可以看到cgroup已为你mount好了。
 $ mount -t cgroup
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset)
cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu)
cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio)
cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio)
cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb)
或者使用lssubsys命令：
$ lssubsys  -m
cpuset /sys/fs/cgroup/cpuset
cpu /sys/fs/cgroup/cpu
cpuacct /sys/fs/cgroup/cpuacct
memory /sys/fs/cgroup/memory
devices /sys/fs/cgroup/devices
freezer /sys/fs/cgroup/freezer
blkio /sys/fs/cgroup/blkio
net_cls /sys/fs/cgroup/net_cls
net_prio /sys/fs/cgroup/net_prio
perf_event /sys/fs/cgroup/perf_event
hugetlb /sys/fs/cgroup/hugetlb
我们可以看到，在/sys/fs下有一个cgroup的目录，这个目录下还有很多子目录，比如： cpu，cpuset，memory，blkio……这些，这些都是cgroup的子系统。分别用于干不同的事的。
如果你没有看到上述的目录，你可以自己mount，下面给了一个示例：
mkdir cgroup
mount -t tmpfs cgroup_root ./cgroup
mkdir cgroup/cpuset
mount -t cgroup -ocpuset cpuset ./cgroup/cpuset/
mkdir cgroup/cpu
mount -t cgroup -ocpu cpu ./cgroup/cpu/
mkdir cgroup/memory
mount -t cgroup -omemory memory ./cgroup/memory/
一旦mount成功，你就会看到这些目录下就有好文件了，比如，如下所示的cpu和cpuset的子系统：
 $ ls /sys/fs/cgroup/cpu /sys/fs/cgroup/cpuset/
/sys/fs/cgroup/cpu:
cgroup.clone_children  cgroup.sane_behavior  cpu.shares         release_agent
cgroup.event_control   cpu.cfs_period_us     cpu.stat           tasks
cgroup.procs           cpu.cfs_quota_us      notify_on_release  user
/sys/fs/cgroup/cpuset/:
cgroup.clone_children  cpuset.mem_hardwall             cpuset.sched_load_balance
cgroup.event_control   cpuset.memory_migrate           cpuset.sched_relax_domain_level
cgroup.procs           cpuset.memory_pressure          notify_on_release
cgroup.sane_behavior   cpuset.memory_pressure_enabled  release_agent
cpuset.cpu_exclusive   cpuset.memory_spread_page       tasks
cpuset.cpus            cpuset.memory_spread_slab       user
cpuset.mem_exclusive   cpuset.mems
你可以到/sys/fs/cgroup的各个子目录下去make个dir，你会发现，一旦你创建了一个子目录，这个子目录里又有很多文件了。
hchen@ubuntu:/sys/fs/cgroup/cpu$ sudo mkdir haoel
[sudo] password for hchen: 
~:/sys/fs/cgroup/cpu$ ls ./haoel
cgroup.clone_children  cgroup.procs       cpu.cfs_quota_us  cpu.stat           tasks
cgroup.event_control   cpu.cfs_period_us  cpu.shares        notify_on_release
好了，我们来看几个示例。
CPU 限制
假设，我们有一个非常吃CPU的程序，叫deadloop，其源码如下：
DEADLOOP.C
int main(void)
{
    int i = 0;
    for(;;) i++;
    return 0;
}
用sudo执行起来后，毫无疑问，CPU被干到了100%（下面是top命令的输出）
PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND   <br />
3529 root      20   0    4196    736    656 R 99.6  0.1   0:23.13 deadloop
然后，我们这前不是在/sys/fs/cgroup/cpu下创建了一个haoel的group。我们先设置一下这个group的cpu利用的限制：
 # cat /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us 
-1
 # echo 20000 &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us
我们看到，这个进程的PID是3529，我们把这个进程加到这个cgroup中：</p>
<h1 id="echo-3529-sysfscgroupcpuhaoeltasks">echo 3529 » /sys/fs/cgroup/cpu/haoel/tasks</h1>
<p>然后，就会在top中看到CPU的利用立马下降成20%了。（前面我们设置的20000就是20%的意思）
PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND   <br />
3529 root      20   0    4196    736    656 R 19.9  0.1   8:06.11 deadloop
然后，在我们另外一边：</p>
<h1 id="创建memory-cgroup">创建memory cgroup</h1>
<p>$ mkdir /sys/fs/cgroup/memory/haoel
$ echo 64k &gt; /sys/fs/cgroup/memory/haoel/memory.limit_in_bytes</p>
<h1 id="把上面的进程的pid加入这个cgroup">把上面的进程的pid加入这个cgroup</h1>
<p>$ echo [pid] &gt; /sys/fs/cgroup/memory/haoel/tasks
你会看到，一会上面的进程就会因为内存问题被kill掉了。
磁盘I/O限制
我们先看一下我们的硬盘IO，我们的模拟命令如下：（从/dev/sda1上读入数据，输出到/dev/null上）
sudo dd if=/dev/sda1 of=/dev/null
我们通过iotop命令我们可以看到相关的IO速度是55MB/s（虚拟机内）：
TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND        <br />
8128 be/4 root       55.74 M/s    0.00 B/s  0.00 % 85.65 % dd if=/de~=/dev/null…
然后，我们先创建一个blkio（块设备IO）的cgroup
mkdir /sys/fs/cgroup/blkio/haoel
并把读IO限制到1MB/s，并把前面那个dd命令的pid放进去（注：8:0 是设备号，你可以通过ls -l /dev/sda1获得）：
 # echo ‘8:0 1048576’  &gt; /sys/fs/cgroup/blkio/haoel/blkio.throttle.read_bps_device 
 # echo 8128 &gt; /sys/fs/cgroup/blkio/haoel/tasks
再用iotop命令，你马上就能看到读速度被限制到了1MB/s左右。
TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND        <br />
8128 be/4 root      973.20 K/s    0.00 B/s  0.00 % 94.41 % dd if=/de~=/dev/null…
CGroup的子系统
好了，有了以上的感性认识我们来，我们来看看control group有哪些子系统：
blkio — 这​​​个​​​子​​​系​​​统​​​为​​​块​​​设​​​备​​​设​​​定​​​输​​​入​​​/输​​​出​​​限​​​制​​​，比​​​如​​​物​​​理​​​设​​​备​​​（磁​​​盘​​​，固​​​态​​​硬​​​盘​​​，USB 等​​​等​​​）。
cpu — 这​​​个​​​子​​​系​​​统​​​使​​​用​​​调​​​度​​​程​​​序​​​提​​​供​​​对​​​ CPU 的​​​ cgroup 任​​​务​​​访​​​问​​​。​​​
cpuacct — 这​​​个​​​子​​​系​​​统​​​自​​​动​​​生​​​成​​​ cgroup 中​​​任​​​务​​​所​​​使​​​用​​​的​​​ CPU 报​​​告​​​。​​​
cpuset — 这​​​个​​​子​​​系​​​统​​​为​​​ cgroup 中​​​的​​​任​​​务​​​分​​​配​​​独​​​立​​​ CPU（在​​​多​​​核​​​系​​​统​​​）和​​​内​​​存​​​节​​​点​​​。​​​
devices — 这​​​个​​​子​​​系​​​统​​​可​​​允​​​许​​​或​​​者​​​拒​​​绝​​​ cgroup 中​​​的​​​任​​​务​​​访​​​问​​​设​​​备​​​。​​​
freezer — 这​​​个​​​子​​​系​​​统​​​挂​​​起​​​或​​​者​​​恢​​​复​​​ cgroup 中​​​的​​​任​​​务​​​。​​​
memory — 这​​​个​​​子​​​系​​​统​​​设​​​定​​​ cgroup 中​​​任​​​务​​​使​​​用​​​的​​​内​​​存​​​限​​​制​​​，并​​​自​​​动​​​生​​​成​​​​​内​​​存​​​资​​​源使用​​​报​​​告​​​。​​​
net_cls — 这​​​个​​​子​​​系​​​统​​​使​​​用​​​等​​​级​​​识​​​别​​​符​​​（classid）标​​​记​​​网​​​络​​​数​​​据​​​包​​​，可​​​允​​​许​​​ Linux 流​​​量​​​控​​​制​​​程​​​序​​​（tc）识​​​别​​​从​​​具​​​体​​​ cgroup 中​​​生​​​成​​​的​​​数​​​据​​​包​​​。​​​
net_prio — 这个子系统用来设计网络流量的优先级
hugetlb — 这个子系统主要针对于HugeTLB系统进行限制，这是一个大页文件系统。
注意，你可能在Ubuntu 14.04下看不到net_cls和net_prio这两个cgroup，你需要手动mount一下：
$ sudo modprobe cls_cgroup
$ sudo mkdir /sys/fs/cgroup/net_cls
$ sudo mount -t cgroup -o net_cls none /sys/fs/cgroup/net_cls 
$ sudo modprobe netprio_cgroup
$ sudo mkdir /sys/fs/cgroup/net_prio
$ sudo mount -t cgroup -o net_prio none /sys/fs/cgroup/net_prio
关于各个子系统的参数细节，以及更多的Linux CGroup的文档，你可以看看下面的文档：
Linux Kernel的官方文档
Redhat的官方文档
CGroup的术语
CGroup有下述术语：
任务（Tasks）：就是系统的一个进程。
控制组（Control Group）：一组按照某种标准划分的进程，比如官方文档中的Professor和Student，或是WWW和System之类的，其表示了某进程组。Cgroups中的资源控制都是以控制组为单位实现。一个进程可以加入到某个控制组。而资源的限制是定义在这个组上，就像上面示例中我用的haoel一样。简单点说，cgroup的呈现就是一个目录带一系列的可配置文件。
层级（Hierarchy）：控制组可以组织成hierarchical的形式，既一颗控制组的树（目录结构）。控制组树上的子节点继承父结点的属性。简单点说，hierarchy就是在一个或多个子系统上的cgroups目录树。
子系统（Subsystem）：一个子系统就是一个资源控制器，比如CPU子系统就是控制CPU时间分配的一个控制器。子系统必须附加到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。Cgroup的子系统可以有很多，也在不断增加中。
下一代的CGroup
上面，我们可以看到，CGroup的一些常用方法和相关的术语。一般来说，这样的设计在一般情况下还是没什么问题的，除了操作上的用户体验不是很好，但基本满足我们的一般需求了。
不过，对此，有个叫Tejun Heo的同学非常不爽，他在Linux社区里对cgroup吐了一把槽，还引发了内核组的各种讨论。
对于Tejun Heo同学来说，cgroup设计的相当糟糕。他给出了些例子，大意就是说，如果有多种层级关系，也就是说有多种对进程的分类方式，比如，我们可以按用户来分，分成Professor和Student，同时，也有按应用类似来分的，比如WWW和NFS等。那么，当一个进程即是Professor的，也是WWW的，那么就会出现多层级正交的情况，从而出现对进程上管理的混乱。另外，一个case是，如果有一个层级A绑定cpu，而层级B绑定memory，还有一个层级C绑定cputset，而有一些进程有的需要AB，有的需要AC，有的需要ABC，管理起来就相当不易。
层级操作起来比较麻烦，而且如果层级变多，更不易于操作和管理，虽然那种方式很好实现，但是在使用上有很多的复杂度。你可以想像一个图书馆的图书分类问题，你可以有各种不同的分类，分类和图书就是一种多对多的关系。
所以，在Kernel 3.16后，引入了unified hierarchy的新的设计，这个东西引入了一个叫__DEVEL__sane_behavior的特性（这个名字很明显意味目前还在开发试验阶段），它可以把所有子系统都挂载到根层级下，只有叶子节点可以存在tasks，非叶子节点只进行资源控制。
我们mount一下看看：
$ sudo mount -t cgroup -o __DEVEL__sane_behavior cgroup ./cgroup
$ ls ./cgroup
cgroup.controllers  cgroup.procs  cgroup.sane_behavior  cgroup.subtree_control 
$ cat ./cgroup/cgroup.controllers
cpuset cpu cpuacct memory devices freezer net_cls blkio perf_event net_prio hugetlb
我们可以看到有四个文件，然后，你在这里mkdir一个子目录，里面也会有这四个文件。上级的cgroup.subtree_control控制下级的cgroup.controllers。
cgroup只有上线控制下级，无法传递到下下级。所以，C和D中没有memory的限制，E中没有blkio和memory的限制。而本层的cgroup.controllers文件是个只读的，其中的内容就看上级的subtree_control里有什么了。
任何被配置过subtree_control的目录都不能绑定进程，根结点除外。所以，A,C,D,E可以绑上进程，但是B不行。
我们可以看到，这种方式干净的区分开了两个事，一个是进程的分组，一个是对分组的资源控制（以前这两个事完全混在一起），在目录继承上增加了些限制，这样可以避免一些模棱两可的情况。
当然，这个事还在演化中，cgroup的这些问题这个事目前由cgroup的吐槽人Tejun Heo和华为的Li Zefan同学负责解决中。总之，这是一个系统管理上的问题，而且改变会影响很多东西，但一旦方案确定，老的cgroup方式将一去不复返。
Cgroup是进行分组化管理的Linux内核功能，具体的资源管理是通过子系统来完成的。可以理解为子系统就是资源控制器，每种子系统就是一个资源的分配器，比如cpu子系统是控制cpu时间分配的，使用方式如下
安装（ubuntu）
#apt-get install cgroup-bin
基本命令
cgclassify – cgclassify命令是用来将运行的任务移动到一个或者多个cgroup。
cgclear – cgclear 命令是用来删除层级中的所有cgroup。
cgconfig.conf – 在cgconfig.conf文件中定义cgroup。
cgconfigparser – cgconfigparser命令解析cgconfig.conf文件和并挂载层级。
cgcreate – cgcreate在层级中创建新cgroup。
cgdelete – cgdelete命令删除指定的cgroup。
cgexec – cgexec命令在指定的cgroup中运行任务。
cgget – cgget命令显示cgroup参数。
cgred.conf – cgred.conf是cgred服务的配置文件。
cgrules.conf – cgrules.conf 包含用来决定何时任务术语某些 cgroup的规则。
cgrulesengd – cgrulesengd 在 cgroup 中发布任务。
cgset – cgset 命令为 cgroup 设定参数。
lscgroup – lscgroup 命令列出层级中的 cgroup。
lssubsys – lssubsys 命令列出包含指定子系统的层级
子系统说明
可以使用lssubsys -a来列出系统支持多少种子系统，和：比如cpu是控制cpu时间片的，memory是控制内存使用的
#lssubsys -a
cpuset
cpu,cpuacct
memory
devices
freezer
net_cls,net_prio
blkio
perf_event
hugetlb
主要的几种子系统说明如下：
blkio 这个子系统设置限制每个块设备的输入输出控制。例如:磁盘，光盘以及usb等等。
cpu 这个子系统使用调度程序为cgroup任务提供cpu的访问。
cpuacct 产生cgroup任务的cpu资源报告。
cpuset 如果是多核心的cpu，这个子系统会为cgroup任务分配单独的cpu和内存。
devices 允许或拒绝cgroup任务对设备的访问。
freezer 暂停和恢复cgroup任务。
memory 设置每个cgroup的内存限制以及产生内存资源报告。
net_cls 标记每个网络包以供cgroup方便使用。
ns 名称空间子系统
perf_event: 增加了对每group的监测跟踪的能力，即可以监测属于某个特定的group的所有线程以及运行在特定CPU上的线程
要为Cgroup分配限制的资源,首先要挂载子系统，然后才有控制组，比如想要对目标程序进行内存限制，那就需要挂载memory子系统
使用lssubsys -am来显示已经挂载的子系统
#lssubsys -am
cpuset /sys/fs/cgroup/cpuset
cpu,cpuacct /sys/fs/cgroup/cpu,cpuacct
memory /sys/fs/cgroup/memory
devices /sys/fs/cgroup/devices
freezer /sys/fs/cgroup/freezer
net_cls,net_prio /sys/fs/cgroup/net_cls,net_prio
blkio /sys/fs/cgroup/blkio
perf_event /sys/fs/cgroup/perf_event
hugetlb /sys/fs/cgroup/hugetlb
可以手动挂载或者卸载子系统，如执行umount /sys/fs/cgroup/memory，memory子系统就被卸载了，这时候手动执行# mount -t cgroup -o memory memory /sys/fs/cgroup/memory就又挂载上了。 
要确保需要的子系统都挂上了，不然创建控制组的时候会报错 is not mounted
#cgcreate -g memory,cpu:/hzmali_test
cgcreate: can’t create cgroup /hzmali_test: Cgroup one of the needed subsystems is not mounted
如何创建control group（即需要资源管理的组）呢, 这里用cgcreate命令，当然也有其他方法, 如cgconfig.conf等
#cgcreate -g memory,cpu:/hzmali_test
这里有个重要特性：一个组可以同时做多个资源的限制，如这里我同时限制了memory和cpu，然后memory和cpu子系统目录下会自动生成这个组的目录和些文件，如memory
#/sys/fs/cgroup/memory/hzmali_test$ ls -lrt
文件很多，选几个重要的讲下：
tasks 可以将想要限制资源的进程都加到这个文件中
memory.max_usage_in_bytes内存的最大使用量，用来限制资源 
-memory.soft_limit_in_bytes 和 memory.limit_in_bytes 的差异是，这个限制并不会阻止进程使用超过限额的内存，只是在系统内存不足时，会优先回收超过限额的进程占用的内存，使之向限定值靠拢。
memory.oom_control 
包含一个标志（0或1）来开启或者关闭cgroup的OOM killer。如果开启（1），任务如果尝试申请内存超过允许，就会被系统OOM killer终止。OOM killer在每个使用cgroup内存子系统中都是默认开启的。如果需要关闭，则可以向memory.oom_control文件写入1：
 # echo 1 &gt; /sys/fs/cgroup/memory.oom_control 
如果OOM killer关闭，那么进程尝试申请的内存超过允许，那么它就会被暂停，直到额外的内存被释放
memory.mem.usage_in_bytes 当前进程内存用量，因为现在还没有进程加到组里，就是0了
memory.mem.failcnt显示内存达到限制值的次数
Cgroup文档
Cgroup的使用细节，子系统和参数设置都可以可以在https://www.kernel.org/doc/Documentation/cgroups/中找到，继承等特性由于篇幅所限，可以看下文档
Cgroup实战
内存限制测试
用控制组限制目标程序内存使用为1000000 byte，当然，需要root执行 
echo “1000000” &gt;memory.limit_in_bytes
一般更推荐用cgset来设置数值
cgset -r memory.limit_in_bytes=1000000 hzmali_test
然后构造一个吃内存的程序，每运行一次内存使用就大幅增加
如果我不想把机器跑死，这里想要限制组里的进程的CPU使用，有2种做法 
1.在cpu子系统中控制cpu调度的配额 
先看下当前cpu分配情况
cat /sys/fs/cgroup/cpu/hzmali_test/cpu.cfs_quota_us
-1
cat /sys/fs/cgroup/cpu/hzmali_test/cpu.cfs_period_us
100000
-1表示无限制，这里改为50000，即相对于cpu.cfs_period_us 来说为50000/100000约占1个核50%的cpu时间
 #./cpu_test.sh &amp;
[1] 17709
 # echo 17709 &gt;/sys/fs/cgroup/cpu/hzmali_test/tasks
或者直接使用命令cgexec执行
cgexec -g cpu:hzmali_test ./cpu_test.sh
top了下基本上就是在50%的cpu占用
%Cpu0 : 50.5 us, 0.0 sy, 0.0 ni, 49.5 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
%Cpu1 : 0.0 us, 0.3 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 17709 root 20 0 25368 2020 1764 R 50.2 0.1 1:14.74 bash
2.在cpuset控制物理cpu的分配 
当前使用了上面的方法后，我们发现进程的CPU使用都在Cpu0上，这次希望只用Cpu1来跑这个小程序 
所以把控制组也加到cpuset
 # cgcreate -g cpuset:/hzmali_test
看一下现在使用的cpu的设置
 # cat /sys/fs/cgroup/cpuset/hzmali_test/cpuset.cpus
0-1
改为只用Cpu1，输入以下命令
 # echo 1 &gt; /sys/fs/cgroup/cpuset/hzmali_test/cpuset.cpus
 # echo 17709 &gt; /sys/fs/cgroup/cpuset/hzmali_test/tasks
或用命令
 # cgset -r cpuset.cpus=’1’ hzmali_test
 # cgclassify -g cpu,cpuset:hzmali_test 17709
top一下，内存的使用从CPU0到CPU1了
%Cpu0 : 0.0 us, 0.0 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.3 si, 0.0 st
%Cpu1 : 50.3 us, 0.0 sy, 0.0 ni, 49.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
17709 root 20 0 25368 2108 2076 R 50.1 0.1 8:56.78 bash
IO限制测试
用dd对硬盘进行写操作
 # dd if=/dev/sda of=/dev/null &amp;
打开iotop看下IO速度
Total DISK READ : 100.37 M/s | Total DISK WRITE : 0.00 B/s
Actual DISK READ: 100.37 M/s | Actual DISK WRITE: 0.00 B/s
TID PRIO USER DISK READ DISK WRITE SWAPIN IO&gt; COMMAND
18081 be/4 root 100.37 M/s 0.00 B/s 0.00 % 1.34 % dd if=/dev/sda of=/dev/null
为了控制IO速度，在blkio上创建控制组
 # cgcreate -g blkio:/hzmali_test
查看下硬盘号
 # ls -l /dev/sda
brw-rw—- 1 root disk 8, 0 Jul 25 22:46 /dev/sda
设置硬盘号和对应的读取速度限制，然后执行同样的命令
 # cgset -r blkio.throttle.read_bps_device=”8:0 1000000” hzmali_test
 # cgexec -g blkio:hzmali_test “dd if=/dev/sda of=/dev/null”
用iotop查看下，速度果然就降到1M以下</p>

    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/29/cgroup.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/29/bridge.html" class="post-title-link">
      <h2>bridge</h2>
    </a>

    <div class="post-date">Apr 29, 2018</div>
    
    <div class="post-body">
      
      <p>网桥设备作为一个虚拟设备，用于连接多个端口，可以构建一个局域网。与之相似的是vlan设备，在linux中，vlan设备是为了处理802.1q的添加和去除TAG的问题，这和传统交换机中vlan的功能—划分局域网，不太一样，在这里仅仅是处理了消息头，只是实现了隔离功能，并未实现交换功能，如果需要vlan内的数据转发，可以把vlan子接口挂接在网桥设备下。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/29/bridge.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/22/expect.html" class="post-title-link">
      <h2>expect</h2>
    </a>

    <div class="post-date">Apr 22, 2018</div>
    
    <div class="post-body">
      
      <p>expect是一个自动交互功能的工具。expect是开了一个子进程，通过spawn来执行shell脚本，监测到脚本的返回结果，通过expect判断要进行的交互输入内容（send）
1.安装expect 
需要先安装tcl：apt-get install tcl
apt-get install expect
2.expect使用
2.1一个简单的输入密码操作</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre> <span class="c">#！/usr/bin/expect</span>
<span class="nb">set </span>timeout 100
<span class="nb">set </span>password <span class="s2">"123456"</span>
spawn <span class="nb">sudo </span>rm <span class="nt">-rf</span> zzlogic
expect <span class="s2">"root123456"</span>
send <span class="s2">"</span><span class="nv">$password</span><span class="se">\n</span><span class="s2">"</span>
interact</pre></td></tr></tbody></table></code></pre></figure>

<p>说明：
第一行#！/usr/bin/expect表示使用expect的shell交互模式
set是对变量password赋值
set timeout 100：设置超时时间为100秒，如果要执行的shell命令很长可以设置超时时间长一些。expect超过超时时间没有监测到要找的字符串，则不执行，默认timeout为10秒
spawn在expect下执行shell脚本
expect对通过spawn执行的shell脚本的返回进行判断，是否包含“”中的字段
send：如果expect监测到了包含的字符串，将输入send中的内容，\n相当于回车
interact：退出expect返回终端，可以继续输入，否则将一直在expect不能退出到终端
2.2expect的命令行参数
[lindex $argv n]获得index为n的参数（index从0开始计算）
$argc为命令行参数的个数
[lrange $argv 0 0]表示第一个参数
[lrange $argv 0 3]表示第1到第3个参数
例如scp_service.sh文件，可以./scp_service.sh -rm来执行，这时是赋值了一个参数
set option  [lindex $argv 0]（获得第一个参数存到变量option中，参数是的index是从0开始计算的）
2.3if…elif…else…
expect支持if语句，
if {条件1} {
     条件1执行语句
} elif {条件2} {
     条件2执行语句
} else {
     其他情况执行语句
}
说明：
1.if的条件用{}来包含条件
2.if和后面的{}必须有空格隔开
3.两个花括号之间必须有空格隔开，比如if {} {}，否则会报错 expect:extra characters after close-brace
3.使用{来衔接下一行，所以if的条件后需要加左花括号{
4.else不能单独放一行，所以else要跟在}后面
2.4 expect {}，多行期望，匹配到哪条执行哪条
背景：有时执行shell后预期结果是不固定的，有可能是询问是yes/no，有可能是去输入密码，所以可以用expect{}
花括号内放多行语句，从上至下匹配，匹配到哪个expect执行哪句。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/22/expect.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/20/linux_shell.html" class="post-title-link">
      <h2>Linux下的shell工作原理</h2>
    </a>

    <div class="post-date">Apr 20, 2018</div>
    
    <div class="post-body">
      
      <p>Linux系统提供给用户的最重要的系统程序是Shell命令语言解释程序。它不属于内核部分，而是在核心之外，以用户态方式运行。其基本功能是解释并执行用户打入的各种命令，实现用户与Linux核心的接口。系统初启后，核心为每个终端用户建立一个进程去执行Shell解释程序。它的执行过程基本上按如下步骤： 
(1)读取用户由键盘输入的命令行。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/20/linux_shell.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/04/16/dup.html" class="post-title-link">
      <h2>dup dup2</h2>
    </a>

    <div class="post-date">Apr 16, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>有时我们希望把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接。
dup()与dup2()能对输入文件描述符进行重定向。
int dup(int oldfd);
int dup2(int oldfd, intnewfd);
dup函数创建一个新的文件描述符，该新文件描述符和原有文件描述符oldfd指向相同的文件、管道或者网络连接。
并且dup返回的文件描述符总是取系统当前可用的最小整数值。dup2和dup类似，不过它将返回第一个不小于oldfd的整数值。dup和dup2失败时返回-1并设置errno。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/04/16/dup.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/03/27/rsync.html" class="post-title-link">
      <h2>rsync</h2>
    </a>

    <div class="post-date">Mar 27, 2018</div>
    
    <div class="post-body">
      
      <p>它比scp更强大，支持“不覆盖”原目录
例子：
rsync -avz –progress /root/client/   root@202.112.23.12:/home/work/</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/03/27/rsync.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/03/13/system_call.html" class="post-title-link">
      <h2>系统调用</h2>
    </a>

    <div class="post-date">Mar 13, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>为什么需要系统调用
   现代的操作系统通常都具有多任务处理的功能，通常靠进程来实现。由于操作系统快速的在每个进程间切换执行，所以一切看起来就会像是同时的。同时这也带来了很多安全问题，例如，一个进程可以轻易的修改进程的内存空间中的数据来使另一个进程异常或达到一些目的，因此操作系统必须保证每一个进程都能安全的执行。这一问题的解决方法是在处理器中加入基址寄存器和界限寄存器。这两个寄存器中的内容用硬件限制了对储存器的存取指令所访问的储存器的地址。这样就可以在系统切换进程时写入这两个寄存器的内容到该进程被分配的地址范围，从而避免恶意软件。
   为了防止用户程序修改基址寄存器和界限寄存器中的内容来达到访问其他内存空间的目的，这两个寄存器必须通过一些特殊的指令来访问。通常，处理器设有两种模式：“用户模式”与“内核模式”，通过一个标签位来鉴别当前正处于什么模式。一些诸如修改基址寄存器内容的指令只有在内核模式中可以执行，而处于用户模式的时候硬件会直接跳过这个指令并继续执行下一个。
   当操作系统接收到系统调用请求后，会让处理器进入内核模式，从而执行诸如I/O操作，修改基址寄存器内容等指令，而当处理完系统调用内容后，操作系统会让处理器返回用户模式，来执行用户代码。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/03/13/system_call.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/02/05/iputils.html" class="post-title-link">
      <h2>iputils</h2>
    </a>

    <div class="post-date">Feb 5, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>1.1       iputils软件包简介
    iputils软件包是linux环境下一些实用的网络工具的集合。一开始由Alexey Kuznetsov维护。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/02/05/iputils.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/01/26/zero_copy.html" class="post-title-link">
      <h2>zero copy</h2>
    </a>

    <div class="post-date">Jan 26, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>许多web应用都会向用户提供大量的静态内容，这意味着有很多data从硬盘读出之后，会原封不动的通过socket传输给用户。这种操作看起来可能不会怎么消耗CPU，但是实际上它是低效的：kernal把数据从disk读出来，然后把它传输给user级的application，然后application再次把同样的内容再传回给处于kernal级的socket。这种场景下，application实际上只是作为一种低效的中间介质，用来把disk file的data传给socket。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/01/26/zero_copy.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/01/24/nohup.html" class="post-title-link">
      <h2>进程在后台运行原理</h2>
    </a>

    <div class="post-date">Jan 24, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>nohup/setsid/&amp;
场景：
如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/01/24/nohup.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2018/01/16/ln.html" class="post-title-link">
      <h2>Linux、Mac上面ln命令使用说明</h2>
    </a>

    <div class="post-date">Jan 16, 2018</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同不的链接，这个命令最常用的参数是 -s，具体用法是：ln –s 源文件 目标文件。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2018/01/16/ln.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/30/broad_cast.html" class="post-title-link">
      <h2>单播、多播和广播</h2>
    </a>

    <div class="post-date">Dec 30, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>　　单播在网络中得到了广泛的应用，网络上绝大部分的数据都是以单播的形式传输的，只是一般网络用户不知道而已。例如，你在收发电子邮件、浏览网页时，必须与邮件服务器、Web服务器建立连接，此时使用的就是单播数据传输方式。但是通常使用“点对点通信”（Point to Point）代替“单播”，因为“单播”一般与“多播”和“广播”相对应使用
　　　“多播”也可以称为“组播”，在网络技术的应用并不是很多，网上视频会议、网上视频点播特别适合采用多播方式。因为如果采用单播方式，逐个节点传输，有多少个目标节点，就会有多少次传送过程，这种方式显然效率极低，是不可取的；如果采用不区分目标、全部发送的广播方式，虽然一次可以传送完数据，但是显然达不到区分特定数据接收对象的目的。采用多播方式，既可以实现一次传送所有目标节点的数据，也可以达到只对特定对象传送数据的目的。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/30/broad_cast.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/30/arp.html" class="post-title-link">
      <h2>arp</h2>
    </a>

    <div class="post-date">Dec 30, 2017</div>
    
    <div class="post-body">
      
      <p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。
<!-- more -->
工作过程
主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；
主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；
当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：
第1步：根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。
第2步：如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。
第3步：主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。
第4步：主机B将包含其MAC地址的ARP回复消息直接发送回主机A。
第5步：当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。
ARP缓存是个用来储存IP地址和MAC地址的缓冲区，其本质就是一个IP地址–&gt;MAC地址的对应表，表中每一个条目分别记录了网络上其他主机的IP地址和对应的MAC地址。每一个以太网或令牌环网络适配器都有自己单独的表。当地址解析协议被询问一个已知IP地址节点的MAC地址时，先在ARP缓存中查看，若存在，就直接返回与之对应的MAC地址，若不存在，才发送ARP请求向局域网查询。
为使广播量最小，ARP维护IP地址到MAC地址映射的缓存以便将来使用。ARP缓存可以包含动态和静态项目。动态项目随时间推移自动添加和删除。每个动态ARP缓存项的潜在生命周期是10分钟。新加到缓存中的项目带有时间戳，如果某个项目添加后2分钟内没有再使用，则此项目过期并从ARP缓存中删除；如果某个项目已在使用，则又收到2分钟的生命周期；如果某个项目始终在使用，则会另外收到2分钟的生命周期，一直到10分钟的最长生命周期。静态项目一直保留在缓存中，直到重新启动计算机为止。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/30/arp.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/27/ioctl.html" class="post-title-link">
      <h2>ioctl</h2>
    </a>

    <div class="post-date">Dec 27, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>ioctl函数详细说明（网络）
ioctl 函数
本函数影响由fd 参数引用的一个打开的文件。
 #include<unistd.h></unistd.h></p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/27/ioctl.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/27/inetd.html" class="post-title-link">
      <h2>inetd</h2>
    </a>

    <div class="post-date">Dec 27, 2017</div>
    
    <div class="post-body">
      
      <p>inetd是监视一些网络请求的守护进程，其根据网络请求来调用相应的服务进程来处理连接请求。它可以为多种服务管理连接，当 inetd 接到连接时，它能够确定连接所需的程序，启动相应的进程，并把 socket 交给它 （服务 socket 会作为程序的标准输入、 输出和错误输出描述符）。 使用 inetd 来运行那些负载不重的服务有助于降低系统负载，因为它不需要为每个服务都启动独立的服务程序。
<!-- more -->
inetd是通过rc系统启动的。inetd_enable选项默认设为NO，但可以在安装系统时，由用户根据需要sysinstall通过来打开。
inetd.conf则是inetd的配置文件。inetd.conf文件告诉inetd监听哪些网络端口，为每个端口启动哪个服务。在任何的网络环境中使用Linux系统，第一件要做的事就是了解一下服务器到底要提供哪些服务。不需要的那些服务应该被禁止掉，最好卸载掉，这样黑客就少了一些攻击系统的机会。查看“/etc/inetd.conf”文件，了解一下inetd提供哪些服务。用加上注释的方法（在一行的开头加上#号），禁止任何不需要的服务，再给inetd进程发一个SIGHUP信号。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/27/inetd.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/24/unix_io5.html" class="post-title-link">
      <h2>UNIX下的5种IO模型</h2>
    </a>

    <div class="post-date">Dec 24, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>套接字的IO操作，如recvfrom，分为两个阶段：</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/24/unix_io5.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/24/thread_namespace.html" class="post-title-link">
      <h2>用户空间实现线程 内核实现线程 线程的调度</h2>
    </a>

    <div class="post-date">Dec 24, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>1、在用户空间中实现线程</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/24/thread_namespace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/24/thread.html" class="post-title-link">
      <h2>进程切换</h2>
    </a>

    <div class="post-date">Dec 24, 2017</div>
    
    <div class="post-body">
      
      <p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（process switch）、任务切换（task switch）或上下文切换（content switch）。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/24/thread.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/24/select_poll.html" class="post-title-link">
      <h2>IO多路复用之select、poll、epoll</h2>
    </a>

    <div class="post-date">Dec 24, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 目前支持I/O多路复用的系统调用有 select，pselect，poll，epoll，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，pselect，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。
 与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。
</code></pre></div></div>

<p>一、使用场景
IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：
　　1）当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。
　　2）当一个客户同时处理多个套接口时，这种情况是可能的，但很少出现。
　　3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。
　　4）如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。
　　5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p>

<p>二、select、poll、epoll简介
　　epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现。
1、select
基本原理：select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>

<p>基本流程，如图所示：
	<img src="https://xiazemin.github.io/MyBlog/img/ioMutex.png" /></p>

<p>　　select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p>

<p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：
1、select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。
　　一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.
2、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。
　　当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。
3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</p>

<p>2、poll
基本原理：poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>

<p>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：
1）大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。
2）poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>

<p>注意：从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>

<p>3、epoll
　　epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>

<p>基本原理：epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p>

<p>epoll的优点：
1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。
2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。
　　只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。
3、内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p>

<p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：
LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。
ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。
1、LT模式
　　LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。
2、ET模式
　　ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。
　　ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。
3、在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)
注意：如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll。</p>

<p>三、select、poll、epoll区别
1、支持一个进程所能打开的最大连接数
 	<img src="https://xiazemin.github.io/MyBlog/img/selectPoolConnect.png" />
2、FD剧增后带来的IO效率问题
 	<img src="https://xiazemin.github.io/MyBlog/img/selectPollFd.png" />
3、消息传递方式
 	<img src="https://xiazemin.github.io/MyBlog/img/selectPollMmap.png" /></p>

<p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：
1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/24/select_poll.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/24/goroutine.html" class="post-title-link">
      <h2>goroutine</h2>
    </a>

    <div class="post-date">Dec 24, 2017</div>
    
    <div class="post-body">
      
      <p>Go runtime的调度器：在了解Go的运行时的scheduler之前，需要先了解为什么需要它，因为我们可能会想，OS内核不是已经有一个线程scheduler了嘛？熟悉POSIX API的人都知道，POSIX的方案在很大程度上是对Unix process进场模型的一个逻辑描述和扩展，两者有很多相似的地方。 Thread有自己的信号掩码，CPU affinity等。但是很多特征对于Go程序来说都是累赘。 尤其是context上下文切换的耗时。另一个原因是Go的垃圾回收需要所有的goroutine停止，使得内存在一个一致的状态。垃圾回收的时间点是不确定的，如果依靠OS自身的scheduler来调度，那么会有大量的线程需要停止工作。 单独的开发一个GO得调度器，可以是其知道在什么时候内存状态是一致的，也就是说，当开始垃圾回收时，运行时只需要为当时正在CPU核上运行的那个线程等待即可，而不是等待所有的线程。用户空间线程和内核空间线程之间的映射关系有：N:1,1:1和M:NN:1是说，多个（N）用户线程始终在一个内核线程上跑，context上下文切换确实很快，但是无法真正的利用多核。1：1是说，一个用户线程就只在一个内核线程上跑，这时可以利用多核，但是上下文switch很慢。M:N是说， 多个goroutine在多个内核线程上跑，这个看似可以集齐上面两者的优势，但是无疑增加了调度的难度。
Go的调度器内部有三个重要的结构：M，P，G
M:代表真正的内核OS线程，和POSIX里的thread差不多，真正干活的人G:代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度。P:代表调度的上下文，可以把它看做一个局部的调度器，使go代码在一个线程上跑，它是实现从N:1到N:M映射的关键。
有2个物理线程M，每一个M都拥有一个context（P），每一个也都有一个正在运行的goroutine。P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。图中灰色的那些goroutine并没有运行，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为runqueue），Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个goroutine，在下一个调度点，就从runqueue中取出（如何决定取哪个goroutine？）一个goroutine执行。为何要维护多个上下文P？因为当一个OS线程被阻塞时，P可以转而投奔另一个OS线程！图中看到，当一个OS线程M0陷入阻塞时，P转而在OS线程M1上运行。调度器保证有足够的线程来运行所以的context P。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/24/goroutine.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/22/pid_0_1.html" class="post-title-link">
      <h2>ID为0和ID为1的进程</h2>
    </a>

    <div class="post-date">Dec 22, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>ID为0的进程通常是调度进程，常常被称为交换进程（swapper）。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。
ID为1的进程，通常是init进程，在自举过程结束时由内核调用。该进程的程序文件，在UNIX早起版本中是/etc/init，在较新的版本中是/sbin/init。该进程负责在自举内核后启动一个UNIX系统。init通常读与系统有关的初始化文件（/etc/rc*文件或/etc/inittab文件，以及/etc/init.d中的文件），并将系统引导到一个状态。init 进程绝不会终止，它是一个普通的用户进程（与交换进程不同，它不是内核的系统进程）但是它以超级用户特权运行。 ——摘自APUE
父进程ID为0的进程通常是内核进程，它们作为系统自举过程的一部分而启动，但init进程是个例外，它的父进程是0，但是它是用户进程。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/22/pid_0_1.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/22/fork_b.html" class="post-title-link">
      <h2>Shell脚本经典之Fork炸弹</h2>
    </a>

    <div class="post-date">Dec 22, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>众所周知，bash是一款极其强大的shell，提供了强大的交互与编程功能。这样的一款shell中自然不会缺少“函数”这个元素来帮助程序进行模块化的高效开发与管理。于是产生了由于其特殊的特性，bash拥有了fork炸弹。Jaromil在2002年设计了最为精简的一个fork炸弹的实现。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/22/fork_b.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/22/fork.html" class="post-title-link">
      <h2>fork</h2>
    </a>

    <div class="post-date">Dec 22, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>一、fork入门知识</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/22/fork.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/22/exec.html" class="post-title-link">
      <h2>Linux进程控制——exec函数族</h2>
    </a>

    <div class="post-date">Dec 22, 2017</div>
    
    <div class="post-body">
      
      <p>在Linux中，并不存在exec()函数，exec指的是一组函数，一共有6个，分别是：
 #include <unistd.h>
extern char **environ;
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
其中只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。
exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。
函数名与参数的关系：
细看一下，这6个函数都是以exec开头（表示属于exec函数组），前3个函数接着字母l的，后3个接着字母v的，我的理解是l表示list（列举参数），v表示vector（参数向量表）
。它们的区别在于，execv开头的函数是以"char *argv[]"(vector)形式传递命令行参数，而execl开头的函数采用了罗列(list)的方式，把参数一个一个列出来，然后以一个NULL表示结束。这里的NULL的作用和argv数组里的NULL作用是一样的。
字母p是指在环境变量PATH的目录里去查找要执行的可执行文件。2个以p结尾的函数execlp和execvp，看起来，和execl与execv的差别很小，事实也如此，它们的区别从第一个参数名可以看出：除 execlp和execvp之外的4个函数都要求，它们的第1个参数path必须是一个完整的路径，如"/bin/ls"；而execlp和execvp 的第1个参数file可以仅仅只是一个文件名，如"ls"，这两个函数可以自动到环境变量PATH指定的目录里去查找。
字母e是指给可执行文件指定环境变量。在全部6个函数中，只有execle和execve使用了char *envp[]传递环境变量，其它的4个函数都没有这个参数，这并不意味着它们不传递环境变量，这4个函数将把默认的环境变量不做任何修改地传给被执行的应用程序。而execle和execve用指定的环境变量去替代默认的那些。
返回值
与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只有进程ID等一些表面上的信息仍保持原样。调用失败时，会设置errno并返回-1，然后从原程序的调用点接着往下执行。
与其他系统调用比起来，exec很容易失败，被执行文件的位置，权限等很多因素都能导致调用失败。因此，使用exec函数族时，一定要加错误判断语句。最常见的错误：
找不到文件或路径，此时errno被设置为ENOENT；
数组argv和envp忘记用NULL结束，此时errno被设置为EFAULT；
没有对要执行文件的运行权限，此时errno被设置为EACCES。
2、应用
如果一个进程想执行另一个程序，它就可以fork或vfork出一个新进程，然后调用任何一个exec函数。
为此，Linux还专门对fork作了优化：通常fork会将调用进程的所有内容原封不动的拷贝到新产生的子进程中去，这些拷贝的动作很消耗时 间，而如果fork完之后我们马上就调用exec，那这些辛辛苦苦拷贝来的东西就会被立刻抹掉，这看起来非常不划算，于是人们设计了一种"写时复制（copy-on-write）" 技术，使得fork结束后并不立刻复制父进程的内容到子进程，而是到了真正使用时才复制，这样如果下一条语句是exec，它就不会作无用功了。其实"写时 复制"还是有复制，进程的mm结构、页表都还是被复制了（"写时复制"也必须由这些信息来支撑。否则内核捕捉到CPU访存异常，怎么区分 这是“写时复制”引起的，还是真正的越权访问呢？）。
而vfork就把事情做绝了，所有有关于内存的东西都不复制了，父子进程的内存是完全共享的。 但是这样一来又有问题了，虽然用户程序可以设计很多方法来避免父子进程间的访存冲突。但是关键的一点，父子进程共用着栈，这可不由用户程序控制的。一个进 程进行了关于函数调用或返回的操作，则另一个进程的调用栈 （实际上就是同一个栈）也被影响了。这样的程序没法运行下去。所以，vfork有个限制，子进程生成后，父进程在vfork中被内核挂起，直到子进程有了 自己的内存空间（exec**）或退出(_exit)。并且， 在此之前，子进程不能从调用vfork的函数中返回（同时，不能修改栈上变量、不能继续调用除_exit或exec系列之外的函数，否则父进程的数据可能 被改写）。
尽管限制很多，vfork后马上exec效率会比fork高不少。
<!-- more -->
fork函数是用于创建一个子进程，该子进程几乎是父进程的副本，而有时我们希望子进程去执行另外的程序，exec函数族就提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。
（2）在Linux中使用exec函数族主要有以下两种情况
a. 当进程认为自己不能再为系统和用户做出任何贡献时，就可以调用任何exec 函数族让自己重生。
b. 如果一个进程想执行另一个程序，那么它就可以调用fork函数新建一个进程，然后调用任何一个exec函数使子进程重生。
（3）exec函数族语法
实际上，在Linux中并没有exec函数，而是有6个以exec开头的函数族，下表列举了exec函数族的6个成员函数的语法。
所需头文件： #include <unistd.h>
函数说明： 执行文件
函数原型：
[plain] view plain copy
int execl(const char *path, const char *arg, ...)  
int execv(const char *path, char *const argv[])  
int execle(const char *path, const char *arg, ..., char *const envp[])  
int execve(const char *path, char *const argv[], char *const envp[])  
int execlp(const char *file, const char *arg, ...)  
int execvp(const char *file, char *const argv[])</unistd.h></unistd.h></p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/22/exec.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/13/radix_tree.html" class="post-title-link">
      <h2>radix tree</h2>
    </a>

    <div class="post-date">Dec 13, 2017</div>
    
    <div class="post-body">
      
      <p>基数树</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/13/radix_tree.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/10/strace.html" class="post-title-link">
      <h2>truss、strace或ltrace</h2>
    </a>

    <div class="post-date">Dec 10, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>truss和strace用来 跟踪一个进程的系统调用或信号产生的情况，而 ltrace用来 跟踪进程调用库函数的情况。truss是早期为System V R4开发的调试程序，包括Aix、FreeBSD在内的大部分Unix系统都自带了这个工具；而strace最初是为SunOS系统编写的，ltrace最早出现在GNU/Debian Linux中。这两个工具现在也已被移植到了大部分Unix系统中，大多数Linux发行版都自带了strace和ltrace，而FreeBSD也可通过Ports安装它们。
你不仅可以从命令行调试一个新开始的程序，也可以把truss、strace或ltrace绑定到一个已有的PID上来调试一个正在运行的程序。三个调试工具的基本使用方法大体相同，下面仅介绍三者共有，而且是最常用的三个命令行参数：
-f ：除了跟踪当前进程外，还跟踪其子进程。
-o file ：将输出信息写到文件file中，而不是显示到标准错误输出（stderr）。
-p pid ：绑定到一个由pid对应的正在运行的进程。此参数常用来调试后台进程。
使用上述三个参数基本上就可以完成大多数调试任务了，下面举几个命令行例子：
truss -o ls.truss ls -al： 跟踪ls -al的运行，将输出信息写到文件/tmp/ls.truss中。
strace -f -o vim.strace vim： 跟踪vim及其子进程的运行，将输出信息写到文件vim.strace。
ltrace -p 234： 跟踪一个pid为234的已经在运行的进程。
三个调试工具的输出结果格式也很相似，以strace为例：
brk(0)                                  = 0x8062aa8
brk(0x8063000)                          = 0x8063000
mmap2(NULL, 4096, PROT_READ, MAP_PRIVATE, 3, 0x92f) = 0x40016000
每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。 truss、strace和ltrace的工作原理大同小异，都是使用ptrace系统调用跟踪调试运行中的进程，详细原理不在本文讨论范围内，有兴趣可以参考它们的源代码。
每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。
strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。
-c 统计每一系统调用的所执行的时间,次数和出错的次数等. 
-d 输出strace关于标准错误的调试信息. 
-f 跟踪由fork调用所产生的子进程. 
-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号. 
-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪. 
-h 输出简要的帮助信息. 
-i 输出系统调用的入口指针. 
-q 禁止输出关于脱离的消息. 
-r 打印出相对时间关于,,每一个系统调用. 
-t 在输出中的每一行前加上时间信息. 
-tt 在输出中的每一行前加上时间信息,微秒级. 
-ttt 微秒级输出,以秒了表示时间. 
-T 显示每一调用所耗的时间. 
-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出. 
-V 输出strace的版本信息. 
-x 以十六进制形式输出非标准字符串 
-xx 所有字符串以十六进制形式输出. 
-a column 
设置返回值的输出位置.默认 为40. 
-e expr 
指定一个表达式,用来控制如何跟踪.格式如下: 
[qualifier=][!]value1[,value2]… 
qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如: 
-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. 
注意有些shell使用!来执行历史记录里的命令,所以要使用\. 
-e trace=set 
只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all. 
-e trace=file 
只跟踪有关文件操作的系统调用. 
-e trace=process 
只跟踪有关进程控制的系统调用. 
-e trace=network 
跟踪与网络有关的所有系统调用. 
-e strace=signal 
跟踪所有与系统信号有关的 系统调用 
-e trace=ipc 
跟踪所有与进程通讯有关的系统调用 
-e abbrev=set 
设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all. 
-e raw=set 
将指 定的系统调用的参数以十六进制显示. 
-e signal=set 
指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号. 
-e read=set 
输出从指定文件中读出 的数据.例如: 
-e read=3,5 
-e write=set 
输出写入到指定文件中的数据. 
-o filename 
将strace的输出写入文件filename 
-p pid 
跟踪指定的进程pid. 
-s strsize 
指定输出的字符串的最大长度.默认为32.文件名一直全部输出. 
-u username 
以username 的UID和GID执行被跟踪的命令
通用的完整用法：</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/10/strace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/10/netlink.html" class="post-title-link">
      <h2>netlink</h2>
    </a>

    <div class="post-date">Dec 10, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>Linux中的进程间通信机制源自于Unix平台上的进程通信机制。Unix的两大分支AT&amp;T Unix和BSD Unix在进程通信实现机制上的各有所不同，前者形成了运行在单个计算机上的System V IPC，后者则实现了基于socket的进程间通信机制。同时Linux也遵循IEEE制定的Posix IPC标准，在三者的基础之上实现了以下几种主要的IPC机制：管道(Pipe)及命名管道(Named Pipe)，信号(Signal)，消息队列(Message queue)，共享内存(Shared Memory)，信号量(Semaphore)，套接字(Socket)。通过这些IPC机制，用户空间进程之间可以完成互相通信。为了完成内核空间与用户空间通信，Linux提供了基于socket的Netlink通信机制，可以实现内核与用户空间数据的及时交换。
本文第2节概述相关研究工作，第3节与其他IPC机制对比，详细介绍Netlink机制及其关键技术，第4节使用KGDB+GDB组合调试，通过一个示例程序演示Netlink通信过程。第5节做总结并指出Netlink通信机制的不足之处。
2 相关研究
到目前Linux提供了9种机制完成内核与用户空间的数据交换，分别是内核启动参数、模块参数与 sysfs、sysctl、系统调用、netlink、procfs、seq_file、debugfs和relayfs，其中模块参数与sysfs、procfs、debugfs、relayfs是基于文件系统的通信机制，用于内核空间向用户控件输出信息；sysctl、系统调用是由用户空间发起的通信机制。由此可见，以上均为单工通信机制，在内核空间与用户空间的双向互动数据交换上略显不足。Netlink是基于socket的通信机制，由于socket本身的双共性、突发性、不阻塞特点，因此能够很好的满足内核与用户空间小量数据的及时交互，因此在Linux 2.6内核中广泛使用，例如SELinux，Linux系统的防火墙分为内核态的netfilter和用户态的iptables，netfilter与iptables的数据交换就是通过Netlink机制完成。 
3 Netlink机制及其关键技术
3.1 Netlink机制</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/10/netlink.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/09/sysfs.html" class="post-title-link">
      <h2>linux sysfs</h2>
    </a>

    <div class="post-date">Dec 9, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>在调试驱动，或驱动涉及一些参数的输入输出时，难免需要对驱动里的某些变量或内核参数进行读写，或函数调用。此时sysfs接口就很有用了，它可以使得可以在用户空间直接对驱动的这些变量读写或调用驱动的某些函数。sysfs接口与proc文件系统很相似，有人将proc文件系统形容为Windows XP，而将sysfs接口形容为Windows 7。
而在Android系统中，振动器、背光、电源系统等往往使用sysfs接口作为内核空间和用户空间的接口，驱动程序需要提供这些接口内容。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/09/sysfs.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/09/proc.html" class="post-title-link">
      <h2>proc文件系统</h2>
    </a>

    <div class="post-date">Dec 9, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>proc文件系统是一种无存储的文件系统，当读其中的文件时，其内容动态生成，当写文件时，文件所关联的写函数被调用。每个proc文件都关联的字节特定的读写函数，因而它提供了另外的一种和内核通信的机制：内核部件可以通过该文件系统向用户空间提供接口来提供查询信息、修改软件行为，因而它是一种比较重要的特殊文件系统。
由于proc文件系统以文件的形式向用户空间提供了访问接口，这些接口可以用于在运行时获取相关部件的信息或者修改部件的行为，因而它是非常方便的一个接口。内核中大量使用了该文件系统。proc文件系统就是一个文件系统，它可以挂载在目录树的任意位置，不过通常挂载在/proc下，它大致包含了如下信息：
内存管理
每个进程的相关信息
文件系统
设备驱动程序
系统总线
电源管理
终端
系统控制参数
网络
使用proc文件系统之前必须将其初始化并且挂载到系统中。proc文件系统的的初始化主要完成：
调用proc_init_inodecache创建proc文件系统所使用的专用缓冲区
调用register_filesystem注册proc文件系统，这里会提供proc文件系统自己的file_system_type，其中包括了用于mount的函数指针。在执行mount的时候会用到这些信息，并最终找到mount函数进行挂载操作
调用proc_mkdir创建一些proc文件目录
在sys文件系统下注册proc文件系统的相关信息
在proc的mount函数中会调用proc_fill_super，它会给出proc文件系统超级块所需要的信息（比如文件系统的超级块操作函数指针，超级块大小等），并且会创建proc文件系统的根目录，在创建根目录时也会指定与之对应的inode_operations和file_operations，有了这些信息后，VFS就可以在该文件系统上进行各种操作了（创建、删除、查找文件）。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/09/proc.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/08/namespace.html" class="post-title-link">
      <h2>namespace</h2>
    </a>

    <div class="post-date">Dec 8, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>Linux Namespace</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/08/namespace.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/07/vfs.html" class="post-title-link">
      <h2>vfs</h2>
    </a>

    <div class="post-date">Dec 7, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>在Linux中，文件系统主要分为下面3种：
（1）基于磁盘的文件系统（Disk-based Filesystem) 是在非易失介质上存储文件的经典方法，用以在多次会话之间保持文件的内容。如Ext2/3/4， Reiserfs, FAT等。
（2）虚拟文件系统（Virtual Filesystem） 在内核中生成，是一种用户应用程序与内核通信的方法。如proc，它不许要在任何类的硬件设备上分配存储空间，所有的信息都是动态在内存中开辟和存储。
（3）网络文件系统（Network Filesystem） 是基于磁盘的文件系统和虚拟文件系统之间的折中。这种文件系统允许访问另一台计算机上的数据，该计算机通过网络连接到本地计算机。在这种情况下，数据实际上存储在一个不同系统的硬件设备上。
由于VFS抽象层的存在，用户空间进程不会看到本地文件系统与网络文件系统之间的区别。</p>
<ol>
  <li>VFS的模型与结构
VFS不仅为文件系统提供了方法和抽象，还支持文件系统中对象（或文件）的统一视图。并非每一种文件系统都支持VFS中的所有抽象，如FAT，因为其设计没有考虑到此类对象。定义一个最小的通用模型，来支持内核中所有文件系统都实现的那些功能，这是不实际的。因为这样会损失许多本质性的功能特性，或者导致这些特性只能通过特定文件系统的路径访问。
VFS的方案完全相反：提供一种结构模型，包含了一个强大文件系统所具备的所有组件。但该模型只存在于虚拟中，必须使用各种对象和函数指针与每种文件系统适配。所有文件系统的实现都必须提供与VFS定义的结构配合的例程，以弥合两种视图之间的差异。
VFS是由基于经典文件系统的结构衍化而来，所以VFS与Ext类文件系统类似，从而在处理Ext类文件系统的时候，Ext和VFS之间的转换，几乎不会损失时间。</li>
</ol>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/07/vfs.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/06/linux_rcu.html" class="post-title-link">
      <h2>linux_rcu</h2>
    </a>

    <div class="post-date">Dec 6, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>1:RCU使用在读者多而写者少的情况.RCU和读写锁相似.但RCU的读者占锁没有任何的系统开销.写者与写写者之间必须要保持同步,且写者必须要等它之前的读者全部都退出之后才能释放之前的资源.
2:RCU保护的是指针.这一点尤其重要.因为指针赋值是一条单指令.也就是说是一个原子操作.因它更改指针指向没必要考虑它的同步.只需要考虑cache的影响. 
3:读者是可以嵌套的.也就是说rcu_read_lock()可以嵌套调用. 
4:读者在持有rcu_read_lock()的时候,不能发生进程上下文切换.否则,因为写者需要要等待读者完成,写者进程也会一直被阻塞.</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/06/linux_rcu.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/06/linux_mmap.html" class="post-title-link">
      <h2>Linux的mmap内存映射机制</h2>
    </a>

    <div class="post-date">Dec 6, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>一个进程应该包括一个mm_struct(memory manage struct), 该结构是进程虚拟地址空间的抽象描述,里面包括了进程虚拟空间的一些管理信息: start_code, end_code, start_data, end_data, start_brk, end_brk等等信息.另外,也有一个指向进程虚存区表(vm_area_struct: virtual memory area)的指针,该链是按照虚拟地址的增长顺序排列的.在Linux进程的地址空间被分作许多区(vma),每个区(vma)都对应虚拟地址空间上一段连续的区域, vma是可以被共享和保护的独立实体,这里的vma就是前面提到的内存对象.</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/06/linux_mmap.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/06/linux_lock.html" class="post-title-link">
      <h2>linux_lock</h2>
    </a>

    <div class="post-date">Dec 6, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实象多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。在主流的Linux内核中包含了几乎所有现代的操作系统具有的同步机制，这些同步机制包括：原子操作、信号量（semaphore）、读写信号量（rw_semaphore）、spinlock、 BKL(Big Kernel Lock)、rwlock、brlock（只包含在2.4内核中）、RCU（只包含在2.6内核中）和seqlock（只包含在2.6内核中）。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/06/linux_lock.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/06/linux_elf.html" class="post-title-link">
      <h2>linux_elf</h2>
    </a>

    <div class="post-date">Dec 6, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>可执行连接格式是UNIX系统实验室(USL)作为应用程序二进制接口
(Application Binary Interface(ABI)而开发和发布的。工具接口标准委
员会(TIS)选择了正在发展中的ELF标准作为工作在32位INTEL体系上不同操
作系统之间可移植的二进制文件格式。
假定开发者定义了一个二进制接口集合，ELF标准用它来支持流线型的软件
发展。 应该减少不同执行接口的数量。因此可以减少重新编程重新编译的
代码。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/06/linux_elf.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/06/linux_cow.html" class="post-title-link">
      <h2>linux_cow</h2>
    </a>

    <div class="post-date">Dec 6, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/06/linux_cow.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>




  <div class="post">

    <a href="/MyBlog/linux/2017/12/05/linux_memory.html" class="post-title-link">
      <h2>linux_memory</h2>
    </a>

    <div class="post-date">Dec 5, 2017</div>
    
    <div class="post-body">
      
      <!-- more -->
<p>TLB(Translation Lookaside Buffer)转换检测缓冲区是一个内存管理单元,用于改进虚拟地址到物理地址转换速度的缓存。
TLB是一个小的，虚拟寻址的缓存，其中每一行都保存着一个由单个PTE(Page Table Entry,页表项)组成的块。如果没有TLB，则每次取数据都需要两次访问内存，即查页表获得物理地址和取数据。
当cpu要访问一个虚拟地址/线性地址时，CPU会首先根据虚拟地址的高20位（20是x86特定的，不同架构有不同的值）在TLB中查找。如果是表中没有相应的表项，称为TLB miss，需要通过访问慢速RAM中的页表计算出相应的物理地址。同时，物理地址被存放在一个TLB表项中，以后对同一线性地址的访问，直接从TLB表项中获取物理地址即可，称为TLB hit。
Linux把物理内存划分为三个层次来管理
存储节点(Node)	CPU被划分为多个节点(node), 内存则被分簇, 每个CPU对应一个本地物理内存, 即一个CPU-node对应一个内存簇bank，即每个内存簇被认为是一个节点
管理区(Zone)	每个物理内存节点node被划分为多个内存管理区域, 用于表示不同范围的内存, 内核可以使用不同的映射方式映射物理内存
页面(Page)	内存被细分为多个页面帧, 页面是最基本的页面分配的单位　
为了支持NUMA模型，也即CPU对不同内存单元的访问时间可能不同，此时系统的物理内存被划分为几个节点(node), 一个node对应一个内存簇bank，即每个内存簇被认为是一个节点</p>


    </div>

    <a class="read-more" href="/MyBlog/linux/2017/12/05/linux_memory.html">
       <span class="read-more-text" style="color:green; float: right;">阅读全文</span>
    </a>

</div>



                    </div>
					<hr>
            </div>

            <!-- Blog Sidebar Widgets Column -->
            <div class="col-md-4">

            	 <div class="well">
            	 	<span id='statics' ></span>
            	 </div>

                <!-- Blog Search Well -->
                <div class="well">
                    <h4>Search</h4>
                    <div class="input-group">
					<form action="#" id="cse-search-box">
					  <div>
					    <input type="hidden" name="cx" value="" />
					    <input type="hidden" name="ie" value="UTF-8" />
					    <!-- 搜索框 -->   
					    <input type="text" name="q" size="20" id='txt' />
					    <input type="submit" name="sa" value="Search" />
						<!-- 模糊查询结果显示框 -->
						<div id="msg"></div>
							<script type="text/javascript">  
							var searchIndex={
							"code" : 0 ,
							"data" : [
							
							{
							"title" : " - ",
							"url" : "/MyBlog/2018/05/01/2018-04-29-namespace.html"
							}
							
							,
							
							
							{
							"title" : "veth - ",
							"url" : "/MyBlog/linux/2018/04/29/veth.html"
							}
							
							,
							
							
							{
							"title" : "docker_net - ",
							"url" : "/MyBlog/linux/2018/04/29/docker_net.html"
							}
							
							,
							
							
							{
							"title" : "Docker容器通过独立IP暴露给局域网的方法 - ",
							"url" : "/MyBlog/linux/2018/04/29/docker_ip.html"
							}
							
							,
							
							
							{
							"title" : "linux cgroup - ",
							"url" : "/MyBlog/linux/2018/04/29/cgroup.html"
							}
							
							,
							
							
							{
							"title" : "bridge - ",
							"url" : "/MyBlog/linux/2018/04/29/bridge.html"
							}
							
							,
							
							
							{
							"title" : "flag - ",
							"url" : "/MyBlog/golang/2018/04/24/flag.html"
							}
							
							,
							
							
							{
							"title" : "expect - ",
							"url" : "/MyBlog/linux/2018/04/22/expect.html"
							}
							
							,
							
							
							{
							"title" : "站群 - ",
							"url" : "/MyBlog/web/2018/04/21/zq.html"
							}
							
							,
							
							
							{
							"title" : "urlencode - ",
							"url" : "/MyBlog/cryptology/2018/04/20/urlencode.html"
							}
							
							,
							
							
							{
							"title" : "shell 运行原理 & unix 缺陷 - ",
							"url" : "/MyBlog/jekyll/2018/04/20/shell.html"
							}
							
							,
							
							
							{
							"title" : "Linux下的shell工作原理 - ",
							"url" : "/MyBlog/linux/2018/04/20/linux_shell.html"
							}
							
							,
							
							
							{
							"title" : "base64 - ",
							"url" : "/MyBlog/cryptology/2018/04/20/base64.html"
							}
							
							,
							
							
							{
							"title" : "aes 的工作模式（ECB、CBC、CFB、OFB） - ",
							"url" : "/MyBlog/cryptology/2018/04/19/aes.html"
							}
							
							,
							
							
							{
							"title" : "json - ",
							"url" : "/MyBlog/golang/2018/04/16/json.html"
							}
							
							,
							
							
							{
							"title" : "dup dup2 - ",
							"url" : "/MyBlog/linux/2018/04/16/dup.html"
							}
							
							,
							
							
							{
							"title" : "Reactor and Proactor - ",
							"url" : "/MyBlog/web/2018/04/15/proactor.html"
							}
							
							,
							
							
							{
							"title" : "fsnotify bee 热编译 - ",
							"url" : "/MyBlog/golang/2018/04/15/fsnotify.html"
							}
							
							,
							
							
							{
							"title" : "Git内部原理 blob tree commit - ",
							"url" : "/MyBlog/computer/2018/04/12/git.html"
							}
							
							,
							
							
							{
							"title" : "rsync - ",
							"url" : "/MyBlog/linux/2018/03/27/rsync.html"
							}
							
							,
							
							
							{
							"title" : "intellij 配置 - ",
							"url" : "/MyBlog/golang/2018/03/27/intellij.html"
							}
							
							,
							
							
							{
							"title" : "context - ",
							"url" : "/MyBlog/golang/2018/03/27/context.html"
							}
							
							,
							
							
							{
							"title" : "golang热编译工具 - ",
							"url" : "/MyBlog/golang/2018/03/23/online_build.html"
							}
							
							,
							
							
							{
							"title" : "glide 包依赖管理 - ",
							"url" : "/MyBlog/golang/2018/03/23/glide.html"
							}
							
							,
							
							
							{
							"title" : "utxo 比特币查询原理 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/utxo.html"
							}
							
							,
							
							
							{
							"title" : "数字时间戳 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/timestamp.html"
							}
							
							,
							
							
							{
							"title" : "stratum协议原理 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/stratum.html"
							}
							
							,
							
							
							{
							"title" : "区块链共识机制 Pow、Pos、DPos、Pool - ",
							"url" : "/MyBlog/cryptology/2018/03/18/pow.html"
							}
							
							,
							
							
							{
							"title" : "PBFT（实用拜占庭容错）、PAXOS、RAFT - ",
							"url" : "/MyBlog/cryptology/2018/03/18/pbft.html"
							}
							
							,
							
							
							{
							"title" : "hamming 码校验 汉明距离 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/hamming_code.html"
							}
							
							,
							
							
							{
							"title" : "block chain 区块链 - ",
							"url" : "/MyBlog/cryptology/2018/03/18/block_chain.html"
							}
							
							,
							
							
							{
							"title" : "unsafe cgo - ",
							"url" : "/MyBlog/golang/2018/03/17/unsafe.html"
							}
							
							,
							
							
							{
							"title" : "数字签名及应用 - ",
							"url" : "/MyBlog/cryptology/2018/03/17/signature.html"
							}
							
							,
							
							
							{
							"title" : "reflect - ",
							"url" : "/MyBlog/golang/2018/03/17/reflect.html"
							}
							
							,
							
							
							{
							"title" : "go package - ",
							"url" : "/MyBlog/golang/2018/03/17/package.html"
							}
							
							,
							
							
							{
							"title" : "goroutine - ",
							"url" : "/MyBlog/golang/2018/03/17/goroutine.html"
							}
							
							,
							
							
							{
							"title" : "go test - ",
							"url" : "/MyBlog/golang/2018/03/17/go_test.html"
							}
							
							,
							
							
							{
							"title" : "进程和线程、协程的区别 - ",
							"url" : "/MyBlog/golang/2018/03/17/coroutine.html"
							}
							
							,
							
							
							{
							"title" : "golang 返回函数的匿名函数 vs 接收器的方法 - ",
							"url" : "/MyBlog/golang/2018/03/16/go_func.html"
							}
							
							,
							
							
							{
							"title" : "go-tour 安装 - ",
							"url" : "/MyBlog/golang/2018/03/16/go-tour.html"
							}
							
							,
							
							
							{
							"title" : "git默认不区分文件夹大小写 - ",
							"url" : "/MyBlog/computer/2018/03/16/git.html"
							}
							
							,
							
							
							{
							"title" : "栈与活动记录 - ",
							"url" : "/MyBlog/lang/2018/03/15/active_record.html"
							}
							
							,
							
							
							{
							"title" : "Lambda演算的类型 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_type.html"
							}
							
							,
							
							
							{
							"title" : "lambda 演算中的数字 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_num.html"
							}
							
							,
							
							
							{
							"title" : "Lambda演算建模 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_model.html"
							}
							
							,
							
							
							{
							"title" : "lambda 演算中的布尔值和选择 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_bool.html"
							}
							
							,
							
							
							{
							"title" : "lambda Y组合子(y-combinator) - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_Y.html"
							}
							
							,
							
							
							{
							"title" : "lambda_Evaluation - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_Evaluation.html"
							}
							
							,
							
							
							{
							"title" : "从Lambda演算到组合子演算 - ",
							"url" : "/MyBlog/lang/2018/03/14/lambda_Combinator.html"
							}
							
							,
							
							
							{
							"title" : "Lambda 演算 - ",
							"url" : "/MyBlog/lang/2018/03/14/Lambda.html"
							}
							
							,
							
							
							{
							"title" : "系统调用 - ",
							"url" : "/MyBlog/linux/2018/03/13/system_call.html"
							}
							
							,
							
							
							{
							"title" : "mysql 分页 - ",
							"url" : "/MyBlog/web/2018/03/13/page.html"
							}
							
							,
							
							
							{
							"title" : "尾递归优化 - ",
							"url" : "/MyBlog/lang/2018/03/12/tco.html"
							}
							
							,
							
							
							{
							"title" : "三地址代码 - ",
							"url" : "/MyBlog/lang/2018/03/09/three-address-code.html"
							}
							
							,
							
							
							{
							"title" : "栈机 - ",
							"url" : "/MyBlog/lang/2018/03/09/Stack_machine.html"
							}
							
							,
							
							
							{
							"title" : "下推自动机 - ",
							"url" : "/MyBlog/lang/2018/03/08/pda.html"
							}
							
							,
							
							
							{
							"title" : "LR分析法 - ",
							"url" : "/MyBlog/lang/2018/03/08/lr.html"
							}
							
							,
							
							
							{
							"title" : "LL(1)文法判别之First集合、Follow集合、Select集合求法 - ",
							"url" : "/MyBlog/lang/2018/03/07/first_follow_select.html"
							}
							
							,
							
							
							{
							"title" : "thrift - ",
							"url" : "/MyBlog/lang/2018/03/02/thrift.html"
							}
							
							,
							
							
							{
							"title" : "thrift 低版本安装 - ",
							"url" : "/MyBlog/web/2018/03/01/thrift_low.html"
							}
							
							,
							
							
							{
							"title" : "jekyll paginate 分页失败原因 - ",
							"url" : "/MyBlog/jekyll/2018/03/01/paginate.html"
							}
							
							,
							
							
							{
							"title" : "git add 删除文件问题 - ",
							"url" : "/MyBlog/web/2018/03/01/git.html"
							}
							
							,
							
							
							{
							"title" : "symbol_table - ",
							"url" : "/MyBlog/lang/2018/02/28/symbol_table.html"
							}
							
							,
							
							
							{
							"title" : "re2c - ",
							"url" : "/MyBlog/lang/2018/02/28/re2c.html"
							}
							
							,
							
							
							{
							"title" : "Jekyll目录结构和运行机理 - ",
							"url" : "/MyBlog/jekyll/2018/02/28/jekyll_inside.html"
							}
							
							,
							
							
							{
							"title" : "CollectingCycles - ",
							"url" : "/MyBlog/lang/2018/02/28/CollectingCycles.html"
							}
							
							,
							
							
							{
							"title" : "type_hinting - ",
							"url" : "/MyBlog/web/2018/02/26/type_hinting.html"
							}
							
							,
							
							
							{
							"title" : "tsrm - ",
							"url" : "/MyBlog/web/2018/02/26/tsrm.html"
							}
							
							,
							
							
							{
							"title" : "create_function - ",
							"url" : "/MyBlog/web/2018/02/26/create_function.html"
							}
							
							,
							
							
							{
							"title" : "Xdebug - ",
							"url" : "/MyBlog/web/2018/02/26/Xdebug.html"
							}
							
							,
							
							
							{
							"title" : "Closure - ",
							"url" : "/MyBlog/lang/2018/02/26/Closure.html"
							}
							
							,
							
							
							{
							"title" : "lex - ",
							"url" : "/MyBlog/lang/2018/02/13/lex.html"
							}
							
							,
							
							
							{
							"title" : "vld_dot_graphviz - ",
							"url" : "/MyBlog/web/2018/02/12/vld_dot_graphviz.html"
							}
							
							,
							
							
							{
							"title" : "phpvld - ",
							"url" : "/MyBlog/jekyll/2018/02/12/phpvld.html"
							}
							
							,
							
							
							{
							"title" : "phpize - ",
							"url" : "/MyBlog/web/2018/02/12/phpize.html"
							}
							
							,
							
							
							{
							"title" : "PHP 调试利器之 PHPDBG - ",
							"url" : "/MyBlog/web/2018/02/12/phpdbg.html"
							}
							
							,
							
							
							{
							"title" : "dot - ",
							"url" : "/MyBlog/web/2018/02/12/dot.html"
							}
							
							,
							
							
							{
							"title" : "netty - ",
							"url" : "/MyBlog/web/2018/02/10/netty.html"
							}
							
							,
							
							
							{
							"title" : "Tachyon - ",
							"url" : "/MyBlog/spark/2018/02/10/Tachyon.html"
							}
							
							,
							
							
							{
							"title" : "crlf 攻击 - ",
							"url" : "/MyBlog/web/2018/02/06/crlf.html"
							}
							
							,
							
							
							{
							"title" : "iputils - ",
							"url" : "/MyBlog/linux/2018/02/05/iputils.html"
							}
							
							,
							
							
							{
							"title" : "cscope - ",
							"url" : "/MyBlog/web/2018/02/05/cscope.html"
							}
							
							,
							
							
							{
							"title" : "sklearn - ",
							"url" : "/MyBlog/spark/2018/02/03/sklearn.html"
							}
							
							,
							
							
							{
							"title" : "mathlatex - ",
							"url" : "/MyBlog/web/2018/02/02/mathlatex.html"
							}
							
							,
							
							
							{
							"title" : "二项逻辑斯蒂回归模型 - ",
							"url" : "/MyBlog/spark/2018/02/02/logistic.html"
							}
							
							,
							
							
							{
							"title" : "Duck typing - ",
							"url" : "/MyBlog/web/2018/02/02/Duck_typing.html"
							}
							
							,
							
							
							{
							"title" : "导入第三方依赖到shell - ",
							"url" : "/MyBlog/spark/2018/01/27/spark_jar.html"
							}
							
							,
							
							
							{
							"title" : "zero copy - ",
							"url" : "/MyBlog/linux/2018/01/26/zero_copy.html"
							}
							
							,
							
							
							{
							"title" : "进程在后台运行原理 - ",
							"url" : "/MyBlog/linux/2018/01/24/nohup.html"
							}
							
							,
							
							
							{
							"title" : "mongodb - ",
							"url" : "/MyBlog/web/2018/01/24/mongodb.html"
							}
							
							,
							
							
							{
							"title" : "倒排索引 - ",
							"url" : "/MyBlog/web/2018/01/24/inverted_file.html"
							}
							
							,
							
							
							{
							"title" : "npm registry - ",
							"url" : "/MyBlog/web/2018/01/16/npm.html"
							}
							
							,
							
							
							{
							"title" : "制作地图 - ",
							"url" : "/MyBlog/web/2018/01/16/map.html"
							}
							
							,
							
							
							{
							"title" : "Linux、Mac上面ln命令使用说明 - ",
							"url" : "/MyBlog/linux/2018/01/16/ln.html"
							}
							
							,
							
							
							{
							"title" : "spark on hive - ",
							"url" : "/MyBlog/spark/2018/01/13/spark_hive.html"
							}
							
							,
							
							
							{
							"title" : "scala maven 版本冲突问题解决 - ",
							"url" : "/MyBlog/spark/2018/01/12/scala_version.html"
							}
							
							,
							
							
							{
							"title" : "Eclipse中操作Hive、HDFS、spark时的jar包列表 - ",
							"url" : "/MyBlog/spark/2018/01/12/hive.html"
							}
							
							,
							
							
							{
							"title" : "Eclipse+maven+scala+spark环境搭建 - ",
							"url" : "/MyBlog/spark/2018/01/11/maven_scala_eclipse.html"
							}
							
							,
							
							
							{
							"title" : "maven - ",
							"url" : "/MyBlog/spark/2018/01/11/maven.html"
							}
							
							,
							
							
							{
							"title" : "随机森林 - ",
							"url" : "/MyBlog/spark/2018/01/09/random_foreast.html"
							}
							
							,
							
							
							{
							"title" : "svm - ",
							"url" : "/MyBlog/spark/2018/01/08/svm.html"
							}
							
							,
							
							
							{
							"title" : "virtualenv - ",
							"url" : "/MyBlog/web/2018/01/07/virtualenv.html"
							}
							
							,
							
							
							{
							"title" : "pip - ",
							"url" : "/MyBlog/web/2018/01/07/pip.html"
							}
							
							,
							
							
							{
							"title" : "信息熵 - ",
							"url" : "/MyBlog/spark/2018/01/05/shang.html"
							}
							
							,
							
							
							{
							"title" : "Zookeeper与Paxos - ",
							"url" : "/MyBlog/spark/2018/01/04/zookeeper.html"
							}
							
							,
							
							
							{
							"title" : "安全散列算法SHA256 - ",
							"url" : "/MyBlog/cryptology/2018/01/04/sha.html"
							}
							
							,
							
							
							{
							"title" : "raft - ",
							"url" : "/MyBlog/jekyll/2018/01/04/raft.html"
							}
							
							,
							
							
							{
							"title" : "比较raft ，basic paxos以及multi-paxos - ",
							"url" : "/MyBlog/spark/2018/01/04/paxos_raft.html"
							}
							
							,
							
							
							{
							"title" : "p2p - ",
							"url" : "/MyBlog/web/2018/01/04/p2p.html"
							}
							
							,
							
							
							{
							"title" : "nat - ",
							"url" : "/MyBlog/web/2018/01/04/nat.html"
							}
							
							,
							
							
							{
							"title" : "Chubby与Paxos - ",
							"url" : "/MyBlog/spark/2018/01/04/chubby.html"
							}
							
							,
							
							
							{
							"title" : "Paxos - ",
							"url" : "/MyBlog/spark/2018/01/04/Paxos.html"
							}
							
							,
							
							
							{
							"title" : "rsa 非对称加密原理 - ",
							"url" : "/MyBlog/cryptology/2018/01/03/rsa.html"
							}
							
							,
							
							
							{
							"title" : "Merkle Patricia Tree - ",
							"url" : "/MyBlog/cryptology/2018/01/03/merkle_tree.html"
							}
							
							,
							
							
							{
							"title" : "ecc 椭圆曲线加密 - ",
							"url" : "/MyBlog/cryptology/2018/01/03/ecc.html"
							}
							
							,
							
							
							{
							"title" : "单播、多播和广播 - ",
							"url" : "/MyBlog/linux/2017/12/30/broad_cast.html"
							}
							
							,
							
							
							{
							"title" : "arp - ",
							"url" : "/MyBlog/linux/2017/12/30/arp.html"
							}
							
							,
							
							
							{
							"title" : "json_shell - ",
							"url" : "/MyBlog/web/2017/12/27/json_shell.html"
							}
							
							,
							
							
							{
							"title" : "ioctl - ",
							"url" : "/MyBlog/linux/2017/12/27/ioctl.html"
							}
							
							,
							
							
							{
							"title" : "inetd - ",
							"url" : "/MyBlog/linux/2017/12/27/inetd.html"
							}
							
							,
							
							
							{
							"title" : "Django_nginx_uwsgi - ",
							"url" : "/MyBlog/web/2017/12/27/Django_nginx_uwsgi.html"
							}
							
							,
							
							
							{
							"title" : "UNIX下的5种IO模型 - ",
							"url" : "/MyBlog/linux/2017/12/24/unix_io5.html"
							}
							
							,
							
							
							{
							"title" : "用户空间实现线程 内核实现线程 线程的调度 - ",
							"url" : "/MyBlog/linux/2017/12/24/thread_namespace.html"
							}
							
							,
							
							
							{
							"title" : "进程切换 - ",
							"url" : "/MyBlog/linux/2017/12/24/thread.html"
							}
							
							,
							
							
							{
							"title" : "IO多路复用之select、poll、epoll - ",
							"url" : "/MyBlog/linux/2017/12/24/select_poll.html"
							}
							
							,
							
							
							{
							"title" : "goroutine - ",
							"url" : "/MyBlog/linux/2017/12/24/goroutine.html"
							}
							
							,
							
							
							{
							"title" : "goclipse eclipse go 开发环境搭建＋跳转支持 - ",
							"url" : "/MyBlog/web/2017/12/24/goclipse.html"
							}
							
							,
							
							
							{
							"title" : "tcp_flag - ",
							"url" : "/MyBlog/web/2017/12/22/tcp_flag.html"
							}
							
							,
							
							
							{
							"title" : "url短链 - ",
							"url" : "/MyBlog/web/2017/12/22/short_url.html"
							}
							
							,
							
							
							{
							"title" : "ID为0和ID为1的进程 - ",
							"url" : "/MyBlog/linux/2017/12/22/pid_0_1.html"
							}
							
							,
							
							
							{
							"title" : "Shell脚本经典之Fork炸弹 - ",
							"url" : "/MyBlog/linux/2017/12/22/fork_b.html"
							}
							
							,
							
							
							{
							"title" : "fork - ",
							"url" : "/MyBlog/linux/2017/12/22/fork.html"
							}
							
							,
							
							
							{
							"title" : "Linux进程控制——exec函数族 - ",
							"url" : "/MyBlog/linux/2017/12/22/exec.html"
							}
							
							,
							
							
							{
							"title" : "各种树的应用场景 - ",
							"url" : "/MyBlog/web/2017/12/13/tree.html"
							}
							
							,
							
							
							{
							"title" : "sbt - ",
							"url" : "/MyBlog/spark/2017/12/13/sbt.html"
							}
							
							,
							
							
							{
							"title" : "radix tree - ",
							"url" : "/MyBlog/linux/2017/12/13/radix_tree.html"
							}
							
							,
							
							
							{
							"title" : "maven 安装 - ",
							"url" : "/MyBlog/spark/2017/12/13/maven.html"
							}
							
							,
							
							
							{
							"title" : "figaro mac 安装 - ",
							"url" : "/MyBlog/spark/2017/12/13/figaro.html"
							}
							
							,
							
							
							{
							"title" : "大端小端 - ",
							"url" : "/MyBlog/web/2017/12/13/bigEnd.html"
							}
							
							,
							
							
							{
							"title" : "truss、strace或ltrace - ",
							"url" : "/MyBlog/linux/2017/12/10/strace.html"
							}
							
							,
							
							
							{
							"title" : "netlink - ",
							"url" : "/MyBlog/linux/2017/12/10/netlink.html"
							}
							
							,
							
							
							{
							"title" : "linux sysfs - ",
							"url" : "/MyBlog/linux/2017/12/09/sysfs.html"
							}
							
							,
							
							
							{
							"title" : "proc文件系统 - ",
							"url" : "/MyBlog/linux/2017/12/09/proc.html"
							}
							
							,
							
							
							{
							"title" : "netfliter - ",
							"url" : "/MyBlog/jekyll/2017/12/09/netfliter.html"
							}
							
							,
							
							
							{
							"title" : "namespace - ",
							"url" : "/MyBlog/linux/2017/12/08/namespace.html"
							}
							
							,
							
							
							{
							"title" : "vfs - ",
							"url" : "/MyBlog/linux/2017/12/07/vfs.html"
							}
							
							,
							
							
							{
							"title" : "mysql_index - ",
							"url" : "/MyBlog/web/2017/12/07/mysql_index.html"
							}
							
							,
							
							
							{
							"title" : "linux_rcu - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_rcu.html"
							}
							
							,
							
							
							{
							"title" : "Linux的mmap内存映射机制 - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_mmap.html"
							}
							
							,
							
							
							{
							"title" : "linux_lock - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_lock.html"
							}
							
							,
							
							
							{
							"title" : "linux_elf - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_elf.html"
							}
							
							,
							
							
							{
							"title" : "linux_cow - ",
							"url" : "/MyBlog/linux/2017/12/06/linux_cow.html"
							}
							
							,
							
							
							{
							"title" : "Kibana - ",
							"url" : "/MyBlog/spark/2017/12/06/Kibana.html"
							}
							
							,
							
							
							{
							"title" : "linux_memory - ",
							"url" : "/MyBlog/linux/2017/12/05/linux_memory.html"
							}
							
							,
							
							
							{
							"title" : "server格式 - ",
							"url" : "/MyBlog/web/2017/12/02/server_tyrp.html"
							}
							
							,
							
							
							{
							"title" : "nginx_ssi - ",
							"url" : "/MyBlog/web/2017/12/02/nginx_ssi.html"
							}
							
							,
							
							
							{
							"title" : "go升级遇到问题及解决方案 - ",
							"url" : "/MyBlog/web/2017/11/29/go_update.html"
							}
							
							,
							
							
							{
							"title" : "go_pprof - ",
							"url" : "/MyBlog/web/2017/11/29/go_pprof.html"
							}
							
							,
							
							
							{
							"title" : "go_vs_code - ",
							"url" : "/MyBlog/web/2017/11/28/go_vs_code.html"
							}
							
							,
							
							
							{
							"title" : "scala tuple - ",
							"url" : "/MyBlog/spark/2017/11/19/scala_tuple.html"
							}
							
							,
							
							
							{
							"title" : "redis协议 - ",
							"url" : "/MyBlog/web/2017/11/18/redis_protocal.html"
							}
							
							,
							
							
							{
							"title" : "jupyter 数学公式 - ",
							"url" : "/MyBlog/spark/2017/11/18/jupyter_math.html"
							}
							
							,
							
							
							{
							"title" : "jupyter 数学公式 - ",
							"url" : "/MyBlog/spark/2017/11/18/jupyter_latex.html"
							}
							
							,
							
							
							{
							"title" : "Jupyter Notebook 添加目录 - ",
							"url" : "/MyBlog/spark/2017/11/18/jupyter_index.html"
							}
							
							,
							
							
							{
							"title" : "文字特征提取算法 - ",
							"url" : "/MyBlog/spark/2017/11/17/word_feature.html"
							}
							
							,
							
							
							{
							"title" : "sparl_ml_pipline - ",
							"url" : "/MyBlog/spark/2017/11/16/sparl_ml_pipline.html"
							}
							
							,
							
							
							{
							"title" : "mysql 的排序 - ",
							"url" : "/MyBlog/web/2017/11/16/mysql_sort.html"
							}
							
							,
							
							
							{
							"title" : "mysql_maneager - ",
							"url" : "/MyBlog/web/2017/11/16/mysql_maneager.html"
							}
							
							,
							
							
							{
							"title" : "mysql_index - ",
							"url" : "/MyBlog/web/2017/11/16/mysql_index.html"
							}
							
							,
							
							
							{
							"title" : "MySQL的表类型的（存储引擎） - ",
							"url" : "/MyBlog/web/2017/11/16/mysql_engine.html"
							}
							
							,
							
							
							{
							"title" : "mysql 原理 - ",
							"url" : "/MyBlog/web/2017/11/16/mysql.html"
							}
							
							,
							
							
							{
							"title" : "spark_memory - ",
							"url" : "/MyBlog/spark/2017/11/15/spark_memory.html"
							}
							
							,
							
							
							{
							"title" : "redis 持久化 - ",
							"url" : "/MyBlog/web/2017/11/15/redis_forever.html"
							}
							
							,
							
							
							{
							"title" : "spark toDF 失败原因总结 - ",
							"url" : "/MyBlog/spark/2017/11/14/spark_toDF.html"
							}
							
							,
							
							
							{
							"title" : "spark_start问题原因及解决办法 - ",
							"url" : "/MyBlog/spark/2017/11/14/spark_start.html"
							}
							
							,
							
							
							{
							"title" : "spark_rdd创建转换 - ",
							"url" : "/MyBlog/spark/2017/11/14/spark_rdd.html"
							}
							
							,
							
							
							{
							"title" : "spark的ML和MLLib两个包区别和联系 - ",
							"url" : "/MyBlog/spark/2017/11/14/spark_ml_mllib.html"
							}
							
							,
							
							
							{
							"title" : "RDD/Dataset/DataFrame互转 - ",
							"url" : "/MyBlog/spark/2017/11/14/rdd_dataset_dataframe.html"
							}
							
							,
							
							
							{
							"title" : "dataSet和dataFrame的创建方法 - ",
							"url" : "/MyBlog/spark/2017/11/14/dataSet_dataFrame.html"
							}
							
							,
							
							
							{
							"title" : "php_session - ",
							"url" : "/MyBlog/web/2017/11/09/php_session.html"
							}
							
							,
							
							
							{
							"title" : "jupyter_matplotlib - ",
							"url" : "/MyBlog/web/2017/11/09/jupyter_matplotlib.html"
							}
							
							,
							
							
							{
							"title" : "Jupyter_slides - ",
							"url" : "/MyBlog/web/2017/11/09/Jupyter_slides.html"
							}
							
							,
							
							
							{
							"title" : "composer - ",
							"url" : "/MyBlog/web/2017/11/03/composer.html"
							}
							
							,
							
							
							{
							"title" : "scala_partion_function - ",
							"url" : "/MyBlog/spark/2017/10/24/scala_partion_function.html"
							}
							
							,
							
							
							{
							"title" : "partion_function - ",
							"url" : "/MyBlog/web/2017/10/24/partion_function.html"
							}
							
							,
							
							
							{
							"title" : "高阶函数函数加里化(Currying)和偏函数应用(Partial Application)的比较 - ",
							"url" : "/MyBlog/web/2017/10/24/function.html"
							}
							
							,
							
							
							{
							"title" : "使用Phabricator做为Code Review工具 - ",
							"url" : "/MyBlog/web/2017/10/24/Phabricator.html"
							}
							
							,
							
							
							{
							"title" : "cut - ",
							"url" : "/MyBlog/spark/2017/10/23/cut.html"
							}
							
							,
							
							
							{
							"title" : "akka_sbt_eclipse - ",
							"url" : "/MyBlog/spark/2017/10/18/akka_sbt_eclipse.html"
							}
							
							,
							
							
							{
							"title" : "FunSuite - ",
							"url" : "/MyBlog/spark/2017/10/18/FunSuite.html"
							}
							
							,
							
							
							{
							"title" : "spark基本概念 - ",
							"url" : "/MyBlog/spark/2017/10/13/spark_concepts.html"
							}
							
							,
							
							
							{
							"title" : "Actor模型原理 - ",
							"url" : "/MyBlog/spark/2017/10/13/actor_intro.html"
							}
							
							,
							
							
							{
							"title" : "Actor系统的实体 - ",
							"url" : "/MyBlog/spark/2017/10/13/actor_detail.html"
							}
							
							,
							
							
							{
							"title" : "Actor模型和CSP模型的区别 - ",
							"url" : "/MyBlog/spark/2017/10/13/actor_csp.html"
							}
							
							,
							
							
							{
							"title" : "java_scala - ",
							"url" : "/MyBlog/spark/2017/10/12/java_scala.html"
							}
							
							,
							
							
							{
							"title" : "Scala_collection - ",
							"url" : "/MyBlog/spark/2017/10/12/Scala_collection.html"
							}
							
							,
							
							
							{
							"title" : "scala_list - ",
							"url" : "/MyBlog/spark/2017/10/11/scala_list.html"
							}
							
							,
							
							
							{
							"title" : "spark-session-context - ",
							"url" : "/MyBlog/spark/2017/10/06/spark-session-context.html"
							}
							
							,
							
							
							{
							"title" : "scala_main_class - ",
							"url" : "/MyBlog/spark/2017/09/29/scala_main_class.html"
							}
							
							,
							
							
							{
							"title" : "alibaba_fast_json - ",
							"url" : "/MyBlog/spark/2017/09/29/alibaba_fast_json.html"
							}
							
							,
							
							
							{
							"title" : "gorpc - ",
							"url" : "/MyBlog/jekyll/2017/09/25/gorpc.html"
							}
							
							,
							
							
							{
							"title" : "spark-kafka - ",
							"url" : "/MyBlog/spark/2017/09/22/spark-kafka.html"
							}
							
							,
							
							
							{
							"title" : "mysqldump - ",
							"url" : "/MyBlog/web/2017/09/20/mysqldump.html"
							}
							
							,
							
							
							{
							"title" : "mysql-time - ",
							"url" : "/MyBlog/jekyll/2017/09/20/mysql-time.html"
							}
							
							,
							
							
							{
							"title" : "mac 安装 sshfs - ",
							"url" : "/MyBlog/jekyll/2017/09/18/sshfs.html"
							}
							
							,
							
							
							{
							"title" : "jupyter - ",
							"url" : "/MyBlog/deep_learning/2017/09/17/jupyter.html"
							}
							
							,
							
							
							{
							"title" : "deep_learning - ",
							"url" : "/MyBlog/deep_learning/2017/09/17/deep_learning.html"
							}
							
							,
							
							
							{
							"title" : "spark-rdd - spark",
							"url" : "/MyBlog/spark/2017/09/15/spark-rdd.html"
							}
							
							,
							
							
							{
							"title" : "netcat - ",
							"url" : "/MyBlog/jekyll/2017/09/15/netcat.html"
							}
							
							,
							
							
							{
							"title" : "markdown-table - ",
							"url" : "/MyBlog/jekyll/2017/09/15/markdown-table.html"
							}
							
							,
							
							
							{
							"title" : "books-sites - ",
							"url" : "/MyBlog/jekyll/2017/09/15/books-sites.html"
							}
							
							,
							
							
							{
							"title" : "脚本输出带颜色文字 - ",
							"url" : "/MyBlog/jekyll/2017/09/14/%E8%84%9A%E6%9C%AC%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E6%96%87%E5%AD%97.html"
							}
							
							,
							
							
							{
							"title" : "常见SSL证书格式转换 - ",
							"url" : "/MyBlog/jekyll/2017/09/13/%E5%B8%B8%E8%A7%81SSL%E8%AF%81%E4%B9%A6%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2.html"
							}
							
							,
							
							
							{
							"title" : "php-curl-ext - ",
							"url" : "/MyBlog/jekyll/2017/09/13/php-curl-ext.html"
							}
							
							,
							
							
							{
							"title" : "curl-https-php - ",
							"url" : "/MyBlog/jekyll/2017/09/13/curl-https-php.html"
							}
							
							,
							
							
							{
							"title" : "php-spider - ",
							"url" : "/MyBlog/jekyll/2017/09/12/php-spider.html"
							}
							
							,
							
							
							{
							"title" : "php怎么判断函数，类，类方法是不是存在 - ",
							"url" : "/MyBlog/jekyll/2017/09/12/php-function.html"
							}
							
							,
							
							
							{
							"title" : "composer-source - ",
							"url" : "/MyBlog/jekyll/2017/09/12/composer-source.html"
							}
							
							,
							
							
							{
							"title" : "php-doc - ",
							"url" : "/MyBlog/jekyll/2017/09/11/php-doc.html"
							}
							
							,
							
							
							{
							"title" : "oauth-github-api - ",
							"url" : "/MyBlog/jekyll/2017/09/10/oauth-github-api.html"
							}
							
							,
							
							
							{
							"title" : "http-head 四种常见的 POST 提交数据方式 - ",
							"url" : "/MyBlog/jekyll/2017/09/10/http-head.html"
							}
							
							,
							
							
							{
							"title" : "javascript 实现客户端访问次数统计 - ",
							"url" : "/MyBlog/jekyll/2017/09/09/statics.html"
							}
							
							,
							
							
							{
							"title" : "JavaScript实现模糊匹配搜索 - ",
							"url" : "/MyBlog/jekyll/2017/09/09/search_match.html"
							}
							
							,
							
							
							{
							"title" : "search - ",
							"url" : "/MyBlog/jekyll/2017/09/09/search.html"
							}
							
							,
							
							
							{
							"title" : "robots - ",
							"url" : "/MyBlog/jekyll/2017/09/09/robots.html"
							}
							
							,
							
							
							{
							"title" : "oauth-github - ",
							"url" : "/MyBlog/jekyll/2017/09/09/oauth-github.html"
							}
							
							,
							
							
							{
							"title" : "github-openapi - ",
							"url" : "/MyBlog/jekyll/2017/09/09/github-openapi.html"
							}
							
							,
							
							
							{
							"title" : "github-api - ",
							"url" : "/MyBlog/jekyll/2017/09/09/github-api.html"
							}
							
							,
							
							
							{
							"title" : "Authorization-ajax - ",
							"url" : "/MyBlog/jekyll/2017/09/09/Authorization-ajax.html"
							}
							
							,
							
							
							{
							"title" : "自动化替换网站引用资源到本地工具 - ",
							"url" : "/MyBlog/jekyll/2017/09/08/replace-url.html"
							}
							
							,
							
							
							{
							"title" : "pygments - ",
							"url" : "/MyBlog/jekyll/2017/09/08/pygments.html"
							}
							
							,
							
							
							{
							"title" : "markdown - ",
							"url" : "/MyBlog/markdown/2017/09/07/markdown.html"
							}
							
							,
							
							
							{
							"title" : "mac-sed - ",
							"url" : "/MyBlog/jekyll/2017/09/07/mac-sed.html"
							}
							
							,
							
							
							{
							"title" : "jekyll config - ",
							"url" : "/MyBlog/jekyll/2017/09/07/jeky-env.html"
							}
							
							,
							
							
							{
							"title" : "comment - ",
							"url" : "/MyBlog/jekyll/2017/09/07/comment.html"
							}
							
							,
							
							
							{
							"title" : "Welcome to xiazemin's blog! - ",
							"url" : "/MyBlog/update/2017/09/05/welcome-to-jekyll.html"
							}
							
							,
							
							
							{
							"title" : "nginx lua - octopress_jekyll",
							"url" : "/MyBlog/web/2017/08/05/nginx-lua.html"
							}
							
							,
							
							
							{
							"title" : "jekyll layout - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-layout.html"
							}
							
							,
							
							
							{
							"title" : "jekyll dir - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-dir.html"
							}
							
							,
							
							
							{
							"title" : "jekyll macdown使用 - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-usage.html"
							}
							
							,
							
							
							{
							"title" : "jekyll 分页 - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-page.html"
							}
							
							,
							
							
							{
							"title" : "jekyll mac 安装 - octopress_jekyll",
							"url" : "/MyBlog/jekyll/2017/08/05/jekyll-mac-install.html"
							}
							
							,
							
							
							{
							"title" : "Eleventh post - css_html",
							"url" : "/MyBlog/technology/2016/02/11/eleventh.html"
							}
							
							,
							
							
							{
							"title" : "Tenth post - css_html",
							"url" : "/MyBlog/technology/2016/02/09/tenth.html"
							}
							
							,
							
							
							{
							"title" : "second post - holiday",
							"url" : "/MyBlog/technology/computer/news/2016/02/02/second-post.html"
							}
							
							,
							
							
							{
							"title" : "first post - css_html_hosting_openshift_wordpress",
							"url" : "/MyBlog/jekyll/technology/2016/02/01/first-post.html"
							}
							
							
							]
							};
							function handle(){  
							var word = document.getElementById('txt').value;
							var value = "";
							var data=searchIndex.data;
							for(var i = 0;i < data.length;i++){
							if(word!="" && data[i].title.match(".*"+word+".*") != null){
							value += "<a onclick=add('"+ data[i].title +"') href='"+ data[i]. url +"'>" + data[i].title + "</a><br/>";
							}
							}       
							document.getElementById('msg').innerHTML=value;
							  if(typeof(document.getElementById('msg').children[0])!="undefined"){
								document.getElementById('cse-search-box').action=document.getElementById('msg').children[0].href;
					
							   }
							} 
							function add(city){
							document.getElementById('txt').value=city;
							}
							//firefox下检测状态改变只能用oninput,且需要用addEventListener来注册事件。   
							if(/msie/i.test(navigator.userAgent))    //ie浏览器   
							{document.getElementById('txt').onpropertychange=handle   
							} else{//非ie浏览器，比如Firefox   
							document.getElementById('txt').addEventListener("input",handle,false);   
							}
						 </script> 
					  </div>
					</form>
					<!--script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script-->
				</div>
            </div>

            <!-- time -->
                    <div id="myTime" class="well">
                            <object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="/MyBlog/flash/swflash.cab" style="margin: 0;padding: 0;height: auto;width:auto;">
                                <param name="allowScriptAccess" value="always">
                                <param name="movie" value="/MyBlog/flash/honehone_clock_wh.swf">
                                <param name="quality" value="high">
                                <param name="bgcolor" value="transparent">
                                <param name="wmode" value="transparent">
                                <embed wmode="transparent" src="/MyBlog/flash/honehone_clock_wh.swf" quality="high" name="honehoneclock" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer"  style="margin: 0;padding: 0;border: 0 ;height: auto;width:100%;">
                            </object>
                    </div>
                <!-- Blog Categories Well -->
                <div class="well">
                    <h4>Blog Categories</h4>
                    <div class="row">
                        <div class="col-lg-6">
								
								
								
								
									<a class="bold" href="/MyBlog/category/jekyll">
										jekyll (41)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/technology">
										technology (4)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/computer">
										computer (3)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/news">
										news (1)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/web">
										web (55)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/update">
										update (1)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/markdown">
										markdown (1)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/spark">
										spark (49)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/deep-learning">
										deep_learning (2)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/linux">
										linux (40)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/cryptology">
										cryptology (15)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/lang">
										lang (21)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
								
								
								
									<a class="bold" href="/MyBlog/category/golang">
										golang (15)
									</a>
                        </div>
                        <div class="col-lg-6">
                        	
                        </div>
                    </div>
                    <!-- /.row -->
                </div>
                <!-- Side Widget Well -->

                <!-- Side Widget Well -->
                <div class="well">
                	<h4>Recent posts</h4>
                		<ul class="posts" span="recent"> 
							  
							   <li>  
								   <span>01 May 2018</span>
								   <a href="/MyBlog//2018/05/01/2018-04-29-namespace.html">  
								   </a>  
							   </li>  
							  
							   <li>  
								   <span>29 Apr 2018</span>
								   <a href="/MyBlog//linux/2018/04/29/veth.html">  
								   veth</a>  
							   </li>  
							  
							   <li>  
								   <span>29 Apr 2018</span>
								   <a href="/MyBlog//linux/2018/04/29/docker_net.html">  
								   docker_net</a>  
							   </li>  
							  
							   <li>  
								   <span>29 Apr 2018</span>
								   <a href="/MyBlog//linux/2018/04/29/docker_ip.html">  
								   Docker容器通过独立IP暴露给局域网的方法</a>  
							   </li>  
							  
							   <li>  
								   <span>29 Apr 2018</span>
								   <a href="/MyBlog//linux/2018/04/29/cgroup.html">  
								   linux cgroup</a>  
							   </li>  
							  
						</ul>
                </div>
                <!-- Side Widget Well -->
                <div class="well">
                    <h4>Tags</h4>
                        <ul>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/css">
                                    css (3)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/html">
                                    html (3)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/hosting">
                                    hosting (1)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/openshift">
                                    openshift (1)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/wordpress">
                                    wordpress (1)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/holiday">
                                    holiday (1)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/octopress">
                                    octopress (6)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/jekyll">
                                    jekyll (6)
                                </a>
                            
                            
                            
                            
                                <a class="tag-label bold" href="/MyBlog/tag/spark">
                                    spark (1)
                                </a>
                            
                        </ul>
                </div>
                <div class="well">
                    <h4>This blog is maintained by <a href="＃">夏泽民</a></h4>
                    <p>Get in touch with me at 465474307@qq.com</p>
					<ul class="list-inline">
                            <li>
								<a href="＃">
									<span class="fa-stack fa-2x">
									  <i class="fa fa-circle fa-stack-2x"></i>
									  <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
									</span>
								</a>
                            </li>
                            <li>
								<a href="#">
									<span class="fa-stack fa-2x">
									  <i class="fa fa-circle fa-stack-2x"></i>
									  <i class="fa fa-globe fa-stack-1x fa-inverse"></i>
									</span>
								</a>
                            </li>
                            <li>
								<a href="mailto:465474307@qq.com">
									<span class="fa-stack fa-2x">
									  <i class="fa fa-circle fa-stack-2x"></i>
									  <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
									</span>
								</a>
                            </li>
                            <li>
								<a href="#">
									<span class="fa-stack fa-2x">
									  <i class="fa fa-circle fa-stack-2x"></i>
									  <i class="fa fa-bitbucket fa-stack-1x fa-inverse"></i>
									</span>
								</a>
                            </li>
                    </ul>
                </div>
				 <!-- subscribe -->
                <div class="well">
					<!-- Begin MailChimp Signup Form -->
					<div id="mc_embed_signup">
					<form action="http://maplelearning.us1.list-manage.com/subscribe?u=47d56ac42a95b4295600c0e64&id=5f9ede27c9" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
						<div id="mc_embed_signup_scroll">
						<h2>Subscribe to our mailing list</h2>
					<div class="indicates-required"><span class="asterisk">*</span> indicates required</div>
					<div class="mc-field-group">
						<label for="mce-EMAIL">Email Address  <span class="asterisk">*</span>
					</label>
						<input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL">
					</div>
					<div class="mc-field-group">
						<label for="mce-FNAME">First Name </label>
						<input type="text" value="" name="FNAME" class="" id="mce-FNAME">
					</div>
					<div class="mc-field-group">
						<label for="mce-LNAME">Last Name </label>
						<input type="text" value="" name="LNAME" class="" id="mce-LNAME">
					</div>
						<div id="mce-responses" class="clear">
							<div class="response" id="mce-error-response" style="display:none"></div>
							<div class="response" id="mce-success-response" style="display:none"></div>
						</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
						<div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_47d56ac42a95b4295600c0e64_5f9ede27c9" tabindex="-1" value=""></div>
						<div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
						</div>
					</form>
					</div>

					<!--End mc_embed_signup-->
				</div>

            </div>
        </div>
        <!-- /.row -->
       <hr>


          <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>

    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

	</div>
    </body>

</html>
