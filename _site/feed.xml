<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>泽民博客</title>
    <description>夏泽民的个人主页，学习笔记。</description>
    <link>https://xiazemin.github.io/MyBlog/</link>
    <atom:link href="https://xiazemin.github.io/MyBlog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 28 Feb 2018 22:03:29 +0800</pubDate>
    <lastBuildDate>Wed, 28 Feb 2018 22:03:29 +0800</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>symbol_table</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;符号表在编译程序工作的过程中需要不断收集、记录和使用源程序中一些语法符号的类型和特征等相关信息。这些信息一般以表格形式存储于系统中。如常数表、变量名表、数组名表、过程名表、标号表等等，统称为符号表。对于符号表组织、构造和管理方法的好坏会直接影响编译系统的运行效率。&lt;/p&gt;

&lt;p&gt;编译程序时放在符号表里的不光是内存地址和函数/变量的对应关系，还有很多在编译时要用到的信息。比如该节点的各种属性（类型，作用域，分配空间大小，（函数）的参数类型）等等。符号表与编译的各个阶段都有交互。对符号表的具体使用方法每个编译器都不同。&lt;/p&gt;

&lt;p&gt;目标文件中的符号表用来输出函数/变量符号信息，供连接时给其他模块引用。这种符号表中主要包含函数/变量的名称和地址对应关系，其中的地址一般是位置无关码(PIC码)。&lt;/p&gt;

&lt;p&gt;支持namespace、static method一样的东西，你就知道所有的东西都得用树来和scope组织。但是光用树和scope还不够，当你支持using namespace的时候你就知道麻烦了——这也是为什么80年代设计出来的C++的using namespace的语义这么垃圾，大概是因为以前内存太少了，没法使用复杂的组织方法。因此符号表只需要一个，然后每个语法树的节点都可以决定自己要不要创建scope，然后scope可以挂到符号表的一个节点上，也可以是匿名的，scope还是反向引用的。每个scope上面还要挂着一个额外的为using namespace优化的数据结构，这么弄下来就差不多了，所有的语言的特性都包括在里面了。&lt;/p&gt;

&lt;p&gt;Symbol Table可以用链表、动态数组、hash、map等结构。Symbol Table的设计和Syntax Checking、Type checking、Property Access等都有关系。设计上的选择是多样的，比如可以把常量和变量放在两张表，在语义分析的过程中加一个判断，来决定操作哪张表；也可以放在一起，加上额外的toeken（其他的token包括type等信息）区分它们。抛开复杂功能不谈，最方便的理解方式是实现小型语言的解释器，操作Env（Environment）的过程中自然就是在和Symbol Table打交道：对Identifier的创建、查找、删除，Scope的嵌套、屏蔽等等，都反映在Env的创建、变化以及指向、包含等关系上&lt;/p&gt;

&lt;p&gt;2.1编译预处理&lt;/p&gt;

&lt;p&gt;在这个阶段主要是宏定义的展开，以及头文件的递归处理，即展开所有的以#开头的编译命令。&lt;/p&gt;

&lt;p&gt;2.2编译阶段&lt;/p&gt;

&lt;p&gt;将程序代码段按字符流格式进行切割，处理，主要是词法分析，语法分析，语义分析等阶段，编译完成后生成中间代码。&lt;/p&gt;

&lt;p&gt;2.3汇编&lt;/p&gt;

&lt;p&gt;将编译后的中间代码通过汇编器模块生成计算机能够识别的机器指令用以操控硬件设施生成目标代码（可重定位目标代码）。&lt;/p&gt;

&lt;p&gt;2.4链接&lt;/p&gt;

&lt;p&gt;通过链接器模块将各种目标代码以及库文件（&lt;em&gt;.lib文件），资源文件（&lt;/em&gt;,rec）进行链接处理最终生成可以执行的*.exe文件。&lt;/p&gt;

&lt;p&gt;2.5重定位问题&lt;/p&gt;

&lt;p&gt;通过一个例子来看：假如我们有两个头文件和两个源文件分别叫做function1.h和function2.h以及function1.cpp和function2.cpp文件其中function1.h内容如下&lt;/p&gt;

&lt;p&gt;Function1.h&lt;/p&gt;

&lt;p&gt;#ifndef   _FUNCTION1_H&lt;/p&gt;

&lt;p&gt;#define   _FUNCTION1_H&lt;/p&gt;

&lt;p&gt;Int g_val;&lt;/p&gt;

&lt;p&gt;Int Add(int m, int n);&lt;/p&gt;

&lt;p&gt;#endif&lt;/p&gt;

&lt;p&gt;Function1.cpp&lt;/p&gt;

&lt;p&gt;g_val=10;&lt;/p&gt;

&lt;p&gt;Int Add(int m, int n)&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;Return m+n;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;Function2.cpp其中包含了main函数内容如下&lt;/p&gt;

&lt;p&gt;#include “function1.h”&lt;/p&gt;

&lt;p&gt;Int main()&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;Int  l_valfri=3;&lt;/p&gt;

&lt;p&gt;Int  l_valsec=4;&lt;/p&gt;

&lt;p&gt;g_val=14;&lt;/p&gt;

&lt;p&gt;Int result=Add(l_valfri,l_valsec);&lt;/p&gt;

&lt;p&gt;Return 0;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;对于这样的代码编译器在编译function2.cpp时对于外部符号g_val 和外部函数Add该如何决议呢，这里又会涉及到可重定位文件中的符号表问题。&lt;/p&gt;

&lt;p&gt;其实在可重定位目标文件之中会存在一个用来放置变量和其入口地址的符号表，当编译过程中能够找到该符号的定义时就将该符号入口地址更新到符号表中否则就对该符号的地址不做任何决议一直保留到链接阶段处理。通过两个例子来看符号表的结构。&lt;/p&gt;

&lt;p&gt;在编译过程中function1.cpp文件的可重定位目标文件中的符号表如下&lt;/p&gt;

&lt;p&gt;变量名&lt;/p&gt;

&lt;p&gt;内存地址&lt;/p&gt;

&lt;p&gt;g_val&lt;/p&gt;

&lt;p&gt;0x100&lt;/p&gt;

&lt;p&gt;Add&lt;/p&gt;

&lt;p&gt;0x200&lt;/p&gt;

&lt;p&gt;为什么可以做到对于符号g_val和Add分配内存地址呢，因为在编译阶段就能够在function1.cpp文件中找到他们的定义，所以能够进行明确的内存地址分配。&lt;/p&gt;

&lt;p&gt;再来看看function2.cpp所生成的可重定位目标文件的结构：&lt;/p&gt;

&lt;p&gt;变量名&lt;/p&gt;

&lt;p&gt;内存地址&lt;/p&gt;

&lt;p&gt;g_val&lt;/p&gt;

&lt;p&gt;0x00&lt;/p&gt;

&lt;p&gt;Add&lt;/p&gt;

&lt;p&gt;0x00&lt;/p&gt;

&lt;p&gt;为什么会出现这样的状况。因为在编译阶段虽然可以看到这些符号变量的声明，但却找不到他们的定义所以编译器陷入了一个决而未决的境地。&lt;/p&gt;

&lt;p&gt;将包含文件展开时，function2.cpp大概会是这个样子很明显只有符号变量的声明但是没有定义。&lt;/p&gt;

&lt;p&gt;#ifndef   _FUNCTION1_H&lt;/p&gt;

&lt;p&gt;#define   _FUNCTION1_H&lt;/p&gt;

&lt;p&gt;Int g_val;&lt;/p&gt;

&lt;p&gt;Int Add(int m, int n);&lt;/p&gt;

&lt;p&gt;#endif&lt;/p&gt;

&lt;p&gt;Int main()&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;Int  l_valfri=3;&lt;/p&gt;

&lt;p&gt;Int  l_valsec=4;&lt;/p&gt;

&lt;p&gt;g_val=14;&lt;/p&gt;

&lt;p&gt;Int result=Add(l_valfri,l_valsec);&lt;/p&gt;

&lt;p&gt;Return 0;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;先将他们存放在符号表中但却不去为他们进行内存关联一直等到链接阶段在进行处理。&lt;/p&gt;

&lt;p&gt;重定位发生于目标代码链接阶段，在链接阶段链接器就会查找符号表，当他发现了function2.cpp的符号表之中任然有没有决议的内存地址时，链接器就会查找所有的目标代码文件，一直到他找到了function1.cpp所生成的目标代码文件符号表时发现了这些没有决议的符号变量的真正内存地址，这是function2.cpp所生成的目标代码文件就会更新它的符号表，将这些尚未决议的符号变量的内存地址写进其符号表中。&lt;/p&gt;

&lt;p&gt;更新之后的function2.obj文件符号表&lt;/p&gt;

&lt;p&gt;变量名&lt;/p&gt;

&lt;p&gt;内存地址&lt;/p&gt;

&lt;p&gt;g_val&lt;/p&gt;

&lt;p&gt;0x100&lt;/p&gt;

&lt;p&gt;Add&lt;/p&gt;

&lt;p&gt;0x200&lt;/p&gt;

&lt;p&gt;当所有的符号变量都能够找到合法的内存地址时，链接阶段重定位完成。&lt;/p&gt;

&lt;p&gt;有 些人写C/C++(以下假定为C++)程序，对unresolved external link或者duplicated external simbol的错误信息不知所措（因为这样的错误信息不能定位到某一行）。或者对语言的一些部分不知道为什么要（或者不要）这样那样设计。了解本文之后， 或许会有一些答案。 
    首先看看我们是如何写一个程序的。如果你在使用某种IDE（Visual Studio，Elicpse，Dev C++等），你可能不会发现程序是如何组织起来的（很多人因此而反对初学者使用IDE）。因为使用IDE，你所做的事情，就是在一个项目里新建一系列 的.cpp和.h文件，编写好之后在菜单里点击“编译”，就万事大吉了。但其实以前，程序员写程序不是这样的。他们首先要打开一个编辑器，像编写文本文件 一样的写好代码，然后在命令行下敲 
    cc 1.cpp -o 1.o 
    cc 2.cpp -o 2.o 
    cc 3.cpp -o 3.o 
这里cc代表某个C/C++编译器，后面紧跟着要编译的cpp文件，并且以-o指定要输出的文件（请原谅我没有使用任何一个流行编译器作为例子）。这样当前目录下就会出现： 
    1.o 2.o 3.o 
最后，程序员还要键入 
    link 1.o 2.o 3.o -o a.out 
来生成最终的可执行文件a.out。现在的IDE，其实也同样遵照着这个步骤，只不过把一切都自动化了。 
    让我们来分析上面的过程，看看能发现什么。 
    首先，对源代码进行编译，是对各个cpp文件单独进行的。对于每一次编译，如果排除在cpp文件里include别的cpp文件的情况（这是C++代码编 写中极其错误的写法），那么编译器仅仅知道当前要编译的那一个cpp文件，对其他的cpp文件的存在完全不知情。 
    其次，每个cpp文件编译后，产生的.o文件，要被一个链接器(link)所读入，才能最终生成可执行文件。 
    好了，有了这些感性认识之后，让我们来看看C/C++程序是如何组织的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;首先要知道一些概念： 
编译：编译器对源代码进行编译，是将以文本形式存在的源代码翻译为机器语言形式的目标文件的过程。 
编译单元：对于C++来说，每一个cpp文件就是一个编译单元。从之前的编译过程的演示可以看出，各个编译单元之间是互相不可知的。 
目标文件：由编译所生成的文件，以机器码的形式包含了编译单元里所有的代码和数据，以及一些其他的信息。 
 
下面我们具体看看编译的过程。我们跳过语法分析等，直接来到目标文件的生成。假设我们有一个1.cpp文件 
 int n = 1; 

void f() 
 { 
    ++n; 
} 

它编译出来的目标文件1.o就会有一个区域（假定名称为2进制段），包含了以上数据／函数，其中有n, f，以文件偏移量的形式给出很可能就是： 
偏移量    内容    长度 
0x000    n    4 
0x004    f     ?? 
注意：这仅仅是猜测，不代表目标文件的真实布局。目标文件的各个数据不一定连续，也不一定按照这个顺序，当然也不一定从0x000开始。 
现在我们看看从0x004开始f函数的内容（在0x86平台下的猜测）： 
0x004 inc DWORD PTR [0x000] 
0x00? ret 
注意n++已经被翻译为：inc DWORD PTR [0x000]，也就是把本单元0x000位置上的一个DWORD(4字节)加1。 
 
下面如果有另一个2.cpp，如下 
extern int n; 
void g() 
{ 
    ++n; 
} 
那么它的目标文件2.o的2进制段就应该是 
偏移量    内容    长度 
0x000    g     ?? 
为什么这里没有n的空间（也就是n的定义），因为n被声明为extern，表明n的定义在别的编译单元里。别忘了编译的时候是不可能知道别的编译单元的情 况的，故编译器不知道n究竟在何处，所以这个时候g的二进制代码里没有办法填写inc DWORD PTR [???]中的？？？部分。怎么办呢？这个工作就只能交给后来的链接器去处理。为了让链接器知道哪些地方的地址是没有填好的，所以目标文件还要有一个“未 解决符号表”，也就是unresolved symbol table. 同样,提供n的定义的目标文件(也就是1.o)也要提供一个“导出符号表”，export symbol table, 来告诉链接器自己可以提供哪些地址。 
让我们理一下思路：现在我们知道，每一个目标文件，除了拥有自己的数据和二进制代码之外，还要至少提供2个表：未解决符号表和导出符号表，分别告诉链接器 自己需要什么和能够提供什么。下面的问题是，如何在2个表之间建立对应关系。这里就有一个新的概念：符号。在C/C++中，每一个变量和函数都有自己的符 号。例如变量n的符号就是“n”。函数的符号要更加复杂，它需要结合函数名及其参数和调用惯例等，得到一个唯一的字符串。f的符号可能就是&quot;_f&quot;（根据 不同编译器可以有变化）。 
所以，1.o的导出符号表就是 
符号    地址 
n    0x000 
_f    0x004 
而未解决符号表为空 
2.o的导出符号表为 
符号    地址 
_g    0x000 
未解决符号表为 
符号    地址     
n    0x001     
这里0x001为从0x000开始的inc DWORD PTR [???]的二进制编码中存储???的起始地址(这里假设inc的机器码的第2－5字节为要+1的绝对地址，需要知道确切情况可查手册)。这个表告诉链接 器，在本编译单元0x001的位置上有一个地址，该地址值不明，但是具有符号n。 
链接的时候，链接器在2.o里发现了未解决符号n，那么在查找所有编译单元的时候，在1.o中发现了导出符号n，那么链接器就会将n的地址0x000填写到2.o的0x001的位置上。 
“打住”，可能你就会跳出来指责我了。如果这样做得话，岂不是g的内容就会变成inc DWORD PTR [0x000]，按照之前的理解，这是将本单元的0x000地址的4字节加1，而不是将1.o的对应位置加1。是的，因为每个编译单元的地址都是从0开始 的，所以最终拼接起来的时候地址会重复。所以链接器会在拼接的时候对各个单元的地址进行调整。这个例子中，假设2.o的0x00000000地址被定位在 可执行文件的0x00001000上，而1.o的0x00000000地址被定位在可执行文件的0x00002000上，那么实际上对链接器来说，1.o 的导出符号表其实 
符号    地址 
n    0x000 + 0x2000 
_f    0x004 + 0x2000 
而未解决符号表为空 
2.o的导出符号表为 
符号    地址 
_g    0x000 + 0x1000 
未解决符号表为 
符号    地址             
n    0x001 + 0x1000  所以最终g的代码会变为inc DWORD PTR [0x000 + 0x2000]。 
最后还有一个漏洞，既然最后n的地址变为0x2000了，那么以前f的代码inc DWORD PTR [0x000]就是错误的了。所以目标文件为此还要提供一个表，叫做地址重定向表address redirect table。 
对于1.o来说，它的重定向表为 
地址 
0x005 
这个表不需要符号，当链接器处理这个表的时候，发现地址为0x005的位置上有一个地址需要重定向，那么直接在以0x005开始的4个字节上加上0x2000就可以了。 
让我们总结一下：编译器把一个cpp编译为目标文件的时候，除了要在目标文件里写入cpp里包含的数据和代码，还要至少提供3个表：未解决符号表，导出符号表和地址重定向表。 
未解决符号表提供了所有在该编译单元里引用但是定义并不在本编译单元里的符号及其出现的地址。 
导出符号表提供了本编译单元具有定义，并且愿意提供给其他编译单元使用的符号及其地址。 
地址重定向表提供了本编译单元所有对自身地址的引用的记录。 
链接器进行链接的时候，首先决定各个目标文件在最终可执行文件里的位置。然后访问所有目标文件的地址重定向表，对其中记录的地址进行重定向（即加上该编译 单元实际在可执行文件里的起始地址）。然后遍历所有目标文件的未解决符号表，并且在所有的导出符号表里查找匹配的符号，并在未解决符号表中所记录的位置上 填写实际的地址（也要加上拥有该符号定义的编译单元实际在可执行文件里的起始地址）。最后把所有的目标文件的内容写在各自的位置上，再作一些别的工作，一 个可执行文件就出炉了。 
最终link 1.o 2.o .... 所生成的可执行文件大概是 
0x00000000  ????（别的一些信息） 
.... 
0x00001000  inc DWORD PTR [0x00002000]              //这里是2.o的开始，也就是g的定义 
0x00001005  ret                                  //假设inc为5个字节，这里是g的结尾 
.... 
0x00002000  0x00000001                           //这里是1.o的开始，也是n的定义（初始化为1） 
0x00002004  inc DWORD PTR [0x00002000]         //这里是f的开始 
0x00002009  ret                                  //假设inc为5个字节，这里是f的结尾 
... 
... 
实际链接的时候更为复杂，因为实际的目标文件里把数据／代码分为好几个区，重定向等要按区进行，但原理是一样的。 


 
现在我们可以来看看几个经典的链接错误了： 
unresolved external link.. 
这个很显然，是链接器发现一个未解决符号，但是在导出符号表里没有找到对应的項。 
解决方案么，当然就是在某个编译单元里提供这个符号的定义就行了。（注意，这个符号可以是一个变量，也可以是一个函数），也可以看看是不是有什么该链接的文件没有链接 
duplicated external simbols... 
这个则是导出符号表里出现了重复项，因此链接器无法确定应该使用哪一个。这可能是使用了重复的名称，也可能有别的原因。 


我们再来看看C/C++语言里针对这一些而提供的特性： 
extern:这是告诉编译器，这个符号在别的编译单元里定义，也就是要把这个符号放到未解决符号表里去。（外部链接） 
 
static:如果该关键字位于全局函数或者变量的声明的前面，表明该编译单元不导出这个函数／变量的符号。因此无法在别的编译单元里使用。（内部链接）。如果是static局部变量，则该变量的存储方式和全局变量一样，但是仍然不导出符号。 
 
默认链接属性：对于函数和变量，模认外部链接，对于const变量，默认内部链接。（可以通过添加extern和static改变链接属性） 

外部链接的利弊：外部链接的符号，可以在整个程序范围内使用（因为导出了符号）。但是同时要求其他的编译单元不能导出相同的符号（不然就是duplicated external simbols) 

内部链接的利弊：内部链接的符号，不能在别的编译单元内使用。但是不同的编译单元可以拥有同样名称的内部链接符号。 

为什么头文件里一般只可以有声明不能有定义：头文件可以被多个编译单元包含，如果头文件里有定义，那么每个包含这个头文件的编译单元就都会对同一个符号 进行定义，如果该符号为外部链接，则会导致duplicated external simbols。因此如果头文件里要定义，必须保证定义的符号只能具有内部链接。 

为什么常量默认为内部链接，而变量不是： 
    这就是为了能够在头文件里如const int n = 0这样的定义常量。由于常量是只读的，因此即使每个编译单元都拥有一份定义也没有关系。如果一个定义于头文件里的变量拥有内部链接，那么如果出现多个编译 单元都定义该变量，则其中一个编译单元对该变量进行修改，不会影响其他单元的同一变量，会产生意想不到的后果。 

为什么函数默认是外部链接： 
    虽然函数是只读的，但是和变量不同，函数在代码编写的时候非常容易变化，如果函数默认具有内部链接，则人们会倾向于把函数定义在头文件里，那么一旦函数 被修改，所有包含了该头文件的编译单元都要被重新编译。另外，函数里定义的静态局部变量也将被定义在头文件里。 

为什么类的静态变量不可以就地初始化：所谓就地初始化就是类似于这样的情况： 
    class A 
    { 
        static char msg[] = &quot;aha&quot;; 
    };  不允许这样做得原因是，由于class的声明通常是在头文件里，如果允许这样做，其实就相当于在头文件里定义了一个非const变量。 

在C++里，头文件定义一个const对象会怎么样： 
    一般不会怎么样，这个和C里的在头文件里定义const int一样，每一个包含了这个头文件的编译单元都会定义这个对象。但由于该对象是const的，所以没什么影响。但是：有2种情况可能破坏这个局面： 
    1。如果涉及到对这个const对象取地址并且依赖于这个地址的唯一性，那么在不同的编译单元里，取到的地址可以不同。（但一般很少这么做） 
    2。如果这个对象具有mutable的变量，某个编译单元对其进行修改，则同样不会影响到别的编译单元。 

为什么类的静态常量也不可以就地初始化： 
    因为这相当于在头文件里定义了const对象。作为例外，int/char等可以进行就地初始化，是因为这些变量可以直接被优化为立即数，就和宏一样。 

内联函数： 
    C++里的内联函数由于类似于一个宏，因此不存在链接属性问题。 

为什么公共使用的内联函数要定义于头文件里： 
    因为编译时编译单元之间互相不知道，如果内联函数被定义于.cpp文件中，编译其他使用该函数的编译单元的时候没有办法找到函数的定义，因此无法对函数进行展开。所以说如果内联函数定义于.cpp文件里，那么就只有这个cpp文件可以是用这个函数。 

头文件里内联函数被拒绝会怎样： 
    如果定义于头文件里的内联函数被拒绝，那么编译器会自动在每个包含了该头文件的编译单元里定义这个函数并且不导出符号。 

如果被拒绝的内联函数里定义了静态局部变量，这个变量会被定义于何处： 
    早期的编译器会在每个编译单元里定义一个，并因此产生错误的结果，较新的编译器会解决这个问题，手段未知。 

为什么export关键字没人实现： 
    export要求编译器跨编译单元查找函数定义，使得编译器实现非常困难。
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Wed, 28 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/lang/2018/02/28/symbol_table.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/lang/2018/02/28/symbol_table.html</guid>
        
        
        <category>lang</category>
        
      </item>
    
      <item>
        <title>re2c</title>
        <description>&lt;p&gt;http://re2c.org/&lt;/p&gt;

&lt;!-- more --&gt;
&lt;p&gt;在PHP的实现过程中，包括PHP语言本身的词法分析，一共有多达8处的地方使用了re2c，如果我们常用的时间函数、pdo扩展等。对re2c的了解更能促进我们进PHP内核实现的认知。&lt;/p&gt;

&lt;p&gt;本手册是re2c官网的manual.html文件翻译稿，仅适用于对re2c的初步了解，更多的资料见re2c项目中lessons目录和doc目录。&lt;/p&gt;

&lt;p&gt;Name
re2c – 将正则表达式转化成C/C++代码&lt;/p&gt;

&lt;p&gt;Synopsisre2c [-bdDefFghisuvVw1] [-o output] [-c [-t header]] file
Description
re2c是一个将正则表达式转化成基于C语言标识的预处理器。&lt;/p&gt;

&lt;p&gt;re2c的输入包含C/C++代码，并且以/*!re2c… */注释的格式将扫描标识交错嵌入到这些代码中。在它的输出中，这些注释将会被生成的代码替换掉，当执行时，它将会查找到下一个token，并且执行用户提供的针对该token的特定代码。
如下示例：&lt;/p&gt;

&lt;p&gt;char &lt;em&gt;scan(char *p)
	{
	/&lt;/em&gt;!re2c
	        re2c:define:YYCTYPE  = “unsigned char”;
	        re2c:define:YYCURSOR = p;
	        re2c:yyfill:enable   = 0;
	        re2c:yych:conversion = 1;
	        re2c:indent:top      = 1;
	        [0-9]+          {return p;}
	        [^]             {return (char*)0;}
	*/
	}
re2c将生成如下代码：&lt;/p&gt;

&lt;p&gt;/* Generated by re2c on Sat Apr 16 11:40:58 1994 */
	char *scan(char *p)
	{
	    {
	        unsigned char yych;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       yych = (unsigned char)*p;
        if(yych &amp;lt;= '/') goto yy4;
        if(yych &amp;gt;= ':') goto yy4;
        ++p;
        yych = (unsigned char)*p;
        goto yy7;
yy3:
        {return p;}
yy4:
        ++p;
        yych = (unsigned char)*p;
        {return char*)0;}
yy6:
        ++p;
        yych = (unsigned char)*p;
yy7:
        if(yych &amp;lt;= '/') goto yy3;
        if(yych &amp;lt;= '9') goto yy6;
        goto yy3;
    }
 
} 你可以通过添加注释：/*!max:re2c/ 来输出一个宏定义 YYMAXFILL 来保存输入解析时字符的最大个数。如果使用了-1, YYMAXFILL 只能在最后的 /*!re2c/ 后触发一次。同时，你也可以使用 /*!ignore:re2c */ 来为扫描代码添加注释文档，它们被输出。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Options
re2c提供如下的选项：&lt;/p&gt;

&lt;p&gt;-?
-h 帮助
-b 当指定-b参数时，-s参数也会被默认同时指定。 使用位向量尝试着从编译器捣鼓出更好的代码。它对于关键字比较多的规则很有用，比如大部分的编程语言。re2c的实现是通过生成256个ascii字符的映射表，直接判断对应的字符串是否应该跳转到下一个字符，从而实现优化。
-c 支持类lex或flex的表达式
-d 创建一个解析器用来打印当前位置的信息，这对于调试非常有用。如果你要使用它，你需要定义一个供解析器调用的YYDEBUG宏，它像一个函数一样，接受两个参数：void YYDEBUG(int state,char current)。第一个参数是state或者-1，第二个参数是当前所解析的代码位置。在每个++YYCURSOR、不同的goto跳转变化处，re2c自动添加YYDEBUG宏调用。如果在规则文件中没定义YYDEUBG宏，在编译C文件时会出错。
-D 输出Graphviz dot 格式的数据，比如可以使用” dot -Tpng input.dot &amp;gt; output.png”来处理生成图片。注意扫描器中如果包含太多的状态可能会让dot程序崩溃
-e 从ASCII平台交叉编译EBCDIC
-f 生成带可存储状态的扫描器。更多详情见下面的可存储的扫描器小节。
-F 部分支持flex语法。当-F标记有效时，flex的变量用大括号括起来，并且在定义时不需要等号，在结束时不需要用分号。否则，名字被认为是直接被引号的字符串。
-g 使用GCC的goto特性生成扫描器。当决策复杂时re2c会生成决策跳转表，使用goto针对不同的情况做不同的跳转。仅适用于GCC编译器。注意，这里默认指定了-b参数。re2c的实现中，-g参数会生成yytarget决策跳转表，其实就是一个256个元素的一维数据，针对不同的字符，直接跳转，以优化扫描器。
-i 不输出行信息，当你的用户从你的代码编译，而你又不要求他们拥有re2c环境，此时你可以使用CMS工具管理re2c的输出文件时，此参数就有用武之地了。-o参数指定输出文件。
指在生成的.c文件中不使用#line宏。
-r 允许扫描器在每个 ‘/!use:re2c’块后面重用定义的 ‘/!use:re2c’ 块。这些块可以包含适当的配置，特别是 ‘re2c:flags:w’和re2c:flags:u’。这种方法可能会为不同的字符类型，不同的输入机制或不同的输出机制多次创建相同的扫描器。’/!use:re2c’ 块也可以在 ‘/!rules:re2c’中的规则集中包含额外的规则。
-s 为一些switch语句生成嵌套的if语句。许多编译器需要这个参数的辅助以便生成更好的代码。
-t 生成一个类型定义的头文件，以支持类(f)lex条件，当需要使用-t参数时，需同时指定-c参数，-t参数后面接生成的头文件名称。如果只指定re2c会报错：re2c: error: Can only output a header file when using -c switch
-u 生成一个支持Unicode编码的解析器。这意味着生成的代码能处理任何有效的Unicode字符，直到x10FFFF。当需要支持UTF-8或UTF-16时，你需要自己将输入的数据转化成UTF-32编码。
-v 查看版本信息。如：re2c 0.13.6
-V 以数字格式查看版本信息。如：001306
-w 创建支持宽字符格式的解析器，默认指定-s参数，不能和-e参数共存。
-1 强制一次生成，它不能和-f组合在一起使用，并且在re2c块结束之前不能禁用YYMAXFILL。
–no-generation-date 禁止输出生成日志，所以只会输出re2c的版本信息。
–case-insensitive 所有字符串不区分大小写，所以，双引号中的字符和单引号的意义一样。
–case-inverted 颠倒单引号和双引号包含的字符中的意思，比如，有了这个开关，单引号内的字符串区分大小写，双引号内的字符串不区分大小写。
Interface Code接口代码
不像其他的扫描器程序，re2c 不会生成完整的扫描器：用户必须提供一些接口代码。用户必须定义下面的宏或者是其他相应的配置。&lt;/p&gt;

&lt;p&gt;YYCONDTYPE 用-c 模式你可以使用-t参数来生成一个包含了会被作为条件使用的枚举类型的文件。枚举类型中的每个值都会在规则集合里面作为条件来使用。
YYCTYPE 用来维持一个输入符号。通常是 char 或者unsigned char。
YYCTXMARKER &lt;em&gt;YYCTYPE类型的表达式，生成的代码回溯信息的上下文会保存在
YYCTXMARKER。如果扫描器规则需要使用上下文中的一个或多个正则表达式，则用户需要定义这个宏。
YYCURSOR *YYCTYPE类型的表达式指针指向当前输入的符号，生成的代码作为符号相匹配，在开始的地方，YYCURSOR假定指向当前token的第一个字符。在结束时，YYCURSOR将会指向下一个token的第一个字符。
YYDEBUG(state,current) 这个只有指定-d标记的时候才会需要。调用用户定义的函数时可以非常容易的调试生成的代码。
这个函数应该有以下签名：void YYDEBUG(int state,char current)。第一个参数接受 state ，默认值为-1第二个参数接受输入的当前位置。
YYFILL(n) 当缓冲器需要填充的时候，生成的代码将会调用YYFILL(n)：至少提供n个字符。YYFILL(n)将会根据需要调整YYCURSOR,YYLIMIT,YYMARKER 和 YYCTXMARKER。注意在典型的程序语言当中，n等于最长的关键词的长度加一。用户可以在/&lt;/em&gt;!max:re2c/一次定义YYMAXFILL来指定最长长度。如果使用了-1，YYMAXFILL将会在/&lt;em&gt;!re2c/之后调用一次阻塞。
YYGETCONDITION() 如果使用了-c模式，这个定义将会在扫描器代码之前获取条件集。这个值必须初始化为枚举YYCONDTYPE的类型。
YYGETSTATE() 如果指定了-f模式，用户就需要定义这个宏。此种情况下，扫描器在开始时为了获取保存的状态，生成的代码将会调用YYGETSTATE()。YYGETSTATE()必须返回一个有符号的整数，这个值如果是-1，告诉扫描器这是第一次执行，否则这个值等于以前YYSETSTATE(s) 保存的状态。否则，扫描器将会恢复操作之后立即调用YYFILL(n)。
YYLIMIT 这是一个类型为&lt;/em&gt;YYCTYPE的表达式，它标记了缓冲器的结尾（YYLIMIT[-1]是缓冲区的最后一个字符）。生成的代码将会不断的比较YYCORSUR 和 YYLIMIT 以决定 什么时候填充缓冲区。
YYSETCONDITION(c) 这个宏用来在转换规则中设置条件，它只有在指定-c模式和使用转换规则时有用。
YYSETSTATE(s) 用户只需要在指定-f模式时定义这个宏，如果是这样，生成的代码将会在YYFILL(n)之前调用YYSETSTATE(s)，YYSETSTATE的参数是一个有符号整型，被称为唯一的标示特定的YYFILL(n)实例。
YYMARKER 类型为*YYCTYPE的表达式，生成的代码保存回溯信息到YYMARKER。一些简单的扫描器可能用不到。
解析器支持条件 当使用-c参数时，你可以使用正则表达式条件列表。这样re2c会为每个条件生成扫描块，在每一个生成的扫描器都有自己的先决条件。先决条件是定义YYGETCONDETION ，而且类型必须是YYCONDTYPE。
YYSETSTATE(s) 用户只需要在指定-f模式时定义这个宏。在此种情况下，生成的代码将会在YYFILL(n)之前调用YYSETSTATE(s)，YYSETSTATE的参数是一个有符号整型，被称为唯一的标示特定的YYFILL(n)实例。如果用户希望保存扫描器的状态并用YYFILL(n) 将状态返回给调用 者，他所需要做的是在变量中保存这个唯一的标识。然后，当再次调用扫描器时，它将调用
YYGETSTATE()并在恢复到之前离开的地方继续执行。即使禁用了 YYFILL(n) ，生成的代码也会包含YYSETSTATE(s)和YYGETSTATE。
Scanner With Storable States可存储状态的扫描器
当指定-f标记时，re2c会生成一个存储了它当前状态的扫描器，它能精确的恢复到之前离开的位置，并返回给调用者。&lt;/p&gt;

&lt;p&gt;re2c的默认行为是拉模式，无论何时需要，它都可以要求额外的输入，然而，这种操作模式是基于扫描器可以控制解析循环这一前提的，而这个前提并不一定会存在。
通常情况下，如果有一个预处理过程或其它相关的源程序数据在扫描器之前先执行，则扫描器无法再要求更多的数据，除非他们都在独立的线程之中。&lt;/p&gt;

&lt;p&gt;-f标记刚好可以解决这个问题：它让用户设计的扫描器以拉模式工作，即数据一块一块的输入到扫描器中。当扫描器运行数据时，它仅存储它的状态，并返回给调用者。当更多的输入数据输入到扫描器时，它能很精确的恢复到之前离开的位置。&lt;/p&gt;

&lt;p&gt;当re2c使用-f选项时，它不能接收标准输入，因为它必须做两次完整的全局扫描，而两次扫描就需要读取两次。这就意味着，如果不能打开输入两次或第一次输入影响第二次输入，re2c会执行失败。&lt;/p&gt;

&lt;p&gt;相对于拉模式，可存储的扫描器有以下不同：&lt;/p&gt;

&lt;p&gt;用户必须提供YYSETSTATE() 宏和YYGETSTATE(state)宏
-f参数禁止了yych和yyaccept的声明。因此用户必须声明这些，并且必须能够保存和恢复他们。在example/push.re文件的示例中，这些都被声明为C++类的字段，因此他们不再需要明确的保存或恢复。对于C语言来说，我们可以通过宏，以参数传递的方式从结构体中获取这些字段。或者，可以将他们声明为局部变量，当它决定返回并将之作为函数的一个项保存在 YYFILL(n)中。此外， 使用YYFILL(n)保存的效率更高，因为可以无条件的调用YYSETSTATE(state)。然而，YYFILL(n) 并不能将state作为参数，因此，我们必须通过YYSETSTATE(state)将state保存到局部变量中。
如果需要更多的输入，需要修改YYFILL(n) ，使之可以从调用它的函数处返回。
修改调用者的逻辑，使其在需要更多的输入时做出相应的应答。
生成的代码中将包含一个选择逻辑块，这个选择逻辑会被用来通过跳转到相应的YYFILL(n)调用处，以恢复最后的状态。这个代码块会在第一个 “/&lt;em&gt;!re2c */”块收尾的地方自动生成。通过放置 “/&lt;/em&gt;!getstate:re2c */”注释，可能会触发YYGETSTATE() 的生成操作。这对于被包含在循环中的扫描器非常有用。
请查看 examples/push.re文件中的推模式示例扫描器。它生成的代码可以通过”state:abort”和”state:nextlabel”调整。&lt;/p&gt;

&lt;p&gt;Scanner With Condition Support 可判断条件的扫描
当使用-c参数时，你可以在正则表达式之前优先一系统的条件名。在这种情况下，re2c会针对每个条件生成扫描代码块。这些代码块都有它自己的前置条件，这此前置条件都是通过接口定义YYGETCONDITON实现，并且必须为YYCONDTYPE类型。&lt;/p&gt;

&lt;p&gt;其中有两个特别的类型，一个是‘*’，它表示满足所有条件；另一个是空条件，它提供一个没有扫描内容的代码块，这意味着不需要任何正则表达式。这个特殊的块始终有一个固定的枚举值0。这些特殊的规则可以被用来初始化一个扫描器。这些特殊的规则并不是必须的，但是有时可以用它来声明一些没有初始化的状态。&lt;/p&gt;

&lt;p&gt;非空规则允许指定新的条件，这些条件将导致规则的变化。它会生成定义的YYSETCONDTITION，除此之外再无其它。&lt;/p&gt;

&lt;p&gt;还有另一种特殊的规则，它允许在所有的有规则和没有规则代码前添加代码。例如，它可以用来保存扫描的字符串的长度。这个特殊的规则以感叹号开始，后面可以接条件 &amp;lt;! condition, … &amp;gt; 或星号&amp;lt;!*&amp;gt;。当re2c为这个规则生成代码时，如果这个规则的状态没有起始规则或已经在在一个星号规则，那么这个代码将作为起始代码。&lt;/p&gt;

&lt;p&gt;Scanner Specifications 扫描器规则
每个扫描器规格都由 规则集、命名定义和配置构成。&lt;/p&gt;

&lt;p&gt;规则由正则以及紧跟其后面的C/C++代码构成，当正则匹配时，其后的C/C++代码会被执行。你可以以大括号或：=开始代码。当用大括号开始代码时，re2c会根据大括号判断其尝试并自动结束代码的查找。如果不使用大括号开始代码，则re2c会在第一行不为空时停止查找。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;regular-expression { C/C++ code }
regular-expression := C/C++ code 如果指定-c参数，则每个正则前面都会有一系列的由逗号分隔的条件名称。除了正常命名的规则以外，有两种特殊的情况。一个规则可能包含一个单独的条件名称’*’和没有条件名称。对于没有条件名称的情况，其后面不能接正则表达式。非空规则可能会进一步指定新的条件。在这种情况下，re2c可能会自动生成必要的代码来改变条件。如上所示代码，其以大括号和’:=’开始代码。更进一步，更多的规则可以使用’:=&amp;gt;’快捷方式来自动生成代码，它不仅仅可以设置新的状态，还可以继续执行新的状态。一个快捷规则不应该在循环中使用，这些循环代码在循环开始和re2c块之间，除非用 re2c:cond:goto使之 ‘continue;’如果一段代码必须放在所有的规则之前，你可以使用&amp;lt;! 伪规则。

&amp;lt;condition-list&amp;gt; regular-expression { C/C++ code }
&amp;lt;condition-list&amp;gt; regular-expression := C/C++ code
&amp;lt;condition-list&amp;gt; regular-expression =&amp;gt; condition { C/C++ code }
&amp;lt;condition-list&amp;gt; regular-expression =&amp;gt; condition := C/C++ code
&amp;lt;condition-list&amp;gt; regular-expression :=&amp;gt; condition
&amp;lt;*&amp;gt; regular-expression { C/C++ code }
&amp;lt;*&amp;gt; regular-expression := C/C++ code
&amp;lt;*&amp;gt; regular-expression =&amp;gt; condition { C/C++ code }
&amp;lt;*&amp;gt; regular-expression =&amp;gt; condition := C/C++ code
&amp;lt;*&amp;gt; regular-expression :=&amp;gt; condition
&amp;lt;&amp;gt; { C/C++ code }
&amp;lt;&amp;gt; := C/C++ code
&amp;lt;&amp;gt; =&amp;gt; condition { C/C++ code }
&amp;lt;&amp;gt; =&amp;gt; condition := C/C++ code
&amp;lt;&amp;gt; :=&amp;gt; condition
&amp;lt;!condition-list&amp;gt; { C/C++ code }
&amp;lt;!condition-list&amp;gt; := C/C++ code
&amp;lt;!*&amp;gt; { C/C++ code }
&amp;lt;!*&amp;gt; := C/C++ code 命名定义格式如下：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;name = regular-expression;
如果使用了-F 模式，可以使用如下命名定义方法：&lt;/p&gt;

&lt;p&gt;name regular-expression&amp;lt; /pre&amp;gt;
以”re2c”开始的命名定义配置如下所示：&lt;/p&gt;
&lt;pre lang=&quot;c&quot;&gt;re2c:name = value;
re2c:name = &quot;value&quot;;
Summary Of Re2c Regular-expressionsre2c正则表达式小结
“foo” 字符串foo。可以使用ANSI-C转义序列。
[xyz] 字符集；此种情况匹配字符x,y或z
[abj-oZ] 包含区间的字符集，此种情况匹配a,b,j到o之间的任一字符，或z
[^class] 字符集否定匹配，匹配没有在方括号中定义的字符。
r\s 匹配非s的正则，r和s都必须是可以表示为字符集的正则表达式
r* 零次或多次匹配，r是任一正则表达式
r+ 一次或多次匹配（至少一次）
r? 零次或一次匹配
name 这里name就是在前面的定义段给出的名字
(r) 匹配规则表达式r，圆括号可以提高其优先级。
rs 匹配规则表达式r，其后紧跟着表达式s。这称为联接(concatenation)。
r|s 或者匹配规则表达式r，或者匹配表达式s。
r/s 匹配模式r，但是要求其后紧跟着模式s。s并不会参与文本的匹配。这种正则表达式的匹配称之为“尾部上下文”
r{n} n次匹配
r{n,} 至少n次匹配
r{n,m} 至少n次，至多m次匹配；匹配除换行符外的任意字符
def 当没有使用-F参数时，匹配的命名定义通过def定义。当-F参数指定时，def语名和双引号包含的效果一样，直接匹配def字符串。字符集和字符串可能包含有八进制或十六进制或如下的转义字符 (\n, \t, \v, \b, \r, \f, \a, \)。一个八进制字符由一个反斜杠和紧跟着它的三个八进制数字组成，一个十六进制字符由一个反斜杠，一个小写的x，以及两个十六进制数字组成，或由一个反斜杠，一个大写的X，以及四个十六进制数字组成。re2c进一步会支持更多的C/C++的unicode符号。这些unicode符号由一个反斜杠+u+四个十六进制数字或一个反斜杠+U+八个十六进制的数字组成。然后，仅当-u模式下才能处理这些uincode字符。
在非unicode模式下，大于\X00FF的字符是无法直接匹配的，除非使用”万金油“类型的 (.|”\n”)和[^]正则表达式匹配所有的字符时，包含它们。

如上所示的正则表达式列表按优先级分组，从最上面的最高优先级到最下面的最低优先级。这些组合之间的优先级相同。

Inplace Configuration现场配置
它可能在re2c块中配置并生成代码，如下所示为可用的配置项：

re2c:condprefix = yyc_ ;
允许指定条件标签的前缀。它将在生成的输出文件中的所有条件标签前添加指定的前缀。
re2c:condenumprefix = yyc ;
允许指定条件值的前缀。它将在生成的输出文件中的所有条件枚举值前添加指定的前缀。
re2c:cond:divider = “/* *********************************** */” ;
允许为条件块自定义分隔符。你可以使用’@@’输出条件的名字或使用
re2c:cond:divider@cond = @@ ;
指定即将被 re2c:cond:divider中的条件名替换的占位符。
re2c:cond:goto = “goto @@;” ;
允许使用 ‘:=&amp;gt;’ 规则自定义条件跳转语句。你可以使用’@@’输出条件的名字或使用re2c:cond:divider@cond自定义占位符，同时你也可以使用此语句继续下一个循环周期，这个循环周期包括循环开始到re2c块之间的任何代码。
re2c:cond:goto@cond = @@ ;
指定即将在 re2c:cond:goto语句中被替换的条件标签占位符
re2c:indent:top = 0 ;
指定最小的缩进，大于或等于0
re2c:indent:string = “\t” ;
指定缩进用的字符串。除非你想使用外部工具，否则就需要只包含空白字符串。最简单的方法就是用单引号或双引号包含它们。如果你不需要任何缩进，直接使用””即可。
re2c:yych:conversion = 0 ;
当此设置非零时，re2c会在读取yych时自动生成转换代码。此时的类型必须使用re2c:define:YYCTYPE定义。
re2c:yych:emit = 1 ;
设置为0可以禁止yych的生成。
re2c:yybm:hex = 0 ;
如果设置为0，则生成一个十进制表格，否则将生成一个十六进制表格
re2c:yyfill:enable = 1 ;
将此设置为0可以禁止YYFILL(n)的生成。当使用它时请确认生成的扫描器在输入之后不再读取。允许此行为将给你的程序引入服务安全问题。
re2c:yyfill:check = 1 ;
当YYLIMIT + max(YYFILL)一直可用时，把此设置为0可以禁止使用YYCURSOR和YYLIMIT的先决条件的输出。
re2c:yyfill:parameter = 1 ;
允许禁止YYFILL调用的参数传递。如果设置为0，将没有任何参数传递到YYFILL。然而，define:YYFILL@LEN允许指定一个字符串替换实际字符中的长度。如果设置为非0，除非设置re2c:define:YYFILL:naked，否则YYFILL将使用紧跟其后的大括号内的所要求的字符数。其它请参照：re2c:define:YYFILL:naked和re2c:define:YYFILL@LEN.
re2c:startlabel = 0 ;如果设置为0的整数，即使没有扫描器本身，下一个扫描块的开始标签也会被生成。否则仅在需要的时候生成常规的yy0开始标签。如果设置为一个文本值，不管常规的开始标签生成是否，包含当前文本的标签都会被生成。在开始标签生成后，当前设置会被重置为0。
re2c:labelprefix = yy ;
允许修改数字标签的前缀，默认为yy，任何有效的标签都是可以的。
re2c:state:abort = 0 ;
当设置为非零，并且开启-f模式时，YYGETSTATE 块会包含一个默认的情况，初始化时设置为-1
re2c:state:nextlabel = 0 ;
当开启-f模式时，使用此设置可以控制是否在YYGETSTATE块后面接yyNext标签行。通常，你可以用startlabel配置强制指定开始标签或用默认的yy0作为开始标签，而不是用yyNext。通常我们通过放置”/*!getstate:re2c */” 注释来分隔实际扫描器的YYGETSTATE 代码，而不是专用的标签。
re2c:cgoto:threshold = 9 ;
当启用-g模式时，这个值指定生成的跳转表的复杂度阈值，而不是使用嵌套的if语句和决策位字段。
re2c:yych:conversion = 0 ;
当输入使用有符号字符时，并且开启-s和-b械时，re2c会自动将其转化为无符号类型。当设置为0时会禁用空字符串转化。设置为非零时，转化将在YYCTYPE处进行。如果这个值通过现场配置，则使用该值。否则，将会变成(YYCTYPE)，并且不能再修改成配置。当设置为一个字符串时，必须用括号括起来。现在，假设你的输入为char*并且使用上述的设置，你可以设置YYCTYPE为unsigned char，并且当前值设置为1或者”(unsigned char)”
re2c:define:define:YYCONDTYPE = YYCONDTYPE ;枚举用于支持-c模式的条件
re2c:define:YYCTXMARKER = YYCTXMARKER ;
允许覆盖定义的YYCTXMARKER ，从而避免将其设置为实际所需的代码。
re2c:define:YYCTYPE = YYCTYPE ;
允许覆盖定义的YYCTYPE ，从而避免将其设置为实际所需的代码。
re2c:define:YYCURSOR = YYCURSOR ;
允许覆盖定义的YYCURSOR ，从而避免将其设置为实际所需的代码。
re2c:define:YYDEBUG = YYDEBUG ;
允许覆盖定义的YYDEBUG ，从而避免将其设置为实际所需的代码。
re2c:define:YYFILL = YYFILL ;
允许覆盖定义的YYFILL ，从而避免将其设置为实际所需的代码。
re2c:define:YYFILL:naked = 0 ;
当设置为1时，括号、参数、分号都会被发出。
re2c:define:YYFILL@len = @@ ;
当使用 re2c:define:YYFILL 时，并且re2c:yyfill:parameter 为0时，YYFILL 中的任何文本将会被新的实际的长度值替换。
re2c:define:YYGETCONDITION = YYGETCONDITION ;
允许覆盖定义的YYGETCONDITION
re2c:define:YYGETCONDITION:naked = ;
当设置为1时，括号、参数、分号都会被发出。
re2c:define:YYGETSTATE = YYGETSTATE ;
允许覆盖定义的YYGETSTATE ，从而避免将其设置为实际所需的代码。
re2c:define:YYGETSTATE:naked = 0 ;
当设置为1时，括号、参数、分号都会被发出。
re2c:define:YYLIMIT = YYLIMIT ;
允许覆盖定义的YYLIMIT ，从而避免将其设置为实际所需的代码。
re2c:define:YYMARKER = YYMARKER ;
允许覆盖定义YYMARKER，从而避免将其设置为实际所需的代码。
re2c:define:YYSETCONDITION = YYSETCONDITION ;
允许覆盖定义的YYSETCONDITION
re2c:define:YYSETCONDITION@cond = @@ ;
当使用 re2c:define:YYSETCONDITION时，YYSETCONDITION中的任何文本将会被新的实际的
条件值替换。
re2c:define:YYSETSTATE = YYSETSTATE ;
允许覆盖定义的YYSETSTATE，从而避免将其设置为实际所需的代码。
re2c:define:YYSETSTATE:naked = 0 ;
当设置为1时，括号、参数、分号都会被发出。
re2c:define:YYSETSTATE@state = @@ ;
当使用re2c:define:YYSETSTATE时，YYSETCONDITION中的任何文本将会被新的实际的状态值替换
re2c:label:yyFillLabel = yyFillLabel ;
允许覆盖标签yyFillLabel，即可以自定义生成的yyFillLabel 变量名。
re2c:label:yyNext = yyNext ;
允许覆盖标签yyNext ，即可以自定义生成的yyNext变量名。
re2c:variable:yyaccept = yyaccept ;
允许覆盖变量yyaccept，即可以自定义生成的yyaccept变量名。
re2c:variable:yybm = yybm ;
允许覆盖变量yybm，即可以自定义生成的yybm变量名。
re2c:variable:yych = yych ;
允许覆盖变量yych，即可以自定义生成的yych变量名。
re2c:variable:yyctable = yyctable ;
当指定-c参数和-g参数时，re2c会使用此变量为YYGETCONDITION生成静态跳转表。
re2c:variable:yystable = yystable ;
当指定-f参数和-g参数时，re2c会使用此变量为YYGETSTATE生成静态跳转表。
re2c:variable:yytarget = yytarget ;
允许覆盖变量yytarget，即可以自定义生成的yytarget变量名。
Understanding Re2c 理解re2c
re2c的子目录中包含各种例子教你一步一步的如何开启re2c的世界，所有的例子都是可编译运行的。

Features特点
re2c不提供默认的动作：生成的代码假定输入包含一系列token。通常，可以通过添加一条规则实现，例如上面示例中的异常字符

因为re2c不提供结束表达式，所以用户必须安排一个输入结束符并让一个规则匹配并捕获它。
如果来源是一个以空字符串结尾的字符串，则匹配一个空字符串就可以了。如果来源是一个文件，你可以在文件后添加一个换行（或其它不会出现的标记）；通过识别这个字符，以检查这是否为一个标记点并执行相应的操作。同样，你也可以使用YYFILL(n)判断是否没有足够的字符可用时结束扫描。


&lt;/pre&gt;
</description>
        <pubDate>Wed, 28 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/lang/2018/02/28/re2c.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/lang/2018/02/28/re2c.html</guid>
        
        
        <category>lang</category>
        
      </item>
    
      <item>
        <title>Jekyll目录结构和运行机理</title>
        <description>&lt;p&gt;https://github.com/xiazemin/jekyll-paginate-plugin
&lt;!-- more --&gt;
Jekyll使用Ruby脚本根据模板生成静态网页，实现了内容与排版的分离。模板以嵌入Liquid脚本的HTML格式存放。内容为markdown或者html。&lt;/p&gt;

&lt;p&gt;正常的Jekyll工程包含以下几个目录：&lt;/p&gt;

&lt;p&gt;_posts  博客内容
_pages  其他需要生成的网页，如About页
_layouts 网页排版模板
_includes 被模板包含的HTML片段，可在_config.yml中修改位置
assets 辅助资源 css布局 js脚本 图片等
_data 动态数据
_sites  最终生成的静态网页&lt;/p&gt;

&lt;p&gt;在项目文件夹(含有_config.yml)中运行jekyll build 指令后，jekyll会依次做如下几件事&lt;/p&gt;

&lt;p&gt;加载_layout文件夹内的所有模板，并将其中的%include html% 字段按照_includes文件夹内对应文件填入
遍历_post文件夹及子文件夹，对所有命名符合yyyy-mm–dd-title.md 格式的博客文件放入site.posts 变量(按时间倒序)，并对其进行解析，根据Front Matter 头的内容套入layout生成对应title的博客
遍历整个项目子目录，扫描所有含Front Matter 头的文件，放入site.pages 变量并根据permalink 字段指定的URL目标位置生成index.html
在生成过程中，文件中包含的Liquid脚本&amp;lt;p&amp;gt;http://docs.php.net/manual/zh/features.gc.collecting-cycles.php#features.gc.collecting-cycles
&lt;!-- more --&gt;
传统上，像以前的 php 用到的引用计数内存机制，无法处理循环的引用内存泄漏。然而 5.3.0 PHP 使用文章» 引用计数系统中的同步周期回收(Concurrent Cycle Collection in Reference Counted Systems)中的同步算法，来处理这个内存泄漏问题。&amp;lt;/p&amp;gt;&lt;/p&gt;

&lt;p&gt;对算法的完全说明有点超出这部分内容的范围，将只介绍其中基础部分。首先，我们先要建立一些基本规则，如果一个引用计数增加，它将继续被使用，当然就不再在垃圾中。如果引用计数减少到零，所在变量容器将被清除(free)。就是说，仅仅在引用计数减少到非零值时，才会产生垃圾周期(garbage cycle)。其次，在一个垃圾周期中，通过检查引用计数是否减1，并且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾。
&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/php.png&quot; /&gt;
为避免不得不检查所有引用计数可能减少的垃圾周期，这个算法把所有可能根(possible roots 都是zval变量容器),放在根缓冲区(root buffer)中(用紫色来标记，称为疑似垃圾)，这样可以同时确保每个可能的垃圾根(possible garbage root)在缓冲区中只出现一次。仅仅在根缓冲区满了时，才对缓冲区内部所有不同的变量容器执行垃圾回收操作。看上图的步骤 A。&lt;/p&gt;

&lt;p&gt;在步骤 B 中，模拟删除每个紫色变量。模拟删除时可能将不是紫色的普通变量引用数减”1”，如果某个普通变量引用计数变成0了，就对这个普通变量再做一次模拟删除。每个变量只能被模拟删除一次，模拟删除后标记为灰（原文说确保不会对同一个变量容器减两次”1”,不对的吧）。&lt;/p&gt;

&lt;p&gt;在步骤 C 中，模拟恢复每个紫色变量。恢复是有条件的，当变量的引用计数大于0时才对其做模拟恢复。同样每个变量只能恢复一次，恢复后标记为黑，基本就是步骤 B 的逆运算。这样剩下的一堆没能恢复的就是该删除的蓝色节点了，在步骤 D 中遍历出来真的删除掉。&lt;/p&gt;

&lt;p&gt;算法中都是模拟删除、模拟恢复、真的删除，都使用简单的遍历即可（最典型的深搜遍历）。复杂度为执行模拟操作的节点数正相关，不只是紫色的那些疑似垃圾变量。&lt;/p&gt;

&lt;p&gt;现在，你已经对这个算法有了基本了解，我们回头来看这个如何与PHP集成。默认的，PHP的垃圾回收机制是打开的，然后有个 php.ini 设置允许你修改它：zend.enable_gc 。&lt;/p&gt;

&lt;p&gt;当垃圾回收机制打开时，每当根缓存区存满时，就会执行上面描述的循环查找算法。根缓存区有固定的大小，可存10,000个可能根,当然你可以通过修改PHP源码文件Zend/zend_gc.c中的常量GC_ROOT_BUFFER_MAX_ENTRIES，然后重新编译PHP，来修改这个10,000值。当垃圾回收机制关闭时，循环查找算法永不执行，然而，可能根将一直存在根缓冲区中，不管在配置中垃圾回收机制是否激活。&lt;/p&gt;

&lt;p&gt;当垃圾回收机制关闭时，如果根缓冲区存满了可能根，更多的可能根显然不会被记录。那些没被记录的可能根，将不会被这个算法来分析处理。如果他们是循环引用周期的一部分，将永不能被清除进而导致内存泄漏。&lt;/p&gt;

&lt;p&gt;即使在垃圾回收机制不可用时，可能根也被记录的原因是，相对于每次找到可能根后检查垃圾回收机制是否打开而言，记录可能根的操作更快。不过垃圾回收和分析机制本身要耗不少时间。&lt;/p&gt;

&lt;p&gt;除了修改配置zend.enable_gc ，也能通过分别调用gc_enable() 和 gc_disable()函数来打开和关闭垃圾回收机制。调用这些函数，与修改配置项来打开或关闭垃圾回收机制的效果是一样的。即使在可能根缓冲区还没满时，也能强制执行周期回收。你能调用gc_collect_cycles()函数达到这个目的。这个函数将返回使用这个算法回收的周期数。&lt;/p&gt;

&lt;p&gt;允许打开和关闭垃圾回收机制并且允许自主的初始化的原因，是由于你的应用程序的某部分可能是高时效性的。在这种情况下，你可能不想使用垃圾回收机制。当然，对你的应用程序的某部分关闭垃圾回收机制，是在冒着可能内存泄漏的风险，因为一些可能根也许存不进有限的根缓冲区。因此，就在你调用gc_disable()函数释放内存之前，先调用gc_collect_cycles()函数可能比较明智。因为这将清除已存放在根缓冲区中的所有可能根，然后在垃圾回收机制被关闭时，可留下空缓冲区以有更多空间存储可能根。&lt;/p&gt;
&lt;p&gt;会被解析并替换。Liquid指令 包括Object、Tag、Filter三类，其中object是变量，在解析过程中会被直接文本替换
Tag是控制流，可以做判断和循环
Filter用于对文本进一步处理
.yml文件中，字段的冒号后面必须有空格！&lt;/p&gt;

&lt;p&gt;为了添加除博客以外的页面集合(如Projects)，可将含有Front Matter头的文件放入除_posts之外的任意目录，便可被添入site.pages 变量中。为了与posts相区分，一般来说应该在网页头部添加一个变量，如type 并在对应生成循环中逐个判断。&lt;/p&gt;

&lt;p&gt;首先说说jeykll , 它是一个静态博客系统，你也可以把jekyll当作是一个工具，它可以将特定格式，如markdown, 或者texttile语法格式编辑的文本文件直接转换成html , 当作网页显示。大家都知道使用markdown等语法来编辑发布博客是一件很轻松愉快的事情，比起直接写html或者jsp，自然轻松许多。 jeykll系统的运行依赖ruby运行时，说明jekyll是使用ruby语言开发的。jekyll 可以在本地环境下安装，使用jekyll –server可以在本地启动一个WebRick的HTTP服务器，浏览器访问localhost:4000便可以预览博客。更多关于jekyll系统生成的文件目录以及每个文件夹里文件的作用，可以查看jeykll的官方文档。其次我们再来说说octopress, 看了octopress的官方文档之后，你会发现他的目录结构和jekyll大同小异。这充分说明了octopress是基于jekyll开发的一套高定制化的静态博客系统，你可以把它理解成属于jekyll的二次开发，类似于android与miui, flyme之间的关系。Github pages在其中充当的角色，仅仅是提供了一个jekyll的运行环境，还有项目托管，让用户不仅仅能够使用jeykll来搭建一个静态博客，而且还能够使用Git的方式来更新和管理博客。最后说说使用octopress在github上搭建博客的基本原理: 关于一些如何安装jekyll，octopress，以及和github项目库的连接这些准备工作我就不啰嗦了，直接看下文。新建一篇文章命令行 执行rake new_title[“我的第一篇博客”]这时候会在source/_post目录下自动生成一个[时间][Title].markdown文件(文件名以及后缀可以自己设定)使用octopress可以用多项设置，你可以设置博客的Header, Footer, 已经每篇文章显示样式，字体大小。octopress默认还为用户添加了博客评论，收藏，分享到facebook, google plus , tw等，这也可以通过修改gemfile中的配置信息进行功能添加或者删除。我们还可以自己添加多个模块，例如中国的一些分享，评论插件。还可以自己定义独立页面。编辑完成后，使用rake generate 命令，octopress便会将.markdown文件自动转换成html文件，生成的文件会保存在sass目录下。当用户访问我们的网页时，便会加载各种css样式以及模板文件和配置信息。然后你可以使用rake preview命令在本地启动一个WebRick服务器预览你的博客，ctrl+c可以关闭服务器。最后使用rake deploy命令将本地生成的博客push到github上的远程库里。注意，在使用rake deploy命令后，octopress会首先将generate好的博客文件(包括html,css,js,img等)全部放到_deploy目录下。一般配置好octopress与你github上的repository后，其会自动为你新建一个分支，默认叫做source分支，主分支叫做master。master分支的内容不需要我们手动去pull和push，这些动作octopress会帮助我们完成。我们所有的修改全部是在source分支下完成的。&lt;/p&gt;

&lt;p&gt;Bundle介绍：&lt;/p&gt;

&lt;p&gt;Rails 3中引入Bundle来管理项目中所有gem依赖，该命令只能在一个含有Gemfile的目录下执行，如rails 3项目的根目录。&lt;/p&gt;

&lt;p&gt;关于Gemfile和Gemfile.lock&lt;/p&gt;

&lt;p&gt;所有Ruby项目的信赖包都在Gemfile中进行配置，不再像以往那样，通过require来查找。Rails 3中如果需要require某个gem包，必须通过修改Gemfile文件来管理。&lt;/p&gt;

&lt;p&gt;Gemfile.lock则用来记录本机目前所有依赖的Ruby Gems及其版本。所以强烈建议将该文件放入版本控制器，从而保证大家基于同一环境下工作。&lt;/p&gt;

&lt;p&gt;Bundle命令详解：&lt;/p&gt;

&lt;h1 id=&quot;显示所有的依赖包&quot;&gt;显示所有的依赖包&lt;/h1&gt;
&lt;p&gt;$ bundle show&lt;/p&gt;

&lt;h1 id=&quot;显示指定gem包的安装位置&quot;&gt;显示指定gem包的安装位置&lt;/h1&gt;
&lt;p&gt;$ bundle show [gemname]&lt;/p&gt;

&lt;h1 id=&quot;检查系统中缺少那些项目以来的gem包&quot;&gt;检查系统中缺少那些项目以来的gem包&lt;/h1&gt;
&lt;h1 id=&quot;注如果系统中存在所有项目以来的包则会输出the-gemfiles-dependencies-are-satisfied&quot;&gt;注：如果系统中存在所有项目以来的包，则会输出：The Gemfile’s dependencies are satisfied&lt;/h1&gt;
&lt;p&gt;$ bundle check&lt;/p&gt;

&lt;h1 id=&quot;安装项目依赖的所有gem包&quot;&gt;安装项目依赖的所有gem包&lt;/h1&gt;
&lt;h1 id=&quot;注此命令会尝试更新系统中已存在的gem包&quot;&gt;注：此命令会尝试更新系统中已存在的gem包&lt;/h1&gt;
&lt;p&gt;$ bundle install&lt;/p&gt;

&lt;h1 id=&quot;安装指定的gem包&quot;&gt;安装指定的gem包&lt;/h1&gt;
&lt;p&gt;$ bundle install [gemname]&lt;/p&gt;

&lt;h1 id=&quot;更新系统中存在的项目依赖包并同时更新项目gemfilelock文件&quot;&gt;更新系统中存在的项目依赖包，并同时更新项目Gemfile.lock文件&lt;/h1&gt;
&lt;p&gt;$ bundle update&lt;/p&gt;

&lt;h1 id=&quot;更新系统中指定的gem包信息并同时更新项目gemfilelock中指定的包信息&quot;&gt;更新系统中指定的gem包信息，并同时更新项目Gemfile.lock中指定的包信息&lt;/h1&gt;
&lt;p&gt;$ bundle update [gemname]&lt;/p&gt;

&lt;h1 id=&quot;向项目中添加新的gem包引用&quot;&gt;向项目中添加新的gem包引用&lt;/h1&gt;
&lt;p&gt;$ gem [gemname], [ver]&lt;/p&gt;

&lt;h1 id=&quot;你还可以指定包依赖关系&quot;&gt;你还可以指定包依赖关系&lt;/h1&gt;
&lt;p&gt;$ gem [gemname], :require =&amp;gt; [dependence_gemname]&lt;/p&gt;

&lt;h1 id=&quot;你甚至还可以指定gem包的git源&quot;&gt;你甚至还可以指定gem包的git源&lt;/h1&gt;
&lt;p&gt;$ gem [gemname], :git =&amp;gt; [git_source_url]&lt;/p&gt;

&lt;h1 id=&quot;锁定当前环境&quot;&gt;锁定当前环境&lt;/h1&gt;
&lt;h1 id=&quot;可以使用bundle-lock来锁定当前环境这样便不能通过bundle-update来更新依赖包的版本保证了统一的环境&quot;&gt;可以使用bundle lock来锁定当前环境，这样便不能通过bundle update来更新依赖包的版本，保证了统一的环境&lt;/h1&gt;
&lt;p&gt;$ bundle lock&lt;/p&gt;

&lt;h1 id=&quot;解除锁定&quot;&gt;解除锁定&lt;/h1&gt;
&lt;p&gt;$ bundle unlock&lt;/p&gt;

&lt;h1 id=&quot;打包当装环境&quot;&gt;打包当装环境&lt;/h1&gt;
&lt;h1 id=&quot;bundle-package会把当前所有信赖的包都放到-vendorcache-目录下发布时可用来保证包版本的一致性&quot;&gt;bundle package会把当前所有信赖的包都放到 ./vendor/cache/ 目录下，发布时可用来保证包版本的一致性。&lt;/h1&gt;
&lt;p&gt;$ bundle package&lt;/p&gt;

&lt;p&gt;Make sure all dependencies in your Gemfile are available to your application.
$ bundle install [–binstubs=PATH] [–clean] [–deployment] [–frozen]
                 [–full-index] [–gemfile=FILE] [–local] [–no-cache]
                 [–no-prune] [–path=PATH] [–quiet] [–shebang=STRING]
                 [–standalone=ARRAY] [–system] [–without=GROUP GROUP]
                 [–trust-policy=SECURITYLEVEL]
Options:&lt;/p&gt;

&lt;p&gt;–binstubs: Generate bin stubs for bundled gems to ./bin&lt;/p&gt;

&lt;p&gt;–clean: Run bundle clean automatically after install&lt;/p&gt;

&lt;p&gt;–deployment: Install using defaults tuned for deployment environments&lt;/p&gt;

&lt;p&gt;–frozen: Do not allow the Gemfile.lock to be updated after this install&lt;/p&gt;

&lt;p&gt;–full-index: Use the rubygems modern index instead of the API endpoint&lt;/p&gt;

&lt;p&gt;–gemfile: Use the specified gemfile instead of Gemfile&lt;/p&gt;

&lt;p&gt;–jobs: Install gems using parallel workers.&lt;/p&gt;

&lt;p&gt;–local: Do not attempt to fetch gems remotely and use the gem cache instead&lt;/p&gt;

&lt;p&gt;–no-cache: Don’t update the existing gem cache.&lt;/p&gt;

&lt;p&gt;–no-prune: Don’t remove stale gems from the cache.&lt;/p&gt;

&lt;p&gt;–path: Specify a different path than the system default ($BUNDLE_PATH or $GEM_HOME). Bundler will remember this value for future installs on this machine&lt;/p&gt;

&lt;p&gt;–quiet: Only output warnings and errors.&lt;/p&gt;

&lt;p&gt;–retry: Retry network and git requests that have failed.&lt;/p&gt;

&lt;p&gt;–shebang: Specify a different shebang executable name than the default (usually ‘ruby’)&lt;/p&gt;

&lt;p&gt;–standalone: Make a bundle that can work without the Bundler runtime&lt;/p&gt;

&lt;p&gt;–system: Install to the system location ($BUNDLE_PATH or $GEM_HOME) even if the bundle was previously installed somewhere else for this application&lt;/p&gt;

&lt;p&gt;–trust-policy: Sets level of security when dealing with signed gems. Accepts &lt;code&gt;LowSecurity&lt;/code&gt;, &lt;code&gt;MediumSecurity&lt;/code&gt; and &lt;code&gt;HighSecurity&lt;/code&gt; as values.&lt;/p&gt;

&lt;p&gt;–without: Exclude gems that are part of the specified named group.&lt;/p&gt;

&lt;p&gt;Gems will be installed to your default system location for gems. If your system gems are stored in a root-owned location (such as in Mac OSX), bundle will ask for your root password to install them there.&lt;/p&gt;

&lt;p&gt;While installing gems, Bundler will check vendor/cache and then your system’s gems. If a gem isn’t cached or installed, Bundler will try to install it from the sources you have declared in your Gemfile.&lt;/p&gt;

&lt;p&gt;The –system option is the default. Pass it to switch back after using the –path option as described below.&lt;/p&gt;

&lt;p&gt;Install your dependencies, even gems that are already installed to your system gems, to a location other than your system’s gem repository. In this case, install them to vendor/bundle.
$ bundle install –path vendor/bundle
Further bundle commands or calls to Bundler.setup or Bundler.require will remember this location.
Learn More: Bundler.setup
Learn More: Bundler.require
Install all dependencies except those in groups that are explicitly excluded.
$ bundle install –without development test
Learn More: Groups
Install all dependencies on to a production server. Do not use this flag on a development machine.
$ bundle install –deployment
The –deployment flag activates a number of deployment-friendly conventions:&lt;/p&gt;

&lt;p&gt;Isolate all gems into vendor/bundle
Require an up-to-date Gemfile.lock
If bundle package was run, do not fetch gems from rubygems.org. Instead, only use gems in the checked in vendor/cache
Learn More: Deploying
Install gems parallely by starting the number of workers specificed.
$ bundle install –jobs 4
Retry failed network or git requests.
$ bundle install –retry 3&lt;/p&gt;

&lt;p&gt;一、Ruby
jekyll提供了很多现成的主题可以使用，里面有很多高大上的款式。&lt;/p&gt;

&lt;p&gt;官网上面有专门一节是介绍安装的，不过在实际安装中还是会有一些问题。&lt;/p&gt;

&lt;p&gt;需要有下载Ruby环境，选最新的那个版本即可，官网上面安装列中有一个RubyGems，但Ruby1.9.1 以后版本已经自带了，所以无需额外下载。&lt;/p&gt;

&lt;p&gt;二、切换source源
由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。&lt;/p&gt;

&lt;p&gt;有两张方法，一种是切换到淘宝，另外一种是切换到ruby-china，网上大部分的教程都是用淘宝的。&lt;/p&gt;

&lt;p&gt;在用淘宝的后老是会出现认证错误，后面上google查问题，发现淘宝的已经不维护了，详见《Ruby China的RubyGems 镜像上线》&lt;/p&gt;

&lt;p&gt;我把两种方法都记录了一下，&lt;/p&gt;

&lt;p&gt;1） ruby-china&lt;/p&gt;

&lt;p&gt;将source改成“https://gems.ruby-china.org/”，在打开的页面中，会告诉你几个指令。&lt;/p&gt;

&lt;p&gt;由于我先用了taobao的source，所以这里remove的是淘宝的。&lt;/p&gt;

&lt;p&gt;ruby-china中说道：“如果遇到 SSL 证书问题，你又无法解决，请直接用 http://gems.ruby-china.org 避免 SSL 的问题。”&lt;/p&gt;

&lt;p&gt;2） taobao&lt;/p&gt;

&lt;p&gt;将source改成“https://ruby.taobao.org/”，在打开的页面中，会告诉你几个指令。&lt;/p&gt;

&lt;p&gt;如果在输入指令出错的话，如下图所示，就是要让你下载下载证书文件。&lt;/p&gt;

&lt;p&gt;然后放到某个位置，输入指令set，“D:\Ruby23-x64\cacert.pem”就是文件的具体路径&lt;/p&gt;

&lt;p&gt;set SSL_CERT_FILE=D:\Ruby23-x64\cacert.pem&lt;/p&gt;

&lt;p&gt;也可以将“SSL_CERT_FILE”设置为环境变量，这样就不用每次都要输入设置的指令。&lt;/p&gt;

&lt;p&gt;不知为何，后面我加载包的时候，就是会出现问题，囧，也许是我做了什么操作导致的，额额额。&lt;/p&gt;

&lt;p&gt;三、安装jekyll
在输入安装指令后，就会看到默认安装了14个包。&lt;/p&gt;

&lt;p&gt;gem install jekyll&lt;/p&gt;

&lt;p&gt;四、启动
从主题列表中选了两个，Minimal Mistakes和Jekyll Clean。前者页面比较全但相对比较复杂，后者页面少但很简洁。&lt;/p&gt;

&lt;p&gt;输入指令，&lt;/p&gt;

&lt;p&gt;jekyll serve –watch&lt;/p&gt;

&lt;p&gt;在显示的文字中有一句让你安装“wdm”，会在下面介绍。&lt;/p&gt;

&lt;p&gt;在页面中输入“http://localhost:4000/jekyll-clean/index.html”后就能看到页面了。&lt;/p&gt;

&lt;p&gt;五、wdm
从 v2.4.0 开始，Jekyll 本地部署时，会相当于以前版本加 –watch 一样，监听其源文件的变化。&lt;/p&gt;

&lt;p&gt;而 Windows 似乎有时候并不会奏效，若你碰到，可安装 wdm (Windows Directory Monitor ) 来改善这个问题。&lt;/p&gt;

&lt;p&gt;如果要安装“wdm”得要先安装“Devkit”，在打开的网站中下载后，会让你解压到某个文件夹，接下来就是进入到这个文件夹中。&lt;/p&gt;

&lt;p&gt;执行指令“ruby dk.rb init”。&lt;/p&gt;

&lt;p&gt;再执行指令“ruby dk.rb install”，不过提示我先去修改“config.yml”中的路径。&lt;/p&gt;

&lt;p&gt;config.yml文件就在解压出来的文件中。&lt;/p&gt;

&lt;p&gt;再执行install指令。&lt;/p&gt;

&lt;p&gt;六、Gemfile文件
Gemfile是一个用于描述gem之间依赖的文件。gem是一堆Ruby代码的集合，它能够为我们提供调用。&lt;/p&gt;

&lt;p&gt;Gemfile是可通过Bundler创建。&lt;/p&gt;

&lt;p&gt;gem install bundler
bundle init
bundle install
Gemfile文件中设置的内容如下：&lt;/p&gt;

&lt;p&gt;source “https://rubygems.org”&lt;/p&gt;

&lt;p&gt;gem “jekyll-paginate”
gem “kramdown”
gem “jekyll-watch”
gem “wdm”, “~&amp;gt; 0.1.0” if Gem.win_platform?&lt;/p&gt;

&lt;p&gt;七、自动刷新页面
1）修改Gemfile文件&lt;/p&gt;

&lt;p&gt;gem ‘guard’
gem ‘guard-jekyll-plus’
gem ‘guard-livereload’
要添加三个包，执行“bundle install”，如果执行出错，那就一个一个加吧。&lt;/p&gt;

&lt;p&gt;2）创建guard配置文件&lt;/p&gt;

&lt;p&gt;执行指令，将会生成一个Guardfile文件。&lt;/p&gt;

&lt;p&gt;guard init
生成的Guardfile文件内有一些代码，在代码的最后添加如下代码：&lt;/p&gt;

&lt;p&gt;guard ‘jekyll-plus’, :serve =&amp;gt; true do
  watch /.*/
  ignore /^_site/
end&lt;/p&gt;

&lt;p&gt;guard ‘livereload’ do
  watch /.*/
end&lt;/p&gt;

&lt;p&gt;3）添加livereload插件&lt;/p&gt;

&lt;p&gt;安装Live Reload Extension，如果是chrome，就到Chrome Web Store下载。&lt;/p&gt;

&lt;p&gt;安装成功后，在右上角可以看到一个小按钮&lt;/p&gt;

&lt;p&gt;如果是运行状态，那么会自动添加一个js文件引用：&lt;/p&gt;

&lt;p&gt;4）运行&lt;/p&gt;

&lt;p&gt;执行运行指令：&lt;/p&gt;

&lt;p&gt;bundle exec guard start
这里注意一下，livereload要先关闭。&lt;/p&gt;

&lt;p&gt;运行上面指令，当出现下面的内容后，再运行livereload。&lt;/p&gt;

&lt;p&gt;然后会出现“connected”连接了，接下来修改内容就会自动刷新页面了。&lt;/p&gt;

&lt;p&gt;试用后发现，有时候会刷新不成功，还是原来的样子，看来某些地方还需要改进。&lt;/p&gt;

&lt;p&gt;demo下载：&lt;/p&gt;

&lt;p&gt;http://download.csdn.net/detail/loneleaf1/9508074&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/jekyll/2018/02/28/jekyll_inside.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/jekyll/2018/02/28/jekyll_inside.html</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
      <item>
        <title>CollectingCycles</title>
        <description>&lt;p&gt;http://docs.php.net/manual/zh/features.gc.collecting-cycles.php#features.gc.collecting-cycles
&lt;!-- more --&gt;
传统上，像以前的 php 用到的引用计数内存机制，无法处理循环的引用内存泄漏。然而 5.3.0 PHP 使用文章» 引用计数系统中的同步周期回收(Concurrent Cycle Collection in Reference Counted Systems)中的同步算法，来处理这个内存泄漏问题。&lt;/p&gt;

&lt;p&gt;对算法的完全说明有点超出这部分内容的范围，将只介绍其中基础部分。首先，我们先要建立一些基本规则，如果一个引用计数增加，它将继续被使用，当然就不再在垃圾中。如果引用计数减少到零，所在变量容器将被清除(free)。就是说，仅仅在引用计数减少到非零值时，才会产生垃圾周期(garbage cycle)。其次，在一个垃圾周期中，通过检查引用计数是否减1，并且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾。
&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/php.png&quot; /&gt;
为避免不得不检查所有引用计数可能减少的垃圾周期，这个算法把所有可能根(possible roots 都是zval变量容器),放在根缓冲区(root buffer)中(用紫色来标记，称为疑似垃圾)，这样可以同时确保每个可能的垃圾根(possible garbage root)在缓冲区中只出现一次。仅仅在根缓冲区满了时，才对缓冲区内部所有不同的变量容器执行垃圾回收操作。看上图的步骤 A。&lt;/p&gt;

&lt;p&gt;在步骤 B 中，模拟删除每个紫色变量。模拟删除时可能将不是紫色的普通变量引用数减”1”，如果某个普通变量引用计数变成0了，就对这个普通变量再做一次模拟删除。每个变量只能被模拟删除一次，模拟删除后标记为灰（原文说确保不会对同一个变量容器减两次”1”,不对的吧）。&lt;/p&gt;

&lt;p&gt;在步骤 C 中，模拟恢复每个紫色变量。恢复是有条件的，当变量的引用计数大于0时才对其做模拟恢复。同样每个变量只能恢复一次，恢复后标记为黑，基本就是步骤 B 的逆运算。这样剩下的一堆没能恢复的就是该删除的蓝色节点了，在步骤 D 中遍历出来真的删除掉。&lt;/p&gt;

&lt;p&gt;算法中都是模拟删除、模拟恢复、真的删除，都使用简单的遍历即可（最典型的深搜遍历）。复杂度为执行模拟操作的节点数正相关，不只是紫色的那些疑似垃圾变量。&lt;/p&gt;

&lt;p&gt;现在，你已经对这个算法有了基本了解，我们回头来看这个如何与PHP集成。默认的，PHP的垃圾回收机制是打开的，然后有个 php.ini 设置允许你修改它：zend.enable_gc 。&lt;/p&gt;

&lt;p&gt;当垃圾回收机制打开时，每当根缓存区存满时，就会执行上面描述的循环查找算法。根缓存区有固定的大小，可存10,000个可能根,当然你可以通过修改PHP源码文件Zend/zend_gc.c中的常量GC_ROOT_BUFFER_MAX_ENTRIES，然后重新编译PHP，来修改这个10,000值。当垃圾回收机制关闭时，循环查找算法永不执行，然而，可能根将一直存在根缓冲区中，不管在配置中垃圾回收机制是否激活。&lt;/p&gt;

&lt;p&gt;当垃圾回收机制关闭时，如果根缓冲区存满了可能根，更多的可能根显然不会被记录。那些没被记录的可能根，将不会被这个算法来分析处理。如果他们是循环引用周期的一部分，将永不能被清除进而导致内存泄漏。&lt;/p&gt;

&lt;p&gt;即使在垃圾回收机制不可用时，可能根也被记录的原因是，相对于每次找到可能根后检查垃圾回收机制是否打开而言，记录可能根的操作更快。不过垃圾回收和分析机制本身要耗不少时间。&lt;/p&gt;

&lt;p&gt;除了修改配置zend.enable_gc ，也能通过分别调用gc_enable() 和 gc_disable()函数来打开和关闭垃圾回收机制。调用这些函数，与修改配置项来打开或关闭垃圾回收机制的效果是一样的。即使在可能根缓冲区还没满时，也能强制执行周期回收。你能调用gc_collect_cycles()函数达到这个目的。这个函数将返回使用这个算法回收的周期数。&lt;/p&gt;

&lt;p&gt;允许打开和关闭垃圾回收机制并且允许自主的初始化的原因，是由于你的应用程序的某部分可能是高时效性的。在这种情况下，你可能不想使用垃圾回收机制。当然，对你的应用程序的某部分关闭垃圾回收机制，是在冒着可能内存泄漏的风险，因为一些可能根也许存不进有限的根缓冲区。因此，就在你调用gc_disable()函数释放内存之前，先调用gc_collect_cycles()函数可能比较明智。因为这将清除已存放在根缓冲区中的所有可能根，然后在垃圾回收机制被关闭时，可留下空缓冲区以有更多空间存储可能根。&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/lang/2018/02/28/CollectingCycles.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/lang/2018/02/28/CollectingCycles.html</guid>
        
        
        <category>lang</category>
        
      </item>
    
      <item>
        <title>type_hinting</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;从PHP5开始，我们可以使用类型提示来指定定义函数时，函数接收的参数类型。如果在定义函数时，指定了参数的类型，那么当我们调用函数时，如果实参的类型与指定的类型不符，那么PHP会产生一个致命级别的错误(Catchable fatal error)。&lt;/p&gt;

&lt;p&gt;类名称和数组&lt;/p&gt;

&lt;p&gt;在定义函数时，PHP只支持两种类型声明：类名称和数组。类名称表名该参数接收的实参为对应类实例化的对象，数组表明接收的实参为数组类型。下面是一个例子：
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;function demo(array $options){
  var_dump($options);
}&lt;/p&gt;

&lt;p&gt;在定义demo()函数的时候，指定了函数接收的参数类型为数组。如果我们调用函数时，传入的参数不是数组类型，例如像下面这样的调用：
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;$options=’options’;
demo($options);&lt;/p&gt;

&lt;p&gt;那么将产生以下错误：
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;Catchable fatal error: Argument 1 passed to demo() must be of the type array, string given,
可以使用null作为默认参数&lt;/p&gt;

&lt;p&gt;注意&lt;/p&gt;

&lt;p&gt;有一点需要特别注意的是，PHP只支持两种类型的类型声明,其他任何标量类型的声明都是不支持的，比如下下面的代码都将产生错误:
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;function demo(string $str){
}
$str=”hello”;
demo($str)
当我们运行上面的代码时，string会被当做类名称对待，因此会报下面的错误:
Catchable fatal error: Argument 1 passed to demo() must be an instance of string, string given,&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;p&gt;类型声明也是PHP面向对象的一个进步吧，尤其是在捕获某种指定类型的异常时非常有用。
使用类型声明，也可以增加代码的可读性。
但是，由于PHP是弱类型的语言，使用类型声明又于PHP设计的初衷相悖。&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/02/26/type_hinting.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/02/26/type_hinting.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>tsrm</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;名词解释：
TSRM
线程安全资源管理器(Thread Safe Resource Manager)，这是个尝尝被忽视，并很少被人说起的“层”(layer), 她在PHP源码的/TSRM目录下。一般的情况下，这个层只会在被指明需要的时候才会被启用(比如,Apache2+worker MPM,一个基于线程的MPM)，对于Win32下的Apache来说，是基于多线程的，所以这个层在Win32下总是被启用的。
ZTS
Zend线程安全(Zend Thread Safety)，当TSRM被启用的时候，就会定义这个名为ZTS的宏。
tsrm_ls
TSRM存储器(TSRM Local Storage)，这个是在扩展和Zend中真正被实际使用的指代TSRM存储的变量名。
TSRMLS_??
这是一族(4个)宏，用来根据ZTS宏被定义与否来实现TSRM。4个宏如下：&lt;/p&gt;

&lt;p&gt;#define TSRMLS_C   tsrm_ls
#define TSRMLS_D   void  &lt;em&gt;** tsrm_ls
#define TSRMLS_CC  ,tsrm_ls
#define TSRMLS_DS  ,void  **&lt;/em&gt;tsrm_ls   //注意有个逗号&lt;/p&gt;

&lt;p&gt;我们都知道，在C或者PHP编程中，要在多个函数中访问同一个变量有俩种方式，一种是通过参数传递，比如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
 
void output_func(char *message)
{
    printf(&quot;%s\n&quot;, message);
}
 
int main(int argc, char *argv[])
{
    output_func(argv[0]);
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一种方式是，通过在函数的高一级作用域中存储这个变量(当然，对于PHP，要显示的指明Global变量(这个原因和PHP的作用域的实现－活动表有关系，本处不涉及，我会在将来的某篇文章中介绍她)，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
 
char *message;
 
void output_func(void)
{
    printf(&quot;%s\n&quot;, message);
}
 
int main(int argv, char *argv[])
{
    message = argv[0];
    output_func();
 
    return 0; } 对于在PHP使用第二种方式来说，一般的单线 程模型比如PHP CLI方式，Apache1，或者Apache2+prefork MPM(也是一种多进程模型)，可以放心的被使用，也不会出错。全局变量在MINIT/RINIT的时候被创建，然后在整个进程运行时/请求处理期都能被 访问到，然后在MSHUTDOW/RSHUTDOWN的时候被释放。 但是在多线程的模型下，这种方式就不在安全了，比如Apache2+worker MPM和IIS。在这种情况下，所有的线程共享同一个进程的地址空间，也就说，多个线程共用一个全局变量，这个时候就会产生竞争。用C程序员的方式来说: 这个时候的全局变量是非线程安全的。 为了解决这个问题，并和单线程模式兼容，Zend使用了称作“Non_global Globals”的机制。这个机制的主要思想就是，对于多线程模型来说，每当一个新的线程被创建，就单独的分配一块内存，这块内存存储着一个全局变量的副 本。而这块内存会被一个Vector串起来，由Zend统一管理。为了说明这个方式，咱们看看如下的例子：

typedef struct _zend_myextension_globals {
    int foo;
    char *bar;
} zend_myextension_globals;
 
#ifdef ZTS  //如果TSRM被启用
int myextension_globals_id;
#else
zend_myextension_globals myextension_globals;
#endif
 
/* 当线程被创建的时候调用 */
static void php_myextension_globals_ctor(zend_myextension_globals *myext_globals TSRMLS_DC)
{
    myext_globals-&amp;gt;foo = 0;
    myext_globals-&amp;gt;bar = NULL;
}
 
/* 线程结束的时候被调用 */
static void php_myextension_globals_dtor(zend_myextension_globals *myext_globals TSRMLS_DC)
{
    if (myext_globals-&amp;gt;bar) {
        efree(myext_globals-&amp;gt;bar);
    }
}
 
PHP_MINIT_FUNCTION(myextension)
{
#ifdef ZTS
    ts_allocate_id(&amp;amp;myextension_globals_id, sizeof(zend_myextension_globals),
                   php_myextension_globals_ctor, php_myextension_globals_dtor);
#else
    php_myextension_globals_ctor(&amp;amp;myextension_globals TSRMLS_CC);
#endif
 
    return SUCCESS;
}
 
PHP_MSHUTDOWN_FUNCTION(myextension)
{
#ifndef ZTS
    php_myextension_globals_dtor(&amp;amp;myextension_globals TSRMLS_CC);
#endif
 
    return SUCCESS;
} 这个例子开始的时候向TSRM层申明了一个全局变量” zend_myextension_globals”，

    ts_allocate_id(&amp;amp;myextension_globals_id, sizeof(zend_myextension_globals),
                   php_myextension_globals_ctor, php_myextension_globals_dtor); 他指明了要申请的全局变量的大小，创建器和析构器。并讲这个生成的全局变量在Vector中的偏移量(Index)保存在了myextension_globals_id中。而对于没有启用TSRM的情况，这个全局变量只是简单的被创建。 如果你问我“为什么在没有启用TSRM的情况下还会有TSRMLS_CC?”,那说明你现在还没有被我弄糊涂;)，恩，在ZTS没有被设置的情况下(没有启用TSRM)，TSRMLS_CC会被编译器替换为空，因为:

 #ifdef ZTS
          #define TRSMLS_CC  ,tsrm_ls   #else
  #define TSRMLS_CC   #endif 在没有启用TSRM的情况下还指明TSRMLS_CC的原因仅仅是为了保持代码的一致性。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恩，现在已经设置了全局变量，那么接下来的问题就是，我们如果去访问它呢？看看如下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef ZTS
# define   MYEXTENSION_G(v)     \
             (((zend_myextension_globals*)(*((void ***)tsrm_ls))[(myextension_globals_id)-1])-&amp;gt;v)
#else
# define   MYEXTENSION_G(v)     (myextension_globals.v)
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呵呵，明白了吧？ 在ZTS没有被设置的情况下，宏MYEXTENSION_G(V)简单的被等价于全局变量myextension_globals.v，而对于启用了TSRM的情况，MYEXTENSION_G(V)会被转化成在Vector中根据my_extension_globals_id来查找到要访问的全局变量。
现在，只要你在你的代码中，使用MYEXTENSION_G来访问你的全局变量，并在要使用这个全局变量的函数参数列表中添加上TSRMLS_CC，那么就能保证在单线程和多线程模型下的线程安全，和代码一致性&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/02/26/tsrm.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/02/26/tsrm.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>create_function</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;第一部分：介绍php函数 create_function()：&lt;/p&gt;

&lt;p&gt;string create_function    ( string $args   , string $code   )&lt;/p&gt;

&lt;p&gt;string $args 变量部分&lt;/p&gt;

&lt;p&gt;string $code 方法代码部分&lt;/p&gt;

&lt;p&gt;举例：
create_function(‘$fname’,’echo $fname.”Zhang”’)
类似于：
function fT($fname) {
  echo $fname.”Zhang”;
}&lt;/p&gt;

&lt;p&gt;举一个官方提供的例子：
&lt;?php
$newfunc = create_function('$a,$b', 'return &quot;ln($a) + ln($b) = &quot; . log($a * $b);');
echo &quot;New anonymous function: $newfunc&quot;;
echo $newfunc(2, M_E) . &quot;
&quot;;
// outputs
// New anonymous function: lambda_1
// ln(2) + ln(2.718281828459) = 1.6931471805599
?&gt;
第二部分：如何利用create_function(）代码注入&lt;/p&gt;

&lt;p&gt;测试环境版本：&lt;/p&gt;

&lt;p&gt;apache +php 5.2、apache +php 5.3&lt;/p&gt;

&lt;p&gt;有问题的代码：
&lt;?php
//02-8.php?id=2;}phpinfo();/*
$id=$_GET['id'];
$str2='echo  '.$a.'test'.$id.&quot;;&quot;;
echo $str2;
echo &quot;&lt;br/&gt;&quot;;
echo &quot;==============================&quot;;
echo &quot;&lt;br/&gt;&quot;;
$f1 = create_function('$a',$str2);
echo &quot;&lt;br/&gt;&quot;;
echo &quot;==============================&quot;;
?&gt;
利用方法：&lt;/p&gt;

&lt;p&gt;http://localhost/libtest/02-8.php?id=2;}phpinfo();/*&lt;/p&gt;

&lt;p&gt;实现原理：&lt;/p&gt;

&lt;p&gt;由于id=2;}phpinfo();/*&lt;/p&gt;

&lt;p&gt;执行函数为：
源代码：
function fT($a) {
  echo “test”.$a;
}&lt;/p&gt;

&lt;p&gt;注入后代码：
function fT($a) {
  echo “test”;}
  phpinfo();/*;//此处为注入代码。
}&lt;/p&gt;

&lt;p&gt;测试效果：
实现在后台运行前端提交的php代码phpinfo();&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/02/26/create_function.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/02/26/create_function.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>Xdebug</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;Xdebug是一个开源的PHP程序调试工具，可以使用它来调试、跟踪及分析程序运行状态。当然，Xdebug需要结合PHP的编辑工具来打断点、跟踪、调试及分析，比较常用的PHP的Xdebug调试环境：Vim +Xdebug。
Xdebug是一个开源的PHP程序调试工具，可以使用它来调试、跟踪及分析程序运行状态。当然，Xdebug需要结合PHP的编辑工具来打断点、跟踪、调试及分析，比较常用的PHP的Xdebug调试环境：Vim +Xdebug。&lt;/p&gt;

&lt;p&gt;·     安装配置&lt;/p&gt;

&lt;p&gt;·     调试环境&lt;/p&gt;

&lt;p&gt;·     跟踪分析&lt;/p&gt;

&lt;p&gt;·     注意事项&lt;/p&gt;

&lt;p&gt;·     遇到问题&lt;/p&gt;

&lt;p&gt;一、安装配置&lt;/p&gt;

&lt;p&gt;1、安装&lt;/p&gt;

&lt;p&gt;Xdebug的安装是作为PHP的拓展而存在的，所以可参考PHP拓展文章：&lt;/p&gt;

&lt;p&gt;http://blog.csdn.net/why_2012_gogo/article/details/51120645&lt;/p&gt;

&lt;p&gt;2、配置&lt;/p&gt;

&lt;p&gt;php.ini:&lt;/p&gt;

&lt;p&gt;[xdebug]&lt;/p&gt;

&lt;p&gt;;基本调试配置&lt;/p&gt;

&lt;p&gt;xdebug.auto_trace = on&lt;/p&gt;

&lt;p&gt;xdebug.collect_params = on&lt;/p&gt;

&lt;p&gt;xdebug.collect_return = on&lt;/p&gt;

&lt;p&gt;xdebug.profiler_enable = on&lt;/p&gt;

&lt;p&gt;xdebug.profiler_output_dir =”/php/ext/xdebug_profilers”&lt;/p&gt;

&lt;p&gt;xdebug.trace_output_dir = “/tmp/ext/xdebug_traces”&lt;/p&gt;

&lt;p&gt;;远程调试设置&lt;/p&gt;

&lt;p&gt;xdebug.remote_enable = on&lt;/p&gt;

&lt;p&gt;xdebug.remote_host = localhost&lt;/p&gt;

&lt;p&gt;xdebug.remote_port = 9010&lt;/p&gt;

&lt;p&gt;xdebug.remote_autostart = on
zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20131226/xdebug.so&lt;/p&gt;

&lt;p&gt;用xdebug_debug_zval 和debug_backtrace,可以打印出引用计数&lt;/p&gt;

&lt;p&gt;所有的php变量都放在了zval的容器中，一个zval变量容器，除了包含变量的类型和值，也包括了另外两个字段，一个是is_ref（bool），标识此变量是否属于引用集合，&lt;/p&gt;

&lt;p&gt;（reference set）。另外的就是引用计数机制，用来优化内存试用。refcount用以标识指向这个zval变量容器的变量个数。&lt;/p&gt;

&lt;p&gt;变量容器在”refcount“变成0时就被销毁。&lt;/p&gt;

&lt;p&gt;[php] view plain copy
$a = “dog”;&lt;br /&gt;
$c = $b = $a;&lt;br /&gt;
xdebug_debug_zval( ‘a’ );&lt;br /&gt;
unset( $b, $c );&lt;br /&gt;
xdebug_debug_zval( ‘a’ );&lt;br /&gt;
[php] view plain copy
结果：&lt;br /&gt;
a: (refcount=2, is_ref=1)=’dog’
a: (refcount=1, is_ref=0)=’dog’&lt;/p&gt;

&lt;p&gt;但是如果是数组或者对象&lt;/p&gt;

&lt;p&gt;[php] view plain copy
$a=array(‘a’=&amp;gt;’avalue’,’b’=&amp;gt;’bvalue’);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xdebug_debug_zval('a');  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：
a: (refcount=1, is_ref=0)=array (‘a’ =&amp;gt; (refcount=1, is_ref=0)=’avalue’, ‘b’ =&amp;gt; (refcount=1, is_ref=0)=’bvalue’)
[Finished in 0.2s]&lt;/p&gt;

&lt;p&gt;所以它们的成员或属性存在自己的符号表中，所以上面一共有三个zval变量容器。a （array），a，b&lt;/p&gt;

&lt;p&gt;当有变量引用时，用xdebug_debug_zval的到的结果为：is_ref=1;refcount=变量被引用的数量（算上变量本身）
当变量没有发生引用时，用xdebug_debug_zval的到的结果为：is_ref=0;refcount=变量被复制的数量（算上变量本身）&lt;/p&gt;

&lt;p&gt;当有变量引用时，用debug_zval_dump的到的结果为：refcount=1（始终=1）
当变量没有发生引用时，用debug_zval_dump的到的结果为：refcount=变量被复制的数量（算上变量本身）+1&lt;/p&gt;

</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/02/26/Xdebug.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/02/26/Xdebug.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>Closure</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;匿名函数与闭包的区别
匿名函数：没有函数名称的函数；
这就是匿名函数：
function(argument1,argument2){&lt;/p&gt;

&lt;p&gt;}
闭包：一个可以使用另外一个函数作用域中的变量的函数。
如下面的代码函数b就是闭包，但是这个前提是：当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个我们通常所谓的“闭包”。
意思是说b要变成闭包的话，就必须被外包所引用，即c引用：
&lt;script type=&quot;text/javascript&quot;&gt;
function a(){
   var i=1;
   function b(){
       ++i;
      return i;
   }
  return b;
}
var c=a();
alert(c());
&lt;/script&gt;
用一个专业一点的说法就是：函数调用返回后一个没有释放资源的栈区；
一般，当函数执行完毕后，局部活动对象会被销毁，内存中仅保存全局作用域，但闭包的情况是不一样的。闭包的活动对象依然会保存在内存中，于是像上例中，函数调用返回后，变量i是属于活动对象里面的，就是说其栈区还没有释放，但你调用c()的时候i变量保存的作用域链从b()-&amp;gt;a()-&amp;gt;全局去寻找作用域var i声明所在，然后找到了var i=1;然后在闭包内++i;结果，最后输出的值就是2了；不知道这么说有没人明白，如果不明白，那么只要记住它的闭包的两个点就好了，一点就是闭包的活动对象没有被销毁；第二点是作用域链的关键是他要遇到var 声明；就好了····
共同点：他们都有是函数；除此之外没有任何共同点；&lt;/p&gt;

&lt;p&gt;理论上匿名函数和闭包是不一样的概念，在PHP中这两者概念与其他语言（比如JavaScript）是不一样的，这两者在使用上可以视为等同的&lt;/p&gt;

&lt;p&gt;匿名函数、lambda表达式、闭包（closure）区别与作用
　一.匿名函数、lambda、closure区别
　　从功能性上说lambda和closure（或是OC中的blocks）是一个东西，只是不同语言的不同称呼罢了，它们都是匿名函数。若匿名函数捕获了一个外部变量，那么它就是一个closure。
二.匿名函数、lambda、closure作用
　　简单说，引入它们的作用有2个：&lt;/p&gt;

&lt;p&gt;简洁
捕获变量
　　首先说简洁，匿名函数可以在其他函数内部声明与定义，不用另外写个命名函数
　　
自执行的匿名函数&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;什么是自执行的匿名函数?
它是指形如这样的函数: (function {// code})();&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;疑问
为什么(function {// code})();可以被执行, 而function {// code}();却会报错?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分析
(1). 首先, 要清楚两者的区别:
(function {// code})是表达式, function {// code}是函数声明.
(2). 其次, js”预编译”的特点:
js在”预编译”阶段, 会解释函数声明, 但却会忽略表式.
(3). 当js执行到function() {//code}();时, 由于function() {//code}在”预编译”阶段已经被解释过, js会跳过function(){//code}, 试图去执行();, 故会报错;
当js执行到(function {// code})();时, 由于(function {// code})是表达式, js会去对它求解得到返回值, 由于返回值是一 个函数, 故而遇到();时, 便会被执行.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外， 函数转换为表达式的方法并不一定要靠分组操作符()，我们还可以用void操作符，~操作符，!操作符……&lt;/p&gt;

&lt;p&gt;如：
!function(){ 
alert(“另类的匿名函数自执行”); 
}();
匿名函数与闭包&lt;/p&gt;

&lt;p&gt;闭包的英文单词是closure，这是JavaScript中非常重要的一部分知识，因为使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，总之功能十分强大。&lt;/p&gt;

&lt;p&gt;闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕（这点涉及JavaScript作用域链）。
function checkClosure(){ 
var str = ‘rain-man’; 
setTimeout( 
function(){ alert(str); } //这是一个匿名函数 
, 2000); 
} 
checkClosure();
这个例子看上去十分的简单，仔细分析下它的执行过程还是有许多知识点的：checkClosure函数的执行是瞬间的（也许用时只是0.00001毫秒），在checkClosure的函数体内创建了一个变量str，在checkClosure执行完毕之后str并没有被释放，这是因为setTimeout内的匿名函数存在这对str的引用。待到2秒后函数体内的匿名函数被执行完毕,str才被释放。&lt;/p&gt;

&lt;p&gt;闭包是怎么定义的，该如何理解
闭包本身定义比较抽象，MDN官方上解释是：A closure is the combination of a function and the lexical environment within which that function was declared.
中文解释是：闭包是一个函数和该函数被定义时的词法环境的组合。&lt;/p&gt;

&lt;p&gt;看定义好像比较难理解，那就举个经典的例子吧：&lt;/p&gt;

&lt;p&gt;function box(){
  var a = 10;
  function inner(){
    console.log(a) ; 
  }
  return inner;
}
var outer = box();
outer();//10
但是看到这里，还是一脸蒙比，到底哪个是闭包？貌似有三个函数呀，一个box，一个inner还有一个outer = box()。&lt;/p&gt;

&lt;p&gt;先看这几个函数在结构上有什么关系，box是全局的函数，具有局部变量a，inner是box函数内的局部函数，a对于inner是可以访问的，但无法直接在box外部访问box内部的局部变量a，outer是全局的。&lt;/p&gt;

&lt;p&gt;而执行box()后把box内部的inner return了出去，同时在box函数外部用变量outer作为return出去的inner函数的一个接收，可以理解为是box内部inner函数的一个指针引用。&lt;/p&gt;

&lt;p&gt;在box函数执行完毕后，内部的inner还被外部的outer引用着，此时的这个outer就是一个闭包。而inner又对a有引用，所以执行outer会打印a的值，这样就能在box的外部访问到内部的变量a了。
闭包的产生跟普通函数的压栈运行不太一样，普通函数运行时先被压住运行栈内存中，运行完后，函数和其内部变量以及function会释放掉，被内存给回收。但是闭包不会被回收，因为闭包是在函数外部对其内部function的一个指针引用，就像把闭包放在了堆中。&lt;/p&gt;

&lt;p&gt;所以此处的闭包是box函数内部的inner函数以及inner被定义时的词法环境，并且在执行box()后，有变量在外部引用这个inner，inner被定义时的词法环境就是box函数的私有作用域，这样就跟闭包的定义吻合了。&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/lang/2018/02/26/Closure.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/lang/2018/02/26/Closure.html</guid>
        
        
        <category>lang</category>
        
      </item>
    
      <item>
        <title>lex</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;ex
Lex 是一种生成扫描器的工具。扫描器是一种识别文本中的词汇模式的程序。 这些词汇模式（或者常规表达式）在一种特殊的句子结构中定义，这个我们一会儿就要讨论。&lt;/p&gt;

&lt;p&gt;一种匹配的常规表达式可能会包含相关的动作。这一动作可能还包括返回一个标记。 当 Lex 接收到文件或文本形式的输入时，它试图将文本与常规表达式进行匹配。 它一次读入一个输入字符，直到找到一个匹配的模式。 如果能够找到一个匹配的模式，Lex 就执行相关的动作（可能包括返回一个标记）。 另一方面，如果没有可以匹配的常规表达式，将会停止进一步的处理，Lex 将显示一个错误消息。&lt;/p&gt;

&lt;p&gt;Lex 和 C 是强耦合的。一个 .lex 文件（Lex 文件具有 .lex 的扩展名）通过 lex 公用程序来传递，并生成 C 的输出文件。这些文件被编译为词法分析器的可执行版本。&lt;/p&gt;

&lt;p&gt;Lex 的常规表达式
常规表达式是一种使用元语言的模式描述。表达式由符号组成。符号一般是字符和数字，但是 Lex 中还有一些具有特殊含义的其他标记。 下面两个表格定义了 Lex 中使用的一些标记并给出了几个典型的例子。&lt;/p&gt;

&lt;p&gt;用 Lex 定义常规表达式
字符	含义
A-Z, 0-9, a-z	构成了部分模式的字符和数字。
.	匹配任意字符，除了 \n。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;用来指定范围。例如：A-Z 指从 A 到 Z 之间的所有字符。
[ ]	一个字符集合。匹配括号内的 任意 字符。如果第一个字符是 ^ 那么它表示否定模式。例如: [abC] 匹配 a, b, 和 C中的任何一个。&lt;/li&gt;
  &lt;li&gt;匹配 0个或者多个上述的模式。&lt;/li&gt;
  &lt;li&gt;匹配 1个或者多个上述模式。
?	匹配 0个或1个上述模式。
$	作为模式的最后一个字符匹配一行的结尾。
{ }	指出一个模式可能出现的次数。 例如: A{1,3} 表示 A 可能出现1次或3次。
\	用来转义元字符。同样用来覆盖字符在此表中定义的特殊意义，只取字符的本意。
^	否定。
|	表达式间的逻辑或。
“&lt;一些符号&gt;&quot;	字符的字面含义。元字符具有。
/	向前匹配。如果在匹配的模版中的“/”后跟有后续表达式，只匹配模版中“/”前 面的部分。如：如果输入 A01，那么在模版 A0/1 中的 A0 是匹配的。
( )	将一系列常规表达式分组。
常规表达式举例
常规表达式	含义
joke[rs]	匹配 jokes 或 joker。
A{1,2}shis+	匹配 AAshis, Ashis, AAshi, Ashi。
(A[b-e])+	匹配在 A 出现位置后跟随的从 b 到 e 的所有字符中的 0 个或 1个。
Lex 中的标记声明类似 C 中的变量名。每个标记都有一个相关的表达式。 （下表中给出了标记和表达式的例子。） 使用这个表中的例子，我们就可以编一个字数统计的程序了。 我们的第一个任务就是说明如何声明标记。&lt;/一些符号&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;标记声明举例
标记	相关表达式	含义
数字(number)	([0-9])+	1个或多个数字
字符(chars)	[A-Za-z]	任意字符
空格(blank)	“ “	一个空格
字(word)	(chars)+	1个或多个 chars
变量(variable)	(字符)+(数字)&lt;em&gt;(字符)&lt;/em&gt;(数字)*	
Lex 编程
Lex 编程可以分为三步：&lt;/p&gt;

&lt;p&gt;以 Lex 可以理解的格式指定模式相关的动作。
在这一文件上运行 Lex，生成扫描器的 C 代码。
编译和链接 C 代码，生成可执行的扫描器。
注意: 如果扫描器是用 Yacc 开发的解析器的一部分，只需要进行第一步和第二步。 关于这一特殊问题的帮助请阅读 Yacc和 将 Lex 和 Yacc 结合起来部分。&lt;/p&gt;

&lt;p&gt;现在让我们来看一看 Lex 可以理解的程序格式。一个 Lex 程序分为三个段：第一段是 C 和 Lex 的全局声明，第二段包括模式（C 代码），第三段是补充的 C 函数。 例如, 第三段中一般都有 main() 函数。这些段以%%来分界。 那么，回到字数统计的 Lex 程序，让我们看一下程序不同段的构成。&lt;/p&gt;

&lt;p&gt;C 和 Lex 的全局声明
这一段中我们可以增加 C 变量声明。这里我们将为字数统计程序声明一个整型变量，来保存程序统计出来的字数。 我们还将进行 Lex 的标记声明。&lt;/p&gt;

&lt;p&gt;字数统计程序的声明
%{
 int wordCount = 0;
 %}
 chars [A-za-z_'.&quot;]
 numbers ([0-9])+
 delim [” “\n\t]
 whitespace {delim}+
 words {chars}+
 %%
两个百分号标记指出了 Lex 程序中这一段的结束和三段中第二段的开始。&lt;/p&gt;

&lt;p&gt;Lex 的模式匹配规则
让我们看一下 Lex 描述我们所要匹配的标记的规则。（我们将使用 C 来定义标记匹配后的动作。） 继续看我们的字数统计程序，下面是标记匹配的规则。&lt;/p&gt;

&lt;p&gt;字数统计程序中的 Lex 规则
{words} { wordCount++; /*
 increase the word count by one&lt;em&gt;/ }
 {whitespace} { /&lt;/em&gt; do
 nothing&lt;em&gt;/ }
 {numbers} { /&lt;/em&gt; one may
 want to add some processing here*/ }
 %%
C 代码
Lex 编程的第三段，也就是最后一段覆盖了 C 的函数声明（有时是主函数）。注意这一段必须包括 yywrap() 函数。 Lex 有一套可供使用的函数和变量。 其中之一就是 yywrap。 一般来说，yywrap() 的定义如下例。我们将在 高级 Lex 中探讨这一问题。&lt;/p&gt;

&lt;p&gt;字数统计程序的 C 代码段
void main()
 {
 yylex(); /* start the
 analysis*/
 printf(“ No of words:
 %d\n”, wordCount);
 }
 int yywrap()
 {
 return 1;
 }
上一节我们讨论了 Lex 编程的基本元素，它将帮助你编写简单的词法分析程序。 在 高级 Lex 这一节中我们将讨论 Lex 提供的函数，这样你就能编写更加复杂的程序了。&lt;/p&gt;

&lt;p&gt;将它们全部结合起来
.lex文件是 Lex 的扫描器。它在 Lex 程序中如下表示：&lt;/p&gt;

&lt;p&gt;1
$ lex &lt;file name.lex=&quot;&quot;&gt;
这生成了 lex.yy.c 文件，它可以用 C 编译器来进行编译。它还可以用解析器来生成可执行程序，或者在链接步骤中通过选项 �ll 包含 Lex 库。&lt;/file&gt;&lt;/p&gt;

&lt;p&gt;这里是一些 Lex 的标志：&lt;/p&gt;

&lt;p&gt;-c表示 C 动作，它是缺省的。
-t写入 lex.yy.c 程序来代替标准输出。
-v提供一个两行的统计汇总。
-n不打印 -v 的汇总。
高级 Lex
Lex 有几个函数和变量提供了不同的信息，可以用来编译实现复杂函数的程序。 下表中列出了一些变量和函数，以及它们的使用。 详尽的列表请参考 Lex 或 Flex 手册（见后文的 资源）。&lt;/p&gt;

&lt;p&gt;Lex 变量
yyin	FILE* 类型。 它指向 lexer 正在解析的当前文件。
yyout	FILE* 类型。 它指向记录 lexer 输出的位置。 缺省情况下，yyin 和 yyout 都指向标准输入和输出。
yytext	匹配模式的文本存储在这一变量中（char*）。
yyleng	给出匹配模式的长度。
yylineno	提供当前的行数信息。 （lexer不一定支持。）
Lex 函数
yylex()	这一函数开始分析。 它由 Lex 自动生成。
yywrap()	这一函数在文件（或输入）的末尾调用。 如果函数的返回值是1，就停止解析。 因此它可以用来解析多个文件。 代码可以写在第三段，这就能够解析多个文件。 方法是使用 yyin 文件指针（见上表）指向不同的文件，直到所有的文件都被解析。 最后，yywrap() 可以返回 1 来表示解析的结束。
yyless(int n)	这一函数可以用来送回除了前�n? 个字符外的所有读出标记。
yymore()	这一函数告诉 Lexer 将下一个标记附加到当前标记后。
对 Lex 的讨论就到这里。下面我们来讨论 Yacc…&lt;/p&gt;

&lt;p&gt;Yacc
Yacc 代表 Yet Another Compiler Compiler。 Yacc 的 GNU 版叫做 Bison。它是一种工具，将任何一种编程语言的所有语法翻译成针对此种语言的 Yacc 语 法解析器。它用巴科斯范式(BNF, Backus Naur Form)来书写。按照惯例，Yacc 文件有 .y 后缀。编译行如下调用 Yacc 编译器：
$ yacc &lt;options&gt;
 &amp;lt;filename ending with .y&amp;gt;
在进一步阐述以前，让我们复习一下什么是语法。在上一节中，我们看到 Lex 从输入序列中识别标记。 如果你在查看标记序列，你可能想在这一序列出现时执行某一动作。 这种情况下有效序列的规范称为语法。Yacc 语法文件包括这一语法规范。 它还包含了序列匹配时你想要做的事。&lt;/options&gt;&lt;/p&gt;

&lt;p&gt;为了更加说清这一概念，让我们以英语为例。 这一套标记可能是：名词, 动词, 形容词等等。为了使用这些标记造一个语法正确的句子，你的结构必须符合一定的规则。 一个简单的句子可能是名词+动词或者名词+动词+名词。(如 I care. See spot run.)&lt;/p&gt;

&lt;p&gt;所以在我们这里，标记本身来自语言（Lex），并且标记序列允许用 Yacc 来指定这些标记(标记序列也叫语法)。&lt;/p&gt;

&lt;p&gt;终端和非终端符号
终端符号 : 代表一类在语法结构上等效的标记。 终端符号有三种类型：&lt;/p&gt;

&lt;p&gt;命名标记: 这些由 %token 标识符来定义。 按照惯例，它们都是大写。&lt;/p&gt;

&lt;p&gt;字符标记 : 字符常量的写法与 C 相同。例如, – 就是一个字符标记。&lt;/p&gt;

&lt;p&gt;字符串标记 : 写法与 C 的字符串常量相同。例如，”«” 就是一个字符串标记。&lt;/p&gt;

&lt;p&gt;lexer 返回命名标记。&lt;/p&gt;

&lt;p&gt;非终端符号 : 是一组非终端符号和终端符号组成的符号。 按照惯例，它们都是小写。 在例子中，file 是一个非终端标记而 NAME 是一个终端标记。&lt;/p&gt;

&lt;p&gt;用 Yacc 来创建一个编译器包括四个步骤：&lt;/p&gt;

&lt;p&gt;通过在语法文件上运行 Yacc 生成一个解析器。
说明语法：
编写一个 .y 的语法文件（同时说明 C 在这里要进行的动作）。
编写一个词法分析器来处理输入并将标记传递给解析器。 这可以使用 Lex 来完成。
编写一个函数，通过调用 yyparse() 来开始解析。
编写错误处理例程（如 yyerror()）。
编译 Yacc 生成的代码以及其他相关的源文件。
将目标文件链接到适当的可执行解析器库。
用 Yacc 编写语法
如同 Lex 一样, 一个 Yacc 程序也用双百分号分为三段。 它们是：声明、语法规则和 C 代码。 我们将解析一个格式为 姓名 = 年龄 的文件作为例子，来说明语法规则。 我们假设文件有多个姓名和年龄，它们以空格分隔。 在看 Yacc 程序的每一段时，我们将为我们的例子编写一个语法文件。&lt;/p&gt;

&lt;p&gt;C 与 Yacc 的声明
C 声明可能会定义动作中使用的类型和变量，以及宏。 还可以包含头文件。每个 Yacc 声明段声明了终端符号和非终端符号（标记）的名称，还可能描述操作符优先级和针对不同符号的数据类型。 lexer (Lex) 一般返回这些标记。所有这些标记都必须在 Yacc 声明中进行说明。&lt;/p&gt;

&lt;p&gt;在文件解析的例子中我们感兴趣的是这些标记：name, equal sign, 和 age。Name 是一个完全由字符组成的值。 Age 是数字。于是声明段就会像这样：&lt;/p&gt;

&lt;p&gt;文件解析例子的声明
%
 #typedef char* string; /*
 to specify token types as char* &lt;em&gt;/
 #define YYSTYPE string /&lt;/em&gt;
 a Yacc variable which has the value of returned token &lt;em&gt;/
 %}
 %token NAME EQ AGE
 %%
你可能会觉得 YYSTYPE 有点奇怪。但是类似 Lex, Yacc 也有一套变量和函数可供用户来进行功能扩展。 YYSTYPE 定义了用来将值从 lexer 拷贝到解析器或者 Yacc 的 yylval （另一个 Yacc 变量）的类型。 默认的类型是 int。 由于字符串可以从 lexer 拷贝，类型被重定义为 char&lt;/em&gt;。 关于 Yacc 变量的详细讨论，请参考 Yacc 手册（见 资源）。&lt;/p&gt;

&lt;p&gt;Yacc 语法规则
Yacc 语法规则具有以下一般格式：
result: components { /*
 action to be taken in C */ }
 ;
在这个例子中，result 是规则描述的非终端符号。Components 是根据规则放在一起的不同的终端和非终端符号。 如果匹配特定序列的话 Components 后面可以跟随要执行的动作。 考虑如下的例子：
param : NAME EQ NAME {
 printf(“\tName:%s\tValue(name):%s\n”, $1,$3);}
     | NAME EQ VALUE{
     printf(“\tName:%s\tValue(value):%s\n”,$1,$3);}
 ;
如果上例中序列 NAME EQ NAME 被匹配，将执行相应的 { } 括号中的动作。 这里另一个有用的就是 $1 和 $3 的使用, 它们引用了标记 NAME 和 NAME（或者第二行的 VALUE）的值。 lexer 通过 Yacc 的变量 yylval 返回这些值。标记 NAME 的 Lex 代码是这样的：
char [A-Za-z]
 name {char}+
 %%
 {name} { yylval = strdup(yytext);
 return NAME; }
文件解析例子的规则段是这样的：&lt;/p&gt;

&lt;p&gt;文件解析的语法
file : record file
 | record
 ;
 record: NAME EQ AGE {
 printf(“%s is now %s years old!!!”, $1, $3);}
 ;
 %%
附加 C 代码
现在让我们看一下语法文件的最后一段，附加 C 代码。 （这一段是可选的，如果有人想要略过它的话：）一个函数如 main() 调用 yyparse() 函数（Yacc 中 Lex 的 yylex() 等效函数）。 一般来说，Yacc 最好提供 yyerror(char msg) 函数的代码。 当解析器遇到错误时调用 yyerror(char msg)。错误消息作为参数来传递。 一个简单的 yyerror( char* ) 可能是这样的：
int yyerror(char* msg)
 {
 printf(“Error: %s
 encountered at line number:%d\n”, msg, yylineno);
 }
yylineno 提供了行数信息。&lt;/p&gt;

&lt;p&gt;这一段还包括文件解析例子的主函数：&lt;/p&gt;

&lt;p&gt;附加 C 代码
void main()
 {
     yyparse();
 }
 int yyerror(char* msg)
 {
 printf(“Error: %s
 encountered \n”, msg);
要生成代码，可能用到以下命令：
$ yacc _d &lt;filename.y&gt;
这生成了输出文件 y.tab.h 和 y.tab.c，它们可以用 UNIX 上的任何标准 C 编译器来编译（如 gcc）。&lt;/filename.y&gt;&lt;/p&gt;

&lt;p&gt;命令行的其他常用选项
‘-d’ ,’–defines’ : 编写额外的输出文件，它们包含这些宏定义：语法中定义的标记类型名称，语义的取值类型 YYSTYPE, 以及一些外部变量声明。如果解析器输出文件名叫 ‘name.c’, 那么 ‘-d’ 文件就叫做 ‘name.h’。 如果你想将 yylex 定义放到独立的源文件中，你需要 ‘name.h’, 因为 yylex 必须能够引用标记类型代码和 yylval变量。
‘-b file-prefix’ ,’–file-prefix=prefix’ : 指定一个所有Yacc输出文件名都可以使用的前缀。选择一个名字，就如输入文件名叫 ‘prefix.c’.
‘-o outfile’ ,’–output-file=outfile’ : 指定解析器文件的输出文件名。其他输出文件根据 ‘-d’ 选项描述的输出文件来命名。
Yacc 库通常在编译步骤中自动被包括。但是它也能被显式的包括，以便在编译步骤中指定 �ly选项。这种情况下的编译命令行是：
$ cc &lt;source file=&quot;&quot; names=&quot;&quot; /&gt; -ly
将 Lex 与 Yacc 结合起来
到目前为止我们已经分别讨论了 Lex 和 Yacc。现在让我们来看一下他们是怎样结合使用的。&lt;/p&gt;

&lt;p&gt;一个程序通常在每次返回一个标记时都要调用 yylex() 函数。只有在文件结束或者出现错误标记时才会终止。&lt;/p&gt;

&lt;p&gt;一个由 Yacc 生成的解析器调用 yylex() 函数来获得标记。 yylex() 可以由 Lex 来生成或完全由自己来编写。 对于由 Lex 生成的 lexer 来说，要和 Yacc 结合使用，每当 Lex 中匹配一个模式时都必须返回一个标记。 因此 Lex 中匹配模式时的动作一般格式为：
{pattern} { /* do smthg*/
 return TOKEN_NAME; }
于是 Yacc 就会获得返回的标记。当 Yacc 编译一个带有 _d 标记的 .y文件时，会生成一个头文件，它对每个标记都有 #define 的定义。 如果 Lex 和 Yacc 一起使用的话，头文件必须在相应的 Lex 文件 .lex中的 C 声明段中包括。&lt;/p&gt;

&lt;p&gt;让我们回到名字和年龄的文件解析例子中，看一看 Lex 和 Yacc 文件的代码。&lt;/p&gt;

&lt;p&gt;Name.y - 语法文件
%
 typedef char* string;
 #define YYSTYPE string
 %}
 %token NAME EQ AGE
 %%
 file : record file
 | record
 ;
 record : NAME EQ AGE {
 printf(“%s is %s years old!!!\n”, $1, $3); }
 ;
 %%
 int main()
 {
 yyparse();
 return 0;
 }
 int yyerror(char *msg)
 {
 printf(“Error
 encountered: %s \n”, msg);
 }
Name.lex - Lex 的解析器文件
%{
 #include “y.tab.h”&lt;/p&gt;

&lt;p&gt;#include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
 extern char* yylval;
 %}
 char [A-Za-z]
 num [0-9]
 eq [=]
 name {char}+
 age {num}+
 %%
 {name} { yylval = strdup(yytext);
 return NAME; }
 {eq} { return EQ; }
 {age} { yylval = strdup(yytext);
 return AGE; }
 %%
 int yywrap()
 {
 return 1;
 }
作为一个参考，我们列出了 y.tab.h, Yacc 生成的头文件。&lt;/string.h&gt;&lt;/stdio.h&gt;&lt;/p&gt;

&lt;p&gt;y.tab.h - Yacc 生成的头文件&lt;/p&gt;
&lt;h1 id=&quot;define-name-257&quot;&gt;define NAME 257&lt;/h1&gt;
&lt;p&gt;# define EQ 258
 # define AGE 259&lt;/p&gt;

&lt;p&gt;无论是词法分析，还是语法分析，给我的第一感觉就是逻辑要严谨。由于项目有自己一套完整的语言和语法，设计好其对应的词法分析器和语法分析器显得尤为重要。
        我们采用flex进行词法分析。flex是一个用来生成扫描器（scanners）的工具，其中扫描器就是可以识别文本中词法模式的程序。具体流程为：flex读取给定的输入文件，或标准输入（当没有给定文件名时）读取信息来生成一个扫描器。信息以正则表达式和C代码组成，这种形式称为规则（rule）。flex生成C源代码文件lex.yy.c，其中定义了一个函数yylex()。这个文件通过编译，并用-lfl 链接生成可执行文件。当可执行文件被执行时，它分析输入中可能存在的符合正则表达的内容。当找到任何一个与正则表达式相匹配内容时，相应的C 代码将被执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    flex输入文件由三段组成：定义（definitions），规则（rules），用户代码（user code）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一、定义段（definitions）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    定义段包含了简单名称的声明（这些声明可以简化扫描器的说明）和开始条件。在本项目中，定义段中还包含了选项options。现将介绍一些比较常用的options。

    flex 提供一个机制用来在扫描器的说明中，而不是在flex 命令中控制选项。在扫描器的说明文件（flex 的输入文件）的第一段中使用%option 指令就可以实现。你可以用单个%option 指令指定多个选项，也可以使用多个%option指令。

    %option 7bit，%option 8bit——指示flex生成一个7bit或8bit的扫描器与-7，-8 选项等价。

    %option backup——生成一个备份信息到lex.backup，与-b选项等价。

    %option caseful，%option case-sensitive——区分大小写，与-i相反。

    %option case-insensitive，%option caseless——忽略大小写，与-i选项等价。

    %option debug——让生成的扫描器运行在debug模式，与-d选项等价。

    %option default，%option nodefault——%default与-s选项相反，后者与其等价。-s选项作用：使不匹配的输入回显到输出设备的rule失去作用。在此种情况下，如果扫描器不能匹配到任何规则rule的输入，它会终止并返回错误。在查找扫描器的规则漏洞时，-s和%option nodefault都非常有用。

    %option interactive——指示flex生成一个交互式的扫描器。交互式扫描器就是向前查看下一个匹配的token是什么。结果就是总向前多看了一个字符，即使是在扫描器已经看够了文本已经排除了token 的歧义。但向前查看给了扫描器强大的交互能力。与-I等价。

    %option warn——与-w选项相反。%option nowarn与-w选项等价。

    %option array——与%array等价。

    %option pointer——与%point等价。

    以下为%option中定义，但在命令行里没有的特性。

    %option always-interactive——指示flex 生成的扫描器总是把它的输入认为是&quot;interactive&quot;。

    %option main——指示flex 为扫描器提供一个缺省的main()函数，它只是简单的调用了yylex()。这个选项暗示noyywrap。

    %option never-interactive——flex 生成的扫描器从不认为输入是交互的（不会调用isatty()）。这和总是interactive 正好相反。

    %option yylineno——flex 生成的扫描器用全局变量yylineno 维护着输入文件的当前行编号。option lex-compat隐含有这个选项。

    %option yywrap——如果没有设置（就如%option noyywrap），当扫描器遇到end-of-file 时，不会调用yywrap()，但简单的假定没有更多的文件可以扫描（直到用户把yyin 指向新的文件并再一次调用yylex（））。

    flex 通过扫描rule 中的action 来判断你是否使用了REJECT 或是yymore 属性。你可用%option reject 表示要使用这个特性而用%option noyymore 表示不使用这个特性。

    三个选项使用了字符串值，从'='开始：%option outfile=&quot;ABC&quot;等同于-oABC ；%option prefix=&quot;XYZ&quot; 等同于-PXYZ；最后，%option yyclass=&quot;foo&quot; 只有当生成C++扫描器（-+选项）时才有效。

   有些选项可以限制一个例程不出现在生成的扫描器中。下面这些例程如果不被设置（如%option nounput）将不会出现在生成的扫描器中。

   input unput yy_push_state yy_pop_sate yy_top_state yy_scan_buffer yy_scan_bytes yy_scan_string

   可重入c扫描器（Reentrant C Scanners）

   flex能够生成一个可重入的扫描器。通过定义%option reentrant（与-R选项等价）来实现可重入。所生成的扫描器在一个或多个控制线程中不仅可移植，而且安全性好。可重入扫描器通常应用于多线程应用程序。任何一个线程都可以在不考虑与其他线程同步的情况下创建并执行一个可重入的flex扫描器。

   默认情况下，flex生成一个不可重入的扫描器。本项目为了实现多线程，因而在定义段指定%option reentrant。

   性能考虑（performance consideration）

   flex的设计目标就是生成一个高性能的扫描器。它已经对处理大量rule 做了优化。除了用-C 选项进行表格压缩之外，还有一些option/action 会影响到扫描器的速度。从最大影响到最弱，有这一些：

   REJECT          %option yylineno           arbitrary trailing context

   pattern sets that require backing up        %array          %option interactive             %option always-interactive

   '^'beginning-of-line operator      yymore()

   头三个的开销最大，后两个的开销最小。注意unput()有可能被用例程实现而造成更多操作，而yyless()是一个开销相当低的宏；所以如果只是回放一些你多扫了的文本，可以用yyless()。

   本项目中也用到了名字定义和开始条件。其中名字定义包括数字、字符、空白符，多行注释，单行注释，引号间的字符串，整数、浮点数、实数，标示符，变量，日期。

   数字—digit [0-9]，字符—character [a-zA-Z]，空白符—space [ \t\r](在制表符前面留有空格表示空格符)

   多行注释（以/#开头，中间可以为任意非#非\n字符，也可以为一串#后面紧跟非/非\n字符，最后结尾为1个或多个#后跟/）

   comstart   \/\#

   comstop \#+\/

   cominside ([^#\n]*|#+[^#/\n])

   单行注释 line_comment  ^#[^\n]*

   引号间的字符串（以双引号开头以双引号结尾。内容为非转义字符和双引号，当遇到转义字符时，进行特殊处理；当遇到双引号时，停止匹配）

   dquotes \&quot;

   stringstart {dquotes}

   stringstop {dquotes}

   stringinside [^\\\&quot;]+

   注意：在多行注释和引号间的字符串的匹配中，采用了排斥条件（开始条件分为排斥和共享条件）

   排斥条件的定义为 %xc（针对多行注释）

                                     %xs（针对引号间的字符串）

   整数 integer {digit}+

   浮点数 decimal (({digit}+\.{digit}*)|({digit}*\.{digit}+))

                 decimalfail {digit}+\.\.

   实数 real ({integer}|{decimal})[eE][+-]?{digit}+

             realfail1 ({integer}|decimal)[eE]

             realfail2 ({integer}|decimal)[eE][+-]

   标示符 identstart [a-zA-Z\200-\377_]

   identcont [a-zA-Z\200-\377_0-9\$]

   identifier {identstart}{identcont}*

   变量（$后跟一个或多个字符） variable \${character}+

   日期 date {digit}+\-{digit}+(\-{digit}+)?

             datefail1 {digit}+\-{digit}+\-

             datefail2 {digit}+\- 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、规则段（rules）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   规则段包含模式（pattern）和动作（action），其中模式不能有缩进，而且动作必须在同一行上跟在动作后面。

   在规则段可以使用开始条件（start conditions）。flex 提供了一种按条件激活规则rule 的机制。所有模式以&quot;&amp;lt;sc&amp;gt;&quot;为前缀的rule 只有在扫描器是在一个名为&quot;sc&quot;的启动条件时才会被激活。使用BEGIN action 可以激活一个开始条件。直到下一个BEGIN action 被执行，在给出开始条件的rule将被激活并且其他给出其他开始条件的rule 并不会被激活。如果使用的是排他的开始条件，那么只有以开始条件修饰的rule 才会被激活。跟在同一个排他开始条件后的rule 说明在扫描器中，这些rule 是独立于flex 输入中的其他rule。

    本项目中涉及到排斥条件的有多行注释、引号间的字符串。

    其中MOVELOC,SAVETOKEN为定义段中定义的宏

    #define MOVELOC  {yylloc-&amp;gt;first_column = yylloc-&amp;gt;last_column;\

                                         yylloc-&amp;gt;last_column = yylloc-&amp;gt;first_column + yyleng;}

    #define RESETLOC {yylloc-&amp;gt;first_column = yylloc-&amp;gt;last_column = 1;\

                                        yylloc-&amp;gt;first_line++;\

                                        yylloc-&amp;gt;last_line++;}

   #define SAVETOKEN yylval-&amp;gt;str = new std::string(yytext, yyleng)

    多行注释(语句输出省略)

    {comstart}       {         MOVELOC;

                                        BEGIN(xc);

                              }

    &amp;lt;xc&amp;gt;{cominside} {     MOVELOC;      }

    &amp;lt;xc&amp;gt;\n              {         RESETLOC;     }

    &amp;lt;xc&amp;gt;{comstop} {       MOVELOC;

                                        BEGIN(INITIAL);

                              }

    &amp;lt;xc&amp;gt;&amp;lt;&amp;lt;EOF&amp;gt;&amp;gt; {       BEGIN(INITIAL);

                                       std::cerr &amp;lt;&amp;lt; &quot;unterminated /# comment&quot; &amp;lt;&amp;lt; endl;

                                       yyterminate();

                               }

   引号间的字符串(输出语句省略)

   {stringstart}         {   MOVELOC;

                                     BEGIN(xs);

                                     SAVETOKEN;

                              }

   &amp;lt;xs&amp;gt;{stringstop} {  MOVELOC;

                                     BEGIN(INITIAL);

                                     *(yylval-&amp;gt;str) += yytext;

                                     return QUOTES_STRING;

                              }

   &amp;lt;xs&amp;gt;\n               {       RESETLOC;

                                      *(yylval-&amp;gt;str) += yytext;

                              }

   &amp;lt;xs&amp;gt;\\n               {     MOVELOC;

                                      *(yylval-&amp;gt;str) += &quot;\n&quot;;

                              }

    &amp;lt;xs&amp;gt;\\t               {      MOVELOC;

                                      *(yylval-&amp;gt;str) += &quot;\t&quot;;

                              }

    &amp;lt;xs&amp;gt;\\r               {      MOVLOC;

                                      *(yylval-&amp;gt;str) += &quot;\r&quot;;

                              }

    &amp;lt;xs&amp;gt;\\b             {      MOVELOC;

                                      *(yylval-&amp;gt;str) += &quot;\b&quot;;

                              }

    &amp;lt;xs&amp;gt;\\f               {      MOVELOC;

                                      *(yylval-&amp;gt;str) += &quot;\f&quot;;

                              }

     &amp;lt;xs&amp;gt;\\.             {       MOVELOC;

                                      *(yylval-&amp;gt;str) += yytext[1];

                              }

    &amp;lt;xs&amp;gt;\\\n             {     RESETLOC;

                                      *(yylval-&amp;gt;str) += &quot;\n&quot;;

                              }

   &amp;lt;xs&amp;gt;{stringinside} {        MOVELOC;

                                    *(yylval-&amp;gt;str) += yytext;

                              }

   &amp;lt;xs&amp;gt;&amp;lt;&amp;lt;EOF&amp;gt;&amp;gt; {     BEGIN(INITIAL);

                                    std::cerr &amp;lt;&amp;lt; &quot;unterminated \&quot;&quot; &amp;lt;&amp;lt; endl;

                                     delete yylval-&amp;gt;str;

                                    yyterminate();

                             }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三、用户代码段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  用户代码段只会简单的拷贝到lex.yy.c中。这个和扫描器一起，调用扫描器或者被扫描器调用。如果被省略，则第二个%%可以省略。

  使用了%option reentrant后

  1所有的函数都会带一个额外的参数yyscanner。

  2所有的全局变量都被它们的宏等价替换。

  这些变量包括yytext,yyleng, yylineno, yyin, yyout,yyextra, yylval, and yylloc，你可以在action部分安全地使用这些宏（如同使用普通变量一样），但不能够在外部直接使用。以yytext为例，在一个可重入的扫描器中，yytext以及其他类似变量都不是全局变量，因而不能通过action外部或是其他函数来直接访问yytext，而应该使用yyget_text访问器函数来实现对yytext的访问。

  3在使用yylex之前调用yylex_init，在使用之后调用yylex_destroy。

  init以及destroy函数

  int yylex_init ( yyscan_t * ptr_yy_globals ) ;

  int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t * ptr_yy_globals ) ;

  int yylex ( yyscan_t yyscanner ) ;

  int yylex_destroy ( yyscan_t yyscanner ) ;

  函数yylex_init必须在调用任意其他函数之前调用，其参数是一个未初始化的指针地址，并由该函数初始化，这样会覆盖以前的内容。ptr_yy_global中存储的值会传递给yylex和yylex_destroy。flex不会保存传递给yylex_init的变量，因而传递一个局部指针的地址值给yylex_init是很安全的，只要其在调用扫描器到调用yylex_destroy期间一直存在就行。

  yylex的可重入版本带一个参数，该参数即为yylex_init通过变量返回的值。

  yylex_destroy函数用来释放扫描器使用过的资源。当要重复使用时，就不必destroy。

  4获取函数（get或set）提供了访问普通flex变量的途径。

  5用户自定义数据可以再yyextra中存储。

  在一个可重入的扫描器中，使用全局变量让程序的不同部分通信或是保持状态是不明智的。然而，你需要在action中使用额外的数据或是调用额外的函数。同样，你需要传递信息给你的扫描器。在一个不可重入的扫描器中，实现这的唯一方式就是使用全局变量。flex允许你存储任意的、额外的数据到扫描器中。定义如下：

  #define YY_EXTRA_TYPE void*

  YY_EXTRA_TYPE yyget_extra ( yyscan_t scanner );

  void yyset_extra ( YY_EXTRA_TYPE arbitrary_data , yyscan_t scanner);

  项目中最后的代码如下，其中scanner_init初始化yylex，yy_scan_buffer函数（作用是建立输入缓存）从yyext-&amp;gt;scanbuf指定的开始位置扫描slen+2个字节，最后两个字节必须是YY_END_OF_BUFFER_CHAR。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[html] view plain copy
yyscan_t&lt;br /&gt;
scanner_init(const char *str, inl_yylex_extra *yyext)&lt;br /&gt;
{&lt;br /&gt;
         int             slen = strlen(str);&lt;br /&gt;
         yyscan_t        scanner;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     if(yylex_init(&amp;amp;scanner) != 0)  
     {  
             std::cerr &amp;lt;&amp;lt; &quot;yylex_init() failed&quot; &amp;lt;&amp;lt; std::endl;  
             exit(1);  
     }  
   
     inl_yyset_extra(yyext, scanner);  
   
     yyext-&amp;gt;scanbuf = (char *)malloc(slen + 2);  
     yyext-&amp;gt;scanbuflen = slen;  
   
     memcpy(yyext-&amp;gt;scanbuf, str, slen);  
     yyext-&amp;gt;scanbuf[slen] = yyext-&amp;gt;scanbuf[slen + 1] = YY_END_OF_BUFFER_CHAR;  
     yy_scan_buffer(yyext-&amp;gt;scanbuf, slen + 2, scanner);  
   
     return scanner;   }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;void scanner_finish(yyscan_t yyscanner)&lt;br /&gt;
{&lt;br /&gt;
         free((*((inl_yylex_extra**)(yyscanner)))-&amp;gt;scanbuf);&lt;br /&gt;
         inl_yylex_destroy(yyscanner);&lt;br /&gt;
}&lt;/p&gt;
</description>
        <pubDate>Tue, 13 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/lang/2018/02/13/lex.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/lang/2018/02/13/lex.html</guid>
        
        
        <category>lang</category>
        
      </item>
    
  </channel>
</rss>
