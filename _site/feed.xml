<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>泽民博客</title>
    <description>夏泽民的个人主页，学习笔记。</description>
    <link>https://xiazemin.github.io/MyBlog/</link>
    <atom:link href="https://xiazemin.github.io/MyBlog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 27 Feb 2018 21:28:43 +0800</pubDate>
    <lastBuildDate>Tue, 27 Feb 2018 21:28:43 +0800</lastBuildDate>
    <generator>Jekyll v3.6.0.pre.beta1</generator>
    
      <item>
        <title>type_hinting</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;从PHP5开始，我们可以使用类型提示来指定定义函数时，函数接收的参数类型。如果在定义函数时，指定了参数的类型，那么当我们调用函数时，如果实参的类型与指定的类型不符，那么PHP会产生一个致命级别的错误(Catchable fatal error)。&lt;/p&gt;

&lt;p&gt;类名称和数组&lt;/p&gt;

&lt;p&gt;在定义函数时，PHP只支持两种类型声明：类名称和数组。类名称表名该参数接收的实参为对应类实例化的对象，数组表明接收的实参为数组类型。下面是一个例子：
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;function demo(array $options){
  var_dump($options);
}&lt;/p&gt;

&lt;p&gt;在定义demo()函数的时候，指定了函数接收的参数类型为数组。如果我们调用函数时，传入的参数不是数组类型，例如像下面这样的调用：
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;$options=’options’;
demo($options);&lt;/p&gt;

&lt;p&gt;那么将产生以下错误：
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;Catchable fatal error: Argument 1 passed to demo() must be of the type array, string given,
可以使用null作为默认参数&lt;/p&gt;

&lt;p&gt;注意&lt;/p&gt;

&lt;p&gt;有一点需要特别注意的是，PHP只支持两种类型的类型声明,其他任何标量类型的声明都是不支持的，比如下下面的代码都将产生错误:
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;function demo(string $str){
}
$str=”hello”;
demo($str)
当我们运行上面的代码时，string会被当做类名称对待，因此会报下面的错误:
Catchable fatal error: Argument 1 passed to demo() must be an instance of string, string given,&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;p&gt;类型声明也是PHP面向对象的一个进步吧，尤其是在捕获某种指定类型的异常时非常有用。
使用类型声明，也可以增加代码的可读性。
但是，由于PHP是弱类型的语言，使用类型声明又于PHP设计的初衷相悖。&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/02/26/type_hinting.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/02/26/type_hinting.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>tsrm</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;名词解释：
TSRM
线程安全资源管理器(Thread Safe Resource Manager)，这是个尝尝被忽视，并很少被人说起的“层”(layer), 她在PHP源码的/TSRM目录下。一般的情况下，这个层只会在被指明需要的时候才会被启用(比如,Apache2+worker MPM,一个基于线程的MPM)，对于Win32下的Apache来说，是基于多线程的，所以这个层在Win32下总是被启用的。
ZTS
Zend线程安全(Zend Thread Safety)，当TSRM被启用的时候，就会定义这个名为ZTS的宏。
tsrm_ls
TSRM存储器(TSRM Local Storage)，这个是在扩展和Zend中真正被实际使用的指代TSRM存储的变量名。
TSRMLS_??
这是一族(4个)宏，用来根据ZTS宏被定义与否来实现TSRM。4个宏如下：&lt;/p&gt;

&lt;p&gt;#define TSRMLS_C   tsrm_ls
#define TSRMLS_D   void  &lt;em&gt;** tsrm_ls
#define TSRMLS_CC  ,tsrm_ls
#define TSRMLS_DS  ,void  **&lt;/em&gt;tsrm_ls   //注意有个逗号&lt;/p&gt;

&lt;p&gt;我们都知道，在C或者PHP编程中，要在多个函数中访问同一个变量有俩种方式，一种是通过参数传递，比如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
 
void output_func(char *message)
{
    printf(&quot;%s\n&quot;, message);
}
 
int main(int argc, char *argv[])
{
    output_func(argv[0]);
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一种方式是，通过在函数的高一级作用域中存储这个变量(当然，对于PHP，要显示的指明Global变量(这个原因和PHP的作用域的实现－活动表有关系，本处不涉及，我会在将来的某篇文章中介绍她)，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
 
char *message;
 
void output_func(void)
{
    printf(&quot;%s\n&quot;, message);
}
 
int main(int argv, char *argv[])
{
    message = argv[0];
    output_func();
 
    return 0; } 对于在PHP使用第二种方式来说，一般的单线 程模型比如PHP CLI方式，Apache1，或者Apache2+prefork MPM(也是一种多进程模型)，可以放心的被使用，也不会出错。全局变量在MINIT/RINIT的时候被创建，然后在整个进程运行时/请求处理期都能被 访问到，然后在MSHUTDOW/RSHUTDOWN的时候被释放。 但是在多线程的模型下，这种方式就不在安全了，比如Apache2+worker MPM和IIS。在这种情况下，所有的线程共享同一个进程的地址空间，也就说，多个线程共用一个全局变量，这个时候就会产生竞争。用C程序员的方式来说: 这个时候的全局变量是非线程安全的。 为了解决这个问题，并和单线程模式兼容，Zend使用了称作“Non_global Globals”的机制。这个机制的主要思想就是，对于多线程模型来说，每当一个新的线程被创建，就单独的分配一块内存，这块内存存储着一个全局变量的副 本。而这块内存会被一个Vector串起来，由Zend统一管理。为了说明这个方式，咱们看看如下的例子：

typedef struct _zend_myextension_globals {
    int foo;
    char *bar;
} zend_myextension_globals;
 
#ifdef ZTS  //如果TSRM被启用
int myextension_globals_id;
#else
zend_myextension_globals myextension_globals;
#endif
 
/* 当线程被创建的时候调用 */
static void php_myextension_globals_ctor(zend_myextension_globals *myext_globals TSRMLS_DC)
{
    myext_globals-&amp;gt;foo = 0;
    myext_globals-&amp;gt;bar = NULL;
}
 
/* 线程结束的时候被调用 */
static void php_myextension_globals_dtor(zend_myextension_globals *myext_globals TSRMLS_DC)
{
    if (myext_globals-&amp;gt;bar) {
        efree(myext_globals-&amp;gt;bar);
    }
}
 
PHP_MINIT_FUNCTION(myextension)
{
#ifdef ZTS
    ts_allocate_id(&amp;amp;myextension_globals_id, sizeof(zend_myextension_globals),
                   php_myextension_globals_ctor, php_myextension_globals_dtor);
#else
    php_myextension_globals_ctor(&amp;amp;myextension_globals TSRMLS_CC);
#endif
 
    return SUCCESS;
}
 
PHP_MSHUTDOWN_FUNCTION(myextension)
{
#ifndef ZTS
    php_myextension_globals_dtor(&amp;amp;myextension_globals TSRMLS_CC);
#endif
 
    return SUCCESS;
} 这个例子开始的时候向TSRM层申明了一个全局变量” zend_myextension_globals”，

    ts_allocate_id(&amp;amp;myextension_globals_id, sizeof(zend_myextension_globals),
                   php_myextension_globals_ctor, php_myextension_globals_dtor); 他指明了要申请的全局变量的大小，创建器和析构器。并讲这个生成的全局变量在Vector中的偏移量(Index)保存在了myextension_globals_id中。而对于没有启用TSRM的情况，这个全局变量只是简单的被创建。 如果你问我“为什么在没有启用TSRM的情况下还会有TSRMLS_CC?”,那说明你现在还没有被我弄糊涂;)，恩，在ZTS没有被设置的情况下(没有启用TSRM)，TSRMLS_CC会被编译器替换为空，因为:

 #ifdef ZTS
          #define TRSMLS_CC  ,tsrm_ls   #else
  #define TSRMLS_CC   #endif 在没有启用TSRM的情况下还指明TSRMLS_CC的原因仅仅是为了保持代码的一致性。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恩，现在已经设置了全局变量，那么接下来的问题就是，我们如果去访问它呢？看看如下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef ZTS
# define   MYEXTENSION_G(v)     \
             (((zend_myextension_globals*)(*((void ***)tsrm_ls))[(myextension_globals_id)-1])-&amp;gt;v)
#else
# define   MYEXTENSION_G(v)     (myextension_globals.v)
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呵呵，明白了吧？ 在ZTS没有被设置的情况下，宏MYEXTENSION_G(V)简单的被等价于全局变量myextension_globals.v，而对于启用了TSRM的情况，MYEXTENSION_G(V)会被转化成在Vector中根据my_extension_globals_id来查找到要访问的全局变量。
现在，只要你在你的代码中，使用MYEXTENSION_G来访问你的全局变量，并在要使用这个全局变量的函数参数列表中添加上TSRMLS_CC，那么就能保证在单线程和多线程模型下的线程安全，和代码一致性&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/02/26/tsrm.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/02/26/tsrm.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>create_function</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;第一部分：介绍php函数 create_function()：&lt;/p&gt;

&lt;p&gt;string create_function    ( string $args   , string $code   )&lt;/p&gt;

&lt;p&gt;string $args 变量部分&lt;/p&gt;

&lt;p&gt;string $code 方法代码部分&lt;/p&gt;

&lt;p&gt;举例：
create_function(‘$fname’,’echo $fname.”Zhang”’)
类似于：
function fT($fname) {
  echo $fname.”Zhang”;
}&lt;/p&gt;

&lt;p&gt;举一个官方提供的例子：
&lt;?php
$newfunc = create_function('$a,$b', 'return &quot;ln($a) + ln($b) = &quot; . log($a * $b);');
echo &quot;New anonymous function: $newfunc&quot;;
echo $newfunc(2, M_E) . &quot;
&quot;;
// outputs
// New anonymous function: lambda_1
// ln(2) + ln(2.718281828459) = 1.6931471805599
?&gt;
第二部分：如何利用create_function(）代码注入&lt;/p&gt;

&lt;p&gt;测试环境版本：&lt;/p&gt;

&lt;p&gt;apache +php 5.2、apache +php 5.3&lt;/p&gt;

&lt;p&gt;有问题的代码：
&lt;?php
//02-8.php?id=2;}phpinfo();/*
$id=$_GET['id'];
$str2='echo  '.$a.'test'.$id.&quot;;&quot;;
echo $str2;
echo &quot;&lt;br/&gt;&quot;;
echo &quot;==============================&quot;;
echo &quot;&lt;br/&gt;&quot;;
$f1 = create_function('$a',$str2);
echo &quot;&lt;br/&gt;&quot;;
echo &quot;==============================&quot;;
?&gt;
利用方法：&lt;/p&gt;

&lt;p&gt;http://localhost/libtest/02-8.php?id=2;}phpinfo();/*&lt;/p&gt;

&lt;p&gt;实现原理：&lt;/p&gt;

&lt;p&gt;由于id=2;}phpinfo();/*&lt;/p&gt;

&lt;p&gt;执行函数为：
源代码：
function fT($a) {
  echo “test”.$a;
}&lt;/p&gt;

&lt;p&gt;注入后代码：
function fT($a) {
  echo “test”;}
  phpinfo();/*;//此处为注入代码。
}&lt;/p&gt;

&lt;p&gt;测试效果：
实现在后台运行前端提交的php代码phpinfo();&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/02/26/create_function.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/02/26/create_function.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>Xdebug</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;Xdebug是一个开源的PHP程序调试工具，可以使用它来调试、跟踪及分析程序运行状态。当然，Xdebug需要结合PHP的编辑工具来打断点、跟踪、调试及分析，比较常用的PHP的Xdebug调试环境：Vim +Xdebug。
Xdebug是一个开源的PHP程序调试工具，可以使用它来调试、跟踪及分析程序运行状态。当然，Xdebug需要结合PHP的编辑工具来打断点、跟踪、调试及分析，比较常用的PHP的Xdebug调试环境：Vim +Xdebug。&lt;/p&gt;

&lt;p&gt;·     安装配置&lt;/p&gt;

&lt;p&gt;·     调试环境&lt;/p&gt;

&lt;p&gt;·     跟踪分析&lt;/p&gt;

&lt;p&gt;·     注意事项&lt;/p&gt;

&lt;p&gt;·     遇到问题&lt;/p&gt;

&lt;p&gt;一、安装配置&lt;/p&gt;

&lt;p&gt;1、安装&lt;/p&gt;

&lt;p&gt;Xdebug的安装是作为PHP的拓展而存在的，所以可参考PHP拓展文章：&lt;/p&gt;

&lt;p&gt;http://blog.csdn.net/why_2012_gogo/article/details/51120645&lt;/p&gt;

&lt;p&gt;2、配置&lt;/p&gt;

&lt;p&gt;php.ini:&lt;/p&gt;

&lt;p&gt;[xdebug]&lt;/p&gt;

&lt;p&gt;;基本调试配置&lt;/p&gt;

&lt;p&gt;xdebug.auto_trace = on&lt;/p&gt;

&lt;p&gt;xdebug.collect_params = on&lt;/p&gt;

&lt;p&gt;xdebug.collect_return = on&lt;/p&gt;

&lt;p&gt;xdebug.profiler_enable = on&lt;/p&gt;

&lt;p&gt;xdebug.profiler_output_dir =”/php/ext/xdebug_profilers”&lt;/p&gt;

&lt;p&gt;xdebug.trace_output_dir = “/tmp/ext/xdebug_traces”&lt;/p&gt;

&lt;p&gt;;远程调试设置&lt;/p&gt;

&lt;p&gt;xdebug.remote_enable = on&lt;/p&gt;

&lt;p&gt;xdebug.remote_host = localhost&lt;/p&gt;

&lt;p&gt;xdebug.remote_port = 9010&lt;/p&gt;

&lt;p&gt;xdebug.remote_autostart = on
zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20131226/xdebug.so&lt;/p&gt;

&lt;p&gt;用xdebug_debug_zval 和debug_backtrace,可以打印出引用计数&lt;/p&gt;

&lt;p&gt;所有的php变量都放在了zval的容器中，一个zval变量容器，除了包含变量的类型和值，也包括了另外两个字段，一个是is_ref（bool），标识此变量是否属于引用集合，&lt;/p&gt;

&lt;p&gt;（reference set）。另外的就是引用计数机制，用来优化内存试用。refcount用以标识指向这个zval变量容器的变量个数。&lt;/p&gt;

&lt;p&gt;变量容器在”refcount“变成0时就被销毁。&lt;/p&gt;

&lt;p&gt;[php] view plain copy
$a = “dog”;&lt;br /&gt;
$c = $b = $a;&lt;br /&gt;
xdebug_debug_zval( ‘a’ );&lt;br /&gt;
unset( $b, $c );&lt;br /&gt;
xdebug_debug_zval( ‘a’ );&lt;br /&gt;
[php] view plain copy
结果：&lt;br /&gt;
a: (refcount=2, is_ref=1)=’dog’
a: (refcount=1, is_ref=0)=’dog’&lt;/p&gt;

&lt;p&gt;但是如果是数组或者对象&lt;/p&gt;

&lt;p&gt;[php] view plain copy
$a=array(‘a’=&amp;gt;’avalue’,’b’=&amp;gt;’bvalue’);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xdebug_debug_zval('a');  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：
a: (refcount=1, is_ref=0)=array (‘a’ =&amp;gt; (refcount=1, is_ref=0)=’avalue’, ‘b’ =&amp;gt; (refcount=1, is_ref=0)=’bvalue’)
[Finished in 0.2s]&lt;/p&gt;

&lt;p&gt;所以它们的成员或属性存在自己的符号表中，所以上面一共有三个zval变量容器。a （array），a，b&lt;/p&gt;

&lt;p&gt;当有变量引用时，用xdebug_debug_zval的到的结果为：is_ref=1;refcount=变量被引用的数量（算上变量本身）
当变量没有发生引用时，用xdebug_debug_zval的到的结果为：is_ref=0;refcount=变量被复制的数量（算上变量本身）&lt;/p&gt;

&lt;p&gt;当有变量引用时，用debug_zval_dump的到的结果为：refcount=1（始终=1）
当变量没有发生引用时，用debug_zval_dump的到的结果为：refcount=变量被复制的数量（算上变量本身）+1&lt;/p&gt;

</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/02/26/Xdebug.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/02/26/Xdebug.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>Closure</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;匿名函数与闭包的区别
匿名函数：没有函数名称的函数；
这就是匿名函数：
function(argument1,argument2){&lt;/p&gt;

&lt;p&gt;}
闭包：一个可以使用另外一个函数作用域中的变量的函数。
如下面的代码函数b就是闭包，但是这个前提是：当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个我们通常所谓的“闭包”。
意思是说b要变成闭包的话，就必须被外包所引用，即c引用：
&lt;script type=&quot;text/javascript&quot;&gt;
function a(){
   var i=1;
   function b(){
       ++i;
      return i;
   }
  return b;
}
var c=a();
alert(c());
&lt;/script&gt;
用一个专业一点的说法就是：函数调用返回后一个没有释放资源的栈区；
一般，当函数执行完毕后，局部活动对象会被销毁，内存中仅保存全局作用域，但闭包的情况是不一样的。闭包的活动对象依然会保存在内存中，于是像上例中，函数调用返回后，变量i是属于活动对象里面的，就是说其栈区还没有释放，但你调用c()的时候i变量保存的作用域链从b()-&amp;gt;a()-&amp;gt;全局去寻找作用域var i声明所在，然后找到了var i=1;然后在闭包内++i;结果，最后输出的值就是2了；不知道这么说有没人明白，如果不明白，那么只要记住它的闭包的两个点就好了，一点就是闭包的活动对象没有被销毁；第二点是作用域链的关键是他要遇到var 声明；就好了····
共同点：他们都有是函数；除此之外没有任何共同点；&lt;/p&gt;

&lt;p&gt;理论上匿名函数和闭包是不一样的概念，在PHP中这两者概念与其他语言（比如JavaScript）是不一样的，这两者在使用上可以视为等同的&lt;/p&gt;

&lt;p&gt;匿名函数、lambda表达式、闭包（closure）区别与作用
　一.匿名函数、lambda、closure区别
　　从功能性上说lambda和closure（或是OC中的blocks）是一个东西，只是不同语言的不同称呼罢了，它们都是匿名函数。若匿名函数捕获了一个外部变量，那么它就是一个closure。
二.匿名函数、lambda、closure作用
　　简单说，引入它们的作用有2个：&lt;/p&gt;

&lt;p&gt;简洁
捕获变量
　　首先说简洁，匿名函数可以在其他函数内部声明与定义，不用另外写个命名函数
　　
自执行的匿名函数&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;什么是自执行的匿名函数?
它是指形如这样的函数: (function {// code})();&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;疑问
为什么(function {// code})();可以被执行, 而function {// code}();却会报错?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分析
(1). 首先, 要清楚两者的区别:
(function {// code})是表达式, function {// code}是函数声明.
(2). 其次, js”预编译”的特点:
js在”预编译”阶段, 会解释函数声明, 但却会忽略表式.
(3). 当js执行到function() {//code}();时, 由于function() {//code}在”预编译”阶段已经被解释过, js会跳过function(){//code}, 试图去执行();, 故会报错;
当js执行到(function {// code})();时, 由于(function {// code})是表达式, js会去对它求解得到返回值, 由于返回值是一 个函数, 故而遇到();时, 便会被执行.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外， 函数转换为表达式的方法并不一定要靠分组操作符()，我们还可以用void操作符，~操作符，!操作符……&lt;/p&gt;

&lt;p&gt;如：
!function(){ 
alert(“另类的匿名函数自执行”); 
}();
匿名函数与闭包&lt;/p&gt;

&lt;p&gt;闭包的英文单词是closure，这是JavaScript中非常重要的一部分知识，因为使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，总之功能十分强大。&lt;/p&gt;

&lt;p&gt;闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕（这点涉及JavaScript作用域链）。
function checkClosure(){ 
var str = ‘rain-man’; 
setTimeout( 
function(){ alert(str); } //这是一个匿名函数 
, 2000); 
} 
checkClosure();
这个例子看上去十分的简单，仔细分析下它的执行过程还是有许多知识点的：checkClosure函数的执行是瞬间的（也许用时只是0.00001毫秒），在checkClosure的函数体内创建了一个变量str，在checkClosure执行完毕之后str并没有被释放，这是因为setTimeout内的匿名函数存在这对str的引用。待到2秒后函数体内的匿名函数被执行完毕,str才被释放。&lt;/p&gt;

&lt;p&gt;闭包是怎么定义的，该如何理解
闭包本身定义比较抽象，MDN官方上解释是：A closure is the combination of a function and the lexical environment within which that function was declared.
中文解释是：闭包是一个函数和该函数被定义时的词法环境的组合。&lt;/p&gt;

&lt;p&gt;看定义好像比较难理解，那就举个经典的例子吧：&lt;/p&gt;

&lt;p&gt;function box(){
  var a = 10;
  function inner(){
    console.log(a) ; 
  }
  return inner;
}
var outer = box();
outer();//10
但是看到这里，还是一脸蒙比，到底哪个是闭包？貌似有三个函数呀，一个box，一个inner还有一个outer = box()。&lt;/p&gt;

&lt;p&gt;先看这几个函数在结构上有什么关系，box是全局的函数，具有局部变量a，inner是box函数内的局部函数，a对于inner是可以访问的，但无法直接在box外部访问box内部的局部变量a，outer是全局的。&lt;/p&gt;

&lt;p&gt;而执行box()后把box内部的inner return了出去，同时在box函数外部用变量outer作为return出去的inner函数的一个接收，可以理解为是box内部inner函数的一个指针引用。&lt;/p&gt;

&lt;p&gt;在box函数执行完毕后，内部的inner还被外部的outer引用着，此时的这个outer就是一个闭包。而inner又对a有引用，所以执行outer会打印a的值，这样就能在box的外部访问到内部的变量a了。
闭包的产生跟普通函数的压栈运行不太一样，普通函数运行时先被压住运行栈内存中，运行完后，函数和其内部变量以及function会释放掉，被内存给回收。但是闭包不会被回收，因为闭包是在函数外部对其内部function的一个指针引用，就像把闭包放在了堆中。&lt;/p&gt;

&lt;p&gt;所以此处的闭包是box函数内部的inner函数以及inner被定义时的词法环境，并且在执行box()后，有变量在外部引用这个inner，inner被定义时的词法环境就是box函数的私有作用域，这样就跟闭包的定义吻合了。&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/lang/2018/02/26/Closure.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/lang/2018/02/26/Closure.html</guid>
        
        
        <category>lang</category>
        
      </item>
    
      <item>
        <title>lex</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;ex
Lex 是一种生成扫描器的工具。扫描器是一种识别文本中的词汇模式的程序。 这些词汇模式（或者常规表达式）在一种特殊的句子结构中定义，这个我们一会儿就要讨论。&lt;/p&gt;

&lt;p&gt;一种匹配的常规表达式可能会包含相关的动作。这一动作可能还包括返回一个标记。 当 Lex 接收到文件或文本形式的输入时，它试图将文本与常规表达式进行匹配。 它一次读入一个输入字符，直到找到一个匹配的模式。 如果能够找到一个匹配的模式，Lex 就执行相关的动作（可能包括返回一个标记）。 另一方面，如果没有可以匹配的常规表达式，将会停止进一步的处理，Lex 将显示一个错误消息。&lt;/p&gt;

&lt;p&gt;Lex 和 C 是强耦合的。一个 .lex 文件（Lex 文件具有 .lex 的扩展名）通过 lex 公用程序来传递，并生成 C 的输出文件。这些文件被编译为词法分析器的可执行版本。&lt;/p&gt;

&lt;p&gt;Lex 的常规表达式
常规表达式是一种使用元语言的模式描述。表达式由符号组成。符号一般是字符和数字，但是 Lex 中还有一些具有特殊含义的其他标记。 下面两个表格定义了 Lex 中使用的一些标记并给出了几个典型的例子。&lt;/p&gt;

&lt;p&gt;用 Lex 定义常规表达式
字符	含义
A-Z, 0-9, a-z	构成了部分模式的字符和数字。
.	匹配任意字符，除了 \n。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;用来指定范围。例如：A-Z 指从 A 到 Z 之间的所有字符。
[ ]	一个字符集合。匹配括号内的 任意 字符。如果第一个字符是 ^ 那么它表示否定模式。例如: [abC] 匹配 a, b, 和 C中的任何一个。&lt;/li&gt;
  &lt;li&gt;匹配 0个或者多个上述的模式。&lt;/li&gt;
  &lt;li&gt;匹配 1个或者多个上述模式。
?	匹配 0个或1个上述模式。
$	作为模式的最后一个字符匹配一行的结尾。
{ }	指出一个模式可能出现的次数。 例如: A{1,3} 表示 A 可能出现1次或3次。
\	用来转义元字符。同样用来覆盖字符在此表中定义的特殊意义，只取字符的本意。
^	否定。
|	表达式间的逻辑或。
“&lt;一些符号&gt;&quot;	字符的字面含义。元字符具有。
/	向前匹配。如果在匹配的模版中的“/”后跟有后续表达式，只匹配模版中“/”前 面的部分。如：如果输入 A01，那么在模版 A0/1 中的 A0 是匹配的。
( )	将一系列常规表达式分组。
常规表达式举例
常规表达式	含义
joke[rs]	匹配 jokes 或 joker。
A{1,2}shis+	匹配 AAshis, Ashis, AAshi, Ashi。
(A[b-e])+	匹配在 A 出现位置后跟随的从 b 到 e 的所有字符中的 0 个或 1个。
Lex 中的标记声明类似 C 中的变量名。每个标记都有一个相关的表达式。 （下表中给出了标记和表达式的例子。） 使用这个表中的例子，我们就可以编一个字数统计的程序了。 我们的第一个任务就是说明如何声明标记。&lt;/一些符号&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;标记声明举例
标记	相关表达式	含义
数字(number)	([0-9])+	1个或多个数字
字符(chars)	[A-Za-z]	任意字符
空格(blank)	“ “	一个空格
字(word)	(chars)+	1个或多个 chars
变量(variable)	(字符)+(数字)&lt;em&gt;(字符)&lt;/em&gt;(数字)*	
Lex 编程
Lex 编程可以分为三步：&lt;/p&gt;

&lt;p&gt;以 Lex 可以理解的格式指定模式相关的动作。
在这一文件上运行 Lex，生成扫描器的 C 代码。
编译和链接 C 代码，生成可执行的扫描器。
注意: 如果扫描器是用 Yacc 开发的解析器的一部分，只需要进行第一步和第二步。 关于这一特殊问题的帮助请阅读 Yacc和 将 Lex 和 Yacc 结合起来部分。&lt;/p&gt;

&lt;p&gt;现在让我们来看一看 Lex 可以理解的程序格式。一个 Lex 程序分为三个段：第一段是 C 和 Lex 的全局声明，第二段包括模式（C 代码），第三段是补充的 C 函数。 例如, 第三段中一般都有 main() 函数。这些段以%%来分界。 那么，回到字数统计的 Lex 程序，让我们看一下程序不同段的构成。&lt;/p&gt;

&lt;p&gt;C 和 Lex 的全局声明
这一段中我们可以增加 C 变量声明。这里我们将为字数统计程序声明一个整型变量，来保存程序统计出来的字数。 我们还将进行 Lex 的标记声明。&lt;/p&gt;

&lt;p&gt;字数统计程序的声明
%{
 int wordCount = 0;
 %}
 chars [A-za-z_'.&quot;]
 numbers ([0-9])+
 delim [” “\n\t]
 whitespace {delim}+
 words {chars}+
 %%
两个百分号标记指出了 Lex 程序中这一段的结束和三段中第二段的开始。&lt;/p&gt;

&lt;p&gt;Lex 的模式匹配规则
让我们看一下 Lex 描述我们所要匹配的标记的规则。（我们将使用 C 来定义标记匹配后的动作。） 继续看我们的字数统计程序，下面是标记匹配的规则。&lt;/p&gt;

&lt;p&gt;字数统计程序中的 Lex 规则
{words} { wordCount++; /*
 increase the word count by one&lt;em&gt;/ }
 {whitespace} { /&lt;/em&gt; do
 nothing&lt;em&gt;/ }
 {numbers} { /&lt;/em&gt; one may
 want to add some processing here*/ }
 %%
C 代码
Lex 编程的第三段，也就是最后一段覆盖了 C 的函数声明（有时是主函数）。注意这一段必须包括 yywrap() 函数。 Lex 有一套可供使用的函数和变量。 其中之一就是 yywrap。 一般来说，yywrap() 的定义如下例。我们将在 高级 Lex 中探讨这一问题。&lt;/p&gt;

&lt;p&gt;字数统计程序的 C 代码段
void main()
 {
 yylex(); /* start the
 analysis*/
 printf(“ No of words:
 %d\n”, wordCount);
 }
 int yywrap()
 {
 return 1;
 }
上一节我们讨论了 Lex 编程的基本元素，它将帮助你编写简单的词法分析程序。 在 高级 Lex 这一节中我们将讨论 Lex 提供的函数，这样你就能编写更加复杂的程序了。&lt;/p&gt;

&lt;p&gt;将它们全部结合起来
.lex文件是 Lex 的扫描器。它在 Lex 程序中如下表示：&lt;/p&gt;

&lt;p&gt;1
$ lex &lt;file name.lex=&quot;&quot;&gt;
这生成了 lex.yy.c 文件，它可以用 C 编译器来进行编译。它还可以用解析器来生成可执行程序，或者在链接步骤中通过选项 �ll 包含 Lex 库。&lt;/file&gt;&lt;/p&gt;

&lt;p&gt;这里是一些 Lex 的标志：&lt;/p&gt;

&lt;p&gt;-c表示 C 动作，它是缺省的。
-t写入 lex.yy.c 程序来代替标准输出。
-v提供一个两行的统计汇总。
-n不打印 -v 的汇总。
高级 Lex
Lex 有几个函数和变量提供了不同的信息，可以用来编译实现复杂函数的程序。 下表中列出了一些变量和函数，以及它们的使用。 详尽的列表请参考 Lex 或 Flex 手册（见后文的 资源）。&lt;/p&gt;

&lt;p&gt;Lex 变量
yyin	FILE* 类型。 它指向 lexer 正在解析的当前文件。
yyout	FILE* 类型。 它指向记录 lexer 输出的位置。 缺省情况下，yyin 和 yyout 都指向标准输入和输出。
yytext	匹配模式的文本存储在这一变量中（char*）。
yyleng	给出匹配模式的长度。
yylineno	提供当前的行数信息。 （lexer不一定支持。）
Lex 函数
yylex()	这一函数开始分析。 它由 Lex 自动生成。
yywrap()	这一函数在文件（或输入）的末尾调用。 如果函数的返回值是1，就停止解析。 因此它可以用来解析多个文件。 代码可以写在第三段，这就能够解析多个文件。 方法是使用 yyin 文件指针（见上表）指向不同的文件，直到所有的文件都被解析。 最后，yywrap() 可以返回 1 来表示解析的结束。
yyless(int n)	这一函数可以用来送回除了前�n? 个字符外的所有读出标记。
yymore()	这一函数告诉 Lexer 将下一个标记附加到当前标记后。
对 Lex 的讨论就到这里。下面我们来讨论 Yacc…&lt;/p&gt;

&lt;p&gt;Yacc
Yacc 代表 Yet Another Compiler Compiler。 Yacc 的 GNU 版叫做 Bison。它是一种工具，将任何一种编程语言的所有语法翻译成针对此种语言的 Yacc 语 法解析器。它用巴科斯范式(BNF, Backus Naur Form)来书写。按照惯例，Yacc 文件有 .y 后缀。编译行如下调用 Yacc 编译器：
$ yacc &lt;options&gt;
 &amp;lt;filename ending with .y&amp;gt;
在进一步阐述以前，让我们复习一下什么是语法。在上一节中，我们看到 Lex 从输入序列中识别标记。 如果你在查看标记序列，你可能想在这一序列出现时执行某一动作。 这种情况下有效序列的规范称为语法。Yacc 语法文件包括这一语法规范。 它还包含了序列匹配时你想要做的事。&lt;/options&gt;&lt;/p&gt;

&lt;p&gt;为了更加说清这一概念，让我们以英语为例。 这一套标记可能是：名词, 动词, 形容词等等。为了使用这些标记造一个语法正确的句子，你的结构必须符合一定的规则。 一个简单的句子可能是名词+动词或者名词+动词+名词。(如 I care. See spot run.)&lt;/p&gt;

&lt;p&gt;所以在我们这里，标记本身来自语言（Lex），并且标记序列允许用 Yacc 来指定这些标记(标记序列也叫语法)。&lt;/p&gt;

&lt;p&gt;终端和非终端符号
终端符号 : 代表一类在语法结构上等效的标记。 终端符号有三种类型：&lt;/p&gt;

&lt;p&gt;命名标记: 这些由 %token 标识符来定义。 按照惯例，它们都是大写。&lt;/p&gt;

&lt;p&gt;字符标记 : 字符常量的写法与 C 相同。例如, – 就是一个字符标记。&lt;/p&gt;

&lt;p&gt;字符串标记 : 写法与 C 的字符串常量相同。例如，”«” 就是一个字符串标记。&lt;/p&gt;

&lt;p&gt;lexer 返回命名标记。&lt;/p&gt;

&lt;p&gt;非终端符号 : 是一组非终端符号和终端符号组成的符号。 按照惯例，它们都是小写。 在例子中，file 是一个非终端标记而 NAME 是一个终端标记。&lt;/p&gt;

&lt;p&gt;用 Yacc 来创建一个编译器包括四个步骤：&lt;/p&gt;

&lt;p&gt;通过在语法文件上运行 Yacc 生成一个解析器。
说明语法：
编写一个 .y 的语法文件（同时说明 C 在这里要进行的动作）。
编写一个词法分析器来处理输入并将标记传递给解析器。 这可以使用 Lex 来完成。
编写一个函数，通过调用 yyparse() 来开始解析。
编写错误处理例程（如 yyerror()）。
编译 Yacc 生成的代码以及其他相关的源文件。
将目标文件链接到适当的可执行解析器库。
用 Yacc 编写语法
如同 Lex 一样, 一个 Yacc 程序也用双百分号分为三段。 它们是：声明、语法规则和 C 代码。 我们将解析一个格式为 姓名 = 年龄 的文件作为例子，来说明语法规则。 我们假设文件有多个姓名和年龄，它们以空格分隔。 在看 Yacc 程序的每一段时，我们将为我们的例子编写一个语法文件。&lt;/p&gt;

&lt;p&gt;C 与 Yacc 的声明
C 声明可能会定义动作中使用的类型和变量，以及宏。 还可以包含头文件。每个 Yacc 声明段声明了终端符号和非终端符号（标记）的名称，还可能描述操作符优先级和针对不同符号的数据类型。 lexer (Lex) 一般返回这些标记。所有这些标记都必须在 Yacc 声明中进行说明。&lt;/p&gt;

&lt;p&gt;在文件解析的例子中我们感兴趣的是这些标记：name, equal sign, 和 age。Name 是一个完全由字符组成的值。 Age 是数字。于是声明段就会像这样：&lt;/p&gt;

&lt;p&gt;文件解析例子的声明
%
 #typedef char* string; /*
 to specify token types as char* &lt;em&gt;/
 #define YYSTYPE string /&lt;/em&gt;
 a Yacc variable which has the value of returned token &lt;em&gt;/
 %}
 %token NAME EQ AGE
 %%
你可能会觉得 YYSTYPE 有点奇怪。但是类似 Lex, Yacc 也有一套变量和函数可供用户来进行功能扩展。 YYSTYPE 定义了用来将值从 lexer 拷贝到解析器或者 Yacc 的 yylval （另一个 Yacc 变量）的类型。 默认的类型是 int。 由于字符串可以从 lexer 拷贝，类型被重定义为 char&lt;/em&gt;。 关于 Yacc 变量的详细讨论，请参考 Yacc 手册（见 资源）。&lt;/p&gt;

&lt;p&gt;Yacc 语法规则
Yacc 语法规则具有以下一般格式：
result: components { /*
 action to be taken in C */ }
 ;
在这个例子中，result 是规则描述的非终端符号。Components 是根据规则放在一起的不同的终端和非终端符号。 如果匹配特定序列的话 Components 后面可以跟随要执行的动作。 考虑如下的例子：
param : NAME EQ NAME {
 printf(“\tName:%s\tValue(name):%s\n”, $1,$3);}
     | NAME EQ VALUE{
     printf(“\tName:%s\tValue(value):%s\n”,$1,$3);}
 ;
如果上例中序列 NAME EQ NAME 被匹配，将执行相应的 { } 括号中的动作。 这里另一个有用的就是 $1 和 $3 的使用, 它们引用了标记 NAME 和 NAME（或者第二行的 VALUE）的值。 lexer 通过 Yacc 的变量 yylval 返回这些值。标记 NAME 的 Lex 代码是这样的：
char [A-Za-z]
 name {char}+
 %%
 {name} { yylval = strdup(yytext);
 return NAME; }
文件解析例子的规则段是这样的：&lt;/p&gt;

&lt;p&gt;文件解析的语法
file : record file
 | record
 ;
 record: NAME EQ AGE {
 printf(“%s is now %s years old!!!”, $1, $3);}
 ;
 %%
附加 C 代码
现在让我们看一下语法文件的最后一段，附加 C 代码。 （这一段是可选的，如果有人想要略过它的话：）一个函数如 main() 调用 yyparse() 函数（Yacc 中 Lex 的 yylex() 等效函数）。 一般来说，Yacc 最好提供 yyerror(char msg) 函数的代码。 当解析器遇到错误时调用 yyerror(char msg)。错误消息作为参数来传递。 一个简单的 yyerror( char* ) 可能是这样的：
int yyerror(char* msg)
 {
 printf(“Error: %s
 encountered at line number:%d\n”, msg, yylineno);
 }
yylineno 提供了行数信息。&lt;/p&gt;

&lt;p&gt;这一段还包括文件解析例子的主函数：&lt;/p&gt;

&lt;p&gt;附加 C 代码
void main()
 {
     yyparse();
 }
 int yyerror(char* msg)
 {
 printf(“Error: %s
 encountered \n”, msg);
要生成代码，可能用到以下命令：
$ yacc _d &lt;filename.y&gt;
这生成了输出文件 y.tab.h 和 y.tab.c，它们可以用 UNIX 上的任何标准 C 编译器来编译（如 gcc）。&lt;/filename.y&gt;&lt;/p&gt;

&lt;p&gt;命令行的其他常用选项
‘-d’ ,’–defines’ : 编写额外的输出文件，它们包含这些宏定义：语法中定义的标记类型名称，语义的取值类型 YYSTYPE, 以及一些外部变量声明。如果解析器输出文件名叫 ‘name.c’, 那么 ‘-d’ 文件就叫做 ‘name.h’。 如果你想将 yylex 定义放到独立的源文件中，你需要 ‘name.h’, 因为 yylex 必须能够引用标记类型代码和 yylval变量。
‘-b file-prefix’ ,’–file-prefix=prefix’ : 指定一个所有Yacc输出文件名都可以使用的前缀。选择一个名字，就如输入文件名叫 ‘prefix.c’.
‘-o outfile’ ,’–output-file=outfile’ : 指定解析器文件的输出文件名。其他输出文件根据 ‘-d’ 选项描述的输出文件来命名。
Yacc 库通常在编译步骤中自动被包括。但是它也能被显式的包括，以便在编译步骤中指定 �ly选项。这种情况下的编译命令行是：
$ cc &lt;source file=&quot;&quot; names=&quot;&quot; /&gt; -ly
将 Lex 与 Yacc 结合起来
到目前为止我们已经分别讨论了 Lex 和 Yacc。现在让我们来看一下他们是怎样结合使用的。&lt;/p&gt;

&lt;p&gt;一个程序通常在每次返回一个标记时都要调用 yylex() 函数。只有在文件结束或者出现错误标记时才会终止。&lt;/p&gt;

&lt;p&gt;一个由 Yacc 生成的解析器调用 yylex() 函数来获得标记。 yylex() 可以由 Lex 来生成或完全由自己来编写。 对于由 Lex 生成的 lexer 来说，要和 Yacc 结合使用，每当 Lex 中匹配一个模式时都必须返回一个标记。 因此 Lex 中匹配模式时的动作一般格式为：
{pattern} { /* do smthg*/
 return TOKEN_NAME; }
于是 Yacc 就会获得返回的标记。当 Yacc 编译一个带有 _d 标记的 .y文件时，会生成一个头文件，它对每个标记都有 #define 的定义。 如果 Lex 和 Yacc 一起使用的话，头文件必须在相应的 Lex 文件 .lex中的 C 声明段中包括。&lt;/p&gt;

&lt;p&gt;让我们回到名字和年龄的文件解析例子中，看一看 Lex 和 Yacc 文件的代码。&lt;/p&gt;

&lt;p&gt;Name.y - 语法文件
%
 typedef char* string;
 #define YYSTYPE string
 %}
 %token NAME EQ AGE
 %%
 file : record file
 | record
 ;
 record : NAME EQ AGE {
 printf(“%s is %s years old!!!\n”, $1, $3); }
 ;
 %%
 int main()
 {
 yyparse();
 return 0;
 }
 int yyerror(char *msg)
 {
 printf(“Error
 encountered: %s \n”, msg);
 }
Name.lex - Lex 的解析器文件
%{
 #include “y.tab.h”&lt;/p&gt;

&lt;p&gt;#include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
 extern char* yylval;
 %}
 char [A-Za-z]
 num [0-9]
 eq [=]
 name {char}+
 age {num}+
 %%
 {name} { yylval = strdup(yytext);
 return NAME; }
 {eq} { return EQ; }
 {age} { yylval = strdup(yytext);
 return AGE; }
 %%
 int yywrap()
 {
 return 1;
 }
作为一个参考，我们列出了 y.tab.h, Yacc 生成的头文件。&lt;/string.h&gt;&lt;/stdio.h&gt;&lt;/p&gt;

&lt;p&gt;y.tab.h - Yacc 生成的头文件&lt;/p&gt;
&lt;h1 id=&quot;define-name-257&quot;&gt;define NAME 257&lt;/h1&gt;
&lt;p&gt;# define EQ 258
 # define AGE 259&lt;/p&gt;

&lt;p&gt;无论是词法分析，还是语法分析，给我的第一感觉就是逻辑要严谨。由于项目有自己一套完整的语言和语法，设计好其对应的词法分析器和语法分析器显得尤为重要。
        我们采用flex进行词法分析。flex是一个用来生成扫描器（scanners）的工具，其中扫描器就是可以识别文本中词法模式的程序。具体流程为：flex读取给定的输入文件，或标准输入（当没有给定文件名时）读取信息来生成一个扫描器。信息以正则表达式和C代码组成，这种形式称为规则（rule）。flex生成C源代码文件lex.yy.c，其中定义了一个函数yylex()。这个文件通过编译，并用-lfl 链接生成可执行文件。当可执行文件被执行时，它分析输入中可能存在的符合正则表达的内容。当找到任何一个与正则表达式相匹配内容时，相应的C 代码将被执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    flex输入文件由三段组成：定义（definitions），规则（rules），用户代码（user code）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一、定义段（definitions）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    定义段包含了简单名称的声明（这些声明可以简化扫描器的说明）和开始条件。在本项目中，定义段中还包含了选项options。现将介绍一些比较常用的options。

    flex 提供一个机制用来在扫描器的说明中，而不是在flex 命令中控制选项。在扫描器的说明文件（flex 的输入文件）的第一段中使用%option 指令就可以实现。你可以用单个%option 指令指定多个选项，也可以使用多个%option指令。

    %option 7bit，%option 8bit——指示flex生成一个7bit或8bit的扫描器与-7，-8 选项等价。

    %option backup——生成一个备份信息到lex.backup，与-b选项等价。

    %option caseful，%option case-sensitive——区分大小写，与-i相反。

    %option case-insensitive，%option caseless——忽略大小写，与-i选项等价。

    %option debug——让生成的扫描器运行在debug模式，与-d选项等价。

    %option default，%option nodefault——%default与-s选项相反，后者与其等价。-s选项作用：使不匹配的输入回显到输出设备的rule失去作用。在此种情况下，如果扫描器不能匹配到任何规则rule的输入，它会终止并返回错误。在查找扫描器的规则漏洞时，-s和%option nodefault都非常有用。

    %option interactive——指示flex生成一个交互式的扫描器。交互式扫描器就是向前查看下一个匹配的token是什么。结果就是总向前多看了一个字符，即使是在扫描器已经看够了文本已经排除了token 的歧义。但向前查看给了扫描器强大的交互能力。与-I等价。

    %option warn——与-w选项相反。%option nowarn与-w选项等价。

    %option array——与%array等价。

    %option pointer——与%point等价。

    以下为%option中定义，但在命令行里没有的特性。

    %option always-interactive——指示flex 生成的扫描器总是把它的输入认为是&quot;interactive&quot;。

    %option main——指示flex 为扫描器提供一个缺省的main()函数，它只是简单的调用了yylex()。这个选项暗示noyywrap。

    %option never-interactive——flex 生成的扫描器从不认为输入是交互的（不会调用isatty()）。这和总是interactive 正好相反。

    %option yylineno——flex 生成的扫描器用全局变量yylineno 维护着输入文件的当前行编号。option lex-compat隐含有这个选项。

    %option yywrap——如果没有设置（就如%option noyywrap），当扫描器遇到end-of-file 时，不会调用yywrap()，但简单的假定没有更多的文件可以扫描（直到用户把yyin 指向新的文件并再一次调用yylex（））。

    flex 通过扫描rule 中的action 来判断你是否使用了REJECT 或是yymore 属性。你可用%option reject 表示要使用这个特性而用%option noyymore 表示不使用这个特性。

    三个选项使用了字符串值，从'='开始：%option outfile=&quot;ABC&quot;等同于-oABC ；%option prefix=&quot;XYZ&quot; 等同于-PXYZ；最后，%option yyclass=&quot;foo&quot; 只有当生成C++扫描器（-+选项）时才有效。

   有些选项可以限制一个例程不出现在生成的扫描器中。下面这些例程如果不被设置（如%option nounput）将不会出现在生成的扫描器中。

   input unput yy_push_state yy_pop_sate yy_top_state yy_scan_buffer yy_scan_bytes yy_scan_string

   可重入c扫描器（Reentrant C Scanners）

   flex能够生成一个可重入的扫描器。通过定义%option reentrant（与-R选项等价）来实现可重入。所生成的扫描器在一个或多个控制线程中不仅可移植，而且安全性好。可重入扫描器通常应用于多线程应用程序。任何一个线程都可以在不考虑与其他线程同步的情况下创建并执行一个可重入的flex扫描器。

   默认情况下，flex生成一个不可重入的扫描器。本项目为了实现多线程，因而在定义段指定%option reentrant。

   性能考虑（performance consideration）

   flex的设计目标就是生成一个高性能的扫描器。它已经对处理大量rule 做了优化。除了用-C 选项进行表格压缩之外，还有一些option/action 会影响到扫描器的速度。从最大影响到最弱，有这一些：

   REJECT          %option yylineno           arbitrary trailing context

   pattern sets that require backing up        %array          %option interactive             %option always-interactive

   '^'beginning-of-line operator      yymore()

   头三个的开销最大，后两个的开销最小。注意unput()有可能被用例程实现而造成更多操作，而yyless()是一个开销相当低的宏；所以如果只是回放一些你多扫了的文本，可以用yyless()。

   本项目中也用到了名字定义和开始条件。其中名字定义包括数字、字符、空白符，多行注释，单行注释，引号间的字符串，整数、浮点数、实数，标示符，变量，日期。

   数字—digit [0-9]，字符—character [a-zA-Z]，空白符—space [ \t\r](在制表符前面留有空格表示空格符)

   多行注释（以/#开头，中间可以为任意非#非\n字符，也可以为一串#后面紧跟非/非\n字符，最后结尾为1个或多个#后跟/）

   comstart   \/\#

   comstop \#+\/

   cominside ([^#\n]*|#+[^#/\n])

   单行注释 line_comment  ^#[^\n]*

   引号间的字符串（以双引号开头以双引号结尾。内容为非转义字符和双引号，当遇到转义字符时，进行特殊处理；当遇到双引号时，停止匹配）

   dquotes \&quot;

   stringstart {dquotes}

   stringstop {dquotes}

   stringinside [^\\\&quot;]+

   注意：在多行注释和引号间的字符串的匹配中，采用了排斥条件（开始条件分为排斥和共享条件）

   排斥条件的定义为 %xc（针对多行注释）

                                     %xs（针对引号间的字符串）

   整数 integer {digit}+

   浮点数 decimal (({digit}+\.{digit}*)|({digit}*\.{digit}+))

                 decimalfail {digit}+\.\.

   实数 real ({integer}|{decimal})[eE][+-]?{digit}+

             realfail1 ({integer}|decimal)[eE]

             realfail2 ({integer}|decimal)[eE][+-]

   标示符 identstart [a-zA-Z\200-\377_]

   identcont [a-zA-Z\200-\377_0-9\$]

   identifier {identstart}{identcont}*

   变量（$后跟一个或多个字符） variable \${character}+

   日期 date {digit}+\-{digit}+(\-{digit}+)?

             datefail1 {digit}+\-{digit}+\-

             datefail2 {digit}+\- 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、规则段（rules）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   规则段包含模式（pattern）和动作（action），其中模式不能有缩进，而且动作必须在同一行上跟在动作后面。

   在规则段可以使用开始条件（start conditions）。flex 提供了一种按条件激活规则rule 的机制。所有模式以&quot;&amp;lt;sc&amp;gt;&quot;为前缀的rule 只有在扫描器是在一个名为&quot;sc&quot;的启动条件时才会被激活。使用BEGIN action 可以激活一个开始条件。直到下一个BEGIN action 被执行，在给出开始条件的rule将被激活并且其他给出其他开始条件的rule 并不会被激活。如果使用的是排他的开始条件，那么只有以开始条件修饰的rule 才会被激活。跟在同一个排他开始条件后的rule 说明在扫描器中，这些rule 是独立于flex 输入中的其他rule。

    本项目中涉及到排斥条件的有多行注释、引号间的字符串。

    其中MOVELOC,SAVETOKEN为定义段中定义的宏

    #define MOVELOC  {yylloc-&amp;gt;first_column = yylloc-&amp;gt;last_column;\

                                         yylloc-&amp;gt;last_column = yylloc-&amp;gt;first_column + yyleng;}

    #define RESETLOC {yylloc-&amp;gt;first_column = yylloc-&amp;gt;last_column = 1;\

                                        yylloc-&amp;gt;first_line++;\

                                        yylloc-&amp;gt;last_line++;}

   #define SAVETOKEN yylval-&amp;gt;str = new std::string(yytext, yyleng)

    多行注释(语句输出省略)

    {comstart}       {         MOVELOC;

                                        BEGIN(xc);

                              }

    &amp;lt;xc&amp;gt;{cominside} {     MOVELOC;      }

    &amp;lt;xc&amp;gt;\n              {         RESETLOC;     }

    &amp;lt;xc&amp;gt;{comstop} {       MOVELOC;

                                        BEGIN(INITIAL);

                              }

    &amp;lt;xc&amp;gt;&amp;lt;&amp;lt;EOF&amp;gt;&amp;gt; {       BEGIN(INITIAL);

                                       std::cerr &amp;lt;&amp;lt; &quot;unterminated /# comment&quot; &amp;lt;&amp;lt; endl;

                                       yyterminate();

                               }

   引号间的字符串(输出语句省略)

   {stringstart}         {   MOVELOC;

                                     BEGIN(xs);

                                     SAVETOKEN;

                              }

   &amp;lt;xs&amp;gt;{stringstop} {  MOVELOC;

                                     BEGIN(INITIAL);

                                     *(yylval-&amp;gt;str) += yytext;

                                     return QUOTES_STRING;

                              }

   &amp;lt;xs&amp;gt;\n               {       RESETLOC;

                                      *(yylval-&amp;gt;str) += yytext;

                              }

   &amp;lt;xs&amp;gt;\\n               {     MOVELOC;

                                      *(yylval-&amp;gt;str) += &quot;\n&quot;;

                              }

    &amp;lt;xs&amp;gt;\\t               {      MOVELOC;

                                      *(yylval-&amp;gt;str) += &quot;\t&quot;;

                              }

    &amp;lt;xs&amp;gt;\\r               {      MOVLOC;

                                      *(yylval-&amp;gt;str) += &quot;\r&quot;;

                              }

    &amp;lt;xs&amp;gt;\\b             {      MOVELOC;

                                      *(yylval-&amp;gt;str) += &quot;\b&quot;;

                              }

    &amp;lt;xs&amp;gt;\\f               {      MOVELOC;

                                      *(yylval-&amp;gt;str) += &quot;\f&quot;;

                              }

     &amp;lt;xs&amp;gt;\\.             {       MOVELOC;

                                      *(yylval-&amp;gt;str) += yytext[1];

                              }

    &amp;lt;xs&amp;gt;\\\n             {     RESETLOC;

                                      *(yylval-&amp;gt;str) += &quot;\n&quot;;

                              }

   &amp;lt;xs&amp;gt;{stringinside} {        MOVELOC;

                                    *(yylval-&amp;gt;str) += yytext;

                              }

   &amp;lt;xs&amp;gt;&amp;lt;&amp;lt;EOF&amp;gt;&amp;gt; {     BEGIN(INITIAL);

                                    std::cerr &amp;lt;&amp;lt; &quot;unterminated \&quot;&quot; &amp;lt;&amp;lt; endl;

                                     delete yylval-&amp;gt;str;

                                    yyterminate();

                             }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三、用户代码段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  用户代码段只会简单的拷贝到lex.yy.c中。这个和扫描器一起，调用扫描器或者被扫描器调用。如果被省略，则第二个%%可以省略。

  使用了%option reentrant后

  1所有的函数都会带一个额外的参数yyscanner。

  2所有的全局变量都被它们的宏等价替换。

  这些变量包括yytext,yyleng, yylineno, yyin, yyout,yyextra, yylval, and yylloc，你可以在action部分安全地使用这些宏（如同使用普通变量一样），但不能够在外部直接使用。以yytext为例，在一个可重入的扫描器中，yytext以及其他类似变量都不是全局变量，因而不能通过action外部或是其他函数来直接访问yytext，而应该使用yyget_text访问器函数来实现对yytext的访问。

  3在使用yylex之前调用yylex_init，在使用之后调用yylex_destroy。

  init以及destroy函数

  int yylex_init ( yyscan_t * ptr_yy_globals ) ;

  int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t * ptr_yy_globals ) ;

  int yylex ( yyscan_t yyscanner ) ;

  int yylex_destroy ( yyscan_t yyscanner ) ;

  函数yylex_init必须在调用任意其他函数之前调用，其参数是一个未初始化的指针地址，并由该函数初始化，这样会覆盖以前的内容。ptr_yy_global中存储的值会传递给yylex和yylex_destroy。flex不会保存传递给yylex_init的变量，因而传递一个局部指针的地址值给yylex_init是很安全的，只要其在调用扫描器到调用yylex_destroy期间一直存在就行。

  yylex的可重入版本带一个参数，该参数即为yylex_init通过变量返回的值。

  yylex_destroy函数用来释放扫描器使用过的资源。当要重复使用时，就不必destroy。

  4获取函数（get或set）提供了访问普通flex变量的途径。

  5用户自定义数据可以再yyextra中存储。

  在一个可重入的扫描器中，使用全局变量让程序的不同部分通信或是保持状态是不明智的。然而，你需要在action中使用额外的数据或是调用额外的函数。同样，你需要传递信息给你的扫描器。在一个不可重入的扫描器中，实现这的唯一方式就是使用全局变量。flex允许你存储任意的、额外的数据到扫描器中。定义如下：

  #define YY_EXTRA_TYPE void*

  YY_EXTRA_TYPE yyget_extra ( yyscan_t scanner );

  void yyset_extra ( YY_EXTRA_TYPE arbitrary_data , yyscan_t scanner);

  项目中最后的代码如下，其中scanner_init初始化yylex，yy_scan_buffer函数（作用是建立输入缓存）从yyext-&amp;gt;scanbuf指定的开始位置扫描slen+2个字节，最后两个字节必须是YY_END_OF_BUFFER_CHAR。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[html] view plain copy
yyscan_t&lt;br /&gt;
scanner_init(const char *str, inl_yylex_extra *yyext)&lt;br /&gt;
{&lt;br /&gt;
         int             slen = strlen(str);&lt;br /&gt;
         yyscan_t        scanner;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     if(yylex_init(&amp;amp;scanner) != 0)  
     {  
             std::cerr &amp;lt;&amp;lt; &quot;yylex_init() failed&quot; &amp;lt;&amp;lt; std::endl;  
             exit(1);  
     }  
   
     inl_yyset_extra(yyext, scanner);  
   
     yyext-&amp;gt;scanbuf = (char *)malloc(slen + 2);  
     yyext-&amp;gt;scanbuflen = slen;  
   
     memcpy(yyext-&amp;gt;scanbuf, str, slen);  
     yyext-&amp;gt;scanbuf[slen] = yyext-&amp;gt;scanbuf[slen + 1] = YY_END_OF_BUFFER_CHAR;  
     yy_scan_buffer(yyext-&amp;gt;scanbuf, slen + 2, scanner);  
   
     return scanner;   }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;void scanner_finish(yyscan_t yyscanner)&lt;br /&gt;
{&lt;br /&gt;
         free((*((inl_yylex_extra**)(yyscanner)))-&amp;gt;scanbuf);&lt;br /&gt;
         inl_yylex_destroy(yyscanner);&lt;br /&gt;
}&lt;/p&gt;
</description>
        <pubDate>Tue, 13 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/lang/2018/02/13/lex.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/lang/2018/02/13/lex.html</guid>
        
        
        <category>lang</category>
        
      </item>
    
      <item>
        <title>vld_dot_graphviz</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;PHP7.1下 vld扩展的安装使用
PHP7.1下 vld扩展的安装使用
原创 2017年03月29日 08:03:05 595
1）git clone https://github.com/derickr/vld.git&lt;/p&gt;

&lt;p&gt;2）cd vld&lt;/p&gt;

&lt;p&gt;3）phpize&lt;/p&gt;

&lt;p&gt;4）./configure&lt;/p&gt;

&lt;p&gt;5）make &amp;amp;&amp;amp; make install&lt;/p&gt;

&lt;p&gt;6）添加ext-vld.ini配置文件&lt;/p&gt;

&lt;p&gt;7）重启fpm&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;8）php -m&lt;/td&gt;
      &lt;td&gt;grep vld 查看扩展&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;9）php -dvld.active test.php 测试vld扩展&lt;/p&gt;

&lt;p&gt;PHP7.1下 vld扩展的安装使用
原创 2017年03月29日 08:03:05 595
1）git clone https://github.com/derickr/vld.git&lt;/p&gt;

&lt;p&gt;2）cd vld&lt;/p&gt;

&lt;p&gt;3）phpize&lt;/p&gt;

&lt;p&gt;4）./configure&lt;/p&gt;

&lt;p&gt;5）make &amp;amp;&amp;amp; make install&lt;/p&gt;

&lt;p&gt;6）添加ext-vld.ini配置文件&lt;/p&gt;

&lt;p&gt;7）重启fpm&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;8）php -m&lt;/td&gt;
      &lt;td&gt;grep vld 查看扩展&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;9）php -dvld.active test.php 测试vld扩展&lt;/p&gt;

&lt;p&gt;关于VLD扩展显示信息的一点点解释&lt;/p&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;p&gt;branch analysis from position 在分析数组时使用&lt;/p&gt;

&lt;p&gt;return found是否返还&lt;/p&gt;

&lt;p&gt;filename 分析的文件名&lt;/p&gt;

&lt;p&gt;function name函数名&lt;/p&gt;

&lt;p&gt;number of ops生成的操作数&lt;/p&gt;

&lt;p&gt;compiled vars编译期间的变量，PHP5后添加，是一个缓存优化，在PHP源码中以IS_CV标记&lt;/p&gt;

&lt;p&gt;op list生成的中间代码的变量列表&lt;/p&gt;

&lt;p&gt;-dvld.active输出的是VLD的默认设置，使用-dvld.verbosity可以查看更加详细的内容&lt;/p&gt;

&lt;p&gt;包含各个中间代码的操作数等&lt;/p&gt;

&lt;p&gt;若只想看到输出的中间代码，并不想实际执行这段代码，可以使用-dvld.execute = 0来禁用代码的执行&lt;/p&gt;

&lt;p&gt;php -dvld.active=1 -dvld.execute=0 test.php&lt;/p&gt;

&lt;p&gt;它还可以支持输出.dot文件&lt;/p&gt;

&lt;p&gt;php -dvld.active=1 -dvld.save_dir=’D:\tmp’ -dvld.save_paths=1 -dvld.dump_paths=1 t.php 会将生成的中间代码的信息输出再D:/tmp/path.dot中&lt;/p&gt;

&lt;p&gt;-dvld.format是否以自定义的格式输出，默认为否，是指以-dvld.col_sep指定的参数间隔&lt;/p&gt;

&lt;p&gt;-dvld.col_sep在-dvld.format参数启用时才会有效，默认为 \t&lt;/p&gt;

&lt;p&gt;-dvld.verbosity是否显示更加详细的信息，默认为1，其值可以是0，1，2，3 或者小于0只是比1小的效果会喝0一样，负数的效果和3的效果一样&lt;/p&gt;

&lt;p&gt;-dvld.save_dir指定文件的输出路径，默认/tmp&lt;/p&gt;

&lt;p&gt;-dvld.save_path指定文件输出的路径，默认0表示不输出文件&lt;/p&gt;

&lt;p&gt;-dvld.dump_paths控制输出的内容，0或1 默认1，即输出内容&lt;/p&gt;

&lt;p&gt;2、linux下咋安装graphviz
http://www.cnblogs.com/sld666666/archive/2010/06/25/1765510.html
2.1）CentOS 下安装 graphviz&lt;/p&gt;

&lt;p&gt;$ sudo yum install graphviz&lt;/p&gt;

&lt;p&gt;Install 39 Package(s)&lt;/p&gt;

&lt;p&gt;总下载量：13 M
Installed size: 35 M
确定吗？[y/N]：y&lt;/p&gt;

&lt;p&gt;已安装:
graphviz.i686 0:2.26.0-10.el6&lt;/p&gt;

&lt;p&gt;完毕！&lt;/p&gt;

&lt;p&gt;3、在Linux下如何使用&lt;/p&gt;

&lt;p&gt;　　假设我们把上面的代码写到了一个叫做aa.gv的文本文件里面，那么我们执行如下命令就可以了：&lt;/p&gt;

&lt;p&gt;　　$ dot -Tpng -ohehe.png aa.gv&lt;/p&gt;

&lt;p&gt;　　这样就会在当前目录下生成一个叫做hehe.png的图片文件
　　&lt;/p&gt;

&lt;p&gt;mac&lt;/p&gt;

&lt;p&gt;wget http://pecl.php.net/get/vld-0.14.0.tgz
tar zxvf vld-0.14.0.tgz
cd vld-0.14.0
phpize
locate php-config
./configure –with-php-config=/usr/local/Cellar/php70/7.0.25_17/bin/php-config
 make &amp;amp;&amp;amp; make install
 php -r ‘phpinfo();’ |grep vld
 ls /usr/local/Cellar/php70/7.0.25_17/lib/php/extensions/no-debug-non-zts-20151012/vld.so
 vi  /usr/local/etc/php/7.0/php.ini
 php -r ‘phpinfo();’ |grep vld
 php -dvld.active=1 -dvld.execute=0 test.php
 php -dvld.active=1 -dvld.save_paths=1 test.php
 ls /tmp
 brew install graphviz
 dot -Tpng /tmp/paths.dot -o paths.png
&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/paths.png&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/02/12/vld_dot_graphviz.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/02/12/vld_dot_graphviz.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>phpvld</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;vld介绍&lt;/p&gt;

&lt;p&gt;　　vld是PECL（PHP 扩展和应用仓库）的一个PHP扩展，现在最新版本是 0.14.0（2016-12-18），它的作用是：显示转储PHP脚本（opcode）的内部表示（来自PECL的vld简介）。简单来说，可以查看PHP程序的opcode。
vld扩展的安装&lt;/p&gt;

&lt;p&gt;　　1、下载官方插件安装压缩包&lt;/p&gt;

&lt;p&gt;　　　　官方网址：http://pecl.php.net/package/vld
　　　　下载命令：# wget http://pecl.php.net/get/vld-0.14.0.tgz&lt;/p&gt;

&lt;p&gt;　　　　注：下载的URL是在相对的版本链接上，点击右键，复制链接即可&lt;/p&gt;

&lt;p&gt;　　2、解包&lt;/p&gt;

&lt;p&gt;　　　　解包命令：# tar zxvf vld-0.14.0.tgz&lt;/p&gt;

&lt;p&gt;　　3、编译和安装&lt;/p&gt;

&lt;p&gt;　　　　进入解压后的vld目录：# cd vld-0.14.0/&lt;/p&gt;

&lt;p&gt;　　　　扩展php扩展模块:# phpize&lt;/p&gt;

&lt;p&gt;　　　　使用locate找php-config路径：# locate php-config&lt;/p&gt;

&lt;p&gt;　　　　　　注：locate命令没有的话可以使用命令：【# yum -y install mlocate 】 安装后使用 【#  updatedb】 更新数据后可以直接使用&lt;/p&gt;

&lt;p&gt;　　　　　　找到的php-config如下：&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;/p&gt;

&lt;p&gt;　　　　配置编译vld的php-config路径：#  ./configure –with-php-config=/usr/bin/php-config –enable-vld&lt;/p&gt;

&lt;p&gt;　　　　编译安装：# make &amp;amp;&amp;amp; make install&lt;/p&gt;

&lt;p&gt;　　4、重启服务器&lt;/p&gt;

&lt;p&gt;　　　　重启Apache：# systemctl restart httpd.service&lt;/p&gt;

&lt;p&gt;　　　　重启Nginx和PHP-fpm（如果有Nginx的话重启）：&lt;/p&gt;

&lt;p&gt;　　　　　　# systemctl restart nginx.service&lt;/p&gt;

&lt;p&gt;　　　　　　# systemctl restart php-fpm.service&lt;/p&gt;

&lt;p&gt;　　　　注：systemctl是新版本的centos系统有的，没有该命令的可以使用下面三个命令代替&lt;/p&gt;

&lt;p&gt;　　　　　　# service apachectl restart&lt;/p&gt;

&lt;p&gt;　　　　　　# service nginx restart&lt;/p&gt;

&lt;p&gt;　　　　　　# service php-fpm restart&lt;/p&gt;

&lt;p&gt;vld扩展的测试&lt;/p&gt;

&lt;p&gt;　　使用phpinfo()函数测试是否已成功安装，测试代码：&lt;/p&gt;

&lt;?php 
    phpinfo();
?&gt;
&lt;p&gt;　　　　1、使用网络访问结果如下（显示enabled）：
　　　　2、使用命令测试（显示enabled）：&lt;/p&gt;

&lt;p&gt;　　　　　　命令是:# php test.php | grep “vld”
那么，vld怎么用捏？&lt;/p&gt;

&lt;p&gt;　　vld不能单独使用，它需要和PHP命令一起。它主要有两个参数分别是 -dvld.active （等于1证明是使用vld扩展）和 -dvld.execute （等于1证明是需要执该PHP文件，默认是1）。&lt;/p&gt;

&lt;p&gt;　　测试命令：# php -dvld.active=1 -dvld.execute=0 test.php&lt;/p&gt;

&lt;p&gt;　　（就是指运行test.php的时候，使用vld插件，不执行，只显示opcode）&lt;/p&gt;

&lt;p&gt;VLD(Vulcan Logic Dumper)是一个在Zend引擎中，以挂钩的方式实现的用于输出PHP脚本生成的中间代码（执行单元）的扩展。 它可以在一定程序上查看Zend引擎内部的一些实现原理，是我们学习PHP源码的必备良器。它的作者是Derick Rethans, 除了VLD扩展，我们常用的XDebug扩展的也有该牛人的身影。&lt;/p&gt;

&lt;p&gt;VLD扩展是一个开源的项目，在这里可以下载到最新的版本，虽然最新版本的更新也是一年前的事了。 作者没有提供编译好的扩展，Win下使用VC6.0编译生成dll文件，可以看我之前写过的一篇文章(使用VC6.0生成VLD扩展)。 *nix系统下直接configue,make,make install生成。如果遇到问题，请自行Google之。&lt;/p&gt;

&lt;p&gt;看一个简单的例子,假如存在t.php文件，其内容如下：&lt;/p&gt;

&lt;p&gt;$a = 10;
echo $a;
在命令行下使用VLD扩展显示信息。&lt;/p&gt;

&lt;p&gt;php -dvld.active=1 t.php
-dvld.active=1表示激活VLD扩展，使用VLD扩展输出中间代码，此命令在CMD中输出信息为：&lt;/p&gt;

&lt;p&gt;Branch analysis from position: 0
Return found
filename:       D:\work\xampp\xampp\php\t.php
function name:  (null)
number of ops:  5
compiled vars:  !0 = $a
line     # *  op                           fetch          ext  return  operands
———————————————————————————
   2     0  &amp;gt;   EXT_STMT
         1      ASSIGN                                                   !0, 10
   3     2      EXT_STMT
         3      ECHO                                                     !0
   4     4    &amp;gt; RETURN                                                   1&lt;/p&gt;

&lt;p&gt;branch: #  0; line:     2-    4; sop:     0; eop:     4
path #1: 0,
10
如上为VLD输出的PHP代码生成的中间代码的信息，说明如下：&lt;/p&gt;

&lt;p&gt;Branch analysis from position 这条信息多在分析数组时使用。
Return found 是否返回，这个基本上有都有。
filename 分析的文件名
function name 函数名，针对每个函数VLD都会生成一段如上的独立的信息，这里显示当前函数的名称
number of ops 生成的操作数
compiled vars 编译期间的变量，这些变量是在PHP5后添加的，它是一个缓存优化。这样的变量在PHP源码中以IS_CV标记。
op list 生成的中间代码的变量列表
使用-dvld.active参数输出的是VLD默认设置，如果想看更加详细的内容。可以使用-dvld.verbosity参数。&lt;/p&gt;

&lt;p&gt;php -dvld.active=1 -dvld.verbosity=3 t.php
-dvld.verbosity=3或更大的值的效果都是一样的，它们是VLD在当前版本可以显示的最详细的信息了，包括各个中间代码的操作数等。显示结果如下：&lt;/p&gt;

&lt;p&gt;Finding entry points
Branch analysis from position: 0
Add 0
Add 1
Add 2
Add 3
Add 4
Return found
filename:       D:\work\xampp\xampp\php\t.php
function name:  (null)
number of ops:  5
compiled vars:  !0 = $a
line     # *  op                           fetch          ext  return  operands
——————————————————————————–
-
   2     0  &amp;gt;   EXT_STMT                                          RES[  IS_UNUSED  ]         OP1[  IS_UNUSED  ] OP2[  IS_UNUSED  ]
         1      ASSIGN                                                    OP1[IS_CV !0 ] OP2[ ,  IS_CONST (0) 10 ]
   3     2      EXT_STMT                                          RES[  IS_UNUSED  ]         OP1[  IS_UNUSED  ] OP2[  IS_UNUSED  ]
         3      ECHO                                                      OP1[IS_CV !0 ]
         4    &amp;gt; RETURN                                                    OP1[IS_CONST (0) 1 ]&lt;/p&gt;

&lt;p&gt;branch: #  0; line:     2-    3; sop:     0; eop:     4
path #1: 0,
10
以上的信息与没有加-dvld.verbosity=3的输出相比，多了Add 字段，还有中间代码的操作数的类型，如IS_CV,IS_CONST等。 PHP代码中的$a = 10; 其中10的类型为IS_CONST, $a作为一个编译期间的一个缓存变量存在，其类型为IS_CV。&lt;/p&gt;

&lt;p&gt;如果我们只是想要看输出的中间代码，并不想执行这段PHP代码，可以使用-dvld.execute=0来禁用代码的执行。&lt;/p&gt;

&lt;p&gt;php -dvld.active=1 -dvld.execute=0 t.php
运行这个命令，你会发现这与最开始的输出有一点点不同，它没有输出10。 除了直接在屏幕上输出以外，VLD扩展还支持输出.dot文件，如下的命令：&lt;/p&gt;

&lt;p&gt;php -dvld.active=1 -dvld.save_dir=’D:\tmp’ -dvld.save_paths=1 -dvld.dump_paths=1 t.php
以上的命令的意思是将生成的中间代码的一些信息输出在D:/tmp/paths.dot文件中。 -dvld.save_dir指定文件输出的路径，-dvld.save_paths控制是否输出文件，-dvld.dump_paths控制输出的内容，现在只有0和1两种情况。 输出的文件名已经在程序中硬编码为paths.dot。这三个参数是相互依赖的关系，一般都会同时出现。&lt;/p&gt;

&lt;p&gt;总结一下，VLD扩展的参数列表：&lt;/p&gt;

&lt;p&gt;-dvld.active 是否在执行PHP时激活VLD挂钩，默认为0，表示禁用。可以使用-dvld.active=1启用。
-dvld.skip_prepend 是否跳过php.ini配置文件中auto_prepend_file指定的文件， 默认为0，即不跳过包含的文件，显示这些包含的文件中的代码所生成的中间代码。此参数生效有一个前提条件：-dvld.execute=0
-dvld.skip_append 是否跳过php.ini配置文件中auto_append_file指定的文件， 默认为0，即不跳过包含的文件，显示这些包含的文件中的代码所生成的中间代码。此参数生效有一个前提条件：-dvld.execute=0
-dvld.execute 是否执行这段PHP脚本，默认值为1，表示执行。可以使用-dvld.execute=0，表示只显示中间代码，不执行生成的中间代码。
-dvld.format 是否以自定义的格式显示，默认为0，表示否。可以使用-dvld.format=1，表示以自己定义的格式显示。这里自定义的格式输出是以-dvld.col_sep指定的参数间隔
-dvld.col_sep 在-dvld.format参数启用时此函数才会有效，默认为 “\t”。
-dvld.verbosity 是否显示更详细的信息，默认为1，其值可以为0,1,2,3 其实比0小的也可以，只是效果和0一样，比如0.1之类，但是负数除外，负数和效果和3的效果一样 比3大的值也是可以的，只是效果和3一样。
-dvld.save_dir 指定文件输出的路径，默认路径为/tmp。
-dvld.save_paths 控制是否输出文件，默认为0，表示不输出文件
-dvld.dump_paths 控制输出的内容，现在只有0和1两种情况，默认为1,输出内容&lt;/p&gt;

&lt;p&gt;VLD(Vulcan Logic Dumper)的简介如下：&lt;/p&gt;

&lt;p&gt;The Vulcan Logic Dumper hooks into the Zend Engine and dumps all the opcodes (execution units) of a script. It can be used to see what is going on in the Zend Engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 之前的文章 PHP解释器引擎执行流程 结尾处提到了VLD的原理，此扩展利用PHP对扩展模块提供的请求初始化钩子函数（PHP_RINIT_FUNCTION），在每此请求到来的时候将默认的编译函数指针zend_compile_file和执行函数指针zend_execute指向自己定义的vld_compile_file函数和vld_execute函数，这两个函数中，对原函数进行了封装，原编译函数能返回一个op_array的指针，所以在新的编译函数中可以截获这个op_array的指针，然后输出相关opcode信息。  

关于PHP扩展模块的安装这里就不介绍了，网络上很多相关资料。

那么让我们看看这个扩展安装后的实际效果，以下为一个非常简单的PHP脚本，test.php:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[php] view plain copy
&lt;?php  
$a = &quot;Hello world&quot;;  
echo $a;  
?&gt;&lt;/p&gt;

&lt;p&gt;在命令行下执行该脚本：&lt;/p&gt;

&lt;p&gt;php -dvld.active=1 test.php&lt;/p&gt;

&lt;p&gt;于是可以看到vld输出的内容:&lt;/p&gt;

&lt;p&gt;希望看到跟详细的内容可以用以下方式：&lt;/p&gt;

&lt;p&gt;php -dvld.active=1 -dvld.verbosity=3 test.php&lt;/p&gt;

&lt;p&gt;这里简单的说说输出内容的含义：&lt;/p&gt;

&lt;p&gt;这段代码一共有3个op分别是：&lt;/p&gt;

&lt;p&gt;1：ASSIGN          // #define ZEND_ASSIGN                           38&lt;/p&gt;

&lt;p&gt;2：ECHO             // #define ZEND_ECHO                             40&lt;/p&gt;

&lt;p&gt;3：RETURN         //  #define ZEND_RETURN                          62&lt;/p&gt;

&lt;p&gt;第1个op ASSIGN的操作句柄是将OP2的值赋值给OP1，对应的就是$a = “Hello world”这句代码，那么OP2就是”Hello world”的，OP1应该就是$a,但是实际上输出的内容中显示的是!0,实际上$a属于编译后的变量，!0就代表了$a,可以在输出op list的上一行看到&lt;/p&gt;

&lt;p&gt;compiled vars:  !0 = $a&lt;/p&gt;

&lt;p&gt;这样的优化可以避免每次查找变量$a都在变量符号表中去检索，起到一定的缓存的作用。在这条op执行结束之后，!0的值就等于”Hello world”了。&lt;/p&gt;

&lt;p&gt;第2个op ECHO的操作句柄是将 OP1的内容送到标准输出，对应的就是echo $a这句代码，这样就把”Hello world”输出到终端了&lt;/p&gt;

&lt;p&gt;第3个op RETURN 是在每个PHP文件结尾都会自动加上的，它的操作句柄是将OP1的常量值返回&lt;/p&gt;

&lt;p&gt;这样我们就能很清晰的知道一段PHP代码会得到什么样的OP code,vld真的是一个不错的分析工具。&lt;/p&gt;

&lt;p&gt;也许有人会问，你怎么知道每个op对应的执行句柄是什么呢，vld能输出这些信息吗？非常可惜，vld不能帮助我们输出OP对应的执行句柄信息。在默认以CALL方式执行op的模式下，每个op对应的handler都是一个函数，vld中截获的op中有这些handler的指针，但是无法通过这些指针知道相应的函数名，c语言没有一些更高级的语言那样的反射特性。所以如果想知道每个op对应的handler，就需要另外想办法了，目前为止，我只发现了两种方法可以得到这些信息。下面简单的介绍这两种方法。&lt;/p&gt;

&lt;p&gt;方法一：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在之前的文章 PHP代码如何执行？中介绍过，op的handler都定义在{PHPSRC}/Zend/zend_vm_execute.h中，这是一个由PHP生成的极大的c源文件，其中有每个handler的函数定义以及op映射到handler的算法,在zend_init_opcodes_handlers函数中，初始化一个 static const opcode_handler_t labels[]数组，这个 labels数组就是handlers的一张表，这个表有近4000个项，每个项都是一个handler的函数指针，当然有大量的NULL指针，还有一些重复的指针。如果我们能有一个跟labels数组对应的数组handler_names,数组中的每一个项对应的是labels中相应项中函数指针的函数名，那么我们就可以通过现有的op到handler的映射算法从handler_names中得到该op的handler的函数名。但是事情没有想象的那么容易，我们如何正确生成这个拥有4000个项的数组handler_names，答案就在{PHPSRC}/Zend/zend_vm_gen.php,这个PHP文件是用来生成{PHPSRC}/Zend/zend_vm_execute.h，可以在其中找到生成labels数组的部分，只要添加相关代码通过类似方式生成handler_names数组就可以了。有兴趣的读者可以尝试生成这个handler_names数组文件，然后编译到vld扩展中，在输出op list的时候把每个op执行的句柄函数名也一并输出。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法二:&lt;/p&gt;

&lt;p&gt;此方法是我目前经常用到的，相对来说比较方便，还是在{PHPSRC}/Zend/zend_vm_gen.php这个文件里面想办法。这个文件会生成每个op的handler，所以如果想办法在每个handler函数的代码中输出该handler名字，那么就知道哪些handler被调用。这个并不太难，在zend_vm_gen.php第380行左右可以看到类似以下PHP代码：&lt;/p&gt;

&lt;p&gt;if (0 &amp;amp;&amp;amp; strpos($code, ‘{‘) === 0) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;实际上这个条件中的代码就是在每个handler开始的一行中输出内容，但是因为条件永远无法满足，所以实际条件中的代码无法执行，可以将if中的条件改成true,然后大括号输出函数的名字就可以了，具体的代码如下：&lt;/p&gt;

&lt;p&gt;[php] view plain copy
if (1) {&lt;br /&gt;
    $name = $name.($spec?”_SPEC”:””).$prefix[$op1].$prefix[$op2].”_HANDLER”;&lt;br /&gt;
    $code = “{/n/tfprintf(stderr, /”$name//n/”);/n” . substr($code, 1);&lt;br /&gt;
}&lt;br /&gt;
 代码具体的原理就不介绍了。在修改好zend_vm_gen.php之后，在命令行下执行该脚本，就会生成一个新的zend_vm_execute.h( 同时会生成zend_vm_opcodes.h)，打开zend_vm_execute.h文件，可以看到很多函数开头都多出了这么一句:&lt;/p&gt;

&lt;p&gt;fprintf(stderr, “ZEND_***/n”);&lt;/p&gt;

&lt;p&gt;这样每个函数开始执行的时候就会把自己的名字输出到标准错误。下面的工作，就是重新编译Zend/zend_execute.lo，然后重新链接sapi/cli/php，如果你不知道如何单独完成这些操作，那么也可以更暴力一点重新安装整个PHP，需要注意的是修改后的PHP千万不要用在正式环境，因为会输出一大量不需要的信息，自己单独为试验安装一个PHP吧。 另外这个方法也会输出一些非直接的hanlder的函数名，有可能一个handler会调用另外一个函数，这样可能会输出这个handler的名字和那个被调用的函数的名字，所以实际输出的函数名字会多于op的数量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;我们用方法二来查看前面的test.php的op handler的名字，直接用修改后的php 执行test.php得到以下内容：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ZEND_ASSIGN_SPEC_CV_CONST_HANDLER
ZEND_ECHO_SPEC_CV_HANDLER
Hello worldZEND_RETURN_SPEC_CONST_HANDLER
zend_leave_helper_SPEC_HANDLER&lt;/p&gt;

&lt;p&gt;可以看到一共输出了4个函数的名字，其中ZEND_ASSIGN_SPEC_CV_CONST_HANDLER函数就是ASSIGN的handler，ZEND_ECHO_SPEC_CV_HANDLER就是ECHO的handler,ZEND_RETURN_SPEC_CONST_HANDLER是RETURN的handler,这个handler会调用zend_leave_helper_SPEC_HANDLER函数，所以会输出4个函数的名字，知道了这些函数的名字，我们就能在zend_vm_execute.h中去找到其具体定义，这样就知道每个op到底是怎么在执行了。&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/jekyll/2018/02/12/phpvld.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/jekyll/2018/02/12/phpvld.html</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
      <item>
        <title>phpize</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;编译PHP扩展的工具，主要是根据系统信息生成对应的configure文件
安装php（fastcgi模式）的时候，常常有这样一句命令：/usr/local/webserver/php/bin/phpize
一、phpize是干嘛的？
phpize是什么东西呢？php官方的说明：
http://php.net/manual/en/install.pecl.phpize.php
phpize是用来扩展php扩展模块的，通过phpize可以建立php的外挂模块
比如你想在原来编译好的php中加入memcached或者ImageMagick等扩展模块，可以使用phpize，通过以下几步工作。
二、如何使用phpize？
当php编译完成后，php的bin目录下会有phpize这个脚本文件。在编译你要添加的扩展模块之前，执行以下phpize就可以了；
比如现在想在php中加入memcache扩展模块：我们要做的只是如下几步
————————————————————————
tar zxvf memcache-2.2.5.tgz
cd memcache-2.2.5/
/usr/local/webserver/php/bin/phpize
./configure –with-php-config=/usr/local/webserver/php/bin/php-config
make
make install
————————————————————————
注意./configure 后面可以指定的是php-config文件的路径
这样编译就完成了，还需要做的是在php.ini文件中加入extension值
extension = “memcache.so”&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/02/12/phpize.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/02/12/phpize.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>PHP 调试利器之 PHPDBG</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;PHPDBG是一个PHP的SAPI模块，可以在不用修改代码和不影响性能的情况下控制PHP的运行环境。&lt;/p&gt;

&lt;p&gt;PHPDBG的目标是成为一个轻量级、强大、易用的PHP调试平台。可以在PHP5.4和之上版本中使用。在php5.6和之上版本将内部集成。&lt;/p&gt;

&lt;p&gt;主要功能：
– 单步调试&lt;/p&gt;

&lt;p&gt;– 灵活的下断点方式（类方法、函数、文件:行、内存地址、opcode）&lt;/p&gt;

&lt;p&gt;– 可直接调用php的eval&lt;/p&gt;

&lt;p&gt;– 可以查看当前执行的代码&lt;/p&gt;

&lt;p&gt;– 用户空间API（userland/user space）&lt;/p&gt;

&lt;p&gt;– 方便集成&lt;/p&gt;

&lt;p&gt;– 支持指定php配置文件&lt;/p&gt;

&lt;p&gt;– JIT全局变量&lt;/p&gt;

&lt;p&gt;– readline支持（可选），终端操作更方便&lt;/p&gt;

&lt;p&gt;– 远程debug，使用java GUI&lt;/p&gt;

&lt;p&gt;– 操作简便（具体看help）&lt;/p&gt;

&lt;p&gt;安装
为了使用phpdgb，你首先需要下载一个php的源码包。然后下载phpdgb的源码包，并放在php源码包的sapi目录下。最后，你就可以执行命令安装了。编译安装示例如下：
假设我们已经下载php的源码包，并放在了/home/php目录下。&lt;/p&gt;

&lt;p&gt;Shell&lt;/p&gt;

&lt;p&gt;#cd /home/php/sapi
#git clone https://github.com/krakjoe/phpdbg
#cd ../
#./buildconf –force
#./config.nice
#make -j8
#make install-phpdbg&lt;/p&gt;

&lt;p&gt;#cd /home/php/sapi
#git clone https://github.com/krakjoe/phpdbg
#cd ../
#./buildconf –force
#./config.nice
#make -j8
#make install-phpdbg
注意：
1、如果你的php版本是php5.6或者更高的版本，phpdbg已经集成在php的代码包中，无需单独下载了。
2、编译参数中记得要加 –enable-phpdbg。
3、编译时参数，–with-readline 可以选择性添加。如果不添加，phpdbg的history等功能无法使用。&lt;/p&gt;

&lt;p&gt;基本使用
参数介绍
phpdbg是php的一个sapi，它可以以命令行的方式调试php。常用参数如下：&lt;/p&gt;

&lt;p&gt;The following switches are implemented (just like cli SAPI):
-n ignore php ini
-c search for php ini in path
-z load zend extension
-d define php ini entry
The following switches change the default behaviour of phpdbg:
-v disables quietness
-s enabled stepping
-e sets execution context
-b boring – disables use of colour on the console
-I ignore .phpdbginit (default init file)
-i override .phpgdbinit location (implies -I)
-O set oplog output file
-q do not print banner on startup
-r jump straight to run
-E enable step through eval()
Note: passing -rr will cause phpdbg to quit after execution, rather than returning to the console&lt;/p&gt;

&lt;p&gt;常用功能
之前我们介绍过gdb工具。其实phpdbg和gdb功能有些地方非常相似。如，可以设置断点，可以单步执行，等。只是他们调试的语言不一样，gdb侧重于调试c或者c++语言，而phpdbg侧重于调试php语言。下面我们将对phpdbg的一些常用调试功能做下介绍。要调试的代码如下：
文件test_phpdbg_inc.php源代码如下：&lt;/p&gt;

&lt;p&gt;PHP&lt;/p&gt;

&lt;?php 
function phpdbg_inc_func()
{     
    echo &quot;phpdbg_inc_func \n&quot;; 
} 
?&gt;
&lt;?php 
function phpdbg_inc_func()
{     
    echo &quot;phpdbg_inc_func \n&quot;; 
} 
?&gt;
&lt;p&gt;文件test_phpdgb.php的源代码如下：&lt;/p&gt;

&lt;p&gt;PHP&lt;/p&gt;

&lt;?php 
    include(dirname(__FILE__).&quot;/test_phpdbg_inc.php&quot;); 
    class demo{     
        public function __construct(){
             echo __METHOD__.&quot;:&quot;.__LINE__.&quot;\n&quot;;     
        }
        public function func($param){
             $param++;
             echo &quot;method func $param\n&quot;;
        }
        public function __destruct(){
             echo __METHOD__.&quot;:&quot;.__LINE__.&quot;\n&quot;;
        }
    } 

  function func(){     
      $param = &quot;ali&quot;;
      $param = $param + &quot;baba&quot;;
      echo &quot;function func $param\n&quot;;
  }

  $demo = new demo();
  $demo-&gt;func(1);
  func();
  phpdbg_inc_func();
?&gt;
&lt;?php 
    include(dirname(__FILE__).&quot;/test_phpdbg_inc.php&quot;); 
    class demo{     
        public function __construct(){
             echo __METHOD__.&quot;:&quot;.__LINE__.&quot;\n&quot;;     
        }
        public function func($param){
             $param++;
             echo &quot;method func $param\n&quot;;
        }
        public function __destruct(){
             echo __METHOD__.&quot;:&quot;.__LINE__.&quot;\n&quot;;
        }
    } 
 
  function func(){     
      $param = &quot;ali&quot;;
      $param = $param + &quot;baba&quot;;
      echo &quot;function func $param\n&quot;;
  }
 
  $demo = new demo();
  $demo-&gt;func(1);
  func();
  phpdbg_inc_func();
?&gt;
&lt;p&gt;启动phpdbg&lt;/p&gt;

&lt;p&gt;phpdbg安装成功后，会在安装目录的bin目录下。进入bin目录，直接输入phpdbg即可。如下：&lt;/p&gt;

&lt;p&gt;Shell&lt;/p&gt;

&lt;p&gt;#phpdeg
[Welcome to phpdbg, the interactive PHP debugger, v0.4.0]
To get help using phpdbg type “help” and press enter
[Please report bugs to &lt;a href=&quot;http://github.com/krakjoe/phpdbg/issues&quot;&gt;http://github.com/krakjoe/phpdbg/issues&lt;/a&gt;]
prompt&amp;gt;&lt;/p&gt;

&lt;p&gt;#phpdeg
[Welcome to phpdbg, the interactive PHP debugger, v0.4.0]
To get help using phpdbg type “help” and press enter
[Please report bugs to &lt;a href=&quot;http://github.com/krakjoe/phpdbg/issues&quot;&gt;http://github.com/krakjoe/phpdbg/issues&lt;/a&gt;]
prompt&amp;gt;
要想加载要调试的php脚本，只需要执行exec命令即可。如下：&lt;/p&gt;

&lt;p&gt;Shell&lt;/p&gt;

&lt;p&gt;#phpdbg
……
prompt&amp;gt; exec ./test_phpdbg.php&lt;/p&gt;

&lt;p&gt;#phpdbg
……
prompt&amp;gt; exec ./test_phpdbg.php
当然我们也可以在启动phpdbg的时候，指定e参数。如下：&lt;/p&gt;

&lt;p&gt;PHP&lt;/p&gt;

&lt;p&gt;#phpdbg -e ./test_phpdbg.php
#phpdbg -e ./test_phpdbg.php
查看帮助信息&lt;/p&gt;

&lt;p&gt;如果你之前使用过其他的调试工具，你会发现phpdbg和他们比较相似。但是，你使用初期，还是会经常需要获取帮助信息。通过help命令我们可以获取帮助信息。&lt;/p&gt;

&lt;p&gt;PHP&lt;/p&gt;

&lt;p&gt;……
prompt&amp;gt; help&lt;/p&gt;

&lt;p&gt;phpdbg is a lightweight, powerful and easy to use debugging platform for PHP5.4+
It supports the following commands:&lt;/p&gt;

&lt;p&gt;Information
  list     list PHP source
……
……
prompt&amp;gt; help&lt;/p&gt;

&lt;p&gt;phpdbg is a lightweight, powerful and easy to use debugging platform for PHP5.4+
It supports the following commands:&lt;/p&gt;

&lt;p&gt;Information
  list     list PHP source
……
设置断点&lt;/p&gt;

&lt;p&gt;设置断点的命令和gdb一样。都是break，简写形式为b。不过具体的命令参数还是有所差异的。和gdb的断点命令相同之处，它们都可以“按文件名:行号” 或者 行号的方式设置断点。除此之外，phpdbg还提供了一些针对php特有的设置断点的方式。如，根据opline设置断点，根据opcode设置断点等。&lt;/p&gt;

&lt;p&gt;众所周知，php代码最终是解析成opcode，然后由php内核一条条执行。一条php语句，可能会解析成多条opcode。如果可以按opcode设置断点，我们就可以更精确的跟踪程序执行过程。下面我们来看看phapdbg设置断点的具体示例。&lt;/p&gt;

&lt;p&gt;按opline设置断点：
这里所说的opline，就是以方法入口作为起点，当前代码的行号。如test_phpdgb.php文件中，第18行的代码“$param = $param + “baba”;”的opline就是 2。&lt;/p&gt;

&lt;p&gt;PHP&lt;/p&gt;

&lt;p&gt;……
prompt&amp;gt; b func#2
prompt&amp;gt; r
demo::__construct:5
method func 2
[Breakpoint #0 resolved at func#2 (opline 0x7f5b230a2e38)]
[Breakpoint #0 resolved at func#2 (opline 0x7f5b230a2e38)]
[Breakpoint #0 resolved at func#2 (opline 0x7f5b230a2e38)]
[Breakpoint #0 in func()#2 at ./test_phpdbg.php:18, hits: 1]&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;00018:     $param = $param + “baba”;
 00019:     echo “function func $param\n”;;
 00020: }
……
……
prompt&amp;gt; b func#2
prompt&amp;gt; r
demo::__construct:5
method func 2
[Breakpoint #0 resolved at func#2 (opline 0x7f5b230a2e38)]
[Breakpoint #0 resolved at func#2 (opline 0x7f5b230a2e38)]
[Breakpoint #0 resolved at func#2 (opline 0x7f5b230a2e38)]
[Breakpoint #0 in func()#2 at ./test_phpdbg.php:18, hits: 1]
00018:     $param = $param + “baba”;
 00019:     echo “function func $param\n”;;
 00020: }
……
查看断点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;和gdb一样，phpdbg也是使用info break命令查看断点。示例如下：&lt;/p&gt;

&lt;p&gt;PHP&lt;/p&gt;

&lt;p&gt;….
prompt&amp;gt; info break
————————————————
File Breakpoints:
#1      /home/hailong.xhl/test_phpdbg.php:10
————————————————
Opline Breakpoints:
#0      7ff3219e1df0        (function breakpoint)
————————————————
Function opline Breakpoints:
#0      func opline 2
….
….
prompt&amp;gt; info break
————————————————
File Breakpoints:
#1      /home/hailong.xhl/test_phpdbg.php:10
————————————————
Opline Breakpoints:
#0      7ff3219e1df0        (function breakpoint)
————————————————
Function opline Breakpoints:
#0      func opline 2
….
通过上面的显示，我们可以知道。info break的显示结果中会把断点的类型也给显示出来。#后面的数字是断点号。我们可以根据断点号删除断点。&lt;/p&gt;

&lt;p&gt;删除断点&lt;/p&gt;

&lt;p&gt;和gdb命令不一样。phpdbg的删除断点不是delete命令，而是break del 命令。示例如下：&lt;/p&gt;

&lt;p&gt;PHP&lt;/p&gt;

&lt;p&gt;……
prompt&amp;gt; break del 1
[Deleted breakpoint #1]
prompt&amp;gt;
……
……
prompt&amp;gt; break del 1
[Deleted breakpoint #1]
prompt&amp;gt;
……
break del 后面的数字1就是断点号。&lt;/p&gt;

&lt;p&gt;查看代码&lt;/p&gt;

&lt;p&gt;phpdbg查看代码的命令也是list。但是和gdb相比，使用的方式更多样一些。
显示指定函数的代码：&lt;/p&gt;

&lt;p&gt;Shell&lt;/p&gt;

&lt;p&gt;……
prompt&amp;gt; l f func
 00017:     $param = “ali”;
 00018:     $param = $param + “baba”;
 00019:     echo “function func $param\n”;;
 00020: }
 00021:
prompt&amp;gt;
……
……
prompt&amp;gt; l f func
 00017:     $param = “ali”;
 00018:     $param = $param + “baba”;
 00019:     echo “function func $param\n”;;
 00020: }
 00021:
prompt&amp;gt;
……
单步执行&lt;/p&gt;

&lt;p&gt;phpdbg的单步执行只有一个命令 step。和gdb的step命令差不多。都是一行一行的执行代码。注意，phpdbg是没有next命令的。&lt;/p&gt;

&lt;p&gt;PHP&lt;/p&gt;

&lt;p&gt;….
prompt&amp;gt; s
[Breakpoint #0 resolved at func#2 (opline 0x152ba40)]
[L19           0x152ba70 ZEND_ADD_STRING          C2      @0    ./test_phpdbg.php]&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;00019:     echo “function func $param\n”;;
 00020: }
 00021:
….
….
prompt&amp;gt; s
[Breakpoint #0 resolved at func#2 (opline 0x152ba40)]
[L19           0x152ba70 ZEND_ADD_STRING          C2      @0    ./test_phpdbg.php]
00019:     echo “function func $param\n”;;
 00020: }
 00021:
….
继续执行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;和gdb一样，phpdbg的继续执行命令也是continue，简写形式为c。&lt;/p&gt;

&lt;p&gt;执行php代码&lt;/p&gt;

&lt;p&gt;这个是phpdbg的一个特色。可以在调试的过程中使用ev命令执行任意的php代码。如：&lt;/p&gt;

&lt;p&gt;Shell&lt;/p&gt;

&lt;p&gt;……
prompt&amp;gt; ev $var = “val”;
val
prompt&amp;gt; ev var_dump($var);
string(3) “val”
……
……
prompt&amp;gt; ev $var = “val”;
val
prompt&amp;gt; ev var_dump($var);
string(3) “val”
……
可以通过这种方式，在调试过程中动态的修改变量值，查看执行效果。&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/02/12/phpdbg.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/02/12/phpdbg.html</guid>
        
        
        <category>web</category>
        
      </item>
    
  </channel>
</rss>
