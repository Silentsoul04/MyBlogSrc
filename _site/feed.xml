<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>泽民博客</title>
    <description>夏泽民的个人主页，学习笔记。</description>
    <link>https://xiazemin.github.io/MyBlog/</link>
    <atom:link href="https://xiazemin.github.io/MyBlog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 06 Dec 2017 23:34:00 +0800</pubDate>
    <lastBuildDate>Wed, 06 Dec 2017 23:34:00 +0800</lastBuildDate>
    <generator>Jekyll v3.6.0.pre.beta1</generator>
    
      <item>
        <title>linux_rcu</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;1:RCU使用在读者多而写者少的情况.RCU和读写锁相似.但RCU的读者占锁没有任何的系统开销.写者与写写者之间必须要保持同步,且写者必须要等它之前的读者全部都退出之后才能释放之前的资源.
2:RCU保护的是指针.这一点尤其重要.因为指针赋值是一条单指令.也就是说是一个原子操作.因它更改指针指向没必要考虑它的同步.只需要考虑cache的影响. 
3:读者是可以嵌套的.也就是说rcu_read_lock()可以嵌套调用. 
4:读者在持有rcu_read_lock()的时候,不能发生进程上下文切换.否则,因为写者需要要等待读者完成,写者进程也会一直被阻塞.&lt;/p&gt;

&lt;p&gt;RCU（Read-Copy Update）是数据同步的一种方式，在当前的Linux内核中发挥着重要的作用。RCU主要针对的数据对象是链表，目的是提高遍历读取数据的效率，为了达到目的使用RCU机制读取数据的时候不对链表进行耗时的加锁操作。这样在同一时间可以有多个线程同时读取该链表，并且允许一个线程对链表进行修改（修改的时候，需要加锁）。RCU适用于需要频繁的读取数据，而相应修改数据并不多的情景，例如在文件系统中，经常需要查找定位目录，而对目录的修改相对来说并不多，这就是RCU发挥作用的最佳场景。&lt;/p&gt;

&lt;p&gt;在RCU的实现过程中，我们主要解决以下问题：
1，在读取过程中，另外一个线程删除了一个节点。删除线程可以把这个节点从链表中移除，但它不能直接销毁这个节点，必须等到所有的读取线程读取完成以后，才进行销毁操作。RCU中把这个过程称为宽限期（Grace period）。
2，在读取过程中，另外一个线程插入了一个新节点，而读线程读到了这个节点，那么需要保证读到的这个节点是完整的。这里涉及到了发布-订阅机制（Publish-Subscribe Mechanism）。
3， 保证读取链表的完整性。新增或者删除一个节点，不至于导致遍历一个链表从中间断开。但是RCU并不保证一定能读到新增的节点或者不读到要被删除的节点。&lt;/p&gt;

</description>
        <pubDate>Wed, 06 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/linux/2017/12/06/linux_rcu.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/linux/2017/12/06/linux_rcu.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>Linux的mmap内存映射机制</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;一个进程应该包括一个mm_struct(memory manage struct), 该结构是进程虚拟地址空间的抽象描述,里面包括了进程虚拟空间的一些管理信息: start_code, end_code, start_data, end_data, start_brk, end_brk等等信息.另外,也有一个指向进程虚存区表(vm_area_struct: virtual memory area)的指针,该链是按照虚拟地址的增长顺序排列的.在Linux进程的地址空间被分作许多区(vma),每个区(vma)都对应虚拟地址空间上一段连续的区域, vma是可以被共享和保护的独立实体,这里的vma就是前面提到的内存对象.&lt;/p&gt;

&lt;p&gt;设备驱动的mmap实现主要是将一个物理设备的可操作区域（设备空间）映射到一个进程的虚拟地址空间。这样就可以直接采用指针的方式像访问内存的方式访问设备。在驱动中的mmap实现主要是完成一件事，就是实际物理设备的操作区域到进程虚拟空间地址的映射过程。同时也需要保证这段映射的虚拟存储器区域不会被进程当做一般的空间使用，因此需要添加一系列的保护方式。&lt;/p&gt;

&lt;p&gt;Linux提供了内存映射函数mmap,它把文件内容映射到一段内存上(准确说是虚拟内存上),通过对这段内存的读取和修改,实现对文件的读取和修改 。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。
&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg&quot; /&gt;
mmap系统调用的实现过程是
1.先通过文件系统定位要映射的文件；
2.权限检查,映射的权限不会超过文件打开的方式,也就是说如果文件是以只读方式打开,那么则不允许建立一个可写映射； 
3.创建一个vma对象,并对之进行初始化； 
4.调用映射文件的mmap函数,其主要工作是给vm_ops向量表赋值；
5.把该vma链入该进程的vma链表中,如果可以和前后的vma合并则合并；
6.如果是要求VM_LOCKED(映射区不被换出)方式映射,则发出缺页请求,把映射页面读入内存中.&lt;/p&gt;

&lt;p&gt;2、munmap函数
munmap(void * start, size_t length):
该调用可以看作是mmap的一个逆过程.它将进程中从start开始length长度的一段区域的映射关闭,如果该区域不是恰好对应一个vma,则有可能会分割几个或几个vma.
 msync(void * start, size_t length, int flags):
把映射区域的修改回写到后备存储中.因为munmap时并不保证页面回写,如果不调用msync,那么有可能在munmap后丢失对映射区的修改.其中flags可以是MS_SYNC, MS_ASYNC, MS_INVALIDATE, MS_SYNC要求回写完成后才返回, MS_ASYNC发出回写请求后立即返回, MS_INVALIDATE使用回写的内容更新该文件的其它映射.该系统调用是通过调用映射文件的sync函数来完成工作的.
brk(void * end_data_segement):
将进程的数据段扩展到end_data_segement指定的地址,该系统调用和mmap的实现方式十分相似,同样是产生一个vma,然后指定其属性.不过在此之前需要做一些合法性检查,比如该地址是否大于mm-&amp;gt;end_code, end_data_segement和mm-&amp;gt;brk之间是否还存在其它vma等等.通过brk产生的vma映射的文件为空,这和匿名映射产生的vma相似,关于匿名映射不做进一步介绍.库函数malloc就是通过brk实现的.&lt;/p&gt;
</description>
        <pubDate>Wed, 06 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/linux/2017/12/06/linux_mmap.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/linux/2017/12/06/linux_mmap.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>linux_lock</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实象多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。在主流的Linux内核中包含了几乎所有现代的操作系统具有的同步机制，这些同步机制包括：原子操作、信号量（semaphore）、读写信号量（rw_semaphore）、spinlock、 BKL(Big Kernel Lock)、rwlock、brlock（只包含在2.4内核中）、RCU（只包含在2.6内核中）和seqlock（只包含在2.6内核中）。&lt;/p&gt;

&lt;p&gt;原子操作通常用于实现资源的引用计数，在TCP/IP协议栈的IP碎片处理中，就使用了引用计数，碎片队列结构struct ipq描述了一个IP碎片，字段refcnt就是引用计数器，它的类型为atomic_t，当创建IP碎片时（在函数ip_frag_create中），使用atomic_set函数把它设置为1，当引用该IP碎片时，就使用函数atomic_inc把引用计数加1，当不需要引用该IP碎片时，就使用函数 ipq_put来释放该IP碎片，ipq_put使用函数atomic_dec_and_test把引用计数减1并判断引用计数是否为0，如果是就释放 IP碎片。函数ipq_kill把IP碎片从ipq队列中删除，并把该删除的IP碎片的引用计数减1（通过使用函数atomic_dec实现）。&lt;/p&gt;

&lt;p&gt;Linux内核的信号量在概念和原理上与用户态的System V的IPC机制信号量是一样的，但是它绝不可能在内核之外使用，因此它与System V的IPC机制信号量毫不相干。&lt;/p&gt;

&lt;p&gt;信号量在创建时需要设置一个初始值，表示同时可以有几个任务可以访问该信号量保护的共享资源，初始值为1就变成互斥锁（Mutex），即同时只能有一个任务可以访问信号量保护的共享资源。一个任务要想访问共享资源，首先必须得到信号量，获取信号量的操作将把信号量的值减1，若当前信号量的值为负数，表明无法获得信号量，该任务必须挂起在该信号量的等待队列等待该信号量可用；若当前信号量的值为非负数，表示可以获得信号量，因而可以立刻访问被该信号量保护的共享资源。当任务访问完被信号量保护的共享资源后，必须释放信号量，释放信号量通过把信号量的值加1实现，如果信号量的值为非正数，表明有任务等待当前信号量，因此它也唤醒所有等待该信号量的任务。&lt;/p&gt;

&lt;p&gt;读写信号量对访问者进行了细分，或者为读者，或者为写者，读者在保持读写信号量期间只能对该读写信号量保护的共享资源进行读访问，如果一个任务除了需要读，可能还需要写，那么它必须被归类为写者，它在对共享资源访问之前必须先获得写者身份，写者在发现自己不需要写访问的情况下可以降级为读者。读写信号量同时拥有的读者数不受限制，也就说可以有任意多个读者同时拥有一个读写信号量。如果一个读写信号量当前没有被写者拥有并且也没有写者等待读者释放信号量，那么任何读者都可以成功获得该读写信号量；否则，读者必须被挂起直到写者释放该信号量。如果一个读写信号量当前没有被读者或写者拥有并且也没有写者等待该信号量，那么一个写者可以成功获得该读写信号量，否则写者将被挂起，直到没有任何访问者。因此，写者是排他性的，独占性的。&lt;/p&gt;

&lt;p&gt;读写信号量有两种实现，一种是通用的，不依赖于硬件架构，因此，增加新的架构不需要重新实现它，但缺点是性能低，获得和释放读写信号量的开销大；另一种是架构相关的，因此性能高，获取和释放读写信号量的开销小，但增加新的架构需要重新实现。在内核配置时，可以通过选项去控制使用哪一种实现。&lt;/p&gt;

&lt;p&gt;自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。&lt;/p&gt;

&lt;p&gt;信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因此只能在进程上下文使用（_trylock的变种能够在中断上下文使用），而自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用。如果被保护的共享资源只在进程上下文访问，使用信号量保护该共享资源非常合适，如果对共巷资源的访问时间非常短，自旋锁也可以。但是如果被保护的共享资源需要在中断上下文访问（包括底半部即中断处理句柄和顶半部即软中断），就必须使用自旋锁。&lt;/p&gt;

&lt;p&gt;自旋锁保持期间是抢占失效的，而信号量和读写信号量保持期间是可以被抢占的。自旋锁只有在内核可抢占或SMP的情况下才真正需要，在单CPU且不可抢占的内核下，自旋锁的所有操作都是空操作。&lt;/p&gt;

&lt;p&gt;跟互斥锁一样，一个执行单元要想访问被自旋锁保护的共享资源，必须先得到锁，在访问完共享资源后，必须释放锁。如果在获取自旋锁时，没有任何执行单元保持该锁，那么将立即得到锁；如果在获取自旋锁时锁已经有保持者，那么获取锁操作将自旋在那里，直到该自旋锁的保持者释放了锁。&lt;/p&gt;

&lt;p&gt;无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。&lt;/p&gt;

</description>
        <pubDate>Wed, 06 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/linux/2017/12/06/linux_lock.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/linux/2017/12/06/linux_lock.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>linux_elf</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;可执行连接格式是UNIX系统实验室(USL)作为应用程序二进制接口
(Application Binary Interface(ABI)而开发和发布的。工具接口标准委
员会(TIS)选择了正在发展中的ELF标准作为工作在32位INTEL体系上不同操
作系统之间可移植的二进制文件格式。
假定开发者定义了一个二进制接口集合，ELF标准用它来支持流线型的软件
发展。 应该减少不同执行接口的数量。因此可以减少重新编程重新编译的
代码。&lt;/p&gt;

&lt;p&gt;在object文件中有三种主要的类型。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一个可重定位(relocatable)文件保存着代码和适当的数据，用来和其他的
object文件一起来创建一个可执行文件或者是一个共享文件。&lt;/li&gt;
  &lt;li&gt;一个可执行(executable)文件保存着一个用来执行的程序；该文件指出了
exec(BA_OS)如何来创建程序进程映象。&lt;/li&gt;
  &lt;li&gt;一个共享object文件保存着代码和合适的数据，用来被下面的两个链接器
链接。第一个是连接编辑器[请参看ld(SD_CMD)]，可以和其他的可重定位和
共享object文件来创建其他的object。第二个是动态链接器，联合一个
可执行文件和其他的共享object文件来创建一个进程映象。
一个object文件被汇编器和联接器创建, 想要在处理机上直接运行的object
文件都是以二进制来存放的。那些需要抽象机制的程序，比如象shell脚本，
是不被接受的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个ELF头在文件的开始，保存了路线图(road map)，描述了该文件的组织情况。
sections保存着object 文件的信息，从连接角度看：包括指令，数据，
符号表，重定位信息等等。&lt;/p&gt;

&lt;p&gt;假如一个程序头表（program header table）存在，那么它告诉系统如何来创建一
个进程的内存映象。被用来建立进程映象(执行一个程序)的文件必须要有一个程
序头表（program header table）；可重定位文件不需要这个头表。一个
section头表（section header table）包含了描述文件sections的信息。每个
section在这个表中有一个入口；每个入口给出了该section的名字，大小，
等等信息。在联接过程中的文件必须有一个section头表；其他object文件可要
可不要这个section头表。&lt;/p&gt;

&lt;p&gt;对象文件(Object files)有三个种类：&lt;/p&gt;

&lt;p&gt;1) 可重定位的对象文件(Relocatable file)&lt;/p&gt;

&lt;p&gt;这是由汇编器汇编生成的 .o 文件。后面的链接器(link editor)拿一个或一些 Relocatable object files 作为输入，经链接处理后，生成一个可执行的对象文件 (Executable file) 或者一个可被共享的对象文件(Shared object file)。我们可以使用 ar 工具将众多的 .o Relocatable object files 归档(archive)成 .a 静态库文件。如何产生 Relocatable file，你应该很熟悉了，请参见我们相关的基本概念文章和JulWiki。另外，可以预先告诉大家的是我们的内核可加载模块 .ko 文件也是 Relocatable object file。&lt;/p&gt;

&lt;p&gt;2) 可执行的对象文件(Executable file)&lt;/p&gt;

&lt;p&gt;这我们见的多了。文本编辑器vi、调式用的工具gdb、播放mp3歌曲的软件mplayer等等都是Executable object file。你应该已经知道，在我们的 Linux 系统里面，存在两种可执行的东西。除了这里说的 Executable object file，另外一种就是可执行的脚本(如shell脚本)。注意这些脚本不是 Executable object file，它们只是文本文件，但是执行这些脚本所用的解释器就是 Executable object file，比如 bash shell 程序。&lt;/p&gt;

&lt;p&gt;3) 可被共享的对象文件(Shared object file)&lt;/p&gt;

&lt;p&gt;这些就是所谓的动态库文件，也即 .so 文件。如果拿前面的静态库来生成可执行程序，那每个生成的可执行程序中都会有一份库代码的拷贝。如果在磁盘中存储这些可执行程序，那就会占用额外的磁盘空间；另外如果拿它们放到Linux系统上一起运行，也会浪费掉宝贵的物理内存。如果将静态库换成动态库，那么这些问题都不会出现。动态库在发挥作用的过程中，必须经过两个步骤：&lt;/p&gt;

&lt;p&gt;a) 链接编辑器(link editor)拿它和其他Relocatable object file以及其他shared object file作为输入，经链接处理后，生存另外的 shared object file 或者 executable file。&lt;/p&gt;

&lt;p&gt;b) 在运行时，动态链接器(dynamic linker)拿它和一个Executable file以及另外一些 Shared object file 来一起处理，在Linux系统里面创建一个进程映像。&lt;/p&gt;

&lt;p&gt;以上所提到的 link editor 以及 dynamic linker 是什么东西，你可以参考我们基本概念中的相关文章。对于什么是编译器，汇编器等你应该也已经知道，在这里只是使用他们而不再对他们进行详细介绍。为了下面的叙述方便，你可以下载test.tar.gz包，解压缩后使用”make”进行编译。编译完成后，会在目录中生成一系列的ELF对象文件，更多描述见里面的 README 文件。我们下面的论述都基于这些产生的对象文件。&lt;/p&gt;

&lt;p&gt;ELF格式需要使用在两种场合：&lt;/p&gt;

&lt;p&gt;a) 组成不同的可重定位文件，以参与可执行文件或者可被共享的对象文件的链接构建；&lt;/p&gt;

&lt;p&gt;b) 组成可执行文件或者可被共享的对象文件，以在运行时内存中进程映像的构建。&lt;/p&gt;
</description>
        <pubDate>Wed, 06 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/linux/2017/12/06/linux_elf.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/linux/2017/12/06/linux_elf.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>linux_cow</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  那么子进程的物理空间没有代码，怎么去取指令执行exec系统调用呢？

  在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。      

  在网上看到还有个细节问题就是，fork之后内核会通过将子进程放在队列的前面，以让子进程先执行，以免父进程执行导致写时复制，而后子进程执行exec系统调用，因无意义的复制而造成效率的下降。
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 06 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/linux/2017/12/06/linux_cow.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/linux/2017/12/06/linux_cow.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>Kibana</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;ibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。&lt;/p&gt;

&lt;p&gt;Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示Elasticsearch查询动态。&lt;/p&gt;

&lt;p&gt;设置Kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。&lt;/p&gt;

&lt;p&gt;主要功能&lt;/p&gt;

&lt;p&gt;Elasticsearch无缝之集成
Kibana架构为Elasticsearch定制，可以将任何结构化和非结构化数据加入Elasticsearch索引。Kibana还充分利用了Elasticsearch强大的搜索和分析功能&lt;/p&gt;

&lt;p&gt;Kibana可以非常方便地把来自Logstash、ES-Hadoop、Beats或第三方技术的数据整合到Elasticsearch，支持的第三方技术包括Apache Flume、Fluentd等。&lt;/p&gt;

&lt;p&gt;Sense是一个可视化终端，通过Kibana插件支持自动补全、自动缩进和语法检查功能。提升了与Elasticsearch API交互的体验&lt;/p&gt;

</description>
        <pubDate>Wed, 06 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/spark/2017/12/06/Kibana.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/spark/2017/12/06/Kibana.html</guid>
        
        
        <category>spark</category>
        
      </item>
    
      <item>
        <title>linux_memory</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;TLB(Translation Lookaside Buffer)转换检测缓冲区是一个内存管理单元,用于改进虚拟地址到物理地址转换速度的缓存。
TLB是一个小的，虚拟寻址的缓存，其中每一行都保存着一个由单个PTE(Page Table Entry,页表项)组成的块。如果没有TLB，则每次取数据都需要两次访问内存，即查页表获得物理地址和取数据。
当cpu要访问一个虚拟地址/线性地址时，CPU会首先根据虚拟地址的高20位（20是x86特定的，不同架构有不同的值）在TLB中查找。如果是表中没有相应的表项，称为TLB miss，需要通过访问慢速RAM中的页表计算出相应的物理地址。同时，物理地址被存放在一个TLB表项中，以后对同一线性地址的访问，直接从TLB表项中获取物理地址即可，称为TLB hit。
Linux把物理内存划分为三个层次来管理
存储节点(Node)	CPU被划分为多个节点(node), 内存则被分簇, 每个CPU对应一个本地物理内存, 即一个CPU-node对应一个内存簇bank，即每个内存簇被认为是一个节点
管理区(Zone)	每个物理内存节点node被划分为多个内存管理区域, 用于表示不同范围的内存, 内核可以使用不同的映射方式映射物理内存
页面(Page)	内存被细分为多个页面帧, 页面是最基本的页面分配的单位　
为了支持NUMA模型，也即CPU对不同内存单元的访问时间可能不同，此时系统的物理内存被划分为几个节点(node), 一个node对应一个内存簇bank，即每个内存簇被认为是一个节点&lt;/p&gt;

&lt;p&gt;首先, 内存被划分为结点. 每个节点关联到系统中的一个处理器, 内核中表示为pg_data_t的实例. 系统中每个节点被链接到一个以NULL结尾的pgdat_list链表中&amp;lt;而其中的每个节点利用pg_data_tnode_next字段链接到下一节．而对于PC这种UMA结构的机器来说, 只使用了一个成为contig_page_data的静态pg_data_t结构.&lt;/p&gt;

&lt;p&gt;接着各个节点又被划分为内存管理区域, 一个管理区域通过struct zone_struct描述, 其被定义为zone_t, 用以表示内存的某个范围, 低端范围的16MB被描述为ZONE_DMA, 某些工业标准体系结构中的(ISA)设备需要用到它, 然后是可直接映射到内核的普通内存域ZONE_NORMAL,最后是超出了内核段的物理地址域ZONE_HIGHMEM, 被称为高端内存.　是系统中预留的可用内存空间, 不能被内核直接映射.&lt;/p&gt;

&lt;p&gt;最后页帧(page frame)代表了系统内存的最小单位, 堆内存中的每个页都会创建一个struct page的一个实例. 传统上，把内存视为连续的字节，即内存为字节数组，内存单元的编号(地址)可作为字节数组的索引. 分页管理时，将若干字节视为一页，比如4K byte. 此时，内存变成了连续的页，即内存为页数组，每一页物理内存叫页帧，以页为单位对内存进行编号，该编号可作为页数组的索引，又称为页帧号.&lt;/p&gt;

&lt;p&gt;传统伙伴系统算法&lt;/p&gt;

&lt;p&gt;在内核分配内存时, 必须记录页帧的已分配或空闲状态, 以免两个进程使用同样的内存区域. 由于内存分配和释放非常频繁, 内核还必须保证相关操作尽快完成. 内核可以只分配完整的页帧. 将内存划分为更小的部分的工作, 则委托给用户空间中的标准库. 标准库将来源于内核的页帧拆分为小的区域, 并为进程分配内存.&lt;/p&gt;

&lt;p&gt;内核中很多时候要求分配连续页. 为快速检测内存中的连续区域, 内核采用了一种古老而历经检验的技术: 伙伴系统&lt;/p&gt;

&lt;p&gt;系统中的空闲内存块总是两两分组, 每组中的两个内存块称作伙伴. 伙伴的分配可以是彼此独立的. 但如果两个伙伴都是空闲的, 内核会将其合并为一个更大的内存块, 作为下一层次上某个内存块的伙伴.
Linux内核中引入了伙伴系统算法(buddy system)。把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。最大可以申请1024个连续页框，对应4MB大小的连续内存。每个页框块的第一个页框的物理地址是该块大小的整数倍。
 假设要申请一个256个页框的块，先从256个页框的链表中查找空闲块，如果没有，就去512个页框的链表中找，找到了则将页框块分为2个256个页框的块，一个分配给应用，另外一个移到256个页框的链表中。如果512个页框的链表中仍没有空闲块，继续向1024个页框的链表查找，如果仍然没有，则返回错误&lt;/p&gt;

&lt;p&gt;Buddy算法的优缺点：
1）尽管伙伴内存算法在内存碎片问题上已经做的相当出色，但是该算法中，一个很小的块往往会阻碍一个大块的合并，一个系统中，对内存块的分配，大小是随机的，一片内存中仅一个小的内存块没有释放，旁边两个大的就不能合并。&lt;/p&gt;

&lt;p&gt;2）算法中有一定的浪费现象，伙伴算法是按2的幂次方大小进行分配内存块，当然这样做是有原因的，即为了避免把大的内存块拆的太碎，更重要的是使分配和释放过程迅速。但是他也带来了不利的一面，如果所需内存大小不是2的幂次方，就会有部分页面浪费。有时还很严重。比如原来是1024个块，申请了16个块，再申请600个块就申请不到了，因为已经被分割了。
3）另外拆分和合并涉及到 较多的链表和位图操作，开销还是比较大的。
Buddy（伙伴的定义）：
这里给出伙伴的概念，满足以下三个条件的称为伙伴：
1）两个块大小相同；
2）两个块地址连续；
3）两个块必须是同一个大块中分离出来的；
Buddy算法的分配原理：
假如系统需要4(2&lt;em&gt;2)个页面大小的内存块，该算法就到free_area[2]中查找，如果链表中有空闲块，就直接从中摘下并分配出去。如果没有，算法将顺着数组向上查找free_area[3],如果free_area[3]中有空闲块，则将其从链表中摘下，分成等大小的两部分，前四个页面作为一个块插入free_area[2]，后4个页面分配出去，free_area[3]中也没有，就再向上查找，如果free_area[4]中有，就将这16(2&lt;/em&gt;2&lt;em&gt;2&lt;/em&gt;2)个页面等分成两份，前一半挂如free_area[3]的链表头部，后一半的8个页等分成两等分，前一半挂free_area[2]
的链表中，后一半分配出去。假如free_area[4]也没有，则重复上面的过程，知道到达free_area数组的最后，如果还没有则放弃分配。&lt;/p&gt;

&lt;p&gt;Buddy算法的释放原理：
内存的释放是分配的逆过程，也可以看作是伙伴的合并过程。当释放一个块时，先在其对应的链表中考查是否有伙伴存在，如果没有伙伴块，就直接把要释放的块挂入链表头；如果有，则从链表中摘下伙伴，合并成一个大块，然后继续考察合并后的块在更大一级链表中是否有伙伴存在，直到不能合并或者已经合并到了最大的块(2&lt;em&gt;2&lt;/em&gt;2&lt;em&gt;2&lt;/em&gt;2&lt;em&gt;2&lt;/em&gt;2&lt;em&gt;2&lt;/em&gt;2个页面)。
slab机制
slab是Linux操作系统的一种内存分配机制。其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内碎片，而且处理速度也太慢。而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免这些内碎片。slab分配器并不丢弃已分配的对象，而是释放并把它们保存在内存中。当以后又要请求新的对象时，就可以从内存直接获取而不用重复初始化。&lt;/p&gt;

&lt;p&gt;Linux 的slab 可有三种状态：
 满的：slab 中的所有对象被标记为使用。
 空的：slab 中的所有对象被标记为空闲。
 部分：slab 中的对象有的被标记为使用，有的被标记为空闲。
slab 分配器首先从部分空闲的slab 进行分配。如没有，则从空的slab 进行分配。如没有，则从物理连续页上分配新的slab，并把它赋给一个cache ，然后再从新slab 分配空间。&lt;/p&gt;

&lt;p&gt;与传统的内存管理模式相比， slab 缓存分配器提供了很多优点。
1、内核通常依赖于对小对象的分配，它们会在系统生命周期内进行无数次分配。
2、slab 缓存分配器通过对类似大小的对象进行缓存而提供这种功能，从而避免了常见的碎片问题。
3、slab 分配器还支持通用对象的初始化，从而避免了为同一目的而对一个对象重复进行初始化。
4、slab 分配器还可以支持硬件缓存对齐和着色，这允许不同缓存中的对象占用相同的缓存行，从而提高缓存的利用率并获得更好的性能&lt;/p&gt;

&lt;p&gt;Slab是基础，是最早从Sun OS那引进的；Slub是在Slab上进行的改进，在大型机上表现出色（不知道在普通PC上如何），据说还被IA-64作为默认；而Slob是针对小型系统设计的，当然了，主要是嵌入式。&lt;/p&gt;

</description>
        <pubDate>Tue, 05 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/linux/2017/12/05/linux_memory.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/linux/2017/12/05/linux_memory.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>server格式</title>
        <description>&lt;!-- more --&gt;
&lt;div class=&quot;container&quot;&gt;
	&lt;div class=&quot;row&quot;&gt;
CGI程序不是放在服务器上就能顺利运行，如果要想使其在服务器上顺利的运行并准确的处理用户的请求，则须对所使用的服务器进行必要的设置。
配置：根据所使用的服务器类型以及它的设置把CGI程序放在某一特定的目录中或使其带有特定的扩展名。
⑴CREN格式服务器的配置：
编辑CREN格式服务器的配置文件（通常为/etc/httpd.conf）在文件中加入：Exec cgi-bin/*/home/www/cgi-bin/*.exec。命令中出现的第一个参数cgi-bin/*指出了在URL中出现的目录名字，并表示它出现在系统主机后的第一个目录中，如：http://edgar.stern.nyn.***/cgi-bin/。命令中的第二个参数表示CGI程序目录放在系统中的真实路径。
CGI目录除了可以跟网络文件放在同一目录中，也可以放在系统的其它目录中，但必须保证在你的系统中也具有同样的目录。在对服务器完成设置后，须重新启动服务器（除非HTTP服务器是用inetd启动的）。
⑵NCSA格式服务器的配置
在NCSA格式服务器上有两种方法进行设置：
①在srm.conf文件（通常在conf目录下）中加入：Script Alias/cgi-bin/cgi-bin/。Script Alias命令指出某一目录下的文件是可执行程序，且这个命令是用来执行这些程序的；此命令的两个参数与CERN格式服务器中的Exec命令的参数的含意一样。
②在srm.conf文件加入：Add type application/x-httpd-cgi.cgi。此命令表示在服务器上增加了一种新的文件类型，其后第一个参数为CGI程序的MIME类型，第二个参数是文件的扩展名，表示以这一扩展名为扩展名的文件是CGI程序。
在用上述方法之一设置服务器后，都得重新启动服务器（除非HTTP服务器是用inetd启动的）。
编写语言
CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。对初学者来说，最好选用易于归档和能有效表示大量数据结构的语言，例如UNIX环境中：
· Perl (Practical Extraction and Report Language)
· Bourne Shell或者Tcl (Tool Command Language)
· PHP(Hypertext Preprocessor))
由于C语言有较强的平台无关性，所以也是编写CGI程序的首选。
	&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 02 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2017/12/02/server_tyrp.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2017/12/02/server_tyrp.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>nginx_ssi</title>
        <description>&lt;!-- more --&gt;
&lt;div class=&quot;container&quot;&gt;
什么是SSI
Server Side Include，通常称为服务器端嵌入，是一种类似于ASP的基于服务器的网页制作技术。大多数（尤其是基于Unix平台）的WEB服务器如Netscape Enterprise Server等均支持SSI命令。
为什么要用SSI
用个例子来说明，一个静态化的页面中，需要嵌入一小块实时变化的内容，。例如首页，大部分的页面内容需要缓存但是用户登录后的个人信息是动态信息，不能缓存。那么如何解决这个”页面部分缓存”问题，利用SSI就可以解决，在首页的静态页面中嵌入个人信息的动态页，由于是服务器端的嵌入，所以用户浏览的时候都是一个嵌入后的页面。
用途
主要有以下几种用途：

1．显示服务器端环境变量&amp;lt;#echo&amp;gt;。

2．将文本内容直接插入到文档中&amp;lt;#include&amp;gt;。

3．显示WEB文档相关信息&amp;lt;#flastmod #fsize&amp;gt; (如文件制作日期/大小等)。

4．直接执行服务器上的各种程序&amp;lt;#exec&amp;gt;(如CGI或其他可执行程序)。

5．设置SSI信息显示格式&amp;lt;#config&amp;gt;(如文件制作日期/大小显示方式) 高级SSI&lt;XSSI&gt;可设置变量使用if条件语句。

　　SSI工作原理将内容发送到浏览器之前，可以使用“服务器端包含 (SSI)”指令将文本、图形或应用程序信息包含到网页中。例如，可以使用 SSI 包含时间/日期戳、版权声明或供客户填写并返回的表单。对于在多个文件中重复出现的文本或图形，使用包含文件是一种简便的方法。将内容存入一个包含文件中即可，而不必将内容输入所有文件。通过一个非常简单的语句即可调用包含文件，此语句指示 Web服务器将内容插入适当网页。而且，使用包含文件时，对内容的所有更改只需在一个地方就能完成。

　　因为包含 SSI 指令的文件要求特殊处理，所以必须为所有 SSI 文件赋予 SSI文件扩展名。默认扩展名是 .stm、.shtm 和 .shtml。

　　Web服务器在处理网页的同时处理 SSI 指令。当 Web服务器遇到 SSI 指令时，直接将包含文件的内容插入 HTML网页。如果“包含文件”中包含 SSI 指令，则同时插入此文件。除了用于包含文件的基本指令之外，还可以使用 SSI 指令插入文件的相关信息（如文件的大小）或者运行应用程序或 shell 命令。
　使用
SSI是为WEB服务器提供的一套命令，这些命令只要直接嵌入到HTML文档的注释内容之中即可。如：
　　&lt;!--#include file=&quot;info.htm&quot;--&gt;就是一条SSI指令，其作用是将&quot;info.htm&quot;的内容拷贝到当前的页面中，当访问者来浏览时，会看到其它HTML文档一样显示info.htm其中的内容。
　　其它的SSI指令使用形式基本同刚才的举例差不多，可见SSI使用只是插入一点代码而已，使用形式非常简单。
　　当然，如果WEB服务器不支持SSI，它就会只不过将它当作注释信息，直接跳过其中的内容；浏览器也会忽略这些信息。
　　如何在我的WEB服务器上配置SSI功能？
　　在一些WEB服务器上（如IIS 4.0/SAMBAR 4.2），包含 #include 指令的文件必须使用已被映射到 SSI解释程序的扩展名；否则，Web 服务器将不会处理该SSI指令；默认情况下，扩展名 .stm、.shtm 和 .shtml 被映射到解释程序（Ssinc.dll）。
      Apache则是根据你的设置情况而定，修改srm.conf如：AddType text/x-server-parsed-html
　　.shtml 将只对.shtml扩展名的文件解析SSI指令
　　.html将对所有HTML文档解析SSI指令
　　Netscape WEB服务器直接使用Administration Server(管理服务器)可打开SSI功能。
　　Website使用Server Admin程序中的Mapping标签，扩展名添加内容类型为：wwwserver/html-ssi
　　Cern服务器不支持SSI，可用SSI诈骗法，到http://sw.cse.bris. ac .uk/WebTools/fakessi.html;上下载一个PERL脚本，即可使你的CERN服务器使用一些SSI指令。（不支持exec指令。）
格式
SSI指令基本格式：
　　程序代码:
　　&amp;lt;!-– 指令名称=&quot;指令参数&quot;--&amp;gt;
　　&amp;lt;!-– 指令名称=&quot;指令参数&quot;--&amp;gt;
　　如 程序代码：
　　　　&lt;!--#include file=&quot;info.htm&quot;--&gt;
　　　　&lt;!--#include file=&quot;info.htm&quot;--&gt;
　　说明：
　　　　1．&lt;!-- --&gt;是HTML语法中表示注释，当WEB服务器不支持SSI时，会忽略这些信息。
　　　　2．#include 为SSI指令之一。
　　　　3．file 为include的参数，info.htm为参数值，在本指令中指将要包含的文档名。
　　注意：
　　　　1．&lt;!--与#号间无空格，只有SSI指令与参数间存在空格。
　　　　2．上面的标点=&quot;&quot;，一个也不能少。
　　　　3．SSI指令是大小写敏感的，因此参数必须是小写才会起作用。
详解
#echo 示范
作用：
　　将环境变量插入到页面中。
语法：
　　程序代码：
　　&lt;!--#echo var=&quot;变量名称&quot;--&gt;
　　本文档名称：程序代码：
　　&lt;!--#echo var=&quot;DOCUMENT_NAME&quot;--&gt;
　　当前时间：程序代码：
　　&lt;!--#echo var=&quot;DATE_LOCAL&quot;--&gt;
　　&lt;!--#echo var=&quot;DATE_LOCAL&quot;--&gt;
　　你的IP地址是程序代码：
　　&lt;!--#echo var=&quot;REMOTE_ADDR&quot;--&gt;
 
#include 示范
作用：
　　将文本文件的内容直接插入到文档页面中。
语法：
　　程序代码：
　　&lt;!--#include file=&quot;文件名称&quot;--&gt;
　　&lt;!--#include virtual=&quot;文件名称&quot;--&gt;
　　file 文件名是一个相对路径，该路径相对于使用 #include 指令的文档所在的目录。被包含文件可以在同一级目录或其子目录中，但不能在上一级目录中。如表示当前目录下的的nav_head.htm文档，则为　　　file=&quot;nav_head.htm&quot;。
　　virtual 文件名是 Web 站点上的虚拟目录的完整路径。如表示相对于服务器文档根目录下hoyi目录下的nav_head.htm文件；则为virtual=&quot;/hoyi/nav_head.htm&quot;
　　参数：
　　file 指定包含文件相对于本文档的位置
　　virtual 指定相对于服务器文档根目录的位置
　　注意：
　　　　1．文件名称必须带有扩展名。
　　　　2．被包含的文件可以具有任何文件扩展名，我觉得直接使用htm扩展名最方便，微软公司推荐使用 .inc 扩展名（这就看你的爱好了）。
示例：
　　程序代码：
　　&lt;!--#include file=&quot;nav_head.htm&quot;--&gt;将头文件插入到当前页面
　　&lt;!--#include file=&quot;nav_foot.htm&quot;--&gt;将尾文件插入到当前页面
　　#flastmod 和#fsize 示范
作用：#flastmod 文件最后一次更新日期
 
#fsize 文件的长度
语法：
　　程序代码：
　　&lt;!--#flastmod file=&quot;文件名称&quot;--&gt;
　　&lt;!--#fsize file=&quot;文件名称&quot;--&gt;
参数：
　　file 指定包含文件相对于本文档的位置 如 info.txt 表示当前目录下的的info.txt文档
　　virtual 指定相对于服务器文档根目录的位置 如 /hoyi/info.txt 表示
注意：
　　文件名称必须带有扩展名。
示例：
　　程序代码：
　　&lt;!--#flastmod file=&quot;news.htm&quot;--&gt;
　　将当前目录下news.htm文件的最后一次更新日期插入到当前页面
　　程序代码：
　　&lt;!--#fsize file=&quot;news.htm&quot;--&gt;
　　将当前目录下news.htm的文件大小入到当前页面
 
#exec 示范
作用：
　　将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是cgi。
语法：
　　程序代码：
　　&lt;!--#exec cmd=&quot;文件名称&quot;--&gt;
　　&lt;!--#exec cgi=&quot;文件名称&quot;--&gt;
参数：
　　cmd 常规应用程序
　　cgi CGI脚本程序
示例：
　　程序代码：
　　&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;将会显示密码文件
　　&lt;!--#exec cmd=&quot;dir /b&quot;--&gt;将会显示当前目录下文件列表
　　&lt;!--#exec cgi=&quot;/cgi-bin/gb.cgi&quot;--&gt;将会执行CGI程序gb.cgi。
　　&lt;!--#exec cgi=&quot;/cgi-bin/access_log.cgi&quot;--&gt;将会执行CGI程序access_log.cgi。
注意：
　　从上面的示例可以看出，这个指令相当方便，但是也存在安全问题。
禁止方法：
　　．Apache，将access.conf中的&quot;Options Includes ExecCGI&quot;这行代码删除；
　　．在IIS中，要禁用 #exec 命令，可修改 SSIExecDisable 元数据库；
 
#config
作用：
　　指定返回给客户端浏览器的错误信息、日期和文件大小的格式。
语法：
　　程序代码：
　　&lt;!--#config errmsg=&quot;自定义错误信息&quot;--&gt;
　　&lt;!--#config sizefmt=&quot;显示单位&quot;--&gt;
　　&lt;!--#config timefmt=&quot;显示格式&quot;--&gt;
参数：
　　errmsg 自定义SSI执行错误信息，可以为任何你喜欢的方式。
　　sizefmt 文件大小显示方式，默认为字节方式(&quot;bytes&quot;)可以改为千字节方式(&quot;abbrev&quot;)
　　timefmt 时间显示方式，最灵活的配置属性。
示例：显示一个不存在文件的大小
　　程序代码：
　　&lt;!--#config errmsg=&quot;服务器执行错误，谢谢！&quot;--&gt;
　　&lt;!--#fsize file=&quot;不存在的文件.htm&quot;--&gt;
　　以千字节方式显示文件大小
　　程序代码：
　　&lt;!--#config sizefmt=&quot;abbrev&quot;--&gt;
　　&lt;!--#fsizefile=&quot;news.htm&quot;--&gt;
　　以特定的时间格式显示时间
　　程序代码：
　　&lt;!--#config timefmt=&quot;%Y年/%m月%d日 星期%W 北京时间%H:%M:%s，%Y年已过去了%j天 今天是%Y年的第%U个星期&quot;--&gt;
　　&lt;!--#echo var=&quot;DATE_LOCAL&quot;--&gt; 显示今天是星期几，几月，时区
　　&lt;!--#config timefmt=&quot;今天%A,%B,服务器时区是 %z，是&quot;--&gt;
　　&lt;!--#echo var=&quot;DATE_LOCAL&quot;--&gt;
XSSI
XSSI（Extended SSI）是一组高级SSI指令，内置于Apache 1.2或更高版本的mod-include模块之中。
其中可利用的的指令有：
#printenv
#set
#if
#printenv
作用：显示当前存在于WEB服务器环境中的所有环境变量。
语法：程序代码：
&lt;!--#printenv--&gt;
#set
作用：可给变量赋值，以用于后面的if语句。
语法：程序代码：
&lt;!--#set var=&quot;变量名&quot;value=&quot;变量值&quot;--&gt;
参数：无
示例：程序代码：
&lt;!--#set var=&quot;color&quot;value=&quot;红色&quot;--&gt;
#if
作用：创建可以改变数据的页面，这些数据根据使用if语句时计算的要求予以显示。
语法：程序代码：
&lt;!--#if expr=&quot;$变量名=\&quot;变量值A\&quot;&quot;--&gt;
显示内容
&lt;!--#elif expr=&quot;$变量名=\&quot;变量值B\&quot;&quot;--&gt;
显示内容
&lt;!--#else--&gt;
显示内容
&lt;!--#endif&quot;--&gt;
示例：
程序代码：
&lt;!--#if expr=&quot;$SERVER_NAME=\&quot;bk.baidu .com\&quot;&quot;--&gt;
欢迎光临百度。
&lt;!--#elif expr=&quot;$SERVER_NAME=\&quot;bk.baidu .com\&quot;&quot; --&gt;
欢迎光临百度知道。
&lt;!--#else--&gt;
欢迎光临百度百科。
&lt;!--#endif&quot;--&gt;
注意：用于前面指令中的反斜杠，是用来代换内部的引号，以便它们不会被解释为结束表达式。不可省略。
命令
config

Config命令主要用于修改SSI的默认设置。其中：
Errmsg：设置默认错误信息。为了能够正常的返回用户设定的错误信息，在HTML文件中Errmsg参数必须被放置在其它SSI命令的前面，否则客户端只能显示默认的错误信息，而不是由用户设定的自定义信息。
&lt;!--#config errmsg=&quot;Error! --&gt;
Timefmt：定义日期和时间的使用格式。Timefmt参数必须在echo命令之前使用。
&lt;!--#config timefmt=&quot;%A,%B %d,%Y&quot;--&gt;
&lt;!--#echo var=&quot;LAST_MODIFIED&quot; --&gt;
显示结果为：
Wednesday,April 12,2000
也许用户对上例中所使用的%A %B %d感到很陌生，下面我们就以表格的形式总结一下SSI中较为常用的一些日期和时间格式。
Sizefmt：决定文件大小是以字节、千字节还是兆字节为单位表示。如果以字节为单位，参数值为&quot;bytes&quot;；对于千字节和兆字节可以使用缩写形式。同样，sizefmt参数必须放在fsize命令的前面才能使用。
&lt;!--#config sizefmt=&quot;bytes&quot; --&gt;
&lt;!--#fsize file=&quot;index.html&quot; --&gt;
Include

Include命令可以把其它文档中的文字或图片插入到当前被解析的文档中，这是整个SSI的关键所在。通过Include命令只需要改动一个文件就可以瞬间更新整个站点！
Include命令具有两个不同的参数：
Virtual：给出到服务器端某个文档的虚拟路径。例如：
&lt;!--#include virtual=&quot;/includes/header.html&quot; --&gt;
File：给出到当前目录的相对路径，其中不能使用&quot;../&quot;，也不能使用绝对路径。例如：
&lt;!--#include file=&quot;header.html&quot; --&gt;
这就要求每一个目录中都包含一个header.html文件。
echo

Echo命令可以显示以下各环境变量：
DOCUMENT_NAME：显示当前文档的名称。
&lt;!--#echo var=&quot;DOCUMENT_NAME&quot; --&gt;
显示结果为：
index.html
DOCUMENT_URI：显示当前文档的虚拟路径。例如：
&lt;!--#echo var=&quot;DOCUMENT_URI&quot; --&gt;
显示结果为：
/YourDirectory/YourFilename.html
随着网站的不断发展，那些越来越长的URL地址肯定会让人头疼。如果使用SSI，一切就会迎刃而解。因为我们可以把网站的域名和SSI命令结合在一起显示完整的URL，即：
http://YourDomain&lt;!--#echovar=&quot;DOCUMENT_URI&quot; --&gt;
QUERY_STRING_UNESCAPED：显示未经转义处理的由客户端发送的查询字串，其中所有的特殊字符前面都有转义符&quot;\&quot;。例如：
&lt;!--#echo var=&quot;QUERY_STRING_UNESCAPED&quot; --&gt;
DATE_LOCAL：显示服务器设定时区的日期和时间。用户可以结合config命令的timefmt参数，定制输出信息。例如：
&lt;!--#config timefmt=&quot;%A,the %d of %B,in the year %Y&quot; --&gt;
&lt;!--#echo var=&quot;DATE_LOCAL&quot; --&gt;
显示结果为：
Saturday,the 15 of April,in the year 2000
DATE_GMT：功能与DATE_LOCAL一样，只不过返回的是以格林尼治标准时间为基准的日期。例如：
&lt;!--#echo var=&quot;DATE_GMT&quot; --&gt;
LAST_MODIFIED：显示当前文档的最后更新时间。同样，这是SSI中非常实用的一个功能，只要在HTML文档中加入以下这行简单的文字，就可以在页面上动态的显示更新时间。
&lt;!--#echo var=&quot;LAST_MODIFIED&quot; --&gt;
CGI环境变量
除了SSI环境变量之外，echo命令还可以显示以下CGI环境变量：
SERVER_SOFTWARE：显示服务器软件的名称和版本。例如：
&lt;!--#echo var=&quot;SERVER_SOFTWARE&quot; --&gt;
SERVER_NAME：显示服务器的主机名称，DNS别名或IP地址。例如：
&lt;!--#echo var=&quot;SERVER_NAME&quot; --&gt;
SERVER_PROTOCOL：显示客户端请求所使用的协议名称和版本，如HTTP/1.0。例如：
&lt;!--#echo var=&quot;SERVER_PROTOCOL&quot; --&gt;
SERVER_PORT：显示服务器的响应端口。例如：
&lt;!--#echo var=&quot;SERVER_PORT&quot; --&gt;
REQUEST_METHOD：显示客户端的文档请求方法，包括GET,HEAD,和POST。例如：
&lt;!--#echo var=&quot;REQUEST_METHOD&quot; --&gt;
REMOTE_HOST：显示发出请求信息的客户端主机名称。
&lt;!--#echo var=&quot;REMOTE_HOST&quot; --&gt;
REMOTE_ADDR：显示发出请求信息的客户端IP地址。
&lt;!--#echo var=&quot;REMOTE_ADDR&quot; --&gt;
AUTH_TYPE：显示用户身份的验证方法。
&lt;!--#echo var=&quot;AUTH_TYPE&quot; --&gt;
REMOTE_USER：显示访问受保护页面的用户所使用的帐号名称。
&lt;!--#echo var=&quot;REMOTE_USER&quot; --&gt;
fsize

显示指定文件的大小，可以结合config命令的sizefmt参数定制输出格式。
&lt;!--#fsize file=&quot;index_working.html&quot; --&gt;
flastmod

显示指定文件的最后修改日期，可以结合config 命令的timefmt参数控制输出格式。
&lt;!--#config timefmt=&quot;%A,the %d of %B,in the year %Y&quot; --&gt;
&lt;!--#flastmod file=&quot;file.html&quot; --&gt;
这里，我们可以利用flastmod参数显示出一个页面上所有链接页面的更新日期。方法如下：
&lt;!--#config timefmt=&quot; %B %d,%Y&quot; --&gt;
File
&lt;!--#flastmod virtual=&quot;/directory/file.html&quot; --&gt;
Another File
&lt;!--#flastmod virtual=&quot;/another_directory/another_file.html&quot; --&gt;
显示结果为：
File April 19,2000
Another File January 08,2000
exec

Exec命令可以执行CGI脚本或者shell命令。使用方法如下：
Cmd：使用/bin/sh执行指定的字串。如果SSI使用了IncludesNOEXEC选项，则该命令将被屏蔽。
Cgi：可以用来执行CGI脚本。例如，下面这个例子中使用服务端cgi-bin目录下的counter .pl脚本程序在每个页面放置一个计数器
&lt;!--#exec cgi=&quot;/cgi-bin/counter .pl&quot; --&gt;
指令区别
　　SHTML和HTML的区别，如果用一句话来解释就是：SHTML 不是HTML而是一种服务器API,shtml可通过服务器动态产成html. 虽然两者都是超文本格式，但shtml是一种用于SSI技术的文件。也就是Server Side Include--SSI服务器端包含指令。如果Web Server有SSI功能的话(大多数（尤其是基于Unix平台）的WEB服务器如Netscape Enterprise Server等均支持SSI命令)。会对shtml文件特殊招待。先扫一次shtml文件看有没有特殊的SSI指令存在。有就按Web Server设定规则解释SSI指令。解释完后跟一般html一起调去客户端。html或htm与shtml或shtm的关系是什么？html或者htm是一种静态的页面格式，也就是说不需要服务器解析其中的脚本，或者说里面没有服务器端执行的脚本，而shtml或者shtm由于它基于SSI技术，当有服务器端可执行脚本时被当作一种动态编程语言来看待，就如asp、jsp或者php一样。当shtml或者shtm中不包含服务器端可执行脚本时其作用和html或者htm是一样的。

　如下是支持ssi的配置部分：
server {
    listen          80;
    server_name     doc.outofmemory.cn;
    access_log      /www/logs/doc.outofmemory.cn/access.log;

    ssi on;
    ssi_silent_errors on;
    ssi_types text/shtml;

    location / {
        index index.html;
        root  /www/doc.outofmemory.cn/;
    }
}
在上面的server配置中，只要有如下三行，就可以支持ssi（server side include）了

需要的选项主要是以下三个：
ssi: 默认值off，启用ssi时将其设为on
ssi_silent_errors: 默认值off，开启后在处理SSI文件出错时不输出错误提示&quot;[an error occurred while processing the directive]&quot;。
ssi_types: 默认是text/html，所以如果需支持html，则不需要设置这句，如果需要支持shtml则需要设置：ssi_types text/shtml
三个参数可以放在http, server或location作用域下。

 # ./nginx -s reload
nginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; failed (2: No such file or directory)
 解决方法：
[root@localhost nginx]# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf
&amp;lt;/div&amp;gt;
&lt;/XSSI&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 02 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2017/12/02/nginx_ssi.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2017/12/02/nginx_ssi.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>go升级遇到问题及解决方案</title>
        <description>&lt;!-- more --&gt;
&lt;div class=&quot;container&quot;&gt;
brew install  go
会将新版go安装到  /usr/local/Cellar/go/1.9.2/
$ ls /usr/local/Cellar/go/1.9.2/
AUTHORS			LICENSE			bin
INSTALL_RECEIPT.json	README.md		libexec
却少的库和编译工具都在libexec目录下，直接复制src 目录到goroot，虽然能解决找不到库文件的问题，但是会报
go tool: no such tool &quot;compile&quot;
将/usr/local/Cellar/go/1.9.2/libexec 设为gopath
会报
import cycle not allowed
package cmd/dist
    imports bytes
    imports errors
    imports runtime
    imports unsafe
    imports runtime
    
解决办法：
go官网下载安装包
https://golang.org/doc/install?download=go1.9.2.darwin-amd64.pkg

Failded to continue:&quot;Cannot find Delve debugger. Install from https://github.com/derekparker/delve &amp;amp; ensure it is in your &quot;GOPATH/bin&quot; or &quot;PATH&quot;

$go get github.com/derekparker/delve/cmd/dlv

多项目调试

在launch.json中可以添加多组调试入口, 通过调试面板中选中对应的配置开启不同目标的调试

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;version&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;0.2.0&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;configurations&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;client&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;go&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;request&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;launch&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;mode&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;debug&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;remotePath&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;port&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2345&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;host&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;program&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;${fileDirname}&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;env&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;s2&quot;&gt;&amp;quot;GOPATH&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;D:/Develop/vscodegolang&amp;quot;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;args&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;showLog&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;

        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;server&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;go&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;request&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;launch&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;mode&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;debug&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;remotePath&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;port&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2345&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;host&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;program&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;${workspaceRoot}/src/server&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;env&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;s2&quot;&gt;&amp;quot;GOPATH&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;D:/Develop/vscodegolang&amp;quot;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;args&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&amp;quot;showLog&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&quot;program&quot;中的&quot;${fileDirname}&quot;是以当前选中文件作为启动点

更建议使用&quot;program&quot;的&quot;${workspaceRoot}&quot;, 以包名作为启动点的方式进行配置
&lt;/div&gt;
</description>
        <pubDate>Wed, 29 Nov 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2017/11/29/go_update.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2017/11/29/go_update.html</guid>
        
        
        <category>web</category>
        
      </item>
    
  </channel>
</rss>
