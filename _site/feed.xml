<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>泽民博客</title>
    <description>夏泽民的个人主页，学习笔记。</description>
    <link>https://xiazemin.github.io/MyBlog/</link>
    <atom:link href="https://xiazemin.github.io/MyBlog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 24 Oct 2017 19:27:51 +0800</pubDate>
    <lastBuildDate>Tue, 24 Oct 2017 19:27:51 +0800</lastBuildDate>
    <generator>Jekyll v3.6.0.pre.beta1</generator>
    
      <item>
        <title>scala_partion_function</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;从使用case语句构造匿名函数谈起&lt;/p&gt;

&lt;p&gt;在Scala里，我们可以使用case语句来创建一个匿名函数（函数字面量），这有别于一般的匿名函数创建方法。来看个例子：&lt;/p&gt;

&lt;p&gt;scala&amp;gt; List(1,2,3) map {case i:Int=&amp;gt;i+1}
res1: List[Int] = List(2, 3, 4)
1
2
这很有趣，case i:Int=&amp;gt;i+1构建的匿名函数等同于(i:Int)=&amp;gt;i+1，也就是下面这个样子：&lt;/p&gt;

&lt;p&gt;scala&amp;gt; List(1,2,3) map {(i:Int)=&amp;gt;i+1}
res2: List[Int] = List(2, 3, 4)
1
2
《Scala In Programming》一书对独立的case语句作为匿名函数（函数字面量）有权威的解释：&lt;/p&gt;

&lt;p&gt;Essentially, a case sequence is a function literal, only more general. Instead of having a single entry point and list of parameters, a case sequence has multiple entry points, each with their own list of parameters. Each case is an entry point to the function, and the parameters are specified with the pattern. 
1
2
一个case语句就是一个独立的匿名函数，如果有一组case语句的话，从效果上看，构建出的这个匿名函数会有多种不同的参数列表，每一个case对应一种参数列表，参数是case后面的变量声明，其值是通过模式匹配赋予的。&lt;/p&gt;

&lt;p&gt;使用case语句构造匿名函数的“额外”好处&lt;/p&gt;

&lt;p&gt;使用case语句构造匿名函数是有“额外”好处的，这个“好处”在下面这个例子中得到了充分的体现：&lt;/p&gt;

&lt;p&gt;List(1, 3, 5, “seven”) map { case i: Int =&amp;gt; i + 1 } // won’t work
// scala.MatchError: seven (of class java.lang.String)
List(1, 3, 5, “seven”) collect { case i: Int =&amp;gt; i + 1 }
// verify
assert(List(2, 4, 6) == (List(1, 3, 5, “seven”) collect { case i: Int =&amp;gt; i + 1 }))
1
2
3
4
5
在这个例子中：传递给map的case语句构建的是一个普通的匿名函数，在把这个函数适用于”seven”元素时发生了类型匹配错误。而对于collect,它声明接受的是一个偏函数：PartialFunction，传递的case语句能良好的工作说明这个case语句被编译器自动编译成了一个PartialFunction！这就是case语句“额外”的好处：case语句（组合）除了可以被编译为匿名函数（类型是FunctionX，在Scala里，所有的函数字面量都是一个对象，这个对象的类型是FunctionX），还可以非常方便的编译为一个偏函数PartialFunction！（注意：PartialFunction同时是Function1的子类）编译器会根据调用处的函数类型声明自动帮我们判定如何编译这个case语句（组合）。&lt;/p&gt;

&lt;p&gt;上面我们直接抛出了偏函数的概念，这会让人头晕，我们可以只从collect这个示例的效果上去理解偏函数：它只对会作用于指定类型的参数或指定范围值的参数实施计算，超出它的界定范围之外的参数类型和值它会忽略（未必会忽略，这取决于你打算怎样处理）。就像上面例子中一样，case i: Int =&amp;gt; i + 1只声明了对Int参数的处理，在遇到”seven”元素时，不在偏函数的适用范围内，所以这个元素被忽略了。&lt;/p&gt;

&lt;p&gt;正式认识偏函数Partial Function&lt;/p&gt;

&lt;p&gt;如同在一开始的例子中那样，我们手动实现了一个与case i:Int=&amp;gt;i+1等价的那个匿名函数(i:Int)=&amp;gt;i+1,那么在上面的collect方法中使用到的case i: Int =&amp;gt; i + 1它的等价函数是什么呢？显然，不可能是(i:Int)=&amp;gt;i+1了，因为我们已经解释了，collect接受的参数类型是PartialFunction[Any,Int],而不是(Int)=&amp;gt;Int。 那个case语句对应的偏函数具体是什么样的呢？来看：&lt;/p&gt;

&lt;p&gt;scala&amp;gt; val inc = new PartialFunction[Any, Int] {
     | def apply(any: Any) = any.asInstanceOf[Int]+1
     | def isDefinedAt(any: Any) = if (any.isInstanceOf[Int]) true else false
     | }
inc: PartialFunction[Any,Int] = &lt;function1&gt;&lt;/function1&gt;&lt;/p&gt;

&lt;p&gt;scala&amp;gt; List(1, 3, 5, “seven”) collect inc
res4: List[Int] = List(2, 4, 6)
1
2
3
4
5
6
7
8
PartialFunction特质规定了两个要实现的方法：apply和isDefinedAt，isDefinedAt用来告知调用方这个偏函数接受参数的范围，可以是类型也可以是值，在我们这个例子中我们要求这个inc函数只处理Int型的数据。apply方法用来描述对已接受的值如何处理，在我们这个例子中，我们只是简单的把值+1，注意，非Int型的值已被isDefinedAt方法过滤掉了，所以不用担心类型转换的问题。&lt;/p&gt;

&lt;p&gt;上面这个例子写起来真得非常笨拙，和前面的case语句方式比起来真是差太多了。这个例子从反面展示了：通过case语句组合去是实现一个偏函数是多么简洁。实际上case语句组合与偏函数的用意是高度贴合的，所以使用case语句组合是最简单明智的选择，同样是上面的inc函数，换成case去写如下：&lt;/p&gt;

&lt;p&gt;scala&amp;gt; def inc: PartialFunction[Any, Int] =
     | { case i: Int =&amp;gt; i + 1 }
inc: PartialFunction[Any,Int]&lt;/p&gt;

&lt;p&gt;scala&amp;gt; List(1, 3, 5, “seven”) collect inc
res5: List[Int] = List(2, 4, 6)
1
2
3
4
5
6
当然，如果偏函数的逻辑非常复杂，可能通过定义一个专门的类并继承PartialFunction是更好选择。&lt;/p&gt;

&lt;p&gt;Case语句是如何被编译成偏函数的&lt;/p&gt;

&lt;p&gt;关于这个问题在《Programming In Scala》中有较为详细的解释。对于这样一个使用case写在的偏函数：&lt;/p&gt;

&lt;p&gt;val second: PartialFunction[List[Int],Int] = {
    case x :: y :: _ =&amp;gt; y
}
1
2
3
In fact, such an expression gets ranslated by the Scala compiler to a partial function by translating the patterns twice—once for the implementation of the real function, and once to test whether the function is defined or not. For instance, the function literal { case x :: y :: _ =&amp;gt; y }above gets translated to the following partialfunction value:&lt;/p&gt;

&lt;p&gt;new PartialFunction[List[Int], Int] {
    def apply(xs: List[Int]) = xs match {
        case x :: y :: _ =&amp;gt; y
    }
    def isDefinedAt(xs: List[Int]) = xs match {
        case x :: y :: _ =&amp;gt; true
        case _ =&amp;gt; false
    }
}
1
2
3
4
5
6
7
8
9
为什么偏函数需要抽象成一个专门的Trait&lt;/p&gt;

&lt;p&gt;首先，在Scala里，一切皆对象，函数字面量（匿名函数）也不例外！这也是为什么我们可以把函数字面量赋给一个变量的原因, 是对象就有对应的类型，那么一个函数字面量的真实类型是什么呢？看下面这个例子：&lt;/p&gt;

&lt;p&gt;scala&amp;gt; var inc = (x: Int) =&amp;gt; x + 1
inc: Int =&amp;gt; Int = &lt;function1&gt;&lt;/function1&gt;&lt;/p&gt;

&lt;p&gt;scala&amp;gt; inc.isInstanceOf[Function1[Int,Int]]
res0: Boolean = true
1
2
3
4
5
在Scala的scala包里，有一系列Function trait，它们实际上就是函数字面量作为“对象”存在时对应的类型。Function类型有多个版本，Function0表示无参数函数，Function1表示只有一个参数的函数，以此类推。至此我们解释的是一个普遍性问题：是函数就是对象，是对象就有类型。那么，接下来我们看一下偏函数又应该是什么样的一种“类型”？&lt;/p&gt;

&lt;p&gt;从语义上讲，偏函数区别于普通函数的唯一特征就是：偏函数会自主地告诉调用方它的处理参数的范围，范围既可是值也可以是类型。针对这样的场景，我们需要给函数安插一种明确的“标识”，告诉编译器：这个函数具有这种特征。所以特质PartialFunction就被创建出来用于“标记”这类函数的，这个特质最主要的方法就是isDefinedAt！同时你也记得PartialFunction还是Function1的子类，所以它也要有apply方法，这是非常自然的，偏函数本身首先是一个函数嘛。&lt;/p&gt;

&lt;p&gt;从另一个角度思考，偏函数的逻辑是可以通过普通函数去实现的，只是偏函数是更为优雅的一种方式，同时偏函数特质PartialFunction的存在对调用方和实现方都是一种语义更加丰富的约定，比如collect方法声明使用一个偏函数就暗含着它不太可能对每一个元素进行操作，它的返回结果仅仅是针对偏函数“感兴趣”的元素计算出来的&lt;/p&gt;

&lt;p&gt;为什么偏函数只能有一个参数？&lt;/p&gt;

&lt;p&gt;为什么只有针对单一参数的偏函数，而不是像Function特质那样，拥有多个版本的PartialFunction呢？在刚刚接触偏函数时，这也让我感到费解，但看透了偏函数的实质之后就会觉得很合理了。我们说所谓的偏函数本质上是由多个case语句组成的针对每一种可能的参数分别进行处理的一种“结构较为特殊”的函数，那特殊在什么地方呢？对，就是case语句，前面我们提到，case语句声明的变量就是偏函数的参数，既然case语句只能声明一个变量，那么偏函数受限于此，也只能有一个参数！说到底，类型PartialFunction无非是为由一组case语句描述的函数字面量提供一个类型描述而已，case语句只接受一个参数，则偏函数的类型声明自然就只有一个参数。&lt;/p&gt;

&lt;p&gt;但是，上这并不会对编程造成什么阻碍，如果你想给一个偏函数传递多个参数，完全可以把这些参数封装成一个Tuple传递过去&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Oct 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/spark/2017/10/24/scala_partion_function.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/spark/2017/10/24/scala_partion_function.html</guid>
        
        
        <category>spark</category>
        
      </item>
    
      <item>
        <title>partion_function</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。&lt;/p&gt;

&lt;p&gt;在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：&lt;/p&gt;

&lt;p&gt;int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;p&gt;int(‘12345’)
12345
但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;p&gt;int(‘12345’, base=8)
5349
int(‘12345’, 16)
74565
假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;def int2(x, base=2):
    return int(x, base)
这样，我们转换二进制就非常方便了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;p&gt;int2(‘1000000’)
64
int2(‘1010101’)
85
functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;p&gt;import functools
int2 = functools.partial(int, base=2)
int2(‘1000000’)
64
int2(‘1010101’)
85
所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;p&gt;int2(‘1000000’, base=10)
1000000
最后，创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;int2 = functools.partial(int, base=2)
实际上固定了int()函数的关键字参数base，也就是：&lt;/p&gt;

&lt;p&gt;int2(‘10010’)
相当于：&lt;/p&gt;

&lt;p&gt;kw = { base: 2 }
int(‘10010’, **kw)
当传入：&lt;/p&gt;

&lt;p&gt;max2 = functools.partial(max, 10)
实际上会把10作为*args的一部分自动加到左边，也就是：&lt;/p&gt;

&lt;p&gt;max2(5, 6, 7)
相当于：&lt;/p&gt;

&lt;p&gt;args = (10, 5, 6, 7)
max(*args)
结果为10。&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Oct 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2017/10/24/partion_function.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2017/10/24/partion_function.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>高阶函数函数加里化(Currying)和偏函数应用(Partial Application)的比较</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;所谓高阶函数是指可一把函数作为参数，或者是可以将函数作为返回值的函数（我们见得闭包函数就是高阶函数）。&lt;/p&gt;

&lt;p&gt;function foo(x){
   return function(){
        return x;
   }&lt;br /&gt;
}
　　对于程序的编写，高阶函数比普通函数要灵活的多，除了通常意义的函数调用返回外，还形成了一种后续传递风格的结果接收方式，而非单一的返回值形式，后续传递风格的程序编写将函数的业务重点从返回值转移到了回调函数中：&lt;/p&gt;

&lt;p&gt;function(x,bar){
   return bar(x);    &lt;br /&gt;
}
　　以上的代码为例，对于相同的foo()函数，传入的bar的参数不同，则可以得到不同的结果。结合Node提供的最基本的事件模块可以看到，事件的处理方式就是基于高阶函数的特性来完成的。&lt;/p&gt;

&lt;p&gt;　　高阶函数在JS中的应用比比皆是，其中ECMAScript5中提供的一些数组方法就是典型的高阶函数，比如：forEach()、map()、reduce()、reduceRight()、filter()、every()、some()等。&lt;/p&gt;

&lt;p&gt;二、偏函数&lt;/p&gt;

&lt;p&gt;　　偏函数用法是指创建一个调用另一个部分——参数或变量已经预置的的函数——的函数的用法。偏函数解决这样的问题：如果我们有函数是多个参数的，我们希望能固定其中某几个参数的值。
　　几乎所有编程语言中都有非常明显的偏函数应用。在C语言中：&lt;/p&gt;

&lt;p&gt;int foo(int a, int b, int c) {&lt;/p&gt;

&lt;p&gt;return a + b + c;
}&lt;/p&gt;

&lt;p&gt;int foo23(int a, int c) {
  return foo(a, 23, c);&lt;/p&gt;

&lt;p&gt;}
foo23函数实际上就是一个foo函数的偏函数应用，参数b的值被固定为23。&lt;/p&gt;

&lt;p&gt;当然，像这样明显的偏函数并没有太大的用处；我们通常会希望编程语言能提供我们某些偏函数特征。&lt;/p&gt;

&lt;p&gt;例如，在Python语言中，我们可以这样做：&lt;/p&gt;

&lt;p&gt;from functools import partial&lt;/p&gt;

&lt;p&gt;def foo(a,b,c):&lt;/p&gt;

&lt;p&gt;return a + b + c&lt;/p&gt;

&lt;p&gt;foo23 = partial(foo, b=23)&lt;/p&gt;

&lt;p&gt;foo23(a = 1, c = 3)  # =&amp;gt; 27&lt;/p&gt;

&lt;p&gt;三、函数加里化(Currying)
函数加里化(Currying)明显解决的是一个完全不同的问题：如果我们有几个单参数函数，并且这是一种支持一等函数(first-class)的语言，如何去实现一个多参数函数？函数加里化是一种实现多参数函数的方法。&lt;/p&gt;

&lt;p&gt;下面是一个单参数的Javascript函数:&lt;/p&gt;

&lt;p&gt;var foo = function(a) {&lt;/p&gt;

&lt;p&gt;return a * a;
}
如果我们受限只能写单参数函数，可以像下面这样模拟出一个多参数函数：&lt;/p&gt;

&lt;p&gt;var foo = function(a) {&lt;/p&gt;

&lt;p&gt;return function(b) {
    return a * a + b * b;&lt;/p&gt;

&lt;p&gt;}
}
通过这样调用它：(foo(3))(4)，或直接 foo(3)(4)。&lt;/p&gt;

&lt;p&gt;注意，函数加里化提供了一种非常自然的方式来实现某些偏函数应用。如果你希望函数foo的第一个参数值被固定成5，你需要做的就是var foo5 = foo(5)。这就OK了。函数foo5就是foo函数的偏函数。注意，尽管如此，我们没有很简单的方法对foo函数的第二个参数偏函数化(除非先偏函数化第一个参数)。&lt;/p&gt;

&lt;p&gt;当然，Javascript是支持多参数函数的：&lt;/p&gt;

&lt;p&gt;var bar = function(a, b) {&lt;/p&gt;

&lt;p&gt;return a * a + b * b;&lt;/p&gt;

&lt;p&gt;}
我们定义的bar函数并不是一个加里化的函数。调用bar(5)并不会返回一个可以输入12的函数。我们只能像bar(5,12)这样调用这个函数。&lt;/p&gt;

&lt;p&gt;在一些其它语言里，比如 Haskell 和 OCaml，所有的多参数函数都是通过加里化实现的。&lt;/p&gt;

&lt;p&gt;下面是一个把上面的foo函数用OCaml语言写成的例子：&lt;/p&gt;

&lt;p&gt;let foo = fun a -&amp;gt;&lt;/p&gt;

&lt;p&gt;fun b -&amp;gt;
    a * a + b * b&lt;/p&gt;

&lt;p&gt;下面是把上面的bar函数用OCaml语言写成的例子：&lt;/p&gt;

&lt;p&gt;let bar = fun a b -&amp;gt;&lt;/p&gt;

&lt;p&gt;a * a + b * b
头一个函数我们叫做“显式加里化”，第二个叫做“隐式加里化”。&lt;/p&gt;

&lt;p&gt;跟Javascript不一样，在OCaml语言里，foo函数和bar函数是完全一样的。我们用完全一样的方式调用它们。&lt;/p&gt;

&lt;h1 id=&quot;foo-3-4&quot;&gt;foo 3 4;;&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;: int = 25
    &lt;h1 id=&quot;bar-3-4&quot;&gt;bar 3 4;;&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;: int = 25
两个函数都能够通过提供一个参数值来创造一个偏函数：&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;let-foo5--foo-5&quot;&gt;let foo5 = foo 5;;&lt;/h1&gt;
&lt;p&gt;val foo5 : int -&amp;gt; int = &lt;fun&gt;&lt;/fun&gt;&lt;/p&gt;

&lt;h1 id=&quot;let-bar5--bar-5&quot;&gt;let bar5 = bar 5;;&lt;/h1&gt;
&lt;p&gt;val bar5 : int -&amp;gt; int = &lt;fun&gt;&lt;/fun&gt;&lt;/p&gt;
&lt;h1 id=&quot;foo5-12&quot;&gt;foo5 12;;&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;: int = 169
    &lt;h1 id=&quot;bar5-12&quot;&gt;bar5 12;;&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;: int = 169
事实上，我们可以把下面这个匿名函数：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;fun arg1 arg2 … argN -&amp;gt; exp&lt;/p&gt;

&lt;p&gt;当作是下面这个函数的简写：&lt;/p&gt;

&lt;p&gt;fun arg1 -&amp;gt; fun arg2 -&amp;gt; … -&amp;gt; fun argN -&amp;gt; exp&lt;/p&gt;

&lt;p&gt;函数加里化和偏函数应用的总结&lt;/p&gt;

&lt;p&gt;偏函数应用是找一个函数，固定其中的几个参数值，从而得到一个新的函数。
函数加里化是一种使用匿名单参数函数来实现多参数函数的方法。
函数加里化能够让你轻松的实现某些偏函数应用。
有些语言(例如 Haskell, OCaml)所有的多参函数都是在内部通过函数加里化实现的。&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Oct 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2017/10/24/function.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2017/10/24/function.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>使用Phabricator做为Code Review工具</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;目录&lt;/p&gt;

&lt;p&gt;0x10 概述
0x20 我的应用环境
0x30 路线图
0x40 安装
0x41 LNMP环境的安装
0x42 Phabricator源码下载及运行
0x50 配置
0x51 解决基本的配置问题
0x52 设置用户登录认证方式
0x53 设置邮件发送服务参数
0x54 配置代码仓库访问方式：SSH/HTTP
0x60 使用Phabricator进行Code Review
0x61 Phabricator Code Review工作流
0x62 进行Code Review所用工具
0x63 配置进行Code Review
0x70 与GitHub集成
0x80 与Jenkins集成
0x90 结束语
0xA0 Q/A
0x10 概述&lt;/p&gt;

&lt;p&gt;Phabricator是一套基于Web的软件开发协作工具，包括代码审查工具Differential，资源库浏览器Diffusion，变更监测工具Herald，Bug跟踪工具Maniphest和维基工具Phriction。Phabricator可与Git、Mercurial、Subversion集成使用。
Phabricator是开源软件，可在Apache许可证第2版下作为自由软件分发。
Phabricator最初是Facebook的一个内部工具，主要开发者为Evan Priestley。Evan Priestley离开Facebook后，在名为Phacility的新公司继续Phabricator的开发。
官网：https://www.phacility.com/&lt;/p&gt;

&lt;p&gt;官网中的文档很多很全，但是如果对这个工具不太了解，或者对于Code Review不太了解的话，读起来可能会觉得没有头绪。这篇文章就自己的安装及使用过程做一个梳理，对于同样想用这个工具的读者，或许起到一些帮助作用。
对于本文中的一些章节，如果在官方文档有所提及，我会把官方文档地址附上，读者可以阅读一下官方文档，因为他们的语言和表达更优秀。&lt;/p&gt;

&lt;p&gt;0x20 我的应用环境&lt;/p&gt;

&lt;p&gt;我：一个做了很多年Android的程序员啊 （所以当这篇文章有幸被所涉及领域的专家看到，又发现有的部分有所不妥，或者有更好的想法时，请主动联系我改进，多谢~~~ 有任何问题，欢迎评论交流）
主机：Ubuntu 14.04 PC一台
网络：内网
代码库：GitHub
CI：Jenkins
0x30 路线图&lt;/p&gt;

&lt;p&gt;安装和使用路线大致如此图，下面开始详细说明。&lt;/p&gt;

&lt;p&gt;0x40 安装&lt;/p&gt;

&lt;p&gt;Phabricator是一个基于Web的工具软件，使用PHP语言编写的，为了能让他运行起来，我们需要搭建一个LNMP（Linux，Nginx，MySQL，PHP）的Web Server环境。搭建完LNMP的环境后，下载Phabricator源码，配置后即可使用。&lt;/p&gt;

&lt;p&gt;先看我
如果你不想读那么多文字，在Ubuntu环境下可以试试下面的脚本，这个脚本可以安装LNMP环境和下载Phabricator源码，执行完脚本并成功后，跳到 0x42 Phabricator源码下载及运行 查看如何让Phabricator跑起来。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;lineno&quot;&gt; 1 &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2 &lt;/span&gt;confirm&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3 &lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Press RETURN to continue, or ^C to cancel.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4 &lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; -e ignored
&lt;span class=&quot;lineno&quot;&gt; 5 &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6 &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;GIT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;git&amp;#39;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7 &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;LTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;Ubuntu 10.04&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8 &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ISSUE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;cat /etc/issue&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ISSUE&lt;/span&gt; !&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Ubuntu* &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11 &lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;This script is intended for use on Ubuntu, but this system appears&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12 &lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;to be something else. Your results may vary.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;13 &lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14 &lt;/span&gt;  confirm
&lt;span class=&quot;lineno&quot;&gt;15 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;expr match &lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ISSUE&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$LTS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; -eq &lt;span class=&quot;si&quot;&gt;${#&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;LTS&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;16 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;17 &lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;GIT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;git-core&amp;#39;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;18 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;19 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;PHABRICATOR UBUNTU INSTALL SCRIPT&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;20 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;This script will install Phabricator and all of its core dependencies.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;21 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Run it from the directory you want to install into.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;22 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;23 &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ROOT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;24 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Phabricator will be installed to: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ROOT&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;25 &lt;/span&gt;confirm
&lt;span class=&quot;lineno&quot;&gt;26 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Testing sudo...&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;27 &lt;/span&gt;sudo &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;28 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt; -ne &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;29 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;30 &lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;ERROR: You must be able to sudo to run this script.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;31 &lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;32 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;33 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Installing dependencies: git, nginx, mysql, php...&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;34 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;35 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; +x
&lt;span class=&quot;lineno&quot;&gt;36 &lt;/span&gt;sudo apt-get -qq update
&lt;span class=&quot;lineno&quot;&gt;37 &lt;/span&gt;sudo apt-get install &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;38 &lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;$GIT&lt;/span&gt; nginx mysql-server dpkg-dev &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;39 &lt;/span&gt;  php5 php5-mysql php5-gd php5-dev php5-curl php-apc php5-cli php5-json
&lt;span class=&quot;lineno&quot;&gt;40 &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Enable mod_rewrite&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;41 &lt;/span&gt;sudo a2enmod rewrite
&lt;span class=&quot;lineno&quot;&gt;42 &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;HAVEPCNTL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;php -r &lt;span class=&quot;s2&quot;&gt;&amp;quot;echo extension_loaded(&amp;#39;pcntl&amp;#39;);&amp;quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;43 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$HAVEPCNTL&lt;/span&gt; !&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;1&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;44 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;45 &lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Installing pcntl...&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;46 &lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;47 &lt;/span&gt;  apt-get &lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; php5
&lt;span class=&quot;lineno&quot;&gt;48 &lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;PHP5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;ls -1F &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; grep &lt;span class=&quot;s1&quot;&gt;&amp;#39;^php5-.*/$&amp;#39;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;49 &lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$PHP5&lt;/span&gt;/ext/pcntl &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; phpize &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./configure &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sudo make install&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;50 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;51 &lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;pcntl already installed&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;52 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;53 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; ! -e libphutil &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;54 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;55 &lt;/span&gt;  git clone https://github.com/phacility/libphutil.git
&lt;span class=&quot;lineno&quot;&gt;56 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;57 &lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; libphutil &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git pull --rebase&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;58 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;59 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; ! -e arcanist &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;60 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;61 &lt;/span&gt;  git clone https://github.com/phacility/arcanist.git
&lt;span class=&quot;lineno&quot;&gt;62 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;63 &lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; arcanist &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git pull --rebase&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;64 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;65 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; ! -e phabricator &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;66 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;67 &lt;/span&gt;  git clone https://github.com/phacility/phabricator.git
&lt;span class=&quot;lineno&quot;&gt;68 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;69 &lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; phabricator &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git pull --rebase&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;70 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;71 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;72 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;73 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Install probably worked mostly correctly. Continue with the &amp;#39;Configuration Guide&amp;#39;:&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;74 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;75 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;    https://secure.phabricator.com/book/phabricator/article/configuration_guide/&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;76 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;77 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;You can delete any php5-* stuff that&amp;#39;s left over in this directory if you want.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;关于安装和配置，官方文档中有所提及（官方介绍的是 LAMP），请参考&lt;/p&gt;

&lt;p&gt;https://secure.phabricator.com/book/phabricator/article/installation_guide/
0x41 LNMP环境的安装&lt;/p&gt;

&lt;p&gt;安装Linux
关于Linux的安装，这里就不说了。&lt;/p&gt;

&lt;p&gt;安装Nginx&lt;/p&gt;

&lt;p&gt;sudo apt-get install nginx
安装完成后，Nginx 的配置文件存放在 /etc/nginx 目录下。使用下面的命令可以启动Nginx&lt;/p&gt;

&lt;p&gt;sudo service nginx start
在安装完并启动后，可以使用浏览器访问 http://127.0.0.1 试试是否可以跳转到Nginx欢迎页面&lt;/p&gt;

&lt;p&gt;安装MySQL&lt;/p&gt;

&lt;p&gt;sudo apt-get install mysql-server
在安装过程中，会两次提示输入 root 用户密码。
在安装完成后，打开终端，使用以下命令登录MySQL&lt;/p&gt;

&lt;p&gt;mysql -u root -p
安装PHP
Phabricator需要 PHP 5.2 或者更高版本，但是 不支持 PHP 7 。
可以使用以下命令安装PHP&lt;/p&gt;

&lt;p&gt;sudo apt-get install -y php5 php5-fpm php5-mysql
安装完成后，可使用以下命令查看是否安装成功&lt;/p&gt;

&lt;p&gt;php -v
安装成功后，输出类似以下信息&lt;/p&gt;

&lt;p&gt;安装其它
如果你使用 git 来管理代码库的话，你还需要安装 git&lt;/p&gt;

&lt;p&gt;sudo apt-get install git
一些必要的PHP扩展&lt;/p&gt;

&lt;p&gt;mbstring, iconv, mysql (or mysqli), curl, pcntl（这些扩展一般会以 “php-mysql” 或 “php5-mysql” 方式使用）
一些可选的PHP扩展&lt;/p&gt;

&lt;p&gt;gd, apc（官方文档中有详细的介绍和安装说明）, xhprof（如果你想自己开发Phabricator的话，你需要安装这个，官方文档中有详细的介绍说明）
0x42 Phabricator源码下载及运行&lt;/p&gt;

&lt;p&gt;在成功安装LNMP环境后，需要下载Phabricator的源码并配置让它跑起来。&lt;/p&gt;

&lt;p&gt;源码下载
在你想要存放Phabricator源码的位置（假设为 ./path_to_pha），执行这些命令&lt;/p&gt;

&lt;p&gt;git clone https://github.com/phacility/libphutil.git
git clone https://github.com/phacility/arcanist.git
git clone https://github.com/phacility/phabricator.git
或者，你也可以直接点击上面的链接去GitHub下载压缩包，下载完成后解压。&lt;/p&gt;

&lt;p&gt;Nginx配置
在下载完成后，我们需要配置Nginx，让Phabricator跑起来。假设你想为Phabricator分配这个域名：http://pha.example.com
在 /etc/nginx/conf.d 目录下创建文件 pha.example.com.conf，存放Phabricator代理配置信息，以下为我的文件内容（注意把 你存放Phabricator的路径 改为你的实际路径）&lt;/p&gt;

&lt;p&gt;server {
    listen       80;
    server_name  pha.example.com; 
    location / {
        index index.php;
        rewrite ^/(.*)$ /index.php?&lt;strong&gt;path&lt;/strong&gt;=/$1 last;
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#error_page  404              /404.html;

# redirect server error pages to the static page /50x.html
#
error_page   500 502 503 504  /50x.html;
location = /50x.html {
    root   /usr/share/nginx/html;
}

 # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
#
location ~ \.php$ {
    root           /你存放Phabricator的路径/phabricator/webroot;
    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;
    fastcgi_param  SCRIPT_FILENAME  /你存放Phabricator的路径/phabricator/webroot$fastcgi_script_name;
    include        fastcgi_params;
} } 配置完成后，重启Nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sudo service nginx restart
然后在你的 hosts 文件中，加入 pha.example.com 对应的IP&lt;/p&gt;

&lt;p&gt;127.0.0.1 pha.example.com
打开浏览器，访问 http://pha.example.com，会跳转到Phabricator用户注册界面，在这个界面注册的第一个用户，将会成为管理员用户。&lt;/p&gt;

&lt;p&gt;0x50 配置&lt;/p&gt;

&lt;p&gt;0x51 解决基本的配置问题&lt;/p&gt;

&lt;p&gt;使用管理员账号登录，左上角会出现黄色感叹号图标，提示有一些配置问题未解决&lt;/p&gt;

&lt;p&gt;这些问题基本都是关于一些参数的设置。点击每一个问题，显示的界面中会有很详细的关于这个问题的描述，和如何解决。&lt;/p&gt;

&lt;p&gt;0x52 设置用户登录认证方式&lt;/p&gt;

&lt;p&gt;使用管理员账号登录，在左侧的菜单中选择 Auth ，然后点击右上侧 Add Provider，在列表中选则你需要的认证方式。&lt;/p&gt;

&lt;p&gt;我选择是 Username/Password 的方式，即用户自己注册Phabricator账号。为了保障安全，我设置了只允许公司邮箱地址注册：Config —&amp;gt; Core Settings —&amp;gt; Authentication —&amp;gt; auth.email-domains。你还可以选择 auth.require-approval ，即新注册用户需要管理员批准。&lt;/p&gt;

&lt;p&gt;0x53 设置邮件发送服务参数&lt;/p&gt;

&lt;p&gt;首先，配置 mail-adapter （邮件发送方式）：Config —&amp;gt; Core Settings —&amp;gt; Mail —&amp;gt; metamta.mail-adapter，我选择的是 PhabricatorMailImplementationPHPMailerAdapter ，通过SMTP的方式发送邮件。在选择完之后，需要设置SMTP服务器地址、账号和密码：Config —&amp;gt; Core Settings —&amp;gt; PHPMailer —&amp;gt; metamta.mail-adapter，根据你自己邮箱的配置，相应的设置 phpmailer.smtp-host、phpmailer.smtp-port、phpmailer.smtp-protocol、phpmailer.smtp-user、phpmailer.smtp-password、phpmailer.smtp-encoding 。&lt;/p&gt;

&lt;p&gt;0x54 配置代码仓库访问方式：SSH/HTTP&lt;/p&gt;

&lt;p&gt;SSH
(如果你不打算允许使用SSH的方式访问代码仓库的话，请忽略这部分)
1）配置用户账号
Phabricator需要三个用户账号（三种用户身份）：两个用于基本运行，一个用于配置SSH访问。这些账号是指Phabricator所运行服务器系统的账号，不是Phabricator用户账号。
三个账号分别是：
www-user：Phabricator Web服务器运行身份。
daemon-user ：daemons （守护进程）运行身份。这个账号是唯一直接与代码仓库交互的账号，其它账号需要切换到这个账号身份（sudo）才能操作代码仓库。
vcs-user：我们需要以这个账号SSH连接Phabricator。
如果你的服务器系统中现在没有这三个账号，需要创建：
www-user：大部分情况下，这个账号已经存在了，我们不需要理这个账号。
daemon-user ：一般情况下，我们直接使用 root 账号，因为会需要很多权限（当然这可能不安全）。
vcs-user：可以使用系统中现有的一个用户账号，直接创建一个就叫 vcsuser。当用户克隆仓库的时候，需要使用类似 vcsuser@pha.example.com 的URI。
2）配置Phabricator
首先，设置 phd.user 为 daemon-user（root）&lt;/p&gt;

&lt;p&gt;./path_to_pha/bin/config set phd.user root
重启 daemons 以确认这个配置工作正常&lt;/p&gt;

&lt;p&gt;./path_to_pha/bin/phd restart
然后，配置SSH用户账号vcs-user（vcsuser 或其它你想用的用户）&lt;/p&gt;

&lt;p&gt;./path_to_pha/bin/config set diffusion.ssh-user vcsuser
3）配置 Sudo
www-user 和 vcs-user 需要能够使用 sudo 切换到 daemon-user 用户身份才能与仓库交互，所以我们需要配置更改系统的 sudo 配置。
直接编辑 /etc/sudoers 或者在 /etc/sudoers.d 下创建一个新文件，然后把这些内容写到文件内容中&lt;/p&gt;

&lt;p&gt;www-user ALL=(root) SETENV: NOPASSWD: /usr/lib/git-core/git, /usr/bin/git, /var/lib/git, /usr/lib/git-core/git-http-backend, /usr/bin/ssh, /etc/ssh, /etc/default/ssh, /etc/init.d/ssh
vcs-user ALL=(root) SETENV: NOPASSWD: /bin/sh, /usr/bin/git-upload-pack, /usr/bin/git-receive-pack
当然，别忘了把 www-user 和 vcs-user 替换为你实际对应的用户。
接下来，看看你文件中是不是有这行&lt;/p&gt;

&lt;p&gt;Defaults requiretty
如果有的话，请用 # 注释掉。&lt;/p&gt;

&lt;p&gt;4）其它SSH配置
我们还需要查看这两个文件 /etc/shadow 和 /etc/passwd 中 vcs-user 对应的配置是否正确。
打开 /etc/shadow 文件，找到 vcs-user 对应的那行，看一下第二个字段（密码），是不是 !! ，如果是，请改为 空值（什么都不写） 或者 NP 。
打开 /etc/passwd 文件，找到 vcs-user 对应的那行，如果有类似于这样的配置 /bin/false ，请修改为 /bin/sh，否则 sshd 无法执行命令。&lt;/p&gt;

&lt;p&gt;5）配置SSHD端口
注意：Phabricator运行的服务器系统中 sshd 的版本 必须高于 6.2。
假设我们把Phabricator使用的sshd端口设置为 22，这样做的好处是我们不需要在仓库的URI中加入端口号，类似ssh://vcs-user@pha.example.com/xxx/xxx/xxx.git。当然，如果这样做需要我们更改系统已存在的sshd配置改为其它端口。下面来看一下配置的三个步骤：
i）创建脚本 phabricator-ssh-hook.sh，并且把这个脚本放到类似 /usr/libexec/phabricator-ssh-hook.sh 的目录中（我直接放在 /etc/ssh/ 中，后面会要求变更这个脚本和它的父文件夹所有者，所以这个脚本和它的父文件夹所在的文件夹的所有者不正确的话可能会导致这个脚本执行失败），脚本内容如下&lt;/p&gt;

&lt;p&gt;#!/bin/sh&lt;/p&gt;

&lt;h1 id=&quot;note-replace-this-with-the-username-that-you-expect-users-to-connect-with&quot;&gt;NOTE: Replace this with the username that you expect users to connect with.&lt;/h1&gt;
&lt;p&gt;VCSUSER=”vcs-user”&lt;/p&gt;

&lt;h1 id=&quot;note-replace-this-with-the-path-to-your-phabricator-directory&quot;&gt;NOTE: Replace this with the path to your Phabricator directory.&lt;/h1&gt;
&lt;p&gt;ROOT=”/path_to_pha”&lt;/p&gt;

&lt;p&gt;if [ “$1” != “$VCSUSER” ];
then
  exit 1
fi&lt;/p&gt;

&lt;p&gt;exec “$ROOT/bin/ssh-auth” $@
注意把 VCSUSER 替换为你实际的用户，把 ROOT 值替换为你Phabricator源码路径。
创建完脚本后，需要把脚本和它的父文件夹所有者改为 root，并且赋予脚本 755 权限：&lt;/p&gt;

&lt;p&gt;sudo chown root /path/to/somewhere/
sudo chown root /path/to/somewhere/phabricator-ssh-hook.sh
sudo chmod 755 /path/to/somewhere/phabricator-ssh-hook.sh
如果你不这么做，sshd 会拒绝执行 hook。&lt;/p&gt;

&lt;p&gt;ii）为Phabricator创建 sshd_config
在 /etc/ssh 中创建文件名类似 sshd_config.phabricator 的文件，文件内容如下：&lt;/p&gt;

&lt;h1 id=&quot;note-you-must-have-opensshd-62-or-newer-support-for-authorizedkeyscommand&quot;&gt;NOTE: You must have OpenSSHD 6.2 or newer; support for AuthorizedKeysCommand&lt;/h1&gt;
&lt;h1 id=&quot;was-added-in-this-version&quot;&gt;was added in this version.&lt;/h1&gt;

&lt;h1 id=&quot;note-edit-these-to-the-correct-values-for-your-setup&quot;&gt;NOTE: Edit these to the correct values for your setup.&lt;/h1&gt;

&lt;p&gt;AuthorizedKeysCommand /你的脚本路径/phabricator-ssh-hook.sh
AuthorizedKeysCommandUser vcs-user
AllowUsers vcs-user&lt;/p&gt;

&lt;h1 id=&quot;you-may-need-to-tweak-these-options-but-mostly-they-just-turn-off-everything&quot;&gt;You may need to tweak these options, but mostly they just turn off everything&lt;/h1&gt;
&lt;h1 id=&quot;dangerous&quot;&gt;dangerous.&lt;/h1&gt;

&lt;p&gt;Port 你配置的端口号
Protocol 2
PermitRootLogin no
AllowAgentForwarding no
AllowTcpForwarding no
PrintMotd no
PrintLastLog no
PasswordAuthentication no
AuthorizedKeysFile none&lt;/p&gt;

&lt;p&gt;PidFile /var/run/sshd-phabricator.pid
注意把 AuthorizedKeysCommand 值替换为你在上一步中脚本实际路径，把 AuthorizedKeysCommandUser 和 AllowUsers 替换为你实际的用户，把 Port 替换为你想配置的端口号。如果你的 Port 值为 22，在你进行下面的操作之前，请查看当前系统中 22 端口是已否占用&lt;/p&gt;

&lt;p&gt;sudo netstat -atlunp | grep ssh
如果已经被占用，请修改使用 22 端口的 sshd 配置，一般它们会在 /etc/ssh 下，名称类似 sshd_config，修改完成后，请重启 ssh 服务&lt;/p&gt;

&lt;p&gt;sudo /etc/init.d/ssh restart
在完成上面的步骤后，我们来启动Phabricator的 ssh 服务&lt;/p&gt;

&lt;p&gt;sudo /path/to/sshd -f /你的Phabricator sshd配置路径/sshd_config.phabricator
一般情况下，sshd 路径为 /usr/sbin。
在启动后，我们需要验证以下配置是否有效：
首先，请把你的公钥添加到Phabricator自己的账号中（你可以自己注册一个新的账号），注册完成后登录，然后 点击你的头像 —&amp;gt; 左侧菜单面板 Manage —&amp;gt; 右侧菜单面板 Edit Settings —&amp;gt; 左侧菜单面板 SSH Public Keys —&amp;gt; 右上角 SSH Key Actions —&amp;gt; Upload Public Key&lt;/p&gt;

&lt;p&gt;上传公钥后，执行下面的命令&lt;/p&gt;

&lt;p&gt;echo {} | ssh vcs-user@phabricator.yourcompany.com conduit conduit.ping
如果出现类似下面的结果，说明配置有效&lt;/p&gt;

&lt;p&gt;{“result”:”phabricator.yourcompany.com”,”error_code”:null,”error_info”:null}
如果没有出现别的情况，请参考官方文档 Troubleshooting SSH 部分，官方文档地址如下&lt;/p&gt;

&lt;p&gt;https://secure.phabricator.com/book/phabricator/article/diffusion_hosting/
接下来，看一下如何配置 HTTP&lt;/p&gt;

&lt;p&gt;HTTP
首先，请确认Phabricator的配置项 diffusion.allow-http-auth 设置为 true。可以在 左侧菜单面板 All Setttings 中查找 diffusion.allow-http-auth ，点击之后可设置，请设置为 Allow HTTP Basic Auth。
然后，所有用户需要使用 HTTP 访问仓库之前，需要设置自己的密码：点击你的头像 —&amp;gt; 左侧菜单面板 Manage —&amp;gt; 右侧菜单面板 Edit Settings —&amp;gt; 左侧菜单面板 VCS Password&lt;/p&gt;

&lt;p&gt;强烈建议不要把这个密码设置为你的Phabricator登录密码，因为 vcs 密码很容易泄露。
一般来说，不需要其它配置就可以使用 HTTP 了，如果有问题，请参考官方文档 Troubleshooting HTTP 部分&lt;/p&gt;

&lt;p&gt;https://secure.phabricator.com/book/phabricator/article/diffusion_hosting/
配置完仓库访问方式后，我们来看一下如何使用 Phabricator 进行 Code Review。&lt;/p&gt;

&lt;p&gt;0x60 使用Phabricator进行Code Review&lt;/p&gt;

&lt;p&gt;在进行 Code Review 实践前，先说一些理论方面的东西（开头和 0x61 ，不喜欢可绕过）
Code Review，有时候就像打架一样：我提交了变更，你说不行，要修改；我又提交了一次，你说还是不行，还要改。我不知道你究竟要怎样，你也不知道我感觉受到了打击有多不爽。所以，大家需要对Code Review这件事抱有开放的态度：&lt;/p&gt;

&lt;p&gt;为什么我的代码需要其他人审查？
因为我不是神，我会制造Bug，我会当局者迷。
为什么我要审查其他人的代码？
因为我要对我们的团队负责，我要保证我们产品的质量，我可能会看到他人代码的Bug，在这些Bug显示出它们的”威力”前，把它们弄死。
Code Review这件事，旨在创造一个共进的团队氛围（交流和技术等），在产品交付给用户（包括我们的测试人员）前，保证产品的质量。&lt;/p&gt;

&lt;p&gt;在了解如何使用Phabricator进行Code Review前，我们先了解一下Phabricator Code Review的流程，对其有一个整体上的了解。&lt;/p&gt;

&lt;p&gt;0x61 Phabricator Code Review工作流&lt;/p&gt;

&lt;p&gt;Phabricator提供两种Code Review的方式：pre-push，post-push
pre-push 是指审查发生在变更发布前；post-push 是指审查发生在变更已经被发布或者正在发布。
这里我们认为 pre-push 的方式更适合，所以接下来说一下 pre-push 的工作流：&lt;/p&gt;

&lt;p&gt;Write, Review, Merge, Publish
从这篇文章，我了解到了这个流程&lt;/p&gt;

&lt;p&gt;https://secure.phabricator.com/phame/post/view/766/write_review_merge_publish_phabricator_review_workflow/
如果你之前用过其它的Code Review工具，可能会对这样的流程感到不习惯。在其它工具中，变更（代码，资源文件或其它）会经历这样一个流程： Write, Publish, Review, Merge。首先，你做出一些变更（Write），然后把他们推送到远程仓库（Publish）等待审查者审查。一旦这些代码被审查（Review）并通过，变更会合并（Merge）到一个指定的功能分支。在这个流程中，被合并的变更恰好是被推送的变更（这句话有点模模糊糊，不痛不痒，接下来我们看一下Phabricator的流程，也许会清晰很多）。
接下来，我们看一下Phabricator略有不同的工作流：Write, Review, Merge, Publish。像上面一样，开始的时候，你做出一些变更。但是，接下来的流程就不一样了。
Phabricator认为在开发过程中审查（Review）是一个重要的步骤，对于那些没有审查过的变更，是不可以发布的。
理论上来说，没有审查过的变更不算数：这些变更可能只是临时的，易变的。可能方法上不对，可能缺少来龙去脉，可能根本就是解决错误的问题，等等。审查的参考基础是建立在开发人员和审查人员拥有一个共同认可的变更处理方式，并且这种处理方式是开发过程所有参与人员（项目管理、产品、开发）都期望的，而不仅仅是仅仅做到最终的产品看起来没问题。直到变更经过了这样的审查，我们才能得到稳固的版本。
这样的工作流跟其它工具的审查流程没有实质上的技术区别，但是存在明显的社交活动上的不同：由于变更必须经过审查才能被合并、发布，变更作者需要根据反馈对变更进行调整。另外，审查者根据粗略的草图（所有开发参与人员共同认可的变更方式）进行反馈，而不是简单的批判一件已经完成的变更工作。
Phabricator和其它工具的工作流都有着同样的目的：未审查的代码都只是临时的变更，没有长久或者明显的价值，直到通过审查。
Phabricator工作流的第二步是审查（Review）,审查的对象是还没有发布的变更。没有发布的变更被发送到Phabricator等待被审查（通常我们使用 arc diff命令发送审查请求），然后审查者做出反馈。变更作者根据反馈进行修改，在修改过程中，作者不必担心版本、解决方式这些事情。作者可以自由的复位、使用、移除或者舍弃老的变更。在从变更提交审核到审核者反馈，以及作者再次修改整个过程中，没有那种审核者把作者推入一个必须接受或者只能做少量改变的默认发布状态。
一旦通过审核，变更会被合并（Merge）和发布（Publish）（通常，这两个步骤由一个命令完成 arc land）。
这里，Phabricator也与那些先 Publish 的工具不同：默认情况下，Phabricator会舍弃到达最后变更前的所做的中间过程，把最后变更的整个过程压缩成一次提交。总体来说，这意味着舍弃checkpoint commits, rebases, squash-merges, 并且把整个变更过程做为一次 fast-forward commit 提交到目标分支。
Phabricator在一定程度上能做到这些，是因为：什么都没有被发布，所以这种工作流可以以任何想要的方式发布变更。
有了这些，我们可以以我们想要的版本自由的rebase，fast-commit，这些是Phabricator默认的行为。&lt;/p&gt;

&lt;p&gt;0x62 进行Code Review所用工具&lt;/p&gt;

&lt;p&gt;做为一般用户，常用的工具有两个 Differential 和 Arcanist 。&lt;/p&gt;

&lt;p&gt;Differential-审查代码的工作台&lt;/p&gt;

&lt;p&gt;我们在这里查看变更审查情况，对变更进行审查或评论等操作。
这是某次变更界面操作部分截图&lt;/p&gt;

&lt;p&gt;做为 审查人，可进行的操作有：
Comment：说点什么。可以针对某行代码进行评论，直接点击行号即可
Accept Revision：接受变更，这哥们代码写得不错，不需要改
Request Changes：不行，还要改
Resign as Reviewer：重新指定审查代码的人
Commandeer Revision：字面意思是将这个Revision据为己有的意思，实际上这个时候Reviewer的身份已经变为Owner的身份了，不能再进行Review了，但是Comment还是可以的
Add Reviewer：添加审查人
Add Subscribers：添加订阅者，CC&lt;/p&gt;

&lt;p&gt;做为 作者，可进行的操作有：
Comment：说点什么。可以针对某行代码进行评论，直接点击行号即可
Abandon Revision：废除版本。废除后，这个版本就不需要再审核了
Plan Changes：计划变更，我自己发现了一些问题或者需求有变，正在改
Add Reviewer：添加其它审查人（除当前审查人外）
Add Subscribers：添加订阅者，CC&lt;/p&gt;

&lt;p&gt;Arcanist - 命令交互
我们用这个工具提交变更和审查请求，对变更做出更改，或者在通过审查后发布到远程仓库分支中。
常用的命令有：
arc diff：发送变更详情和审查请求
arc land：推送变更（Git and Mercurial），当通过审查后使用这个命令
arc list：显示变更处理的情况
arc cover：查找最有可能审查变更的人
arc patch：给版本打补丁
arc export：从Differential下载补丁
arc amend：更新Git commit
arc commit：提交变更（SVN）
arc branch：查看Git branches更加详细的信息&lt;/p&gt;

&lt;p&gt;在配置了 lint 和 unit test intergration后，可以用这些命令：
arc lint：静态代码检查
arc unit：单元测试&lt;/p&gt;

&lt;p&gt;与其它工具交互：
arc upload：上传文件
arc download：下载文件
arc paste：创建和查看剪贴&lt;/p&gt;

&lt;p&gt;还有一些高级功能：
arc call-conduit：执行 Conduit 方法
arc liberate：创建或更新 libphutil 库
arc shell-complete：激活 tab 补全&lt;/p&gt;

&lt;p&gt;0x63 配置进行Code Review&lt;/p&gt;

&lt;p&gt;一些基本的配置和安装 —&amp;gt; 写代码 —&amp;gt; 提交审查请求(arc diff) —&amp;gt; 审查（Differential） —&amp;gt; （审查通过后）合并提交（arc land）
一些基本的配置和安装
包括：
配置代码仓库（Diffusion）
把你本地的Git远程URL设置为Phabricator上代码仓库地址
安装Arcanist
配置Project信息&lt;/p&gt;

&lt;p&gt;配置代码仓库（Diffusion）
在开始进行代码审查后，我们的代码是由Phabricator直接托管的，所以我们需要配置代码仓库。
使用管理员账号登录Phabricator，点击左侧面板菜单 Diffusion ，然后点击右上侧 Create Repository ，选择你所使用的 Repository 类型，填写 Name 等信息，在创建完成后即可使用。如果没有什么特殊的需求，不需要进行特别的配置，这里列举两种你可能遇到的打算开始使用 Phabricator 时的场景：&lt;/p&gt;

&lt;p&gt;1、代码之前由 GitHub 或其它托管，现在我需要把之前的代码导入
点击 Manage Repository ，点击左侧 URIs，点击 Add New URI，填写GitHub或其它托管系统对应仓库的 URI ， I/O Type 选择 Observe，点击 Create Repository URI 添加新的 URI 。&lt;/p&gt;

&lt;p&gt;在添加完新的 URI 后，你还需要点击 Set Credential 设置访问新的 URI 的认证方式。
如果你打算此时就开始使用 Phabricator ，请务必通知你的团队，暂停一下，不要再向GitHub等提交代码。如果你的 GitHub 等也设置了代码审查，请督促相关人员完成代码审查流程。 
稍等片刻，待 Phabricator 同步完之前的代码后，编辑你添加的 GitHub 或其它代码托管系统的 URI ，务必修改 I/O Type：
1）如果你不再需要使用之前的托管系统，选择 No I/O
2）如果你想继续把代码备份到之前的代码托管系统，选择 Mirror，这时， Phabricator 代码仓库的变更会覆盖推送到之前的代码托管系统
如果你不修改 I/O Type，向 Phabricator 代码仓库提交代码会失败，因为是只读的。
当然，对于导入之前的代码，还有别的方式，例如直接把本地的代码再次向 Phabricator 代码仓库再提交一次。&lt;/p&gt;

&lt;p&gt;2、开始一个新的项目，创建一个新的仓库
参考第1种场景，在 Phabricator 创建代码仓库。如果你希望把代码备份到其它的托管系统，只需要添加对应的 URI，并且把 I/O Type 选为 Mirror。&lt;/p&gt;

&lt;p&gt;把你本地的Git远程URL设置为Phabricator上代码仓库地址&lt;/p&gt;

&lt;p&gt;git remote set-url 远程名称 新的url
安装Arcanist&lt;/p&gt;

&lt;p&gt;https://secure.phabricator.com/book/phabricator/article/arcanist_quick_start/
配置Project信息
在你项目代码的根目录下，创建 .arcconfig 文件，内容如下：&lt;/p&gt;

&lt;p&gt;{
“phabricator.uri” : “你Phabricator系统访问URL”
}
Windows系统下，创建类似这种文件名的文件可能很麻烦，可以使用这条命令创建：&lt;/p&gt;

&lt;p&gt;arc set-config phabricator.uri “你Phabricator系统访问URL”
Windows系统下，还需要配置 Editor ，详情参考：&lt;/p&gt;

&lt;p&gt;https://secure.phabricator.com/book/phabricator/article/arcanist_windows/
Arcanist 使用可参考：&lt;/p&gt;

&lt;p&gt;https://secure.phabricator.com/book/phabricator/article/arcanist_quick_start/
https://secure.phabricator.com/book/phabricator/article/arcanist/
在进行完基本的配置和安装后，可以开始 Code Review 了。&lt;/p&gt;

&lt;p&gt;写代码
当然，不只是代码可以被审查，图标等资源文件的变更也可以被审查。&lt;/p&gt;

&lt;p&gt;提交审查请求（arc diff）
一般情况下，我们直接使用 arc diff 即可，默认情况下，Arcanist 会把本地分支的 HEAD 与远程对应分支的 HEAD 进行对比，并生成差异对比发送到 Phabricator。当你所做的修改没有 commit 时，会提示你进行 commit。
在一些情况下，我们并不希望与本地分支的 HEAD 进行比较，假设想要与上次的 commit 比较，上次 commit id 是 8ffc88dc05d31fffd28e3ff1129d1b8c321dffff，那么我们需要在 arc diff 后把这个 id 加上：arc diff 8ffc88dc05d31fffd28e3ff1129d1b8c321dffff。
执行这条命令时我们需要按照模板填写title（必填），summary（必填），Test Plan（必填，没有可写 N/A 之类的标识），Reviewers（必填，且必须为真实有效的用户名），Subscribers（可选），填写完成后关闭编辑器，Arcanist会自动提交审查请求。&lt;/p&gt;

&lt;p&gt;审查（Differential）
做为 审查人，需要在 Differential 工作台完成代码审查工作，上面已经介绍了 Differential，这里就不再多说了。&lt;/p&gt;

&lt;p&gt;（审查通过后）合并提交（arc land）
做为 作者，在代码审查通过后，需要使用 arc land 把变更发布到远程分支。
注意，在首次执行这条命令前（不一定非要到这个步骤，可以是这个步骤前的任意时刻，例如开始写代码前），建议请使用 git branch -u 远程名称/远程分支名称 把本地的分支与远程分支相关联，否则，在执行完 arc land 后，本地分支会被删除。如果你不想这样做，又需要保留现在分支的话，请使用 arc land –keep-branch。
默认情况下，Arcanist 会把变更推送到与本地分支相关联的远程分支，你可以使用 –remote 和 –onto 参数推送到你想要的远程和远程分支。
关于 arc land 的详细说明，可使用 arc land –help 查看。&lt;/p&gt;

&lt;p&gt;0x70 与GitHub集成&lt;/p&gt;

&lt;p&gt;这里的“集成”其实说的很心虚，因为在使用 Phabricator 后，GitHub 已经变为一个文件存储服务器了。常见的使用情况已经在 0x63 配置进行Code Review 的 配置代码仓库（Diffusion） 中写出，所以你懂的。&lt;/p&gt;

&lt;p&gt;0x80 与Jenkins集成&lt;/p&gt;

&lt;p&gt;在很久很久以前，我已经搭建了 Jenkins 用于自动构建，所以这次把 Phabricator 与 Jenkins 做了集成。
在 Jenkins 中安装完插件： Phabricator Differential Plugin 后，请参考这篇文章：&lt;/p&gt;

&lt;p&gt;https://github.com/uber/phabricator-jenkins-plugin#phabricator-jenkins-plugin–
0x90 结束语&lt;/p&gt;

&lt;p&gt;从配置完到开始试用已经有一个月左右，期间遇到了各种问题。经历了这些问题的洗礼，算是对 Phabricator 使用入门了吧。
这篇文章时隔多日才完成，尽管我想把每个细节写的详尽，但是记忆总是像被虫蛀过的木头，难免有些疏漏。加之文笔水平有限，各位就凑合着看吧。
在安装和使用过程中遇到的问题，欢迎各位评论交流。&lt;/p&gt;

&lt;p&gt;0xA0 Q/A&lt;/p&gt;

&lt;p&gt;1、如何强制用户 Code Review？
再次强调一下前提：在开始 Code Review 流程前，请先确认团队成员的git remote url已经切换为Phabricator上对应仓库地址。
强制用户Code Review，需要创建Herald Rule。在创建时，New Rule for 选：Commit Hook: Commit Content.；Rule Type选：Global，或者根据自己需要选择；Conditions中是组合条件，可以根据自己需要指定一些条件；Action 指定当前情况符合你指定的条件组合时执行的动作。示例如图：&lt;/p&gt;

&lt;p&gt;示例中定义了以下规则：在向develop分支提交代码时，所提交的代码必须是通过 Code Review 流程审查通过的，否则会被拒绝；除非 Commit Message 中包含字符 @bypass-review 。
指定 Commit Message 中包含字符 @bypass-review 这种例外情况，主要考虑到在紧急修复一些问题，没时间等待审查时使用。
当提交被拒绝时，如图：&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Oct 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2017/10/24/Phabricator.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2017/10/24/Phabricator.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>cut</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;数据处理常用命令：
$ cat 3.txt | cut -d ‘ ‘ -f 1  | sed -e ‘s/^/&quot;/’ | sed -e ‘s/$/&quot;,/’&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Oct 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/spark/2017/10/23/cut.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/spark/2017/10/23/cut.html</guid>
        
        
        <category>spark</category>
        
      </item>
    
      <item>
        <title>akka_sbt_eclipse</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;akka项目编译上有两种方法：
第一、 用sbt ，这个是akka 官方推荐的方法，可以用sbt生成Eclipsse项目，然后导入到Eclipse里面，可以运行。 但是我的编译还是通过sbt 命令行的方式来做的。 如果大家有好的方法，请指正。 
sbt的安装方法参考：http://www.scala-sbt.org/download.html
how to write a scala file , build and run  with sbt.
http://www.scala-sbt.org/0.13/tutorial/Hello.html
akka：http://akka.io/
scala for eclipse IDE bundle ： http://scala-ide.org/  （也推荐这个集成开发工具，内含编译所需要的akka actor 和 scala library）&lt;/p&gt;

&lt;p&gt;第二、是用maven， 这是akka essentials 这本书所采用的。 我亲自实验过，可以编译akka 2.0.5， 2.1.2的旧有项目。 而且这本书的大多数例子，我都验证过。 所以，如果是想从头到尾、编译调试程序，不妨试试maven 的elipse 插件。
安装mvn  http://maven.apache.org/download.cgi 然后在readme安装步骤做。
Akka-Essentials 源代码 https://github.com/write2munish/Akka-Essentials
参考： 
Maven实战（三）Eclipse构建Maven项目
http://tangyanbo.iteye.com/blog/1503782&lt;/p&gt;

&lt;p&gt;1,Eclipse安装Scala的开发插件&lt;/p&gt;

&lt;p&gt;2,安装sbt 
  Mac 系统安装很简单：$ brew install sbt
  更多可参考：http://www.scala-sbt.org/0.13/docs/zh-cn/Setup.html
3,创建 akka 项目，并导入Eclipse
 通过sbt创建akka 项目。
   $ mkdir hw
   $ vim build.sbt
   录入(更多详细参考：http://www.scala-sbt.org/1.x/docs/zh-cn/index.html）：
name:=”hw”   –项目名
version:= “1.0” –项目版本
scalaVersion:= “2.11.8”  –scala 版本，注意与Eclipse里的Scala版本一致
lazyval akkaVersion = “2.5.4” –akka 的版本
libraryDependencies++= Seq(
  “com.typesafe.akka” %%”akka-actor” % akkaVersion
   )
创建测试例子
$ mkdir -p  scr/main/scala
$ vim src/main/scala/hw.scala
录入并保存：
import akka.actor.Actor
import akka.actor.ActorSystem
import akka.actor.Props&lt;/p&gt;

&lt;p&gt;class hw9actor extends Actor
{
  def receive={
    case “hello” =&amp;gt; println(“hello akka”)
    case _=&amp;gt;println(“hi”)
  }
}
object hw9 extends App {
  val sy=ActorSystem(“hw9”)
  val helloActor=sy.actorOf(Props[hw9actor], “hello”)
  helloActor ! “hello”
  helloActor ! “ww”&lt;/p&gt;

&lt;p&gt;}
执行、编译、更新
$ sbt        –第一次执行时，会下载相关jar库引用。会保存在当前用户的目录下.sbt .ivy /cache中
$ run       –执行，会搜索src所有可执行的文件，如果有多个会，提供选择执行的列表。如当前只会执行，hw9.scala文件。
$ compile  –如果有修改，重新编译，会使用，$ ~compile 当文件有修改时，自动编译
$ reload   –如果配置文件有修改时，重新加载。
将项目导入Eclipse
进入项目要目录，创建project/plugins.sbt
$ mkdir project
$ vim project/plugins.sbt
录入保存：
addSbtPlugin(“com.typesafe.sbteclipse”% “sbteclipse-plugin” % “5.1.0”)
$ sbt 
$&amp;gt; reload.   – 重新加载
$&amp;gt; eclipse.  —将下载相关引用库
进入Eclipse工具，导入该项目：file -&amp;gt; Import -&amp;gt; Gerneral -&amp;gt; existing projects into workspace&lt;/p&gt;

&lt;p&gt;注意：sbt 里引用的scala的版本与Eclipse里scala的版本一致。不然会报版本错误。
参考：https://github.com/typesafehub/sbteclipse&lt;/p&gt;

&lt;p&gt;版本不正确，参考：
https://github.com/typesafehub/sbteclipse
设置com.typesafe.sbteclipse&lt;/p&gt;

&lt;p&gt;sbt参考文档：
http://www.scala-sbt.org/0.13/docs/zh-cn/Hello.html&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Oct 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/spark/2017/10/18/akka_sbt_eclipse.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/spark/2017/10/18/akka_sbt_eclipse.html</guid>
        
        
        <category>spark</category>
        
      </item>
    
      <item>
        <title>FunSuite</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;参考wiki:http://www.scalatest.org/getting_started_with_fun_suite&lt;/p&gt;

&lt;p&gt;http://www.scalatest.org/install&lt;/p&gt;

</description>
        <pubDate>Wed, 18 Oct 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/spark/2017/10/18/FunSuite.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/spark/2017/10/18/FunSuite.html</guid>
        
        
        <category>spark</category>
        
      </item>
    
      <item>
        <title>spark基本概念</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;我们知道Spark总是以集群的方式运行的，Standalone的部署方式是集群方式中最为精简的一种（另外的是Mesos和Yarn）。Standalone模式中，资源调度是自己实现的，是MS架构的集群模式，故存在单点故障问题。
下面提出几个问题并解决：
1、Standalone部署方式下包含哪些节点？&lt;/p&gt;

&lt;p&gt;由不同级别的三个节点组成，分别是Master主控节点、Worker工作节点、客户端节点；
（1）其中Master主控节点，顾名思义，类似于领导者，在整个集群中，最多只有一个Master处于Active状态。在使用spark-shell等交互式运行或者使用官方提供的run-example实例时，Driver运行在Master节点中；若是使用spark-submit工具进行任务的提交或者IDEA等工具开发运行任务时，Driver是运行在本地客户端的。
Master一方面负责各种信息，比如Driver、Worker、Application的注册；另一方面还负责Executor的启动，Worker心跳等诸多信息的处理。
（2）Woker节点，类似于yarn中的NodeManager，在整个集群中，可以有多个Worker（&amp;gt;0）。负责当前WorkerNode上的资源汇报、监督当前节点运行的Executor。并通过心跳机制来保持和Master的存活性连接。Executor受到Worker掌控，一个Worker启动Executor的个数受限于 机器中CPU核数。每个Worker节点存在一个多个CoarseGrainedExecutorBackend进程，每个进程包含一个Executor对象，该对象持有一个线程池，每个线程执行一个Task。
2、基本的概念？&lt;/p&gt;

&lt;p&gt;（1）Application：指的是用户编写的Spark应用程序，包含了含有一个Driver功能的代码和分布在集群中多个节点上运行的Executor代码。
（2）Driver:运行Application的main函数并创建SparkContext，SparkContext的目的是为了准备Spark应用程序的运行环境。SparkContext负责资源的申请、任务分配和监控等。当Executor运行结束后，Driver负责关闭SparkContext；
（3）Job：一个Application可以产生多个Job，其中Job由Spark Action触发产生。每个Job包含多个Task组成的并行计算。
（4）Stage：每个Job会拆分为多个Task，作为一个TaskSet,称为Stage；Stage的划分和调度是由DAGScheduler负责的。Stage分为Result Stage和Shuffle Map Stage；
（5）Task：Application的运行基本单位，Executor上的工作单元。其调度和 管理又TaskScheduler负责。
（6）RDD：Spark基本计算单元，是Spark最核心的东西。表示已被分区、被序列化、不可变的、有容错机制的、能被并行操作的数据集合。
(7) DAGScheduler:根据Job构建基于Stage的DAG，划分Stage依据是RDD之间的依赖关系。
（8）TaskScheduler：将TaskSet提交给Worker运行，每个Worker运行了什么Task于此处分配。同时还负责监控、汇报任务运行情况等。
3、Standalone启动过程是啥？&lt;/p&gt;

&lt;p&gt;（1）首先，启动master，worker节点。
worker启动后触发Master的RegisterWorker事件，进行注册。主要讲要注册的Worker信息封装成WorkerInfo对象，包括Worker节点的CPU、内存等基本信息。记录Worker的信息（IP、Address）到master缓存中（HashMap），若Worker节点的注册信息有效，持久化已注册的Worker信息。然后给个完成注册的反馈信号。
（2）提交Application
运行spark-shell时，会由Driver端的DAGScheduler向Master发送RegisterApplication请求。根据此请求信息会创建ApplicationInfo对象，将Application加入到Master的缓存apps中，这个结构是HashSet。
如果worker已经注册，发送lanchExecutor指令给相应的Worker。
（3）Worker收到lanchExecutor后，会由ExecutorRunner启动Excutor进程，启动的Executor进程会根据启动时的入参，将自己注册到Drive中的ScheduleBackend。
(4)ScheduleBackend收到Excutor的注册信息后，会将提交到的Spark Job分解为多个具体的Task，然后通过LaunchTask指令将这些Task分散到各个Executor上运行。
4、Standalone部署方式下某一节点出现问题时，系统如何处理？&lt;/p&gt;

&lt;p&gt;出现问题的节点可能发生的情况有三种：
（1）Master崩掉了：这个坏掉了，就真的没法完了。单点故障的问题。
有两种解决办法：第一种基于文件系统的故障恢复，适合Master进程本身挂掉，那直接重启就Ok了。
第二种是基于ZookerKeep的HA方式。此方式被许多的分布式框架使用。
（2）某一Worker崩掉了：
若是所有的Worker挂掉，则整个集群就不可用；
Worker退出之前，会将管控的所有Executor进程kill；由于Worker挂掉，不能向master玩心跳了，根据超时处理会知道Worker挂了，然后Master将相应的情况汇报给Driver。Driver会根据master的信息和没有收到Executor的StatusUpdate确定这个Worker挂了，则Driver会将这个注册的Executor移除。
（3）某Worker的Excutor崩掉了：
Excutor的作为一个独立的进程在运行，由ExcutorRunner线程启动，并收到ExcutorRunner的监控，当Excutor挂了，ExcutorRunner会注意到异常情况，将ExecutorStateChanged汇报给Master，master会再次发送lanchExecutor指令给相应的Worker启动相应的Excutor。&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Oct 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/spark/2017/10/13/spark_concepts.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/spark/2017/10/13/spark_concepts.html</guid>
        
        
        <category>spark</category>
        
      </item>
    
      <item>
        <title>Actor模型原理</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;1.Actor模型
在使用Java进行并发编程时需要特别的关注锁和内存原子性等一系列线程问题，而Actor模型内部的状态由它自己维护即它内部数据只能由它自己修改(通过消息传递来进行状态修改)，所以使用Actors模型进行并发编程可以很好地避免这些问题，Actor由状态(state)、行为(Behavior)和邮箱(mailBox)三部分组成&lt;/p&gt;

&lt;p&gt;状态(state)：Actor中的状态指的是Actor对象的变量信息，状态由Actor自己管理，避免了并发环境下的锁和内存原子性等问题
行为(Behavior)：行为指定的是Actor中计算逻辑，通过Actor接收到消息来改变Actor的状态
邮箱(mailBox)：邮箱是Actor和Actor之间的通信桥梁，邮箱内部通过FIFO消息队列来存储发送方Actor消息，接受方Actor从邮箱队列中获取消息
Actor的基础就是消息传递&lt;/p&gt;

&lt;p&gt;2.使用Actor模型的好处：
事件模型驱动–Actor之间的通信是异步的，即使Actor在发送消息后也无需阻塞或者等待就能够处理其他事情
强隔离性–Actor中的方法不能由外部直接调用，所有的一切都通过消息传递进行的，从而避免了Actor之间的数据共享，想要
观察到另一个Actor的状态变化只能通过消息传递进行询问
位置透明–无论Actor地址是在本地还是在远程机上对于代码来说都是一样的
轻量性–Actor是非常轻量的计算单机，单个Actor仅占400多字节，只需少量内存就能达到高并发
3.Actor模型原理&lt;/p&gt;

&lt;p&gt;创建ActorSystem
ActorSystem作为顶级Actor，可以创建和停止Actors,甚至可关闭整个Actor环境，
此外Actors是按层次划分的，ActorSystem就好比Java中的Object对象，Scala中的Any，
是所有Actors的根，当你通过ActorSystem的actof方法创建Actor时，实际就是在ActorSystem
下创建了一个子Actor。
可通过以下代码来初始化ActorSystem&lt;/p&gt;

&lt;p&gt;val system = ActorSystem(“UniversityMessageSystem”)&lt;/p&gt;

&lt;p&gt;通过ActorSystem创建TeacherActor的代理(ActorRef)
看看TeacherActor的代理的创建代码&lt;/p&gt;

&lt;p&gt;val teacherActorRef:ActorRef = system.actorOf(Props[TeacherActor])&lt;/p&gt;

&lt;p&gt;ActorSystem通过actorOf创建Actor，但其并不返回TeacherActor而是返
回一个类型为ActorRef的东西。
ActorRef作为Actor的代理，使得客户端并不直接与Actor对话，这种Actor
模型也是为了避免TeacherActor的自定义/私有方法或变量被直接访问，所
以你最好将消息发送给ActorRef，由它去传递给目标Actor
发送QuoteRequest消息到代理中
你只需通过!方法将QuoteReques消息发送给ActorRef(注意：ActorRef也有个tell方法,其作用就委托回调给!)&lt;/p&gt;

&lt;p&gt;techerActorRef!QuoteRequest
等价于teacherActorRef.tell(QuoteRequest, teacherActorRef)&lt;/p&gt;

&lt;p&gt;MailBox&lt;/p&gt;

&lt;p&gt;每个Actor都有一个MailBox,同样，Teacher也有个MailBox，其会检查MailBox并处理消息。
MailBox内部采用的是FIFO队列来存储消息，有一点不同的是，现实中我们的最新邮件
会在邮箱的最前面。
Dispatcher&lt;/p&gt;

&lt;p&gt;Dispatcher从ActorRef中获取消息并传递给MailBox,Dispatcher封装了一个线程池，之后在
线程池中执行MailBox。&lt;/p&gt;

&lt;p&gt;protected[akka] override def registerForExecution(mbox: Mailbox, …): Boolean = {
  …
 try {
 executorService execute mbox
 …
}&lt;/p&gt;

&lt;p&gt;为什么能执行MailBox?
看看MailBox的实现,没错，其实现了Runnable接口&lt;/p&gt;

&lt;p&gt;private[akka] abstract class Mailbox(val messageQueue: MessageQueue) extends SystemMessageQueue with Runnable&lt;/p&gt;

</description>
        <pubDate>Fri, 13 Oct 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/spark/2017/10/13/actor_intro.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/spark/2017/10/13/actor_intro.html</guid>
        
        
        <category>spark</category>
        
      </item>
    
      <item>
        <title>Actor系统的实体</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;在Actor系统中，actor之间具有树形的监管结构，并且actor可以跨多个网络节点进行透明通信。 
对于一个Actor而言，其源码中存在Actor，ActorContext，ActorRef等多个概念，它们都是为了描述Actor对象而进行的不同层面的抽象。 
我们先给出一个官方的示例图，再对各个概念进行解释。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/ActorPath.png&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;上图很清晰的展示了一个actor在源码层面的不同抽象，和不同actor之间的父子关系：  Actor类的一个成员context是ActorContext类型，ActorContext存储了Actor类的上下文，包括self、sender。  ActorContext还混入了ActorRefFactory特质，其中实现了actorOf方法用来创建子actor。  这是Actor中context的源码：
&lt;/code&gt;&lt;/pre&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;lineno&quot;&gt; 1 &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Actor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2 &lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3 &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;   * Stores the context for this actor, including self, and sender.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4 &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;   * It is implicit to support operations such as `forward`.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 5 &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;   *&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6 &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;   * WARNING: Only valid within the Actor itself, so do not close over it and&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7 &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;   * publish it to other threads!&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8 &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;   *&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9 &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;   * [[akka.actor.ActorContext]] is the Scala API. `getContext` returns a&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10 &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;   * [[akka.actor.UntypedActorContext]], which is the Java API of the actor&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11 &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;   * context.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12 &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;   */&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;13 &lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ActorContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14 &lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextStack&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ActorCell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;15 &lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;16 &lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ActorInitializationException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;17 &lt;/span&gt;        &lt;span class=&quot;s&quot;&gt;s&amp;quot;You cannot create an instance of [&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;] explicitly using the constructor (new). &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;18 &lt;/span&gt;          &lt;span class=&quot;s&quot;&gt;&amp;quot;You have to use one of the &amp;#39;actorOf&amp;#39; factory methods to create a new actor. See the documentation.&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;19 &lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;20 &lt;/span&gt;    &lt;span class=&quot;nc&quot;&gt;ActorCell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;21 &lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;22 &lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;23 &lt;/span&gt;  &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;ActorCell的self成员是ActorRef类型，ActorRef是一个actor的不可变，可序列化的句柄（handle），它可能不在本地或同一个ActorSystem中，它是实现网络空间位置透明性的关键设计。 
这是ActorContext中self的源码：&lt;/p&gt;

&lt;p&gt;trait ActorContext extends ActorRefFactory {&lt;/p&gt;

&lt;p&gt;def self: ActorRef
ActorRef的path成员是ActorPath类型，ActorPath是actor树结构中唯一的地址，它定义了根actor到子actor的顺序。 
这是ActorRef中path的源码：&lt;/p&gt;

&lt;p&gt;abstract class ActorRef extends java.lang.Comparable[ActorRef] with Serializable {
  /**&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Returns the path for this actor (from this actor up to the root actor).
   */
  def path: ActorPath
Actor引用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Actor引用是ActorRef的子类，它的最重要功能是支持向它所代表的actor发送消息。每个actor通过self来访问它的标准（本地）引用，在发送给其它actor的消息中也缺省包含这个引用。反过来，在消息处理过程中，actor可以通过sender来访问到当前消息的发送者的引用。&lt;/p&gt;

&lt;p&gt;不同类型的Actor引用&lt;/p&gt;

&lt;p&gt;根据actor系统的配置，支持几种不同的actor引用：&lt;/p&gt;

&lt;p&gt;纯本地引用被配置成不支持网络功能的，这些actor引用发送的消息不能通过一个网络发送到另一个远程的JVM。
支持远程调用的本地引用使用在支持同一个jvm中actor引用之间的网络功能的actor系统中。为了在发送到其它网络节点后被识别，这些引用包含了协议和远程地址信息。
本地actor引用有一个子类是用在路由（比如，混入了Router trait的actor）。它的逻辑结构与之前的本地引用是一样的，但是向它们发送的消息会被直接重定向到它的子actor。
远程actor引用代表可以通过远程通讯访问的actor，i.e. 从别的jvm向他们发送消息时，Akka会透明地对消息进行序列化。
有几种特殊的actor引用类型，在实际用途中比较类似本地actor引用： 
PromiseActorRef表示一个Promise，作用是从一个actor返回的响应来完成，它是由akka.pattern.ask调用来创建的
DeadLetterActorRef是死信服务的缺省实现，所有接收方被关闭或不存在的消息都在此被重新路由。
EmptyLocalActorRef是查找一个不存在的本地actor路径时返回的：它相当于DeadLetterActorRef，但是它保有其路径因此可以在网络上发送，以及与其它相同路径的存活的actor引用进行比较，其中一些存活的actor引用可能在该actor消失之前得到了。
然后有一些内部实现，你可能永远不会用上： 
有一个actor引用并不表示任何actor，只是作为根actor的伪监管者存在，我们称它为“时空气泡穿梭者”。
在actor创建设施启动之前运行的第一个日志服务是一个伪actor引用，它接收日志事件并直接显示到标准输出上；它就是Logging.StandardOutLogger。
获得Actor引用&lt;/p&gt;

&lt;p&gt;创建Actor&lt;/p&gt;

&lt;p&gt;一个actor系统通常是在根actor上使用ActorSystem.actorOf创建actor，然后使用ActorContext.actorOf从创建出的actor中生出actor树来启动的。这些方法返回指向新创建的actor的引用。每个actor都拥有到它的父亲，它自己和它的子actor的引用。这些引用可以与消息一直发送给别的actor，以便接收方直接回复。&lt;/p&gt;

&lt;p&gt;具体路径查找&lt;/p&gt;

&lt;p&gt;另一种查找actor引用的途径是使用ActorSystem.actorSelection方法，也可以使用ActorContext.actorSelection来在actor之中查询。它会返回一个（未验证的）本地、远程或集群actor引用。向这个引用发送消息或试图观察它的存活状态会在actor系统树中从根开始一层一层从父向子actor发送消息，直到消息到达目标或是出现某种失败，i.e.路径中的某一个actor名字不存在（在实际中这个过程会使用缓存来优化，但相较使用物理actor路径来说仍然增加了开销，因为物理路径能够从actor的响应消息中的发送方引用中获得），这个消息传递过程由Akka自动完成的，对客户端代码不可见。 
使用相对路径向兄弟actor发送消息：&lt;/p&gt;

&lt;p&gt;context.actorSelection(“../brother”) ! msg
1
也可以用绝对路径：&lt;/p&gt;

&lt;p&gt;context.actorSelection(“/user/serviceA”) ! msg
1
查询逻辑Actor层次结构&lt;/p&gt;

&lt;p&gt;由于actor系统是一个类似文件系统的树形结构，对actor的匹配与unix shell中支持的一样：你可以将路径（中的一部分）用通配符(«*» 和«?»)替换来组成对0个或多个实际actor的匹配。由于匹配的结果不是一个单一的actor引用，它拥有一个不同的类型ActorSelection，这个类型不完全支持ActorRef的所有操作。同样，路径选择也可以用ActorSystem.actorSelection或ActorContext.actorSelection两种方式来获得，并且支持发送消息。 
下面是将msg发送给包括当前actor在内的所有兄弟actor：&lt;/p&gt;

&lt;p&gt;context.actorSelection(“../*”) ! msg
1
与远程部署之间的互操作&lt;/p&gt;

&lt;p&gt;当一个actor创建一个子actor，actor系统的部署者会决定新的actor是在同一个jvm中或是在其它的节点上。如果是在其他节点创建actor，actor的创建会通过网络连接来到另一个jvm中进行，结果是新的actor会进入另一个actor系统。 远程系统会将新的actor放在一个专为这种场景所保留的特殊路径下。新的actor的监管者会是一个远程actor引用（代表会触发创建动作的actor）。这时，context.parent（监管者引用）和context.path.parent（actor路径上的父actor）表示的actor是不同的。但是在其监管者中查找这个actor的名称能够在远程节点上找到它，保持其逻辑结构，e.g.当向另外一个未确定(unresolved)的actor引用发送消息时。&lt;/p&gt;

&lt;p&gt;因为设计分布式执行会带来一些限制，最明显的一点就是所有通过电缆发送的消息都必须可序列化。虽然有一点不太明显的就是包括闭包在内的远程角色工厂，用来在远程节点创建角色（即Props内部）。 
另一个结论是，要意识到所有交互都是完全异步的，它意味着在一个计算机网络中一条消息需要几分钟才能到达接收者那里（基于配置），而且可能比在单JVM中有更高丢失率，后者丢失率接近于0（还没有确凿的证据）。&lt;/p&gt;

&lt;p&gt;Akka使用的特殊路径&lt;/p&gt;

&lt;p&gt;在路径树的根上是根监管者，所有的的actor都可以从通过它找到。在第二个层次上是以下这些：&lt;/p&gt;

&lt;p&gt;“/user”是所有由用户创建的顶级actor的监管者，用ActorSystem.actorOf创建的actor在其下一个层次 are found at the next level。
“/system” 是所有由系统创建的顶级actor（如日志监听器或由配置指定在actor系统启动时自动部署的actor）的监管者。
“/deadLetters” 是死信actor，所有发往已经终止或不存在的actor的消息会被送到这里。
“/temp”是所有系统创建的短时actor(i.e.那些用在ActorRef.ask的实现中的actor)的监管者。
“/remote” 是一个人造的路径，用来存放所有其监管者是远程actor引用的actor。
附录-Actor模型概述：&lt;/p&gt;

&lt;p&gt;Actor模型为编写并发和分布式系统提供了一种更高的抽象级别。它将开发人员从显式地处理锁和线程管理的工作中解脱出来，使编写并发和并行系统更加容易。Actor模型是在1973年Carl Hewitt的论文中提的，但是被Erlang语言采用后才变得流行起来，一个成功案例是爱立信使用Erlang非常成功地创建了高并发的可靠的电信系统。&lt;/p&gt;

&lt;p&gt;Actor的树形结构&lt;/p&gt;

&lt;p&gt;像一个商业组织一样，actor自然会形成树形结构。程序中负责某一个功能的actor可能需要把它的任务分拆成更小的、更易管理的部分。为此它启动子Actor并监管它们。要知道每个actor有且仅有一个监管者，就是创建它的那个actor。&lt;/p&gt;

&lt;p&gt;Actor系统的精髓在于任务被分拆开来并进行委托，直到任务小到可以被完整地进行处理。 这样做不仅使任务本身被清晰地划分出结构，而且最终的actor也能按照它们“应该处理的消息类型”，“如何完成正常流程的处理”以及“失败流程应如何处理”来进行解析。如果一个actor对某种状况无法进行处理，它会发送相应的失败消息给它的监管者请求帮助。这样的递归结构使得失败能够在正确的层次进行处理。&lt;/p&gt;

&lt;p&gt;可以将这与分层的设计方法进行比较。分层的设计方法最终很容易形成防御性编程，以防止任何失败被泄露出来。把问题交由正确的人处理会是比将所有的事情“藏在深处”更好的解决方案。&lt;/p&gt;

&lt;p&gt;现在，设计这种系统的难度在于如何决定谁应该监管什么。这当然没有一个唯一的最佳方案，但是有一些可能会有帮助的原则：&lt;/p&gt;

&lt;p&gt;如果一个actort管理另一个actor所做的工作，如分配一个子任务，那么父actor应该监督子actor，原因是父actor知道可能会出现哪些失败情况，知道如何处理它们。
如果一个actor携带着重要数据（i.e. 它的状态要尽可能地不被丢失），这个actor应该将任何可能的危险子任务分配给它所监管的子actor，并酌情处理子任务的失败。视请求的性质，可能最好是为每一个请求创建一个子actor，这样能简化收集回应时的状态管理。这在Erlang中被称为“Error Kernel Pattern”。
如果actor A需要依赖actor B才能完成它的任务，A应该观测B的存活状态并对收到B的终止提醒消息进行响应。这与监管机制不同，因为观测方对监管机制没有影响，需要指出的是，仅仅是功能上的依赖并不足以用来决定是否在树形监管体系中添加子actor。
Actor实体&lt;/p&gt;

&lt;p&gt;一个Actor是一个容器，它包含了 状态，行为，一个邮箱，子Actor和一个监管策略。所有这些包含在一个Actor引用里。&lt;/p&gt;

&lt;p&gt;状态&lt;/p&gt;

&lt;p&gt;Actor对象通常包含一些变量来反映actor所处的可能状态。这可能是一个明确的状态机，或是一个计数器，一组监听器，待处理的请求，等等。这些数据使得actor有价值，并且必须将这些数据保护起来不被其它的actor所破坏。&lt;/p&gt;

&lt;p&gt;好消息是在概念上每个Akka actor都有它自己的轻量线程，这个线程是完全与系统其它部分隔离的。这意味着你不需要使用锁来进行资源同步，可以完全不必担心并发性地来编写你的actor代码。&lt;/p&gt;

&lt;p&gt;在幕后，Akka会在一组线程上运行一组Actor，通常是很多actor共享一个线程，对某一个actor的调用可能会在不同的线程上进行处理。Akka保证这个实现细节不影响处理actor状态的单线程性。
由于内部状态对于actor的操作是至关重要的，所以状态不一致是致命的。当actor失败并由其监管者重新启动，状态会进行重新创建，就象第一次创建这个actor一样。这是为了实现系统的“自愈合”。&lt;/p&gt;

&lt;p&gt;行为&lt;/p&gt;

&lt;p&gt;每次当一个消息被处理时，消息会与actor的当前的行为进行匹配。行为是一个函数，它定义了处理当前消息所要采取的动作，例如如果客户已经授权过了，那么就对请求进行处理，否则拒绝请求。&lt;/p&gt;

&lt;p&gt;邮箱&lt;/p&gt;

&lt;p&gt;Actor的用途是处理消息，这些消息是从其它的actor（或者从actor系统外部）发送过来的。连接发送者与接收者的纽带是actor的邮箱：每个actor有且仅有一个邮箱，所有的发来的消息都在邮箱里排队。排队按照发送操作的时间顺序来进行，这意味着从不同的actor发来的消息在运行时没有一个固定的顺序，这是由于actor分布在不同的线程中。从另一个角度讲，从同一个actor发送多个消息到相同的actor，则消息会按发送的顺序排队。&lt;/p&gt;

&lt;p&gt;可以有不同的邮箱实现供选择，缺省的是FIFO：actor处理消息的顺序与消息入队列的顺序一致。这通常是一个好的选择，但是应用可能需要对某些消息进行优先处理。在这种情况下，可以使用优先邮箱来根据消息优先级将消息放在某个指定的位置，甚至可能是队列头，而不是队列末尾。如果使用这样的队列，消息的处理顺序是由队列的算法决定的，而不是FIFO。&lt;/p&gt;

&lt;p&gt;Akka与其它actor模型实现的一个重要差别在于当前的行为必须处理下一个从队列中取出的消息，Akka不会去扫描邮箱来找到下一个匹配的消息。无法处理某个消息通常是作为失败情况进行处理，除非actor覆盖了这个行为。&lt;/p&gt;

&lt;p&gt;子Actor&lt;/p&gt;

&lt;p&gt;每个actor都是一个潜在的监管者：如果它创建了子actor来委托处理子任务，它会自动地监管它们。子actor列表维护在actor的上下文中，actor可以访问它。对列表的更改是通过context.actorOf(…)创建或者context.stop(child)停止子actor来实现，并且这些更改会立刻生效。实际的创建和停止操作在幕后以异步的方式完成，这样它们就不会“阻塞”其监管者。&lt;/p&gt;

&lt;p&gt;监督策略&lt;/p&gt;

&lt;p&gt;Actor的最后一部分是它用来处理其子actor错误状况的机制。错误处理是由Akka透明地进行处理的。由于策略是actor系统组织结构的基础，所以一旦actor被创建了它就不能被修改。&lt;/p&gt;

&lt;p&gt;考虑对每个actor只有唯一的策略，这意味着如果一个actor的子actor们应用了不同的策略，这些子actor应该按照相同的策略来进行分组，生成中间的监管者，又一次倾向于根据任务到子任务的划分来组织actor系统的结构。&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Oct 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/spark/2017/10/13/actor_detail.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/spark/2017/10/13/actor_detail.html</guid>
        
        
        <category>spark</category>
        
      </item>
    
  </channel>
</rss>
