<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>泽民博客</title>
    <description>夏泽民的个人主页，学习笔记。</description>
    <link>https://xiazemin.github.io/MyBlog/</link>
    <atom:link href="https://xiazemin.github.io/MyBlog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 03 Jan 2018 21:47:30 +0800</pubDate>
    <lastBuildDate>Wed, 03 Jan 2018 21:47:30 +0800</lastBuildDate>
    <generator>Jekyll v3.6.0.pre.beta1</generator>
    
      <item>
        <title>rsa 非对称加密原理</title>
        <description>&lt;p&gt;一、一点历史&lt;/p&gt;

&lt;p&gt;1976年以前，所有的加密方法都是同一种模式：&lt;/p&gt;

&lt;p&gt;　　（1）甲方选择某一种加密规则，对信息进行加密；&lt;/p&gt;

&lt;p&gt;　　（2）乙方使用同一种规则，对信息进行解密。&lt;/p&gt;

&lt;p&gt;由于加密和解密使用同样规则（简称”密钥”），这被称为”对称加密算法”（Symmetric-key algorithm）。&lt;/p&gt;

&lt;p&gt;这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。&lt;/p&gt;

&lt;p&gt;1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为”Diffie-Hellman密钥交换算法”。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。&lt;/p&gt;

&lt;p&gt;这种新的加密模式被称为”非对称加密算法”。
（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。
（2）甲方获取乙方的公钥，然后用它对信息加密。
（3）乙方得到加密后的信息，用私钥解密。&lt;/p&gt;

&lt;p&gt;如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。&lt;/p&gt;

&lt;p&gt;1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。&lt;/p&gt;

&lt;p&gt;这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。&lt;/p&gt;

&lt;p&gt;下面，我就进入正题，解释RSA算法的原理。文章共分成两部分，今天是第一部分，介绍要用到的四个数学概念。你可以看到，RSA算法并不难，只需要一点数论知识就可以理解。&lt;/p&gt;

&lt;p&gt;二、互质关系&lt;/p&gt;

&lt;p&gt;如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。&lt;/p&gt;

&lt;p&gt;关于互质关系，不难得到以下结论：&lt;/p&gt;

&lt;p&gt;　　1. 任意两个质数构成互质关系，比如13和61。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。
　　3. 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。
    4. 1和任意一个自然数是都是互质关系，比如1和99。
    5. p是大于1的整数，则p和p-1构成互质关系，比如57和56。
    6. p是大于1的奇数，则p和p-2构成互质关系，比如17和15。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三、欧拉函数
请思考以下问题：
　　任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）&lt;/p&gt;

&lt;p&gt;计算这个值的方法就叫做欧拉函数，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。&lt;/p&gt;

&lt;p&gt;φ(n) 的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。&lt;/p&gt;

&lt;p&gt;第一种情况&lt;/p&gt;

&lt;p&gt;如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。&lt;/p&gt;

&lt;p&gt;第二种情况&lt;/p&gt;

&lt;p&gt;如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。&lt;/p&gt;

&lt;p&gt;第三种情况&lt;/p&gt;

&lt;p&gt;如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则
&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/rsa_pk.png&quot; /&gt;
比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。&lt;/p&gt;

&lt;p&gt;这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1)个，即1×p、2×p、3×p、…、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。&lt;/p&gt;

&lt;p&gt;上面的式子还可以写成下面的形式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/rsa_pk_1.png&quot; /&gt;
可以看出，上面的第二种情况是 k=1 时的特例。&lt;/p&gt;

&lt;p&gt;第四种情况&lt;/p&gt;

&lt;p&gt;如果n可以分解成两个互质的整数之积，&lt;/p&gt;

&lt;p&gt;　　n = p1 × p2&lt;/p&gt;

&lt;p&gt;则&lt;/p&gt;

&lt;p&gt;　　φ(n) = φ(p1p2) = φ(p1)φ(p2)&lt;/p&gt;

&lt;p&gt;即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。&lt;/p&gt;

&lt;p&gt;这一条的证明要用到”中国剩余定理”，这里就不展开了，只简单说一下思路：如果a与p1互质(a&amp;lt;p1)，b与p2互质(b&amp;lt;p2)，c与p1p2互质(c&amp;lt;p1p2)，则c与数对 (a,b) 是一一对应关系。由于a的值有φ(p1)种可能，b的值有φ(p2)种可能，则数对 (a,b) 有φ(p1)φ(p2)种可能，而c的值有φ(p1p2)种可能，所以φ(p1p2)就等于φ(p1)φ(p2)。
////////////
中国剩余定理
　　在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。具体解法分三步：&lt;/p&gt;

&lt;p&gt;找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。
用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加15∗2+21∗3+70∗215∗2+21∗3+70∗2得到和233。
用233除以3，5，7三个数的最小公倍数105，得到余数23，即233%105=23233%105=23。这个余数23就是符合条件的最小数。
　　就这么简单。我们在感叹神奇的同时不禁想知道古人是如何想到这个方法的，有什么基本的数学依据吗？&lt;/p&gt;

&lt;p&gt;　　我们将“孙子问题”拆分成几个简单的小问题，从零开始，试图揣测古人是如何推导出这个解法的。&lt;/p&gt;

&lt;p&gt;　　首先，我们假设n1n1是满足除以3余2的一个数，比如2，5，8等等，也就是满足3∗k+2（k&amp;gt;=0）3∗k+2（k&amp;gt;=0）的一个任意数。同样，我们假设n2n2是满足除以5余3的一个数，n3n3是满足除以7余2的一个数。&lt;/p&gt;

&lt;p&gt;　　有了前面的假设，我们先从n1n1这个角度出发，已知n1n1满足除以3余2，能不能使得n1+n2n1+n2的和仍然满足除以3余2？进而使得n1+n2+n3n1+n2+n3的和仍然满足除以3余2？&lt;/p&gt;

&lt;p&gt;　　这就牵涉到一个最基本数学定理，如果有a%b=ca%b=c，则有(a+k∗b)%b=c(k为非零整数)(a+k∗b)%b=c(k为非零整数)，换句话说，如果一个除法运算的余数为cc，那么被除数与kk倍的除数相加（或相减）的和（差）再与除数相除，余数不变。这个是很好证明的。&lt;/p&gt;

&lt;p&gt;　　以此定理为依据，如果n2n2是3的倍数，n1+n2n1+n2就依然满足除以3余2。同理，如果n3n3也是3的倍数，那么n1+n2+n3n1+n2+n3的和就满足除以3余2。这是从n1n1的角度考虑的，再从n2n2，n3n3的角度出发，我们可推导出以下三点：&lt;/p&gt;

&lt;p&gt;为使n1+n2+n3n1+n2+n3的和满足除以3余2，n2n2和n3n3必须是3的倍数。
为使n1+n2+n3n1+n2+n3的和满足除以5余3，n1n1和n3n3必须是5的倍数。
为使n1+n2+n3n1+n2+n3的和满足除以7余2，n1n1和n2n2必须是7的倍数。
　　因此，为使n1+n2+n3n1+n2+n3的和作为“孙子问题”的一个最终解，需满足：&lt;/p&gt;

&lt;p&gt;n1n1除以3余2，且是5和7的公倍数。
n2n2除以5余3，且是3和7的公倍数。
n3n3除以7余2，且是3和5的公倍数。
　　所以，孙子问题解法的本质是从5和7的公倍数中找一个除以3余2的数n1n1，从3和7的公倍数中找一个除以5余3的数n2n2，从3和5的公倍数中找一个除以7余2的数n3n3，再将三个数相加得到解。在求n1n1，n2n2，n3n3时又用了一个小技巧，以n1n1为例，并非从5和7的公倍数中直接找一个除以3余2的数，而是先找一个除以3余1的数，再乘以2。也就是先求出5和7的公倍数模3下的逆元，再用逆元去乘余数。&lt;/p&gt;

&lt;p&gt;　　这里又有一个数学公式，如果a%b=ca%b=c，那么(a∗k)%b=a%b+a%b+…+a%b=c+c+…+c=k∗c(k&amp;gt;0)(a∗k)%b=a%b+a%b+…+a%b=c+c+…+c=k∗c(k&amp;gt;0),也就是说，如果一个除法的余数为cc，那么被除数的kk倍与除数相除的余数为k∗ck∗c。展开式中已证明。&lt;/p&gt;

&lt;p&gt;　　最后，我们还要清楚一点，n1+n2+n3n1+n2+n3只是问题的一个解，并不是最小的解。如何得到最小解？我们只需要从中最大限度的减掉掉3，5，7的公倍数105即可。道理就是前面讲过的定理“如果a%b=ca%b=c，则有(a−k∗b)%b=c(a−k∗b)%b=c”。所以（n1+n2+n3）%105（n1+n2+n3）%105就是最终的最小解。&lt;/p&gt;

&lt;p&gt;　　这样一来就得到了中国剩余定理的公式：&lt;/p&gt;

&lt;p&gt;设正整数两两互素，则同余方程组
有整数解。并且在模下的解是唯一的，解为
其中，而为模的逆元。
////////////
第五种情况&lt;/p&gt;

&lt;p&gt;因为任意一个大于1的正整数，都可以写成一系列质数的积。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/rsa_5_1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据第4条的结论，得到
&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/rsa_5_2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再根据第3条的结论，得到&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/rsa_5_3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也就等于&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/rsa_5_4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这就是欧拉函数的通用计算公式。比如，1323的欧拉函数，计算过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/rsa_5_5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;四、欧拉定理&lt;/p&gt;

&lt;p&gt;欧拉函数的用处，在于欧拉定理。”欧拉定理”指的是：&lt;/p&gt;

&lt;p&gt;如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/rsa4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。&lt;/p&gt;

&lt;p&gt;欧拉定理的证明比较复杂，这里就省略了。我们只要记住它的结论就行了。&lt;/p&gt;

&lt;p&gt;欧拉定理可以大大简化某些运算。比如，7和10互质，根据欧拉定理，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/rsa4_1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;已知 φ(10) 等于4，所以马上得到7的4倍数次方的个位数肯定是1。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/rsa4_2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此，7的任意次方的个位数（例如7的222次方），心算就可以算出来。&lt;/p&gt;

&lt;p&gt;欧拉定理有一个特殊情况。&lt;/p&gt;

&lt;p&gt;假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/rsa4_3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这就是著名的费马小定理。它是欧拉定理的特例。&lt;/p&gt;

&lt;p&gt;欧拉定理是RSA算法的核心。理解了这个定理，就可以理解RSA。&lt;/p&gt;

&lt;p&gt;五、模反元素&lt;/p&gt;

&lt;p&gt;还剩下最后一个概念：&lt;/p&gt;

&lt;p&gt;如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。&lt;/p&gt;

&lt;p&gt;ab三1(mod n)&lt;/p&gt;

&lt;p&gt;这时，b就叫做a的”模反元素”。&lt;/p&gt;

&lt;p&gt;比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {…,-18,-7,4,15,26,…}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。&lt;/p&gt;

&lt;p&gt;欧拉定理可以用来证明模反元素必然存在。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/rsaa.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，a的 φ(n)-1 次方，就是a的模反元素。&lt;/p&gt;

&lt;p&gt;==========================================
六、密钥生成的步骤&lt;/p&gt;

&lt;p&gt;我们通过一个例子，来理解RSA算法。假设爱丽丝要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？&lt;/p&gt;

&lt;p&gt;第一步，随机选择两个不相等的质数p和q。&lt;/p&gt;

&lt;p&gt;爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）&lt;/p&gt;

&lt;p&gt;第二步，计算p和q的乘积n。&lt;/p&gt;

&lt;p&gt;爱丽丝就把61和53相乘。&lt;/p&gt;

&lt;p&gt;　　n = 61×53 = 3233&lt;/p&gt;

&lt;p&gt;n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。&lt;/p&gt;

&lt;p&gt;第三步，计算n的欧拉函数φ(n)。&lt;/p&gt;

&lt;p&gt;根据公式：&lt;/p&gt;

&lt;p&gt;　　φ(n) = (p-1)(q-1)&lt;/p&gt;

&lt;p&gt;爱丽丝算出φ(3233)等于60×52，即3120。&lt;/p&gt;

&lt;p&gt;第四步，随机选择一个整数e，条件是1&amp;lt; e &amp;lt; φ(n)，且e与φ(n) 互质。&lt;/p&gt;

&lt;p&gt;爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）&lt;/p&gt;

&lt;p&gt;第五步，计算e对于φ(n)的模反元素d。&lt;/p&gt;

&lt;p&gt;所谓”模反元素”就是指有一个整数d，可以使得ed被φ(n)除的余数为1。&lt;/p&gt;

&lt;p&gt;　　ed ≡ 1 (mod φ(n))&lt;/p&gt;

&lt;p&gt;这个式子等价于&lt;/p&gt;

&lt;p&gt;　　ed - 1 = kφ(n)&lt;/p&gt;

&lt;p&gt;于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。&lt;/p&gt;

&lt;p&gt;　　ex + φ(n)y = 1&lt;/p&gt;

&lt;p&gt;已知 e=17, φ(n)=3120，&lt;/p&gt;

&lt;p&gt;　　17x + 3120y = 1&lt;/p&gt;

&lt;p&gt;这个方程可以用”扩展欧几里得算法”求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。&lt;/p&gt;

&lt;p&gt;至此所有计算完成。&lt;/p&gt;

&lt;p&gt;第六步，将n和e封装成公钥，n和d封装成私钥。&lt;/p&gt;

&lt;p&gt;在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。&lt;/p&gt;

&lt;p&gt;实际应用中，公钥和私钥的数据都采用ASN.1格式表达（实例）。&lt;/p&gt;

&lt;p&gt;七、RSA算法的可靠性&lt;/p&gt;

&lt;p&gt;回顾上面的密钥生成步骤，一共出现六个数字：&lt;/p&gt;

&lt;p&gt;　　p
　　q
　　n
　　φ(n)
　　e
　　d&lt;/p&gt;

&lt;p&gt;这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。&lt;/p&gt;

&lt;p&gt;那么，有无可能在已知n和e的情况下，推导出d？&lt;/p&gt;

&lt;p&gt;　　（1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。&lt;/p&gt;

&lt;p&gt;　　（2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。&lt;/p&gt;

&lt;p&gt;　　（3）n=pq。只有将n因数分解，才能算出p和q。&lt;/p&gt;

&lt;p&gt;结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。&lt;/p&gt;

&lt;p&gt;可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道：&lt;/p&gt;

&lt;p&gt;　　”对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。&lt;/p&gt;

&lt;p&gt;　　假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。&lt;/p&gt;

&lt;p&gt;　　只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。”&lt;/p&gt;

&lt;p&gt;举例来说，你可以对3233进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。&lt;/p&gt;

&lt;p&gt;　　12301866845301177551304949
　　58384962720772853569595334
　　79219732245215172640050726
　　36575187452021997864693899
　　56474942774063845925192557
　　32630345373154826850791702
　　61221429134616704292143116
　　02221240479274737794080665
　　351419597459856902143413&lt;/p&gt;

&lt;p&gt;它等于这样两个质数的乘积：&lt;/p&gt;

&lt;p&gt;　　33478071698956898786044169
　　84821269081770479498371376
　　85689124313889828837938780
　　02287614711652531743087737
　　814467999489
　　　　×
　　36746043666799590428244633
　　79962795263227915816434308
　　76426760322838157396665112
　　79233373417143396810270092
　　798736308917&lt;/p&gt;

&lt;p&gt;事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。&lt;/p&gt;

&lt;p&gt;八、加密和解密&lt;/p&gt;

&lt;p&gt;有了公钥和密钥，就能进行加密和解密了。&lt;/p&gt;

&lt;p&gt;（1）加密要用公钥 (n,e)&lt;/p&gt;

&lt;p&gt;假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。&lt;/p&gt;

&lt;p&gt;所谓”加密”，就是算出下式的c：&lt;/p&gt;

&lt;p&gt;　　me ≡ c (mod n)&lt;/p&gt;

&lt;p&gt;爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：&lt;/p&gt;

&lt;p&gt;　　6517 ≡ 2790 (mod 3233)&lt;/p&gt;

&lt;p&gt;于是，c等于2790，鲍勃就把2790发给了爱丽丝。&lt;/p&gt;

&lt;p&gt;（2）解密要用私钥(n,d)&lt;/p&gt;

&lt;p&gt;爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：&lt;/p&gt;

&lt;p&gt;　　cd ≡ m (mod n)&lt;/p&gt;

&lt;p&gt;也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出&lt;/p&gt;

&lt;p&gt;　　27902753 ≡ 65 (mod 3233)&lt;/p&gt;

&lt;p&gt;因此，爱丽丝知道了鲍勃加密前的原文就是65。&lt;/p&gt;

&lt;p&gt;至此，”加密–解密”的整个过程全部完成。&lt;/p&gt;

&lt;p&gt;我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。&lt;/p&gt;

&lt;p&gt;你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如DES），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。&lt;/p&gt;

&lt;p&gt;九、私钥解密的证明&lt;/p&gt;

&lt;p&gt;最后，我们来证明，为什么用私钥解密，一定可以正确地得到m。也就是证明下面这个式子：&lt;/p&gt;

&lt;p&gt;　　cd ≡ m (mod n)&lt;/p&gt;

&lt;p&gt;因为，根据加密规则&lt;/p&gt;

&lt;p&gt;　　ｍe ≡ c (mod n)&lt;/p&gt;

&lt;p&gt;于是，c可以写成下面的形式：&lt;/p&gt;

&lt;p&gt;　　c = me - kn&lt;/p&gt;

&lt;p&gt;将c代入要我们要证明的那个解密规则：&lt;/p&gt;

&lt;p&gt;　　(me - kn)d ≡ m (mod n)&lt;/p&gt;

&lt;p&gt;它等同于求证&lt;/p&gt;

&lt;p&gt;　　med ≡ m (mod n)&lt;/p&gt;

&lt;p&gt;由于&lt;/p&gt;

&lt;p&gt;　　ed ≡ 1 (mod φ(n))&lt;/p&gt;

&lt;p&gt;所以&lt;/p&gt;

&lt;p&gt;　　ed = hφ(n)+1&lt;/p&gt;

&lt;p&gt;将ed代入：&lt;/p&gt;

&lt;p&gt;　　mhφ(n)+1 ≡ m (mod n)&lt;/p&gt;

&lt;p&gt;接下来，分成两种情况证明上面这个式子。&lt;/p&gt;

&lt;p&gt;（1）m与n互质。&lt;/p&gt;

&lt;p&gt;根据欧拉定理，此时&lt;/p&gt;

&lt;p&gt;　　mφ(n) ≡ 1 (mod n)&lt;/p&gt;

&lt;p&gt;得到&lt;/p&gt;

&lt;p&gt;　　(mφ(n))h × m ≡ m (mod n)&lt;/p&gt;

&lt;p&gt;原式得到证明。&lt;/p&gt;

&lt;p&gt;（2）m与n不是互质关系。&lt;/p&gt;

&lt;p&gt;此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。&lt;/p&gt;

&lt;p&gt;以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：&lt;/p&gt;

&lt;p&gt;　　(kp)q-1 ≡ 1 (mod q)&lt;/p&gt;

&lt;p&gt;进一步得到&lt;/p&gt;

&lt;p&gt;　　[(kp)q-1]h(p-1) × kp ≡ kp (mod q)&lt;/p&gt;

&lt;p&gt;即&lt;/p&gt;

&lt;p&gt;　　(kp)ed ≡ kp (mod q)&lt;/p&gt;

&lt;p&gt;将它改写成下面的等式&lt;/p&gt;

&lt;p&gt;　　(kp)ed = tq + kp&lt;/p&gt;

&lt;p&gt;这时t必然能被p整除，即 t=t’p&lt;/p&gt;

&lt;p&gt;　　(kp)ed = t’pq + kp&lt;/p&gt;

&lt;p&gt;因为 m=kp，n=pq，所以&lt;/p&gt;

&lt;p&gt;　　med ≡ m (mod n)&lt;/p&gt;

&lt;p&gt;原式得到证明。&lt;/p&gt;
</description>
        <pubDate>Wed, 03 Jan 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/01/03/rsa.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/01/03/rsa.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>Merkle Patricia Tree</title>
        <description>&lt;p&gt;　Merkle Patricia Tree(简称MPT树，实际上是一种trie前缀树)是以太坊中的一种加密认证的数据结构，可以用来存储所有的(key，value)对。以太坊区块的头部包括一个区块头，一个交易的列表和一个uncle区块的列表。在区块头部包括了交易的hash树根，用来校验交易的列表。在p2p网络上传输的交易是一个简单的列表，它们被组装成一个叫做trie树的特殊数据结构，来计算根hash。值得注意的是，除了校验区块外，这个数据结构并不是必须的，一旦区块被验证正确，那么它在技术上是可以忽略的。但是，这意味着交易列表在本地以trie树的形式存储，发送给客户端的时候序列化成列表。客户端接收到交易列表后重新构建交易列表trie树来验证根hash。RLP(Recursive length prefix encoding,递归长度前缀编码)，用来对trie树种所有的条目进行编码(参考：http://www.cnblogs.com/fengzhiwu/p/5565559.html)。&lt;/p&gt;

&lt;p&gt;　　Trie树也叫作Radix树，为了提高效率，以太坊在实现上对其做了一些改进。在一般的radix树中，key是从树根到对应value得真实的路径。即从根节点开始，key中的每个字符会标识走那个子节点从而到达相应value。Value被存储在叶子节点，是每条路径的终止。假如key来自一个包含N个字符的字母表，那么树中的每个节点都可能会有多达N个孩子，树的最大深度是key的最大长度。
　　Radix的好处是具有相同前缀的key所对应的value在树中是非常靠近的，并且trie中不会有像hash-table一样的冲突。但是它也有缺陷，假如有一个很长的key，没有其他的key和它有公共的前缀，那么在遍历或存储它对应的值得时候，你就会遍历或存储相当多的节点，因为这棵树是非常不平衡的。
　　Merkle Tree，是一种树（数据结构中所说的树），网上大都称为Merkle Hash Tree,这是因为 它所构造的Merkle Tree的所有节点都是Hash值。Merkle Tree具有以下特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;它是一种树，可以是二叉树，也可以多叉树，无论是几叉树，它都具有树结构的所有特点；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Merkle树的叶子节点上的value，是由你指定的，这主要看你的设计了，如Merkle Hash Tree会将数据的Hash值作为叶子节点的值；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3 非叶子节点的value是根据它下面所有的叶子节点值，然后按照一定的算法计算而得出的。如Merkle Hash Tree的非叶子节点value的计算方法是将该节点的所有子节点进行组合，然后对组合结果进行hash计算所得出的hash value。&lt;/p&gt;

&lt;p&gt;二、 Merkle Tree的应用&lt;/p&gt;

&lt;p&gt;目前， 在计算机领域，Merkle Tree大多用来进行比对以及验证处理。比特币钱包服务用 Merkle Tree 的机制来作”百分百准备金证明“ 。在处理比对或验证的应用场景中时，特别是在分布式环境下进行比对或验证时，Merkle Tree会大大减少数据的传输量以及计算的复杂度。例如，就拿图一举例，假如是 15,16…….30是一个个数据块的hash值，我把这些数据从A传输到B，数据传输到B后，我想验证下传输到B上的数据的有效性型（验证数据是否在传输过程中发生变化），只需要验证A 和 B上所构造的Merkle
 Tree的root节点值是否一致即可，如果一致，表示数据是有效的，传输过程中没有发生改变。假如在传输过程中，15对应的数据被人篡改，通过Merkle Tree很容易定位找到（因为此时，节点0,1,3,7,15对应的hash值都发生了变化），定位的时间复杂度为O（log(n））&lt;/p&gt;

&lt;p&gt;三、Merkle Tree的优点&lt;/p&gt;

&lt;p&gt;相对于 Hash List，Merkle Tree 的明显的一个好处是可以单独拿出一个分支来（作为一个小树）对部分数据进行校验，这个很多使用场合就带来了哈希列表所不能比拟的方便和高效&lt;/p&gt;

&lt;p&gt;什么是merkle tree
假设你已经知道了什么是哈希算法以及哈希是用来干啥的。&lt;/p&gt;

&lt;p&gt;网络传输数据的时候，A收到B的传过来的文件，需要确认收到的文件有没有损坏。如何解决？&lt;/p&gt;

&lt;p&gt;有一种方法是B在传文件之前先把文件的hash结果给A，A收到文件再计算一次哈希然后和收到的哈希比较就知道文件有无损坏。&lt;/p&gt;

&lt;p&gt;但是当文件很大的时候，往往需要把文件拆分很多的数据块各自传输，这个时候就需要知道每个数据块的哈希值。怎么办呢？&lt;/p&gt;

&lt;p&gt;这种情况，可以在下载数据之前先下载一份哈希列表(hash list)，这个列表每一项对应一个数据块的哈希值。对这个hash list拼接后可以计算一个根hash。实际应用中，我们只要确保从一个可信的渠道获取正确的根hash，就可以确保下载正确的文件。&lt;/p&gt;

&lt;p&gt;似乎很完美了。但是还不够好！&lt;/p&gt;

&lt;p&gt;上面基于hash list的方案这样一个问题：&lt;/p&gt;

&lt;p&gt;有些时候我们获取(遍历)所有数据块的hash list代价比较大，只能获取部分节点的哈希。&lt;/p&gt;

&lt;p&gt;有没有一种方法可以通过部分hash就能校验整个文件的完整性呢？&lt;/p&gt;

&lt;p&gt;答案是肯定的，merkle tree能做到。它长这样子:&lt;/p&gt;

&lt;p&gt;这里写图片描述&lt;/p&gt;

&lt;p&gt;特点如下:&lt;/p&gt;

&lt;p&gt;1、数据结构是一个树，可以是二叉树，也可以是多叉树（本BLOG以二叉树来分析）&lt;/p&gt;

&lt;p&gt;2、Merkle Tree的叶子节点的value是数据集合的单元数据或者单元数据HASH。&lt;/p&gt;

&lt;p&gt;3、Merke Tree非叶子节点value是其所有子节点value的HASH值。&lt;/p&gt;

&lt;p&gt;很明显，这种结构跟hash list相比较，根哈希不是用所有的数据块哈希拼接起来计算的，而是通过一个层级的关系计算出来的。&lt;/p&gt;

&lt;p&gt;在上图中，叶子节点node7的value（v7) = hash(f1),是f1文件的HASH;而其父亲节点node3的value = hash(v7, v8)，也就是其子节点node7 node8的值得HASH&lt;/p&gt;

&lt;p&gt;其它应用场景
文件下载
假设我有两台机器，A和B，有一个文件从A传输到B。B首先获取可信的文件merkle tree，当文件下载完毕后，B通过自己构建的merkle tree根节点和获取的根节点比较，如果不一致,通过这种二叉树的结构可以在log(N)的复杂度快速定位到出错的数据块。&lt;/p&gt;

&lt;p&gt;副本同步
一个集群里的所有机器，需要保持数据的同步，如果数据不一致，需要快速的定位到不一致的节点。&lt;/p&gt;

&lt;p&gt;可以在每台机器上针对每个区间里的数据构造一棵Merkle Tree，这样，在两台机器间进行数据比对时，从Merkle Tree的根节点开始进行比对，如果根节点一样，则表示两个副本目前是一致的，不再需要任何处理；如果不一样，则遍历Merkle Tree，定位到不一致的节点也非常快速&lt;/p&gt;

&lt;p&gt;merkle tree应用在区块链上
下面是本文的重点。&lt;/p&gt;

&lt;p&gt;比特币系统的区块链中，每个区块都有一个merkle tree。&lt;/p&gt;

&lt;p&gt;这里写图片描述&lt;/p&gt;

&lt;p&gt;可以看到merkle root哈希值存在每一个区块的头部，通过这个root值连接着区块体，而区块体内就是包含着大量的交易。每个交易就相当于前面提到的数据块，交易本身有都有自己的哈希值来唯一标识自己。&lt;/p&gt;

&lt;p&gt;什么是SPV
为了更好的解释，这里先插播一个概念，SPV。也就是中本聪描述到的“简化支付验证” 正是有了SPV，才让区块链和比特币更加广泛的被传播。&lt;/p&gt;

&lt;p&gt;我们大部分人在电脑安装的比特币钱包都是轻量级(非全节点)的，也就是本地并没有所有的区块数据(上百G)。理论上来说，要验证一笔交易，钱包需要遍历所有的区块找到和该笔交易相关的所有交易进行逐个验证才是可靠的。&lt;/p&gt;

&lt;p&gt;但是轻量级的钱包没有完整的数据，如何验证一笔支付的合法性呢?&lt;/p&gt;

&lt;p&gt;merkle tree就起到了关键的作用。&lt;/p&gt;

&lt;p&gt;当然SPV有它的局限性(这个有空再写文章细讲)。&lt;/p&gt;

&lt;p&gt;这里是分割点
比特币系统是如何验证一笔交易的合法性呢？&lt;/p&gt;

&lt;p&gt;首先区块链中每个区块中的merkle tree的根哈希都是公开可信的。假设现在alice转账给bob一个比特币，比特币钱包需要确认这笔交易是否被包含在了区块链中。&lt;/p&gt;

&lt;p&gt;这里写图片描述&lt;/p&gt;

&lt;p&gt;入上图所示， 
假设我们要判断HK代表的交易是否存在，只需要生成一个仅有 4 个哈希值长度的 Merkle 路径，来证明区块中存该笔交易。该路径有 4 个哈希值（在图中由蓝色标注）HL、HIJ、HMNOP 和 HABCDEFGH。&lt;/p&gt;

&lt;p&gt;由这 4 个 
哈希值产生的认证路径， 再通过计算另外四对哈希值 HKL、 HIJKL、 HIJKLMNOP 
和 Merkle 树根（在图中由虚线标注），任何节点都能证明 HK（在图中由绿色 
标注）包含在 Merkle 根中。&lt;/p&gt;

&lt;p&gt;Merkle Tree概念
这里写图片描述 
Merkle Tree，通常也被称作Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块(例如，文件或者文件的集合)的hash值。非叶节点是其对应子节点串联字符串的hash。[1]&lt;/p&gt;

&lt;p&gt;1、Hash&lt;/p&gt;

&lt;p&gt;Hash是一个把任意长度的数据映射成固定长度数据的函数[2]。例如，对于数据完整性校验，最简单的方法是对整个数据做Hash运算得到固定长度的Hash值，然后把得到的Hash值公布在网上，这样用户下载到数据之后，对数据再次进行Hash运算，比较运算结果和网上公布的Hash值进行比较，如果两个Hash值相等，说明下载的数据没有损坏。可以这样做是因为输入数据的稍微改变就会引起Hash运算结果的面目全非，而且根据Hash值反推原始输入数据的特征是困难的。[3] 
　　这里写图片描述 
如果从一个稳定的服务器进行下载，采用单一Hash是可取的。但如果数据源不稳定，一旦数据损坏，就需要重新下载，这种下载的效率是很低的。&lt;/p&gt;

&lt;p&gt;2、Hash List 
在点对点网络中作数据传输的时候，会同时从多个机器上下载数据，而且很多机器可以认为是不稳定或者不可信的。为了校验数据的完整性，更好的办法是把大的文件分割成小的数据块（例如，把分割成2K为单位的数据块）。这样的好处是，如果小块数据在传输过程中损坏了，那么只要重新下载这一快数据就行了，不用重新下载整个文件。&lt;/p&gt;

&lt;p&gt;怎么确定小的数据块没有损坏哪？只需要为每个数据块做Hash。BT下载的时候，在下载到真正数据之前，我们会先下载一个Hash列表。那么问题又来了，怎么确定这个Hash列表本事是正确的哪？答案是把每个小块数据的Hash值拼到一起，然后对这个长字符串在作一次Hash运算，这样就得到Hash列表的根Hash(Top Hash or Root Hash)。下载数据的时候，首先从可信的数据源得到正确的根Hash，就可以用它来校验Hash列表了，然后通过校验后的Hash列表校验数据块。 
这里写图片描述&lt;/p&gt;

&lt;p&gt;3、 Merkle Tree&lt;/p&gt;

&lt;p&gt;Merkle Tree可以看做Hash List的泛化（Hash List可以看作一种特殊的Merkle Tree，即树高为2的多叉Merkle Tree）。&lt;/p&gt;

&lt;p&gt;在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应地哈希和它对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希就结婚生子，得到了一个”子哈希“。如果最底层的哈希总数是单数，那到最后必然出现一个单身哈希，这种情况就直接对它进行哈希运算，所以也能得到它的子哈希。于是往上推，依然是一样的方式，可以得到数目更少的新一级哈希，最终必然形成一棵倒挂的树，到了树根的这个位置，这一代就剩下一个根哈希了，我们把它叫做 Merkle Root[3]。&lt;/p&gt;

&lt;p&gt;在p2p网络下载网络之前，先从可信的源获得文件的Merkle Tree树根。一旦获得了树根，就可以从其他从不可信的源获取Merkle tree。通过可信的树根来检查接受到的Merkle Tree。如果Merkle Tree是损坏的或者虚假的，就从其他源获得另一个Merkle Tree，直到获得一个与可信树根匹配的Merkle Tree。&lt;/p&gt;

&lt;p&gt;Merkle Tree和Hash List的主要区别是，可以直接下载并立即验证Merkle Tree的一个分支。因为可以将文件切分成小的数据块，这样如果有一块数据损坏，仅仅重新下载这个数据块就行了。如果文件非常大，那么Merkle tree和Hash list都很到，但是Merkle tree可以一次下载一个分支，然后立即验证这个分支，如果分支验证通过，就可以下载数据了。而Hash list只有下载整个hash list才能验证。 
　　这里写图片描述&lt;/p&gt;

&lt;p&gt;Merkle Tree的特点
MT是一种树，大多数是二叉树，也可以多叉树，无论是几叉树，它都具有树结构的所有特点；
Merkle Tree的叶子节点的value是数据集合的单元数据或者单元数据HASH。
非叶子节点的value是根据它下面所有的叶子节点值，然后按照Hash算法计算而得出的。[4][5] 
　　
通常，加密的hash方法像SHA-2和MD5用来做hash。但如果仅仅防止数据不是蓄意的损坏或篡改，可以改用一些安全性低但效率高的校验和算法，如CRC。&lt;/p&gt;

&lt;p&gt;Second Preimage Attack: Merkle tree的树根并不表示树的深度，这可能会导致second-preimage attack，即攻击者创建一个具有相同Merkle树根的虚假文档。一个简单的解决方法在Certificate Transparency中定义：当计算叶节点的hash时，在hash数据前加0x00。当计算内部节点是，在前面加0x01。另外一些实现限制hash tree的根，通过在hash值前面加深度前缀。因此，前缀每一步会减少，只有当到达叶子时前缀依然为正，提取的hash链才被定义为有效。&lt;/p&gt;

&lt;p&gt;Merkle Tree的操作
1、创建Merckle Tree&lt;/p&gt;

&lt;p&gt;　　加入最底层有9个数据块。&lt;/p&gt;

&lt;p&gt;　　step1：（红色线）对数据块做hash运算，Node0i = hash(Data0i), i=1,2,…,9&lt;/p&gt;

&lt;p&gt;　　step2: （橙色线）相邻两个hash块串联，然后做hash运算，Node1((i+1)/2) = hash(Node0i+Node0(i+1)), i=1,3,5,7;对于i=9, Node1((i+1)/2) = hash(Node0i)&lt;/p&gt;

&lt;p&gt;　　step3: （黄色线）重复step2&lt;/p&gt;

&lt;p&gt;　　step4：（绿色线）重复step2&lt;/p&gt;

&lt;p&gt;　　step5：（蓝色线）重复step2，生成Merkle Tree Root 
这里写图片描述 
易得，创建Merkle Tree是O(n)复杂度(这里指O(n)次hash运算)，n是数据块的大小。得到Merkle Tree的树高是log(n)+1。&lt;/p&gt;

&lt;p&gt;2、检索数据块&lt;/p&gt;

&lt;p&gt;为了更好理解，我们假设有A和B两台机器，A需要与B相同目录下有8个文件，文件分别是f1 f2 f3 ….f8。这个时候我们就可以通过Merkle Tree来进行快速比较。假设我们在文件创建的时候每个机器都构建了一个Merkle Tree。具体如下图: 
这里写图片描述 
从上图可得知，叶子节点node7的value = hash(f1),是f1文件的HASH;而其父亲节点node3的value = hash(v7, v8)，也就是其子节点node7 node8的值得HASH。就是这样表示一个层级运算关系。root节点的value其实是所有叶子节点的value的唯一特征。&lt;/p&gt;

&lt;p&gt;　　假如A上的文件5与B上的不一样。我们怎么通过两个机器的merkle treee信息找到不相同的文件? 这个比较检索过程如下:&lt;/p&gt;

&lt;p&gt;　　Step1. 首先比较v0是否相同,如果不同，检索其孩子node1和node2.&lt;/p&gt;

&lt;p&gt;　　Step2. v1 相同，v2不同。检索node2的孩子node5 node6;&lt;/p&gt;

&lt;p&gt;　　Step3. v5不同，v6相同，检索比较node5的孩子node 11 和node 12&lt;/p&gt;

&lt;p&gt;　　Step4. v11不同，v12相同。node 11为叶子节点，获取其目录信息。&lt;/p&gt;

&lt;p&gt;　　Step5. 检索比较完毕。&lt;/p&gt;

&lt;p&gt;　　以上过程的理论复杂度是Log(N)。过程描述图如下:&lt;/p&gt;

&lt;p&gt;这里写图片描述 
从上图可以得知真个过程可以很快的找到对应的不相同的文件。&lt;/p&gt;

&lt;p&gt;3、更新，插入和删除&lt;/p&gt;

&lt;p&gt;　　虽然网上有很多关于Merkle Tree的资料，但大部分没有涉及Merkle Tree的更新、插入和删除操作，讨论Merkle Tree的检索和遍历的比较多。我也是非常困惑，一种树结构的操作肯定不仅包括查找，也包括更新、插入和删除的啊。后来查到stackexchange上的一个问题，才稍微有点明白，原文见[6]。&lt;/p&gt;

&lt;p&gt;　　对于Merkle Tree数据块的更新操作其实是很简单的，更新完数据块，然后接着更新其到树根路径上的Hash值就可以了，这样不会改变Merkle Tree的结构。但是，插入和删除操作肯定会改变Merkle Tree的结构，如下图，一种插入操作是这样的： 
这里写图片描述 
插入数据块0后(考虑数据块的位置)，Merkle Tree的结构是这样的： 
这里写图片描述 
而[6]中的同学在考虑一种插入的算法，满足下面条件：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;re-hashing操作的次数控制在log(n)以内&lt;/li&gt;
  &lt;li&gt;数据块的校验在log(n)+1以内&lt;/li&gt;
  &lt;li&gt;除非原始树的n是偶数，插入数据后的树没有孤儿，并且如果有孤儿，那么孤儿是最后一个数据块&lt;/li&gt;
  &lt;li&gt;数据块的顺序保持一致&lt;/li&gt;
  &lt;li&gt;插入后的Merkle Tree保持平衡&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后上面的插入结果就会变成这样： 
这里写图片描述 
根据[6]中回答者所说，Merkle Tree的插入和删除操作其实是一个工程上的问题，不同问题会有不同的插入方法。如果要确保树是平衡的或者是树高是log(n)的，可以用任何的标准的平衡二叉树的模式，如AVL树，红黑树，伸展树，2-3树等。这些平衡二叉树的更新模式可以在O(lgn)时间内完成插入操作，并且能保证树高是O(lgn)的。那么很容易可以看出更新所有的Merkle Hash可以在O((lgn)2)时间内完成（对于每个节点如要更新从它到树根O(lgn)个节点，而为了满足树高的要求需要更新O(lgn)个节点）。如果仔细分析的话，更新所有的hash实际上可以在O(lgn)时间内完成，因为要改变的所有节点都是相关联的，即他们要不是都在从某个叶节点到树根的一条路径上，或者这种情况相近。&lt;/p&gt;

&lt;p&gt;[6]的回答者说实际上Merkle Tree的结构(是否平衡，树高限制多少)在大多数应用中并不重要，而且保持数据块的顺序也在大多数应用中也不需要。因此，可以根据具体应用的情况，设计自己的插入和删除操作。一个通用的Merkle Tree插入删除操作是没有意义的。&lt;/p&gt;

&lt;p&gt;Merkle Tree的应用
1、数字签名&lt;/p&gt;

&lt;p&gt;最初Merkle Tree目的是高效的处理Lamport one-time signatures。 每一个Lamport key只能被用来签名一个消息，但是与Merkle tree结合可以来签名多条Merkle。这种方法成为了一种高效的数字签名框架，即Merkle Signature Scheme。&lt;/p&gt;

&lt;p&gt;2、P2P网络&lt;/p&gt;

&lt;p&gt;在P2P网络中，Merkle Tree用来确保从其他节点接受的数据块没有损坏且没有被替换，甚至检查其他节点不会欺骗或者发布虚假的块。大家所熟悉的BT下载就是采用了P2P技术来让客户端之间进行数据传输，一来可以加快数据下载速度，二来减轻下载服务器的负担。BT即BitTorrent，是一种中心索引式的P2P文件分分析通信协议[7]。&lt;/p&gt;

&lt;p&gt;要进下载必须从中心索引服务器获取一个扩展名为torrent的索引文件（即大家所说的种子），torrent文件包含了要共享文件的信息，包括文件名，大小，文件的Hash信息和一个指向Tracker的URL[8]。Torrent文件中的Hash信息是每一块要下载的文件内容的加密摘要，这些摘要也可运行在下载的时候进行验证。大的torrent文件是Web服务器的瓶颈，而且也不能直接被包含在RSS或gossiped around(用流言传播协议进行传播)。一个相关的问题是大数据块的使用，因为为了保持torrent文件的非常小，那么数据块Hash的数量也得很小，这就意味着每个数据块相对较大。大数据块影响节点之间进行交易的效率，因为只有当大数据块全部下载下来并校验通过后，才能与其他节点进行交易。&lt;/p&gt;

&lt;p&gt;就解决上面两个问题是用一个简单的Merkle Tree代替Hash List。设计一个层数足够多的满二叉树，叶节点是数据块的Hash，不足的叶节点用0来代替。上层的节点是其对应孩子节点串联的hash。Hash算法和普通torrent一样采用SHA1。其数据传输过程和第一节中描述的类似。 
这里写图片描述&lt;/p&gt;

&lt;p&gt;3、Trusted Computing&lt;/p&gt;

&lt;p&gt;可信计算是可信计算组为分布式计算环境中参与节点的计算平台提供端点可信性而提出的。可信计算技术在计算平台的硬件层引入可信平台模块(Trusted Platform，TPM)，实际上为计算平台提供了基于硬件的可信根(Root of trust，RoT)。从可信根出发，使用信任链传递机制，可信计算技术可对本地平台的硬件及软件实施逐层的完整性度量，并将度量结果可靠地保存再TPM的平台配置寄存器(Platform configuration register，PCR)中，此后远程计算平台可通过远程验证机制(Remote Attestation)比对本地PCR中度量结果，从而验证本地计算平台的可信性。可信计算技术让分布式应用的参与节点摆脱了对中心服务器的依赖，而直接通过用户机器上的TPM芯片来建立信任，使得创建扩展性更好、可靠性更高、可用性更强的安全分布式应用成为可能[10]。可信计算技术的核心机制是远程验证(remote attestation),分布式应用的参与结点正是通过远程验证机制来建立互信,从而保障应用的安全。 
这里写图片描述&lt;/p&gt;

&lt;p&gt;文献[10]提出了一种基于Merkle Tree的远程验证机制，其核心是完整性度量值哈希树。&lt;/p&gt;

&lt;p&gt;首先,RAMT 在内核中维护的不再是一张完整性度量值列表(ML),而是一棵完整性度量值哈希树(integrity measurement hash tree,简称IMHT).其中,IMHT的叶子结点存储的数据对象是待验证计算平台上被度量的各种程序的完整性哈希值,而其内部结点则依据Merkle 哈希树的构建规则由子结点的连接的哈希值动态生成。&lt;/p&gt;

&lt;p&gt;其次,为了维护IMHT 叶子结点的完整性,RAMT 需要使用TPM 中的一段存储器来保存IMHT 可信根哈希的值。&lt;/p&gt;

&lt;p&gt;再次,RAMT 的完整性验证过程基于认证路径(authentication path)实施.认证路径是指IMHT 上从待验证叶子结点到根哈希的路径。&lt;/p&gt;

&lt;p&gt;4、IPFS&lt;/p&gt;

&lt;p&gt;IPFS(InterPlanetary File System)是很多NB的互联网技术的综合体，如DHT( Distributed HashTable，分布式哈希表)，Git版本控制系统，Bittorrent等。它创建了一个P2P的集群，这个集群允许IPFS对象的交换。全部的IPFS对象形成了一个被称作Merkle DAG的加密认证数据结构。&lt;/p&gt;

&lt;p&gt;IPFS对象是一个含有两个域的数据结构:&lt;/p&gt;

&lt;p&gt;Data – 非结构的二进制数据，大小小于256kB
Links – 一个Link数据结构的数组。IPFS对象通过他们链接到其他对象
Link数据结构包含三个域：&lt;/p&gt;

&lt;p&gt;Name – Link的名字
Hash – Link链接到对象的Hash
Size – Link链接到对象的累积大小，包括它的Links
这里写图片描述 
通过Name和Links，IPFS的集合组成了一个Merkle DAG（有向无环图）。&lt;/p&gt;

&lt;p&gt;这里写图片描述 
对于小文件（&amp;lt;256kB），是一个没有Links的IPFS对象。 
这里写图片描述&lt;/p&gt;

&lt;p&gt;对于大文件，被表示为一个文件块(&amp;lt;256kB)的集合。只有拥有最小的Data的对象来代表这个大文件。这个对象的Links的名字都为空字符串。 
这里写图片描述 
这里写图片描述 
目录结构：目录是没有数据的IPFS对象，它的链接指向其包含的文件和目录。 
这里写图片描述 
IPFS可以表示Git使用的数据结构，Git commit object。Commit Object主要的特点是他有一个或多个名为’parent0’和‘parent1’等的链接（这些链接指向前一个版本），以及一个名为object的对象(在Git中成为tree)指向引用这个commit的文件系统结构。 
这里写图片描述&lt;/p&gt;

&lt;p&gt;5、BitCoin和Ethereum[12][13]&lt;/p&gt;

&lt;p&gt;Merkle Proof最早的应用是Bitcoin，它是由中本聪在2009年描述并创建的。Bitcoin的Blockchain利用Merkle proofs来存储每个区块的交易。 
　　这里写图片描述&lt;/p&gt;

&lt;p&gt;而这样做的好处，也就是中本聪描述到的“简化支付验证”（Simplified Payment Verification，SPV）的概念:一个“轻客户端”（light client）可以仅下载链的区块头即每个区块中的80byte的数据块，仅包含五个元素，而不是下载每一笔交易以及每一个区块：&lt;/p&gt;

&lt;p&gt;上一区块头的哈希值
时间戳
挖矿难度值
工作量证明随机数（nonce）
包含该区块交易的Merkle Tree的根哈希 
如果客户端想要确认一个交易的状态，它只需简单的发起一个Merkle proof请求，这个请求显示出这个特定的交易在Merkle trees的一个之中，而且这个Merkle Tree的树根在主链的一个区块头中。
但是Bitcoin的轻客户端有它的局限。一个局限是，尽管它可以证明包含的交易，但是它不能进行涉及当前状态的证明（如数字资产的持有，名称注册，金融合约的状态等）。&lt;/p&gt;

&lt;p&gt;Bitcoin如何查询你当前有多少币？一个比特币轻客户端，可以使用一种协议，它涉及查询多个节点，并相信其中至少会有一个节点会通知你，关于你的地址中任何特定的交易支出，而这可以让你实现更多的应用。但对于其他更为复杂的应用而言，这些远远是不够的。一笔交易影响的确切性质（precise nature），可以取决于此前的几笔交易，而这些交易本身则依赖于更为前面的交易，所以最终你可以验证整个链上的每一笔交易。为了解决这个问题，Ethereum的Merkle Tree的概念，会更进一步。&lt;/p&gt;

&lt;p&gt;Ethereum的Merkle Proof
每个以太坊区块头不是包括一个Merkle树，而是为三种对象设计的三棵树：&lt;/p&gt;

&lt;p&gt;交易Transaction
收据Receipts(本质上是显示每个交易影响的多块数据)
状态State 
这里写图片描述
这使得一个非常先进的轻客户端协议成为了可能，它允许轻客户端轻松地进行并核实以下类型的查询答案：
这笔交易被包含在特定的区块中了么？
告诉我这个地址在过去30天中，发出X类型事件的所有实例（例如，一个众筹合约完成了它的目标）
目前我的账户余额是多少？
这个账户是否存在？
假如在这个合约中运行这笔交易，它的输出会是什么？ 
第一种是由交易树（transaction tree）来处理的；第三和第四种则是由状态树（state tree）负责处理，第二种则由收据树（receipt tree）处理。计算前四个查询任务是相当简单的。服务器简单地找到对象，获取Merkle分支，并通过分支来回复轻客户端。
第五种查询任务同样也是由状态树处理，但它的计算方式会比较复杂。这里，我们需要构建一个Merkle状态转变证明（Merkle state transition proof）。从本质上来讲，这样的证明也就是在说“如果你在根S的状态树上运行交易T，其结果状态树将是根为S’，log为L，输出为O” （“输出”作为存在于以太坊的一种概念，因为每一笔交易都是一个函数调用；它在理论上并不是必要的）。&lt;/p&gt;

&lt;p&gt;为了推断这个证明，服务器在本地创建了一个假的区块，将状态设为 S，并在请求这笔交易时假装是一个轻客户端。也就是说，如果请求这笔交易的过程，需要客户端确定一个账户的余额，这个轻客户端(由服务器模拟的)会发出一个余额查询请求。如果需要轻客户端在特点某个合约的存储中查询特定的条目，这个轻客户端就会发出这样的请求。也就是说服务器(通过模拟一个轻客户端)正确回应所有自己的请求，但服务器也会跟踪它所有发回的数据。&lt;/p&gt;

&lt;p&gt;然后，服务器从上述的这些请求中把数据合并并把数据以一个证明的方式发送给客户端。&lt;/p&gt;

&lt;p&gt;然后，客户端会进行相同的步骤，但会将服务器提供的证明作为一个数据库来使用。如果客户端进行步骤的结果和服务器提供的是一样的话，客户端就接受这个证明。 
这里写图片描述&lt;/p&gt;

&lt;p&gt;MPT(Merkle Patricia Trees)
前面我们提到，最为简单的一种Merkle Tree大多数情况下都是一棵二叉树。然而，Ethereum所使用的Merkle Tree则更为复杂，我们称之为“梅克尔.帕特里夏树”（Merkle Patricia tree）。&lt;/p&gt;

&lt;p&gt;对于验证属于list格式（本质上来讲，它就是一系列前后相连的数据块）的信息而言，二叉Merkle Tree是非常好的数据结构。对于交易树来说，它们也同样是不错的，因为一旦树已经建立，花多少时间来编辑这棵树并不重要，树一旦建立了，它就会永远存在并且不会改变。&lt;/p&gt;

&lt;p&gt;但是，对于状态树，情况会更复杂些。以太坊中的状态树基本上包含了一个键值映射，其中的键是地址，而值包括账户的声明、余额、随机数nounce、代码以及每一个账户的存储（其中存储本身就是一颗树）。例如，摩登测试网络（the Morden testnet ）的创始状态如下所示： 
这里写图片描述 
然而，不同于交易历史记录，状态树需要经常地进行更新：账户余额和账户的随机数nonce经常会更变，更重要的是，新的账户会频繁地插入，存储的键（ key）也会经常被插入以及删除。我们需要这样的数据结构，它能在一次插入、更新、删除操作后快速计算到树根，而不需要重新计算整个树的Hash。这种数据结构同样得包括两个非常好的第二特征：&lt;/p&gt;

&lt;p&gt;树的深度是有限制的，即使考虑攻击者会故意地制造一些交易，使得这颗树尽可能地深。不然，攻击者可以通过操纵树的深度，执行拒绝服务攻击（DOS attack），使得更新变得极其缓慢。
树的根只取决于数据，和其中的更新顺序无关。换个顺序进行更新，甚至重新从头计算树，并不会改变根。 
MPT是最接近同时满足上面的性质的的数据结构。MPT的工作原理的最简单的解释是，值通过键来存储，键被编码到搜索树必须要经过的路径中。每个节点有16个孩子，因此路径又16进制的编码决定：例如，键‘dog’的16进制编码是6 4 6 15 6 7，所以从root开始到第六个分支，然后到第四个，再到第六个，再到第十五个，这样依次进行到达树的叶子。
在实践中，当树稀少时也会有一些额外的优化，我们会使过程更为有效，但这是基本的原则。&lt;/p&gt;

&lt;p&gt;6、其他应用&lt;/p&gt;

&lt;p&gt;用到Merkle Tree的应用还有很多，比如Git，Amazon Dynamo，Apache Wave Protocol，Tahoe-LAFS backup system，Certificate Transparency framework，NoSQL systems like Apache Cassadra and Riak等&lt;/p&gt;

&lt;p&gt;参考
[1] https://en.wikipedia.org/wiki/Merkle_tree&lt;/p&gt;

&lt;p&gt;[2] https://en.wikipedia.org/wiki/Hash_function#Hash_function_algorithms&lt;/p&gt;

&lt;p&gt;[3] http://www.jianshu.com/p/458e5890662f&lt;/p&gt;

&lt;p&gt;[4] http://blog.csdn.net/xtu_xiaoxin/article/details/8148237&lt;/p&gt;

&lt;p&gt;[5] http://blog.csdn.net/yuanrxdu/article/details/22474697?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/p&gt;

&lt;p&gt;[6] http://crypto.stackexchange.com/questions/22669/merkle-hash-tree-updates&lt;/p&gt;

&lt;p&gt;[7] https://en.wikipedia.org/wiki/BitTorrent&lt;/p&gt;

&lt;p&gt;[8] 梁成仁, 李健勇, 黄道颖, 等. 基于 Merkle 树的 BT 系统 torrent 文件优化策略[J]. 计算机工程, 2008, 34(3): 85-87.&lt;/p&gt;

&lt;p&gt;[9] http://bittorrent.org/beps/bep_0030.html&lt;/p&gt;

&lt;p&gt;[10] 徐梓耀, 贺也平, 邓灵莉. 一种保护隐私的高效远程验证机制[J]. Journal of Software, 2011, 22(2).&lt;/p&gt;

&lt;p&gt;[11] http://whatdoesthequantsay.com/2015/09/13/ipfs-introduction-by-example/&lt;/p&gt;

&lt;p&gt;[12] https://www.weusecoins.com/what-is-a-merkle-tree/&lt;/p&gt;

&lt;p&gt;[13] http://www.8btc.com/merkling-in-ethereum&lt;/p&gt;

</description>
        <pubDate>Wed, 03 Jan 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/01/03/merkle_tree.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/01/03/merkle_tree.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>ecc 椭圆曲线加密</title>
        <description>&lt;p&gt;比特币使用椭圆曲线算法生成公钥和私钥，选择的是secp256k1曲线。与RSA（Ron Rivest，Adi Shamir，Len Adleman三位天才的名字）一样，ECC（Elliptic Curves Cryptography，椭圆曲线加密）也属于公开密钥算法。&lt;/p&gt;

&lt;p&gt;一、从平行线谈起&lt;/p&gt;

&lt;p&gt;　　平行线，永不相交。没有人怀疑把：）不过到了近代这个结论遭到了质疑。平行线会不会在很远很远的地方相交了？事实上没有人见到过。所以“平行线，永不相交”只是假设（大家想想初中学习的平行公理，是没有证明的）。既然可以假设平行线永不相交，也可以假设平行线在很远很远的地方相交了。即平行线相交于无穷远点P∞（请大家闭上眼睛，想象一下那个无穷远点P∞，P∞是不是很虚幻，其实与其说数学锻炼人的抽象能力，还不如说是锻炼人的想象力）。
　　直线上出现P∞点，所带来的好处是所有的直线都相交了，且只有一个交点。这就把直线的平行与相交统一了。为与无穷远点相区别把原来平面上的点叫做平常点。&lt;/p&gt;

&lt;p&gt;　　以下是无穷远点的几个性质。&lt;/p&gt;

&lt;p&gt;　　▲直线L上的无穷远点只能有一个。（从定义可直接得出）
　　▲平面上一组相互平行的直线有公共的无穷远点。（从定义可直接得出）
　　▲ 平面上任何相交的两直线L1,L2有不同的无穷远点。（否则L1和L2有公共的无穷远点P ，则L1和L2有两个交点A、P，故假设错误。）
　　▲平面上全体无穷远点构成一条无穷远直线。（自己想象一下这条直线吧）
　　▲平面上全体无穷远点与全体平常点构成射影平面。&lt;/p&gt;

&lt;p&gt;二、射影平面坐标系&lt;/p&gt;

&lt;p&gt;　　射影平面坐标系是对普通平面直角坐标系（就是我们初中学到的那个笛卡儿平面直角坐标系）的扩展。我们知道普通平面直角坐标系没有为无穷远点设计坐标，不能表示无穷远点。为了表示无穷远点，产生了射影平面坐标系，当然射影平面坐标系同样能很好的表示旧有的平常点（数学也是“向下兼容”的）。
　　我们对普通平面直角坐标系上的点A的坐标（x,y）做如下改造：
　　令x=X/Z ，y=Y/Z（Z≠0）；则A点可以表示为（X:Y:Z）。
　　变成了有三个参量的坐标点，这就对平面上的点建立了一个新的坐标体系。&lt;/p&gt;

&lt;p&gt;　　例2.1：求点（1,2）在新的坐标体系下的坐标。
　　解：∵X/Z=1 ，Y/Z=2（Z≠0）∴X=Z，Y=2Z ∴坐标为（Z:2Z:Z），Z≠0。即（1:2:1）（2:4:2）（1.2:2.4:1.2）等形如（Z:2Z:Z），Z≠0的坐标，都是（1,2）在新的坐标体系下的坐标。&lt;/p&gt;

&lt;p&gt;　　我们也可以得到直线的方程aX+bY+cZ=0（想想为什么？提示：普通平面直角坐标系下直线一般方程是ax+by+c=0）。新的坐标体系能够表示无穷远点么？那要让我们先想想无穷远点在哪里。根据上一节的知识，我们知道无穷远点是两条平行直线的交点。那么，如何求两条直线的交点坐标？这是初中的知识，就是将两条直线对应的方程联立求解。平行直线的方程是：aX+bY+c1Z =0； aX+bY+c2Z =0  (c1≠c2)；
　　（为什么？提示：可以从斜率考虑，因为平行线斜率相同）；&lt;/p&gt;

&lt;p&gt;　　将二方程联立，求解。有c2Z= c1Z= -（aX+bY），∵c1≠c2 ∴Z=0  ∴aX+bY=0；
　　所以无穷远点就是这种形式（X：Y：0）表示。注意，平常点Z≠0，无穷远点Z=0，因此无穷远直线对应的方程是Z=0。&lt;/p&gt;

&lt;p&gt;　　例2.2：求平行线L1：X+2Y+3Z=0 与L2：X+2Y+Z=0 相交的无穷远点。
　　解：因为L1∥L2 所以有Z=0， X+2Y=0；所以坐标为（-2Y:Y:0），Y≠0。即（-2:1:0）（-4:2:0）（-2.4:1.2:0）等形如（-2Y:Y:0），Y≠0的坐标，都表示这个无穷远点。&lt;/p&gt;

&lt;p&gt;　　看来这个新的坐标体系能够表示射影平面上所有的点，我们就把这个能够表示射影平面上所有点的坐标体系叫做射影平面坐标系。&lt;/p&gt;

&lt;p&gt;练习：
　　1、求点A(2,4) 在射影平面坐标系下的坐标。
　　2、求射影平面坐标系下点(4.5:3:0.5)，在普通平面直角坐标系下的坐标。
　　3、求直线X+Y+Z=0上无穷远点的坐标。
　　4、判断：直线aX+bY+cZ=0上的无穷远点 和 无穷远直线与直线aX+bY=0的交点，是否是同一个点？&lt;/p&gt;

&lt;p&gt;三、椭圆曲线&lt;/p&gt;

&lt;p&gt;　　上一节，我们建立了射影平面坐标系，这一节我们将在这个坐标系下建立椭圆曲线方程。因为我们知道，坐标中的曲线是可以用方程来表示的（比如：单位圆方程是x2+y2=1）。椭圆曲线是曲线，自然椭圆曲线也有方程。&lt;/p&gt;

&lt;p&gt;　　椭圆曲线的定义：
　　一条椭圆曲线是在射影平面上满足方程Y2Z+a1XYZ+a3YZ2=X3+a2X2Z+a4XZ2+a6Z3   —————-[3-1]的所有点的集合，且曲线上的每个点都是非奇异（或光滑）的。&lt;/p&gt;

&lt;p&gt;　　定义详解：&lt;/p&gt;

&lt;p&gt;　　▲ Y2Z+a1XYZ+a3YZ2 = X3+a2X2Z+a4XZ2+a6Z3是Weierstrass方程（维尔斯特拉斯，Karl Theodor Wilhelm Weierstrass,1815-1897），是一个齐次方程。&lt;/p&gt;

&lt;p&gt;　　▲ 椭圆曲线的形状，并不是椭圆的。只是因为椭圆曲线的描述方程，类似于计算一个椭圆周长的方程（计算椭圆周长的方程，我没有见过，而对椭圆线积分（设密度为1）是求不出来的。谁知道这个方程，请告诉我呀^_^），故得名。&lt;/p&gt;

&lt;p&gt;　　我们来看看椭圆曲线是什么样的。
&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/ecc_1.gif&quot; /&gt;
　　▲ 所谓“非奇异”或“光滑”的，在数学中是指曲线上任意一点的偏导数Fx(x,y,z)，Fy(x,y,z)，Fz(x,y,z)不能同时为0。如果你没有学过高等数学，可以这样理解这个词，即满足方程的任意一点都存在切线。&lt;/p&gt;

&lt;p&gt;　　下面两个方程都不是椭圆曲线，尽管他们是方程[3-1]的形式。
&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/ecc_2.gif&quot; /&gt;
　　因为他们在（0:0:1）点处（即原点）没有切线。&lt;/p&gt;

&lt;p&gt;　　▲椭圆曲线上有一个无穷远点O∞（0:1:0），因为这个点满足方程[3-1]。&lt;/p&gt;

&lt;p&gt;　　知道了椭圆曲线上的无穷远点。我们就可以把椭圆曲线放到普通平面直角坐标系上了。因为普通平面直角坐标系只比射影平面坐标系少无穷远点。我们在普通平面直角坐标系上，求出椭圆曲线上所有平常点组成的曲线方程，再加上无穷远点O∞（0:1:0），不就构成椭圆曲线了么？&lt;/p&gt;

&lt;p&gt;　　我们设x=X/Z ，y=Y/Z代入方程[3-1]得到：
　　y2+a1xy+a3y = x3+a2x2+a4x+a6 ————————-[3-2]&lt;/p&gt;

&lt;p&gt;　　也就是说满足方程[3-2]的光滑曲线加上一个无穷远点O∞，组成了椭圆曲线。为了方便运算，表述，以及理解，今后论述椭圆曲线将主要使用[3-2]的形式。&lt;/p&gt;

&lt;p&gt;　　本节的最后，我们谈一下求椭圆曲线一点的切线斜率问题。
　　由椭圆曲线的定义可以知道，椭圆曲线是光滑的，所以椭圆曲线上的平常点都有切线。而切线最重要的一个参数就是斜率k。&lt;/p&gt;

&lt;p&gt;　　例3.1：求椭圆曲线方程y2+a1xy+a3y=x3+a2x2+a4x+a6上，平常点A(x,y)的切线的斜率k。
　　解：令F(x,y)= y2+a1xy+a3y-x3-a2x2-a4x-a6
　　求偏导数
　　Fx(x,y)= a1y-3x2-2a2x-a4
　　Fy(x,y)= 2y+a1x +a3
　　则导数为：f’(x)=- Fx(x,y)/ Fy(x,y)=-( a1y-3x2-2a2x-a4)/(2y+a1x +a3)
　　　　　　　　 = (3x2+2a2x+a4-a1y) /(2y+a1x +a3)
　　所以k=(3x2+2a2x+a4-a1y) /(2y+a1x +a3)  ————————[3-3]&lt;/p&gt;

&lt;p&gt;　　看不懂解题过程没有关系，记住结论[3-3]就可以了。&lt;/p&gt;

&lt;p&gt;练习：
      1、将给出图例的椭圆曲线方程Y2Z=X3-XZ2 和Y2Z=X3+XZ2+Z3转换成普通平面直角坐标系上的方程。&lt;/p&gt;

&lt;p&gt;四、椭圆曲线上的加法&lt;/p&gt;

&lt;p&gt;　　上一节，我们已经看到了椭圆曲线的图象，但点与点之间好象没有什么联系。我们能不能建立一个类似于在实数轴上加法的运算法则呢？天才的数学家找到了这一运算法则&lt;/p&gt;

&lt;p&gt;　　自从近世纪代数学引入了群、环、域的概念，使得代数运算达到了高度的统一。比如数学家总结了普通加法的主要特征，提出了加群（也叫交换群，或Abel（阿贝尔）群），在加群的眼中。实数的加法和椭圆曲线的上的加法没有什么区别。这也许就是数学抽象把：）。关于群以及加群的具体概念请参考近世代数方面的数学书。&lt;/p&gt;

&lt;p&gt;　　运算法则：任意取椭圆曲线上两点P、Q （若P、Q两点重合，则做P点的切线）做直线交于椭圆曲线的另一点R’，过R’做y轴的平行线交于R。我们规定P+Q=R。（如图）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/ecc_3.gif&quot; /&gt;
 法则详解：
　　▲这里的+不是实数中普通的加法，而是从普通加法中抽象出来的加法，他具备普通加法的一些性质，但具体的运算法则显然与普通加法不同。&lt;/p&gt;

&lt;p&gt;　　▲根据这个法则，可以知道椭圆曲线无穷远点O∞与椭圆曲线上一点P的连线交于P’，过P’作y轴的平行线交于P，所以有 无穷远点 O∞+ P = P 。这样，无穷远点 O∞的作用与普通加法中零的作用相当（0+2=2），我们把无穷远点 O∞ 称为 零元。同时我们把P’称为P的负元（简称，负P；记作，-P）。（参见下图）
&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/ecc_4.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　▲根据这个法则，可以得到如下结论 ：如果椭圆曲线上的三个点A、B、C，处于同一条直线上，那么他们的和等于零元，即A+B+C= O∞&lt;/p&gt;

&lt;p&gt;　　▲k个相同的点P相加，我们记作kP。如下图：P+P+P = 2P+P = 3P。
&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/ecc_5.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　下面，我们利用P、Q点的坐标(x1,y1)，(x2,y2)，求出R=P+Q的坐标(x4,y4)。&lt;/p&gt;

&lt;p&gt;　　例4.1：求椭圆曲线方程y2+a1xy+a3y=x3+a2x2+a4x+a6上，平常点P(x1,y1)，Q(x2,y2)的和R(x4,y4)的坐标。
　　解：（1）先求点-R(x3,y3)
　　因为P,Q,-R三点共线，故设共线方程为y=kx+b,其中
　　若P≠Q(P,Q两点不重合) 则
　　直线斜率k=(y1-y2)/(x1-x2)
　　若P=Q(P,Q两点重合) 则直线为椭圆曲线的切线，故由例3.1可知：
　　k=(3x2+2a2x+a4 -a1y) /(2y+a1x+a3)&lt;/p&gt;

&lt;p&gt;　　因此P,Q,-R三点的坐标值就是方程组：
　　y2+a1xy+a3y=x3+a2x2+a4x+a6    —————–[1] 
　　y=(kx+b)                     —————–[2]
的解。&lt;/p&gt;

&lt;p&gt;　　将[2]，代入[1] 有
　　(kx+b)2+a1x(kx+b)+a3(kx+b) =x3+a2x2+a4x+a6    ——–[3]
　　对[3]化为一般方程，根据三次方程根与系数关系（当三次项系数为1时；-x1x2x3 等于常数项系数， x1x2+x2x3+x3x1等于一次项系数，-(x1+x2+x3)等于二次项系数。）
　　所以-(x1+x2+x3)=a2-ka1-k2
　　x3=k2+ka1+a2+x1+x2;———————求出点-R的横坐标
　　因为k=(y1-y3)/(x1-x3) 故
　　y3=y1-k(x1-x3);——————————-求出点-R的纵坐标&lt;/p&gt;

&lt;p&gt;　　（2）利用-R求R
　　显然有 x4=x3= k2+ka1+a2+x1+x2; ————求出点R的横坐标
　　而y3 y4 为 x=x4时 方程y2+a1xy+a3y=x3+a2x2+a4x+a6的解
　　化为一般方程y2+(a1x+a3)y-(x3+a2x2+a4x+a6)=0 , 根据二次方程根与系数关系得：
　　-(a1x+a3)=y3+y4
　　故y4=-y3-(a1x+a3)=k(x1-x4)-y1-(a1x4+a3); —————求出点R的纵坐标
　　即：
　　x4=k2+ka1+a2+x1+x2;
　　y4=k(x1-x4)-y1-a1x4-a3;&lt;/p&gt;

&lt;p&gt;　　本节的最后，提醒大家注意一点，以前提供的图像可能会给大家产生一种错觉，即椭圆曲线是关于x轴对称的。事实上，椭圆曲线并不一定关于x轴对称。如下图的y2-xy=x3+1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/ecc_6.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;五、密码学中的椭圆曲线&lt;/p&gt;

&lt;p&gt;　　我们现在基本上对椭圆曲线有了初步的认识，这是值得高兴的。但请大家注意，前面学到的椭圆曲线是连续的，并不适合用于加密；所以，我们必须把椭圆曲线变成离散的点。&lt;/p&gt;

&lt;p&gt;　　让我们想一想，为什么椭圆曲线为什么连续？是因为椭圆曲线上点的坐标，是实数的（也就是说前面讲到的椭圆曲线是定义在实数域上的），实数是连续的，导致了曲线的连续。因此，我们要把椭圆曲线定义在有限域上（顾名思义，有限域是一种只有由有限个元素组成的域）。&lt;/p&gt;

&lt;p&gt;　　域的概念是从我们的有理数，实数的运算中抽象出来的，严格的定义请参考近世代数方面的数。简单的说，域中的元素同有理数一样，有自己得加法、乘法、除法、单位元(1)，零元(0),并满足交换率、分配率。&lt;/p&gt;

&lt;p&gt;　　下面，我们给出一个有限域Fp，这个域只有有限个元素。&lt;/p&gt;

&lt;p&gt;　　Fp中只有p（p为素数）个元素0,1,2 …… p-2,p-1；
　　Fp 的加法（a+b）法则是 a+b≡c (mod p)；即，(a+c)÷p的余数 和c÷p的余数相同。
　　Fp 的乘法(a×b)法则是  a×b≡c (mod p)；
　　Fp 的除法(a÷b)法则是  a/b≡c (mod p)；即 a×b-1≡c  (mod p)；（b-1也是一个0到p-1之间的整数，但满足b×b-1≡1 (mod p)；具体求法可以参考初等数论，或我的另一篇文章）。
　　Fp 的单位元是1，零元是 0。&lt;/p&gt;

&lt;p&gt;　　同时，并不是所有的椭圆曲线都适合加密。y2=x3+ax+b是一类可以用来加密的椭圆曲线，也是最为简单的一类。下面我们就把y2=x3+ax+b 这条曲线定义在Fp上：&lt;/p&gt;

&lt;p&gt;　　选择两个满足下列条件的小于p(p为素数)的非负整数a、b
　　4a3+27b2≠0　(mod p)
　　则满足下列方程的所有点(x,y)，再加上 无穷远点O∞ ，构成一条椭圆曲线。
　　y2=x3+ax+b  (mod p)
　　其中 x,y属于0到p-1间的整数，并将这条椭圆曲线记为Ep(a,b)。&lt;/p&gt;

&lt;p&gt;　　我们看一下y2=x3+x+1  (mod 23)的图像&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/ecc_7.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　是不是觉得不可思议？椭圆曲线，怎么变成了这般模样，成了一个一个离散的点？
　　椭圆曲线在不同的数域中会呈现出不同的样子，但其本质仍是一条椭圆曲线。举一个不太恰当的例子，好比是水，在常温下，是液体；到了零下，水就变成冰，成了固体；而温度上升到一百度，水又变成了水蒸气。但其本质仍是H2O。&lt;/p&gt;

&lt;p&gt;　　Fp上的椭圆曲线同样有加法，但已经不能给以几何意义的解释。不过，加法法则和实数域上的差不多，请读者自行对比。&lt;/p&gt;

&lt;p&gt;　　1. 无穷远点 O∞是零元，有O∞+ O∞= O∞，O∞+P=P
　　2. P(x,y)的负元是 (x,-y)，有P+(-P)= O∞
　　3. P(x1,y1),Q(x2,y2)的和R(x3,y3) 有如下关系：
　　x3≡k2-x1-x2(mod p) 
　　y3≡k(x1-x3)-y1(mod p)
　　其中若P=Q 则 k=(3x2+a)/2y1  若P≠Q，则k=(y2-y1)/(x2-x1)&lt;/p&gt;

&lt;p&gt;　　例5.1 已知E23(1,1)上两点P(3,10)，Q(9,7)，求1)-P，2)P+Q，3) 2P。
　　解 1)  –P的值为(3,-10)
　　　 2)  k=(7-10)/(9-3)=-1/2，2的乘法逆元为12 因为2&lt;em&gt;12≡1 (mod 23)
　　　　　k≡-1&lt;/em&gt;12 (mod 23) 故 k=11。
　　　　　x=112-3-9=109≡17 (mod 23);
　　　　　y=11[3-(-6)]-10=89≡20 (mod 23)
　　　　　故P+Q的坐标为(17,20)
　　　 3)  k=[3(32)+1]/(2*10)=1/4≡6 (mod 23)
　　　　　x=62-3-3=30≡20 (mod 23)
　　　　　y=6(3-7)-10=-34≡12 (mod 23)
　　　　　故2P的坐标为(7,12)&lt;/p&gt;

&lt;p&gt;　　最后，我们讲一下椭圆曲线上的点的阶。
　　如果椭圆曲线上一点P，存在最小的正整数n，使得数乘nP=O∞，则将n称为P的 阶，若n不存在，我们说P是无限阶的。
　　事实上，在有限域上定义的椭圆曲线上所有的点的阶n都是存在的（证明，请参考近世代数方面的书）&lt;/p&gt;

&lt;p&gt;练习：
　　1． 求出E11(1,6)上所有的点。
　　2．已知E11(1,6)上一点G(2,7)，求2G到13G所有的值。&lt;/p&gt;

&lt;p&gt;六、椭圆曲线上简单的加密/解密&lt;/p&gt;

&lt;p&gt;　　公开密钥算法总是要基于一个数学上的难题。比如RSA 依据的是：给定两个素数p、q 很容易相乘得到n，而对n进行因式分解却相对困难。那椭圆曲线上有什么难题呢？&lt;/p&gt;

&lt;p&gt;　　考虑如下等式：
　　K=kG  [其中 K,G为Ep(a,b)上的点，k为小于n（n是点G的阶）的整数]
　　不难发现，给定k和G，根据加法法则，计算K很容易；但给定K和G，求k就相对困难了。
　　这就是椭圆曲线加密算法采用的难题。我们把点G称为基点（base point），k（k&lt;/p&gt;

&lt;p&gt;　　现在我们描述一个利用椭圆曲线进行加密通信的过程：&lt;/p&gt;

&lt;p&gt;　　1、用户A选定一条椭圆曲线Ep(a,b)，并取椭圆曲线上一点，作为基点G。
　　2、用户A选择一个私有密钥k，并生成公开密钥K=kG。
　　3、用户A将Ep(a,b)和点K，G传给用户B。
　　4、用户B接到信息后 ，将待传输的明文编码到Ep(a,b)上一点M（编码方法很多，这里不作讨论），并产生一个随机整数r（r　　5、用户B计算点C1=M+rK；C2=rG。
　　6、用户B将C1、C2传给用户A。
　　7、用户A接到信息后，计算C1-kC2，结果就是点M。因为
          C1-kC2=M+rK-k(rG)=M+rK-r(kG)=M
　　　再对点M进行解码就可以得到明文。&lt;/p&gt;

&lt;p&gt;　　在这个加密通信中，如果有一个偷窥者H ，他只能看到Ep(a,b)、K、G、C1、C2 而通过K、G 求k 或通过C2、G求r 都是相对困难的。因此，H无法得到A、B间传送的明文信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xiazemin.github.io/MyBlog/img/ecc_8.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　密码学中，描述一条Fp上的椭圆曲线，常用到六个参量：
       T=(p,a,b,G,n,h)。
　　（p 、a 、b 用来确定一条椭圆曲线，G为基点，n为点G的阶，h 是椭圆曲线上所有点的个数m与n相除的整数部分）&lt;/p&gt;

&lt;p&gt;　　这几个参量取值的选择，直接影响了加密的安全性。参量值一般要求满足以下几个条件：&lt;/p&gt;

&lt;p&gt;　　1、p 当然越大越安全，但越大，计算速度会变慢，200位左右可以满足一般安全要求；
　　2、p≠n×h；
　　3、pt≠1 (mod n)，1≤t&amp;lt;20；
　　4、4a3+27b2≠0 (mod p)；
　　5、n 为素数；
　　6、h≤4。&lt;/p&gt;

&lt;p&gt;七、椭圆曲线在软件注册保护的应用&lt;/p&gt;

&lt;p&gt;　　我们知道将公开密钥算法作为软件注册算法的好处是Cracker很难通过跟踪验证算法得到注册机。下面，将简介一种利用Fp(a,b)椭圆曲线进行软件注册的方法。&lt;/p&gt;

&lt;p&gt;　　软件作者按如下方法制作注册机（也可称为签名过程）&lt;/p&gt;

&lt;p&gt;　　1、选择一条椭圆曲线Ep(a,b)，和基点G；
　　2、选择私有密钥k（k　　3、产生一个随机整数r（r　　4、将用户名和点R的坐标值x,y作为参数，计算SHA（Secure Hash Algorithm 安全散列算法，类似于MD5）值，即Hash=SHA(username,x,y)；
　　5、计算sn≡r - Hash * k (mod n)
　　6、将sn和Hash作为 用户名username的序列号&lt;/p&gt;

&lt;p&gt;　　软件验证过程如下：（软件中存有椭圆曲线Ep(a,b)，和基点G，公开密钥K）&lt;/p&gt;

&lt;p&gt;　　1、从用户输入的序列号中，提取sn以及Hash；
　　2、计算点R≡sn&lt;em&gt;G+Hash&lt;/em&gt;K ( mod p )，如果sn、Hash正确，其值等于软件作者签名过程中点R(x,y)的坐标，因为
　　　sn≡r-Hash&lt;em&gt;k （mod n）
　　　所以
　　　sn&lt;/em&gt;G + Hash&lt;em&gt;K
　　　=(r-Hash&lt;/em&gt;k)&lt;em&gt;G+Hash&lt;/em&gt;K
　　　=rG-Hash&lt;em&gt;kG+Hash&lt;/em&gt;K
　　　=rG- Hash&lt;em&gt;K+ Hash&lt;/em&gt;K
　　　=rG=R ；
　　3、将用户名和点R的坐标值x,y作为参数，计算H=SHA(username,x,y)；
　　4、如果H=Hash 则注册成功。如果H≠Hash ，则注册失败(为什么？提示注意点R与Hash的关联性)。&lt;/p&gt;

&lt;p&gt;　　简单对比一下两个过程：
　　作者签名用到了：椭圆曲线Ep(a,b)，基点G，私有密钥k，及随机数r。
　　软件验证用到了：椭圆曲线Ep(a,b)，基点G，公开密钥K。
　　Cracker要想制作注册机，只能通过软件中的Ep(a,b)，点G，公开密钥K ，并利用K=kG这个关系获得k后，才可以。而求k是很困难的。&lt;/p&gt;

&lt;p&gt;练习：
　　下面也是一种常于软件保护的注册算法，请认真阅读，并试回答签名过程与验证过程都用到了那些参数，Cracker想制作注册机，应该如何做。&lt;/p&gt;

&lt;p&gt;　　软件作者按如下方法制作注册机（也可称为签名过程）
　　1、选择一条椭圆曲线Ep(a,b)，和基点G；
　　2、选择私有密钥k（k　　3、产生一个随机整数r（r　　4、将用户名作为参数，计算Hash=SHA(username)；
　　5、计算 x’=x  (mod n)
　　6、计算sn≡(Hash+x’*k)/r (mod n)
　　7、将sn和x’作为 用户名username的序列号&lt;/p&gt;

&lt;p&gt;　　软件验证过程如下：(软件中存有椭圆曲线Ep(a,b)，和基点G，公开密钥K)
　　1、从用户输入的序列号中，提取sn以及x’；
　　2、将用户名作为参数，计算Hash=SHA(username)；
　　3、计算 R=(Hash&lt;em&gt;G+x’&lt;/em&gt;K)/sn，如果sn、Hash正确,其值等于软件作者签名过程中点R(x,y)，因为
　　　sn≡(Hash+x’&lt;em&gt;k)/r (mod n)
　　　所以
　　　(Hash&lt;/em&gt;G+x’&lt;em&gt;K)/sn
　　　=(Hash&lt;/em&gt;G+x’&lt;em&gt;K)/[(Hash+x’&lt;/em&gt;k)/r]
　　　=(Hash&lt;em&gt;G+x’&lt;/em&gt;K)/[(Hash&lt;em&gt;G+x’&lt;/em&gt;k&lt;em&gt;G)/(rG)]
　　　=rG&lt;/em&gt;[(Hash&lt;em&gt;G+x’&lt;/em&gt;K)/(Hash&lt;em&gt;G+x’&lt;/em&gt;K)]
　　　=rG=R (mod p)
　　4、v≡x (mod n)
　　5、如果v=x’ 则注册成功。如果v≠x’ ，则注册失败。&lt;/p&gt;

&lt;p&gt;主要参考文献&lt;/p&gt;

&lt;p&gt;　　张禾瑞，《近世代数基础》，高等教育出版社，1978
　　闵嗣鹤 严士健，《初等数论》，高等教育出版社，1982
　　段云所，《网络信息安全》第三讲，北大计算机系
　　Michael Rosing ，chapter5《Implementing Elliptic Curve Cryptography》，Softbound，1998
　　《SEC 1: Elliptic Curve Cryptography》，Certicom Corp.，2000
　　《IEEE P1363a / D9》，2001
&lt;!-- more --&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 03 Jan 2018 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2018/01/03/ecc.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2018/01/03/ecc.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>单播、多播和广播</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;　　单播在网络中得到了广泛的应用，网络上绝大部分的数据都是以单播的形式传输的，只是一般网络用户不知道而已。例如，你在收发电子邮件、浏览网页时，必须与邮件服务器、Web服务器建立连接，此时使用的就是单播数据传输方式。但是通常使用“点对点通信”（Point to Point）代替“单播”，因为“单播”一般与“多播”和“广播”相对应使用
　　　“多播”也可以称为“组播”，在网络技术的应用并不是很多，网上视频会议、网上视频点播特别适合采用多播方式。因为如果采用单播方式，逐个节点传输，有多少个目标节点，就会有多少次传送过程，这种方式显然效率极低，是不可取的；如果采用不区分目标、全部发送的广播方式，虽然一次可以传送完数据，但是显然达不到区分特定数据接收对象的目的。采用多播方式，既可以实现一次传送所有目标节点的数据，也可以达到只对特定对象传送数据的目的。&lt;/p&gt;

&lt;p&gt;　　IP网络的多播一般通过多播IP地址来实现。多播IP地址就是D类IP地址，即224.0.0.0至239.255.255.255之间的IP地址。Windows 2000中的DHCP管理器支持多播IP地址的自动分配。
　　
　　“广播”在网络中的应用较多，如客户机通过DHCP自动获得IP地址的过程就是通过广播来实现的。但是同单播和多播相比，广播几乎占用了子网内网络的所有带宽。拿开会打一个比方吧，在会场上只能有一个人发言，想象一下如果所有的人同时都用麦克风发言，那会场上就会乱成一锅粥。&lt;/p&gt;

&lt;p&gt;　　在网络中不能长时间出现大量的广播包，否则就会出现所谓的“广播风暴”。广播风暴就是网络长时间被大量的广播数据包所占用，正常的点对点通信无法正常进行，外在表现为网络速度奇慢无比。出现广播风暴的原因有很多，一块有故障的网卡，就可能长时间向网络上发送广播包而导致广播风暴。
一、单播：&lt;/p&gt;

&lt;p&gt;主机之间“一对一”的通讯模式，网络中的交换机和路由器对数据只进行转发不进行复制。如果10个客户机需要相同的数据，则服务器需要逐一传送，重复10次相同的工作。但由于其能够针对每个客户的及时响应，所以现在的网页浏览全部都是采用IP单播协议。网络中的路由器和交换机根据其目标地址选择传输路径，将 IP单播数据传送到其指定的目的地。
单播的优点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;服务器及时响应客户机的请求&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务器针对每个客户不通的请求发送不通的数据，容易实现个性化服务。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;单播的缺点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;服务器针对每个客户机发送数据流，服务器流量＝客户机数量×客户机流量；在客户数量大、每个客户机流量大的流媒体应用中服务器不堪重负。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;现有的网络带宽是金字塔结构，城际省际主干带宽仅仅相当于其所有用户带宽之和的5％。如果全部使用单播协议，将造成网络主干不堪重负。现在的P2P应用就已经使主干经常阻塞，只要有5％的客户在全速使用网络，其他人就不要玩了。而将主干扩展20倍几乎是不可能。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二、 广播：&lt;/p&gt;

&lt;p&gt;主机之间“一对所有”的通讯模式，网络对其中每一台主机发出的信号都进行无条件复制并转发，所有主机都可以接收到所有信息（不管你是否需要），由于其不用路径选择，所以其网络成本可以很低廉。有线电视网就是典型的广播型网络，我们的电视机实际上是接受到所有频道的信号，但只将一个频道的信号还原成画面。在数据网络中也允许广播的存在，但其被限制在二层交换机的局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机。
广播的优点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;网络设备简单，维护简单，布网成本低廉&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于服务器不用向每个客户机单独发送数据，所以服务器流量负载极低。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;广播的缺点：&lt;/p&gt;

&lt;p&gt;1.无法针对每个客户的要求和时间及时提供个性化服务。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;网络允许服务器提供数据的带宽有限，客户端的最大带宽＝服务总带宽。例如有线电视的客户端的线路支持100个频道（如果采用数字压缩技术，理论上可以提供 500个频道），即使服务商有更大的财力配置更多的发送设备、改成光纤主干，也无法超过此极限。也就是说无法向众多客户提供更多样化、更加个性化的服务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;广播禁止在Internet宽带网上传输。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三、组播：&lt;/p&gt;

&lt;p&gt;主机之间“一对一组”的通讯模式，也就是加入了同一个组的主机可以接受到此组内的所有数据，网络中的交换机和路由器只向有需求者复制并转发其所需数据。主机可以向路由器请求加入或退出某个组，网络中的路由器和交换机有选择的复制并传输数据，即只将组内数据传输给那些加入组的主机。这样既能一次将数据传输给多个有需要（加入组）的主机，又能保证不影响其他不需要（未加入组）的主机的其他通讯。
组播的优点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;需要相同数据流的客户端加入相同的组共享一条数据流，节省了服务器的负载。具备广播所具备的优点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于组播协议是根据接受者的需要对数据流进行复制转发，所以服务端的服务总带宽不受客户接入端带宽的限制。IP协议允许有2亿6千多万个（268435456）组播，所以其提供的服务可以非常丰富。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;此协议和单播协议一样允许在Internet宽带网上传输。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;组播的缺点：&lt;/p&gt;

&lt;p&gt;1．与单播协议相比没有纠错机制，发生丢包错包后难以弥补，但可以通过一定的容错机制和QOS加以弥补。&lt;/p&gt;

&lt;p&gt;2．现行网络虽然都支持组播的传输，但在客户认证、QOS等方面还需要完善，这些缺点在理论上都有成熟的解决方案，只是需要逐步推广应用到现存网络当中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    二层交换机是数据链路层的设备，它能够读取数据包中的MAC地址信息并根据MAC地址来进行交换。交换机内部有一个地址表，这个地址表标明了MAC地址和交换机端口的对应关系.二层交换机对广播包是不做限制的，把广播包复制到所有端口上。

 广播分二层广播和三层广播，二层广播是FFFF.FFFF.FFFF(MAC地址)，二层交换机遇到这种包就会泛洪到所有同VLAN的端口，不会过滤掉，因为如果二层交换机过滤这种包，arp广播怎么正常工作呢？没有arp，同网段的PC如何通信呢？路由器可以过滤二层广播是因为路由器是三层设备，如果路由器不过滤这种包，任何人发起的二层广播包就会到达Internet的整个范围，这样还要路由器做什么呢？路由器就是为了划分广播域用的阿。

 对于三层广播还有本地广播255.255.255.255和特定子网广播比如192.168.1.255/24之分，255.255.255.255这种本地广播是肯定没发跨越路由器的，因为一旦这种广播能跨越路由器的话，同样任何人发起的这种广播就会跑到Internet的任何角落。然而对于特定子网的广播是可以配置为允许跨路由器或者不允许跨路由器的，如果允许的话，我就可以跨越路由器对特定的子网发起三层广播。通常不要允许这类广播，因为你一旦允许了很容易造成icmp sumrf攻击的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;交换机或是路由器的复制功能猜想是：首先接收到数据，进行处理，再进行相应接口的转发，（存储一份转发多份即为复制）&lt;/p&gt;

&lt;p&gt;三层交换机接收到数据的处理流程：&lt;/p&gt;

&lt;p&gt;使用IP的设备A————————三层交换机————————使用IP的设备B&lt;/p&gt;

&lt;p&gt;　　比如A要给B发送数据，已知目的IP，那么A就用子网掩码取得网络地址，判断目的IP是否与自己在同一网段。&lt;/p&gt;

&lt;p&gt;　　如果在同一网段，但不知道转发数据所需的MAC地址，A就发送一个ARP请求，B返回其MAC地址，A用此MAC封装数据包并发送给交换机，交换机起用二层交换模块，查找MAC地址表，将数据包转发到相应的端口。&lt;/p&gt;

&lt;p&gt;　　如果目的IP地址显示不是同一网段的，那么A要实现和B的通讯，在流缓存条目中没有对应MAC地址条目，就将第一个正常数据包发送向一个缺省网关，这个缺省网关一般在操作系统中已经设好，对应第三层路由模块，所以可见对于不是同一子网的数据，最先在MAC表中放的是缺省网关的MAC地址；然后就由三层模块接收到此数据包，查询路由表以确定到达B的路由，将构造一个新的帧头，其中以缺省网关的MAC地址为源MAC地址，以主机B的MAC地址为目的MAC地址。通过一定的识别触发机制，确立主机A与B的MAC地址及转发端口的对应关系，并记录进流缓存条目表，以后的A到B的数据，就直接交由二层交换模块完成。这就通常所说的一次路由多次转发。&lt;/p&gt;

&lt;p&gt;　　 表面上看，第三层交换机是第二层交换器与路由器的合二而一，然而这种结合并非简单的物理结合，而是各取所长的逻辑结合。其重要表现是，当某一信息源的第一个数据流进行第三层交换后，其中的路由系统将会产生一个MAC地址与IP地址的映射表，并将该表存储起来，当同一信息源的后续数据流再次进入交换环境时，交换机将根据第一次产生并保存的地址映射表，直接从第二层由源地址传输到目的地址，不再经过第三路由系统处理，从而消除了路由选择时造成的网络延迟，提高了数据包的转发效率，解决了网间传输信息时路由产生的速率瓶颈。所以说，第三层交换机既可完成第二层交换机的端口交换功能，又可完成部分路由器的路由功能。即第三层交换机的交换机方案，实际上是一个能够支持多层次动态集成的解决方案，虽然这种多层次动态集成功能在某些程度上也能由传统路由器和第二层交换机搭载完成，但这种搭载方案与采用三层交换机相比，不仅需要更多的设备配置、占用更大的空间、设计更多的布线和花费更高的成本，而且数据传输性能也要差得多，因为在海量数据传输中，搭载方案中的路由器无法克服路由传输速率瓶颈。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   主机开机组播接收程序时，会向TCP/IP协议注册一个组播IP地址，所以当收到目的IP地址是这个组播组的地址时，主机就会接收。  同时它又向工作在数据链路层的网卡也注册了一个二层MAC地址，这样的话，当主机接收到一个组播报文的时候，就可以  直接现在网卡上判断是否是自己所需要的组播报文。  IGMP：Internet组管理协议，用于主机与路由器之间交互信息的一种协议。所有要加入组播组的主机和所有连接到有组播主机的子网中 的路由器都必须使用IGMP。IGMP消息不能被路由转发，只能限制在本地网段内部。IGMP的TTL参数永远是1，保证了IGMP的使用  范围。
  组播路由协议的主要功能是将组播数据从一台路由器跨越一个网络传送到另外一台路由器上。  组播路由协议分为域内组播路由协议及域间组播路由协议。
  http://wenku.baidu.com/view/b30740553c1ec5da50e27015.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;组播的转发技术：
在单播里面，数据转发的依据是数据包的目的地址，这个目的地址明确表示了一个主机的位置，但是组播数据包并不是基于ip数据包的目的地址的，它没有唯一性，因此它需要采用一种叫RTF(Reverse Path Forwarding逆向路径转发)的方式来转发数据包，它是针对转发的时候做检查，这个检查会决定是否转发还是丢弃输入的信息包，那么它的检查过程是什么样的呢？
首先要了解的是，RPF跟单播协议密切相关，所谓的逆向路径转发是基于察看有关组播源在什么地方，组播源是一个IP的单播地址，因此呢，路由器检查到达的数据包的源地址，然后查看路由表，看这个源地址可以通过哪个接口可达，如果信息包是在可返回原站点的接口上到达，那就说明这个组播数据流是从正确的方向过来的，则RPF检查成功，信息包被转发，但如果说这个数据包的原地址不是从这个接口到达的，那就说明这个组播数据包不是从最佳路经过来的，应该丢弃该数据包。
因为RPF是要结合单播路由表的，因此在构件组播之前应该事先完成有关IP单播路由表的实现。&lt;/p&gt;

&lt;p&gt;无组播功能交换机转发组播数据包：
对一些网桥，一些二层设备，他没办法实现路由，也没办法实现RPF，对于一个不能识别组播数据流的二层交换机来说，它收到一个组播数据包会按照广播数据包得处理方法处理。&lt;/p&gt;

&lt;p&gt;二层交换机的组播功能实现：
因为无组播功能的交换机在转发组播数据包的时候是跟广播一样，这样就达不到组播的目的了。因此，现在很多二层交换机增加了组播功能，增加了组播功能后就可以识别组播流，并且可以针对组播流来建立有关组播地址和端口的映射。
能识别组播的交换机在它的转发表里面，都会增加一项MAC地址是组播地址，然后端口包含以希望接收组播数据的主机所相连的所有端口。&lt;/p&gt;

&lt;p&gt;引言&lt;/p&gt;

&lt;p&gt;广播和多播仅应用于UDP，因为TCP是面向连接的协议（IP地址确定）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   单播：以太网帧仅发往单个目的主机，目的地址指明单个接收接口。该模式下，任意两主机通信不会影响网内其他主机（争夺共享信道情况除外）

   广播：主机向网上的所有其他主机发送帧。但是只有ARP和RARP可以看到该过程。

   组播：帧传送给属于多播组的多个主机。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主机对帧过滤过程：&lt;/p&gt;

&lt;p&gt;网卡查看由信道传送过来的帧，确定是否接收该帧。若接收则将它传往设备驱动程序。通常网卡接收目的地址为网卡物理地址或广播地址的帧。多数接口均被设置为混合模式，这种模式能接收每个帧的一个复制。      大多数网卡经过配置，都能接收目的地址为多播地址或某些子网多播地址的帧。对于以太网，当地址中最高字节的最低位设置为1时表示该地址是一个多播地址。用十六进制可表示为01：00：00：00：00：00。（广播地址ff:ff:ff:ff:ff）
网卡收到帧后传递给设备驱动程序（如果帧检验和错，网卡将丢弃该帧）。设备驱动程序会进行另外的帧过滤。首先，帧类型中必须指定要使用的协议（IP、ARP等）。其次，进行组播过滤来检测该主机是否属于多播地址说明的多播组
设备驱动程序将数据帧传送给下一层，比如，当帧类型指定为IP数据报时，就传给IP层。IP根据IP地址中的源地址和目的地址进行更多的过滤监测。若正常，则将数据报传送给下一层（TCP或UDP）
UDP或这IP收到传送来的数据报，就根据目的端口号，有时还有源端口号进行数据报过滤。若当前没有进程使用该目的端口号，就丢弃数据报，并产生ICMP不可达报文。若UDP数据报存在检验和错，则会被丢弃。
多播的作用：减少对广播内容不感兴趣主机的处理负荷。&lt;/p&gt;

&lt;p&gt;使用多播，主机可加入一个或多个多播组。&lt;/p&gt;

&lt;p&gt;2、广播
2.1 受限广播 ——————-系统初始启动时使用&lt;/p&gt;

&lt;p&gt;受限广播地址为255.255.255.255。该地址用于主机配置过程中IP数据报的目的地址。原因：此时主机还不知道自己所在网络的网络掩码，和自己的IP地址。&lt;/p&gt;

&lt;p&gt;任何情况下，路由器都不转发目的地址为受限广播地址的数据报，这样的数据报仅出现在本地网络中。&lt;/p&gt;

&lt;p&gt;2.2 指向网络的广播&lt;/p&gt;

&lt;p&gt;指向网络的广播地址是主机号全为1的地址。例如A类网络广播地址为netid.255.255.255，其中netid为A类网络的网络号。&lt;/p&gt;

&lt;p&gt;一个路由器必须转发指向网络的广播，但它也必须有一个不进行转发的选择。&lt;/p&gt;

&lt;p&gt;2.3 指向子网的广播  ——————最常用&lt;/p&gt;

&lt;p&gt;指向子网的广播地址为主机号为全1且有特定子网号的地址。作为子网直接广播地址的IP地址需要了解子网的掩码。&lt;/p&gt;

&lt;p&gt;2.4 指向所有子网的广播
指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开。&lt;/p&gt;

&lt;p&gt;指向所有子网的广播地址的子网号以及主机号全为1。例如，若目的子网掩码为255.255.255.0，则IP地址128.1.255.255是一个指向所有子网的广播地址。然而，如果网络没有划分子网，则这就是一个指向网络的广播。&lt;/p&gt;

&lt;p&gt;3、多播&lt;/p&gt;

&lt;p&gt;3.1 多播提供两类服务&lt;/p&gt;

&lt;p&gt;向多个目的地址传送数据，例如交互式会议系统和想多个接收者分发邮件或新闻。然而，即使使用多播，某些应用可能继续采用TCP来保证它的可靠性（？）
客户对服务器的请求。例如无盘工作组需要确定启动引导服务器
3.2 多播组地址
分配的28bit均作为多播组号&lt;/p&gt;

&lt;p&gt;多播组地址范围是224.0.0.0 到239.255.255.255&lt;/p&gt;

&lt;p&gt;能够接收发往一个特定多播组地址数据的主机集合称为主机组。一个主机组可跨越多个网络。主机组中成员可随时加入或离开主机组。主机组中对主机的数量没有限制，同时不属于某一主机组的主机可以向该组发送信息。&lt;/p&gt;

&lt;p&gt;注：一些多播组地址被IANA确定为知名地址。他们被当作永久主机组，这些多播地址所代表的组是永久组，他们的组成员却不是永久的。例如：224.0.0.1表示该子网内的所有系统组&lt;/p&gt;

&lt;p&gt;3.3 多播组地址到以太网地址的转换&lt;/p&gt;

&lt;p&gt;IANA拥有高位24bit为00:00:5e的以太网地址块，即该地址块所拥有的地址范围是从00:00:5e:00:00:00到00:00:5e:ff:ff:ff。IANA将其中一半分为i多播地址。任何以太网地址首字节为01的，为一个多播地址。因此，IP多播相对应的以太网地址范围从01:00:5e:00:00:00到01:00:5e:7f:ff:ff（为什么是7f）。&lt;/p&gt;

&lt;p&gt;这种地址分配将使以太网多播地址中的23bit与IP多播组号对应起来。通过将多播组号中的低23bit映射到以太网中的低位23bit实现。
由于多播组号中的最高5bit在映射过程中被忽略，因此每个以太网多播地址对应的多播组是不唯一的。32（2^5）个不同的多播组号被映射为一个以太网地址。&lt;/p&gt;

&lt;p&gt;由于地址映射是不唯一的，因此设备驱动程序或IP层需要对数据报进行过滤。因为网卡可能接收到主机不想接收的多播数据帧。若网卡不提供足够的多播数据帧过滤功能，设备驱动就必须接收所有多播数据帧，并对它们进行过滤。&lt;/p&gt;

&lt;p&gt;局域网网卡趋向两种处理类型：一种是网卡根据对多播地址的散列值实行多播过滤，可能会接收到不想接收的多播数据；另一种是网卡只接收一些固定数目的多播地址，当主机想接收超过网卡预先支持多播地址外的多播地址时，必须将网卡设置为“多播混杂”模式。这两种类型的网卡人需要设备驱动程序检查收到的帧是否为主机所需要的。&lt;/p&gt;

&lt;p&gt;多播传送接收过程&lt;/p&gt;

&lt;p&gt;多播进程将目的IP地址指明为多播地址，设备驱动程序将它转化为相应的以太网地址，然后把数据发出去。而这些接收进程需要通知他们的IP层，他们想接收的发往给定多播地址的数据报，并且设备驱动程序必须能够接收这些多播帧。这个过程就是“加入一个多播组”（在同一个主机或多个主机上存在多个接收者）。当一个主机收到多播数据报时，他必须向属于那个多播组的每个进程均传送一个复制，这和单个进程收到单播UDP数据报的UDP不同。使用多播，一个主机上可能存在多个属于同一多播组的进程。&lt;/p&gt;

&lt;p&gt;当把多播扩展到单个物理网络以外需要通过路由器转发多播数据时，需要一个协议让多播路由器了解确定网络中属于确定多播组的任何一个主机，此协议为IGMP协议（Internet组管理协议）&lt;/p&gt;

&lt;p&gt;3.4 FDDI和令牌环网络中的多播&lt;/p&gt;

&lt;p&gt;FDDI网络使用相同的D类IP地址到48bit FDDI地址的映射过程。令牌环网络通常使用不同的地址映射方法。&lt;/p&gt;

&lt;p&gt;使用UDP协议进行信息的传输之前不需要建议连接。换句话说就是客户端向服务器发送信息，客户端只需要给出服务器的ip地址和端口号，然后将信息封装到一个待发送的报文中并且发送出去。至于服务器端是否存在，或者能否收到该报文，客户端根本不用管。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 单播用于两个主机之间的端对端通信，广播用于一个主机对整个局域网上所有主机上的数据通信。单播和广播是两个极端，要么对一个主机进行通信，要么对整个局域网上的主机进行通信。实际情况下，经常需要对一组特定的主机进行通信，而不是整个局域网上的所有主机，这就是多播的用途。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　通常我们讨论的udp的程序都是一对一的单播程序。本章将讨论一对多的服务：广播（broadcast）、多播（multicast）。对于广播，网络中的所有主机都会接收一份数据副本。对于多播，消息只是发送到一个多播地址，网络知识将数据分发给哪些表示想要接收发送到该多播地址的数据的主机。总得来说，只有UDP套接字允许广播或多播。&lt;/p&gt;

&lt;p&gt;回到顶部(go to top)
一、UDP广播
　　广播UDP与单播UDP的区别就是IP地址不同，广播使用广播地址255.255.255.255，将消息发送到在同一广播网络上的每个主机。值得强调的是：本地广播信息是不会被路由器转发。当然这是十分容易理解的，因为如果路由器转发了广播信息，那么势必会引起网络瘫痪。这也是为什么IP协议的设计者故意没有定义互联网范围的广播机制。&lt;/p&gt;

&lt;p&gt;广播地址通常用于在网络游戏中处于同一本地网络的玩家之间交流状态信息等。&lt;/p&gt;

&lt;p&gt;　　其实广播顾名思义，就是想局域网内所有的人说话，但是广播还是要指明接收者的端口号的，因为不可能接受者的所有端口都来收听广播。
　　
　　1、多播（组播）的概念
　　多播，也称为“组播”，将网络中同一业务类型主机进行了逻辑上的分组，进行数据收发的时候其数据仅仅在同一分组中进行，其他的主机没有加入此分组不能收发对应的数据。&lt;/p&gt;

&lt;p&gt;　　在广域网上广播的时候，其中的交换机和路由器只向需要获取数据的主机复制并转发数据。主机可以向路由器请求加入或退出某个组，网络中的路由器和交换机有选择地复制并传输数据，将数据仅仅传输给组内的主机。多播的这种功能，可以一次将数据发送到多个主机，又能保证不影响其他不需要（未加入组）的主机的其他通 信。&lt;/p&gt;

&lt;p&gt;相对于传统的一对一的单播，多播具有如下的优点：&lt;/p&gt;

&lt;p&gt;　　1、具有同种业务的主机加入同一数据流，共享同一通道，节省了带宽和服务器的优点，具有广播的优点而又没有广播所需要的带宽。&lt;/p&gt;

&lt;p&gt;　　2、服务器的总带宽不受客户端带宽的限制。由于组播协议由接收者的需求来确定是否进行数据流的转发，所以服务器端的带宽是常量，与客户端的数量无关。&lt;/p&gt;

&lt;p&gt;　　3、与单播一样，多播是允许在广域网即Internet上进行传输的，而广播仅仅在同一局域网上才能进行。&lt;/p&gt;

&lt;p&gt;组播的缺点：&lt;/p&gt;

&lt;p&gt;　　1、多播与单播相比没有纠错机制，当发生错误的时候难以弥补，但是可以在应用层来实现此种功能。&lt;/p&gt;

&lt;p&gt;　　2、多播的网络支持存在缺陷，需要路由器及网络协议栈的支持。&lt;/p&gt;

&lt;p&gt;　　3、多播的应用主要有网上视频、网上会议等。&lt;/p&gt;

&lt;p&gt;2、广域网的多播
　　多播的地址是特定的，D类地址用于多播。D类IP地址就是多播IP地址，即224.0.0.0至239.255.255.255之间的IP地址，并被划分为局部连接多播地址、预留多播地址和管理权限多播地址3类：&lt;/p&gt;

&lt;p&gt;　　1、局部多播地址：在224.0.0.0～224.0.0.255之间，这是为路由协议和其他用途保留的地址，路由器并不转发属于此范围的IP包。&lt;/p&gt;

&lt;p&gt;　　2、预留多播地址：在224.0.1.0～238.255.255.255之间，可用于全球范围（如Internet）或网络协议。&lt;/p&gt;

&lt;p&gt;　　3、管理权限多播地址：在239.0.0.0～239.255.255.255之间，可供组织内部使用，类似于私有IP地址，不能用于Internet，可限制多播范围。&lt;/p&gt;

&lt;p&gt;　　多播的程序设计使用setsockopt()函数和getsockopt()函数来实现，组播的选项是IP层的，其选项值和含义参见11.5所示。&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　表11.5 多播相关的选项&lt;/p&gt;

&lt;p&gt;getsockopt()/setsockopt()的选项&lt;/p&gt;

&lt;p&gt;含 义&lt;/p&gt;

&lt;p&gt;IP_MULTICAST_TTL&lt;/p&gt;

&lt;p&gt;设置多播组数据的TTL值&lt;/p&gt;

&lt;p&gt;IP_ADD_MEMBERSHIP&lt;/p&gt;

&lt;p&gt;在指定接口上加入组播组&lt;/p&gt;

&lt;p&gt;IP_DROP_MEMBERSHIP&lt;/p&gt;

&lt;p&gt;退出组播组&lt;/p&gt;

&lt;p&gt;IP_MULTICAST_IF&lt;/p&gt;

&lt;p&gt;获取默认接口或设置接口&lt;/p&gt;

&lt;p&gt;IP_MULTICAST_LOOP&lt;/p&gt;

&lt;p&gt;禁止组播数据回送&lt;/p&gt;

&lt;p&gt;3、多播程序设计的框架
要进行多播的编程，需要遵从一定的编程框架。多播程序框架主要包含套接字初始化、设置多播超时时间、加入多播组、发送数据、接收数据以及从多播组中离开几个方面。其步骤如下：&lt;/p&gt;

&lt;p&gt;（1）建立一个socket。&lt;/p&gt;

&lt;p&gt;（2）然后设置多播的参数，例如超时时间TTL、本地回环许可LOOP等。&lt;/p&gt;

&lt;p&gt;（3）加入多播组。&lt;/p&gt;

&lt;p&gt;（4）发送和接收数据。&lt;/p&gt;

&lt;p&gt;（5）从多播组离开&lt;/p&gt;

&lt;p&gt;三、UDP广播与单播
广播与单播的比较
　　广播和单播的处理过程是不同的，单播的数据只是收发数据的特定主机进行处理，而广播的数据整个局域网都进行处理。&lt;/p&gt;

&lt;p&gt;　　例如在一个以太网上有3个主机，主机的配置如表11.4所示。&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　表11.4 某局域网中主机的配置情况&lt;/p&gt;

&lt;p&gt;主 机&lt;/p&gt;

&lt;p&gt;A&lt;/p&gt;

&lt;p&gt;B&lt;/p&gt;

&lt;p&gt;C&lt;/p&gt;

&lt;p&gt;IP地址&lt;/p&gt;

&lt;p&gt;192.168.1.150&lt;/p&gt;

&lt;p&gt;192.168.1.151&lt;/p&gt;

&lt;p&gt;192.168.1.158&lt;/p&gt;

&lt;p&gt;MAC地址&lt;/p&gt;

&lt;p&gt;00:00:00:00:00:01&lt;/p&gt;

&lt;p&gt;00:00:00:00:00:02&lt;/p&gt;

&lt;p&gt;00:00:00:00:00:03&lt;/p&gt;

&lt;p&gt;　　单播流程：主机A向主机B发送UDP数据报，发送的目的IP为192.168.1.151，端口为 80，目的MAC地址为00:00:00:00:00:02。此数据经过UDP层、IP层，到达数据链路层，数据在整个以太网上传播，在此层中其他主机会 判断目的MAC地址。主机C的MAC地址为00:00:00:00:00:03，与目的MAC地址00:00:00:00:00:02不匹配，数据链路层 不会进行处理，直接丢弃此数据。&lt;/p&gt;

&lt;p&gt;　　主机B的MAC地址为00:00:00:00:00:02，与目的MAC地址00:00:00:00:00:02一致，此数据会经过IP层、UDP层，到达接收数据的应用程序。&lt;/p&gt;

&lt;p&gt;　　广播的流程：主机A向整个网络发送广播数据，发送的目的IP为192.168.1.255，端口为 80，目的MAC地址为FF:FF:FF:FF:FF:FF。此数据经过UDP层、IP层，到达数据链路层，数据在整个以太网上传播，在此层中其他主机会 判断目的MAC地址。由于目的MAC地址为FF:FF:FF:FF:FF:FF，主机C和主机B会忽略MAC地址的比较（当然，如果协议栈不支持广播，则 仍然比较MAC地址），处理接收到的数据。&lt;/p&gt;

&lt;p&gt;　　主机B和主机C的处理过程一致，此数据会经过IP层、UDP层，到达接收数据的应用程序&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/linux/2017/12/30/broad_cast.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/linux/2017/12/30/broad_cast.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>arp</title>
        <description>&lt;p&gt;地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。
&lt;!-- more --&gt;
工作过程
主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；
主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；
当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：
第1步：根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。
第2步：如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。
第3步：主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。
第4步：主机B将包含其MAC地址的ARP回复消息直接发送回主机A。
第5步：当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。
ARP缓存是个用来储存IP地址和MAC地址的缓冲区，其本质就是一个IP地址–&amp;gt;MAC地址的对应表，表中每一个条目分别记录了网络上其他主机的IP地址和对应的MAC地址。每一个以太网或令牌环网络适配器都有自己单独的表。当地址解析协议被询问一个已知IP地址节点的MAC地址时，先在ARP缓存中查看，若存在，就直接返回与之对应的MAC地址，若不存在，才发送ARP请求向局域网查询。
为使广播量最小，ARP维护IP地址到MAC地址映射的缓存以便将来使用。ARP缓存可以包含动态和静态项目。动态项目随时间推移自动添加和删除。每个动态ARP缓存项的潜在生命周期是10分钟。新加到缓存中的项目带有时间戳，如果某个项目添加后2分钟内没有再使用，则此项目过期并从ARP缓存中删除；如果某个项目已在使用，则又收到2分钟的生命周期；如果某个项目始终在使用，则会另外收到2分钟的生命周期，一直到10分钟的最长生命周期。静态项目一直保留在缓存中，直到重新启动计算机为止。&lt;/p&gt;

&lt;p&gt;ARP命令
ARP命令
ARP命令
ARP缓存中包含一个或多个表，它们用于存储IP地址及其经过解析的MAC地址。ARP命令用于查询本机ARP缓存中IP地址–&amp;gt;MAC地址的对应关系、添加或删除静态对应关系等。如果在没有参数的情况下使用，ARP命令将显示帮助信息。
常见用法
arp -a或arp –g
用于查看缓存中的所有项目。-a和-g参数的结果是一样的，多年来-g一直是UNIX平台上用来显示ARP缓存中所有项目的选项，而Windows用的是arp -a（-a可被视为all，即全部的意思），但它也可以接受比较传统的-g选项。
arp -a Ip
如果有多个网卡，那么使用arp -a加上接口的IP地址，就可以只显示与该接口相关的ARP缓存项目。
arp -s Ip 物理地址
可以向ARP缓存中人工输入一个静态项目。该项目在计算机引导过程中将保持有效状态，或者在出现错误时，人工配置的物理地址将自动更新该项目。
arp -d Ip
使用该命令能够人工删除一个静态项目。&lt;/p&gt;

&lt;p&gt;地址解析协议工作在一个网段中，而代理ARP（Proxy ARP，也被称作混杂ARP（Promiscuous ARP）[9-10]  ）工作在不同的网段间，其一般被像路由器这样的设备使用，用来代替处于另一个网段的主机回答本网段主机的ARP请求。
例如，主机PC1（192.168.20.66/24）需要向主机PC2（192.168.20.20/24）发送报文，因为主机PC1不知道子网的存在且和目标主机PC2在同一主网络网段，所以主机PC1将发送ARP协议请求广播报文请求192.168.20.20的MAC地址。这时，路由器将识别出报文的目标地址属于另一个子网（注意，路由器的接口IP地址配置的是28位的掩码），因此向请求主机回复自己的硬件地址（0004.dd9e.cca0）。之后，PC1将发往PC2的数据包都发往MAC地址0004.dd9e.cca0（路由器的接口E0/0），由路由器将数据包转发到目标主机PC2。（接下来路由器将为PC2做同样的代理发送数据包的工作）。代理ARP协议使得子网化网络拓扑对于主机来说时透明的（或者可以说是路由器以一个不真实的PC2的MAC地址欺骗了源主机PC1）。[11] 
NDP
地址解析协议是IPv4中必不可少的协议，但在IPv6中将不再存在地址解析协议。在IPv6中，地址解析协议的功能将由NDP（邻居发现协议，Neighbor Discovery Protocol）实现，它使用一系列IPv6控制信息报文（ICMPv6）来实现相邻节点（同一链路上的节点）的交互管理，并在一个子网中保持网络层地址和数据链路层地址之间的映射。邻居发现协议中定义了5种类型的信息：路由器宣告、路由器请求、路由重定向、邻居请求和邻居宣告。与ARP相比，NDP可以实现路由器发现、前缀发现、参数发现、地址自动配置、地址解析（代替ARP和RARP）、下一跳确定、邻居不可达检测、重复地址检测、重定向等更多功能。
NDP与ARP的区别
IPv4中地址解析协议是独立的协议，负责IP地址到MAC地址的转换，对不同的数据链路层协议要定义不同的地址解析协议。IPv6中NDP包含了ARP的功能，且运行于因特网控制信息协议ICMPv6上，更具有一般性，包括更多的内容，而且适用于各种数据链路层协议；
地址解析协议以及ICMPv4路由器发现和ICMPv4重定向报文基于广播，而NDP的邻居发现报文基于高效的组播和单播。&lt;/p&gt;

&lt;p&gt;ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。
ARP攻击主要是存在于局域网网络中，局域网中若有一台计算机感染ARP木马，则感染该ARP木马的系统将会试图通过“ARP欺骗”手段截获所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。
攻击者向电脑A发送一个伪造的ARP响应，告诉电脑A：电脑B的IP地址192.168.0.2对应的MAC地址是00-aa-00-62-c6-03，电脑A信以为真，将这个对应关系写入自己的ARP缓存表中，以后发送数据时，将本应该发往电脑B的数据发送给了攻击者。同样的，攻击者向电脑B也发送一个伪造的ARP响应，告诉电脑B：电脑A的IP地址192.168.0.1对应的MAC地址是00-aa-00-62-c6-03，电脑B也会将数据发送给攻击者。
至此攻击者就控制了电脑A和电脑B之间的流量，他可以选择被动地监测流量，获取密码和其他涉密信息，也可以伪造数据，改变电脑A和电脑B之间的通信内容。
为了解决ARP攻击问题，可以在网络中的交换机上配置802.1x协议。
IEEE 802.1x是基于端口的访问控制协议，它对连接到交换机的用户进行认证和授权。在交换机上配置802.1x协议后，攻击者在连接交换机时需要进行身份认证（结合MAC、端口、帐户、VLAN和密码等），只有通过认证后才能向网络发送数据。攻击者未通过认证就不能向网络发送伪造的ARP报文。
arp命令网络测试
arp命令用于操作主机的arp缓冲区，它可以显示arp缓冲区中的所有条目、删除指定的条目或者添加静态的ip地址与MAC地址对应关系。&lt;/p&gt;

&lt;p&gt;语法
arp(选项)(参数)
选项
-a&lt;主机&gt;：显示arp缓冲区的所有条目；
-H&lt;地址类型&gt;：指定arp指令使用的地址类型；
-d&lt;主机&gt;：从arp缓冲区中删除指定主机的arp条目；
-D：使用指定接口的硬件地址；
-e：以Linux的显示风格显示arp缓冲区中的条目；
-i&lt;接口&gt;：指定要操作arp缓冲区的网络接口；
-s&lt;主机&gt;&lt;MAC地址&gt;：设置指定的主机的IP地址与MAC地址的静态映射；
-n：以数字方式显示arp缓冲区中的条目；
-v：显示详细的arp缓冲区条目，包括缓冲区条目的统计信息；
-f&lt;文件&gt;：设置主机的IP地址与MAC地址的静态映射。&lt;/文件&gt;&lt;/MAC地址&gt;&lt;/主机&gt;&lt;/接口&gt;&lt;/主机&gt;&lt;/地址类型&gt;&lt;/主机&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/linux/2017/12/30/arp.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/linux/2017/12/30/arp.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>json_shell</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;解析简单json&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;lineno&quot;&gt;1 &lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2 &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;{\&amp;quot;rv\&amp;quot;:0,\&amp;quot;flag\&amp;quot;:1,\&amp;quot;url\&amp;quot;:\&amp;quot;http://www.jinhill.com\&amp;quot;,\&amp;quot;msg\&amp;quot;:\&amp;quot;test\&amp;quot;}&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3 &lt;/span&gt;parse_json&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4 &lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#echo &amp;quot;$1&amp;quot; | sed &amp;quot;s/.*\&amp;quot;$2\&amp;quot;:\([^,}]*\).*/\1/&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; sed &lt;span class=&quot;s2&quot;&gt;&amp;quot;s/.*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:\([^,}]*\).*/\1/&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;6 &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;7 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$s&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;8 &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;parse_json &lt;span class=&quot;nv&quot;&gt;$s&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;url&amp;quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;9 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$value&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;解析URL Query&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;lineno&quot;&gt;1 &lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2 &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;http://www.zonetec.cn/WlanAuth/portal.do?appid=aaaa&amp;amp;apidx=0&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3 &lt;/span&gt;parse&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4 &lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; sed &lt;span class=&quot;s1&quot;&gt;&amp;#39;s/.*&amp;#39;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;=\([[:alnum:]]*\).*/\1/&amp;#39;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5 &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;6 &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;parse &lt;span class=&quot;nv&quot;&gt;$s&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;appid&amp;quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;7 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$value&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Wed, 27 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2017/12/27/json_shell.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2017/12/27/json_shell.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>ioctl</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;ioctl函数详细说明（网络）
ioctl 函数
本函数影响由fd 参数引用的一个打开的文件。
 #include&lt;unistd.h&gt;&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;int ioctl( int fd, int request, …/* void *arg */ );&lt;/p&gt;

&lt;p&gt;返回0 ：成功    -1 ：出错&lt;/p&gt;

&lt;p&gt;第三个参数总是一个指针，但指针的类型依赖于request 参数。&lt;/p&gt;

&lt;p&gt;我们可以把和网络相关的请求划分为6 类：&lt;/p&gt;

&lt;p&gt;套接口操作&lt;/p&gt;

&lt;p&gt;文件操作&lt;/p&gt;

&lt;p&gt;接口操作&lt;/p&gt;

&lt;p&gt;ARP 高速缓存操作&lt;/p&gt;

&lt;p&gt;路由表操作&lt;/p&gt;

&lt;p&gt;流系统&lt;/p&gt;

&lt;p&gt;下表列出了网络相关ioctl 请求的request 参数以及arg 地址必须指向的数据类型：&lt;/p&gt;

&lt;p&gt;类别&lt;/p&gt;

&lt;p&gt;Request&lt;/p&gt;

&lt;p&gt;说明&lt;/p&gt;

&lt;p&gt;数据类型&lt;/p&gt;

&lt;p&gt;套&lt;/p&gt;

&lt;p&gt;接&lt;/p&gt;

&lt;p&gt;口&lt;/p&gt;

&lt;p&gt;SIOCATMARK&lt;/p&gt;

&lt;p&gt;SIOCSPGRP&lt;/p&gt;

&lt;p&gt;SIOCGPGRP&lt;/p&gt;

&lt;p&gt;是否位于带外标记&lt;/p&gt;

&lt;p&gt;设置套接口的进程ID 或进程组ID&lt;/p&gt;

&lt;p&gt;获取套接口的进程ID 或进程组ID&lt;/p&gt;

&lt;p&gt;int&lt;/p&gt;

&lt;p&gt;int&lt;/p&gt;

&lt;p&gt;int&lt;/p&gt;

&lt;p&gt;文&lt;/p&gt;

&lt;p&gt;件&lt;/p&gt;

&lt;p&gt;FIONBIN&lt;/p&gt;

&lt;p&gt;FIOASYNC&lt;/p&gt;

&lt;p&gt;FIONREAD&lt;/p&gt;

&lt;p&gt;FIOSETOWN&lt;/p&gt;

&lt;p&gt;FIOGETOWN&lt;/p&gt;

&lt;p&gt;设置/ 清除非阻塞I/O 标志&lt;/p&gt;

&lt;p&gt;设置/ 清除信号驱动异步I/O 标志&lt;/p&gt;

&lt;p&gt;获取接收缓存区中的字节数&lt;/p&gt;

&lt;p&gt;设置文件的进程ID 或进程组ID&lt;/p&gt;

&lt;p&gt;获取文件的进程ID 或进程组ID&lt;/p&gt;

&lt;p&gt;int&lt;/p&gt;

&lt;p&gt;int&lt;/p&gt;

&lt;p&gt;int&lt;/p&gt;

&lt;p&gt;int&lt;/p&gt;

&lt;p&gt;int&lt;/p&gt;

&lt;p&gt;接&lt;/p&gt;

&lt;p&gt;口&lt;/p&gt;

&lt;p&gt;SIOCGIFCONF&lt;/p&gt;

&lt;p&gt;SIOCSIFADDR&lt;/p&gt;

&lt;p&gt;SIOCGIFADDR&lt;/p&gt;

&lt;p&gt;SIOCSIFFLAGS&lt;/p&gt;

&lt;p&gt;SIOCGIFFLAGS&lt;/p&gt;

&lt;p&gt;SIOCSIFDSTADDR&lt;/p&gt;

&lt;p&gt;SIOCGIFDSTADDR&lt;/p&gt;

&lt;p&gt;SIOCGIFBRDADDR&lt;/p&gt;

&lt;p&gt;SIOCSIFBRDADDR&lt;/p&gt;

&lt;p&gt;SIOCGIFNETMASK&lt;/p&gt;

&lt;p&gt;SIOCSIFNETMASK&lt;/p&gt;

&lt;p&gt;SIOCGIFMETRIC&lt;/p&gt;

&lt;p&gt;SIOCSIFMETRIC&lt;/p&gt;

&lt;p&gt;SIOCGIFMTU&lt;/p&gt;

&lt;p&gt;SIOCxxx&lt;/p&gt;

&lt;p&gt;获取所有接口的清单&lt;/p&gt;

&lt;p&gt;设置接口地址&lt;/p&gt;

&lt;p&gt;获取接口地址&lt;/p&gt;

&lt;p&gt;设置接口标志&lt;/p&gt;

&lt;p&gt;获取接口标志&lt;/p&gt;

&lt;p&gt;设置点到点地址&lt;/p&gt;

&lt;p&gt;获取点到点地址&lt;/p&gt;

&lt;p&gt;获取广播地址&lt;/p&gt;

&lt;p&gt;设置广播地址&lt;/p&gt;

&lt;p&gt;获取子网掩码&lt;/p&gt;

&lt;p&gt;设置子网掩码&lt;/p&gt;

&lt;p&gt;获取接口的测度&lt;/p&gt;

&lt;p&gt;设置接口的测度&lt;/p&gt;

&lt;p&gt;获取接口MTU&lt;/p&gt;

&lt;p&gt;（还有很多取决于系统的实现）&lt;/p&gt;

&lt;p&gt;struct ifconf&lt;/p&gt;

&lt;p&gt;struct ifreq&lt;/p&gt;

&lt;p&gt;struct ifreq&lt;/p&gt;

&lt;p&gt;struct ifreq&lt;/p&gt;

&lt;p&gt;struct ifreq&lt;/p&gt;

&lt;p&gt;struct ifreq&lt;/p&gt;

&lt;p&gt;struct ifreq&lt;/p&gt;

&lt;p&gt;struct ifreq&lt;/p&gt;

&lt;p&gt;struct ifreq&lt;/p&gt;

&lt;p&gt;struct ifreq&lt;/p&gt;

&lt;p&gt;struct ifreq&lt;/p&gt;

&lt;p&gt;struct ifreq&lt;/p&gt;

&lt;p&gt;struct ifreq&lt;/p&gt;

&lt;p&gt;struct ifreq&lt;/p&gt;

&lt;p&gt;ARP&lt;/p&gt;

&lt;p&gt;SIOCSARP&lt;/p&gt;

&lt;p&gt;SIOCGARP&lt;/p&gt;

&lt;p&gt;SIOCDARP&lt;/p&gt;

&lt;p&gt;创建/ 修改ARP 表项&lt;/p&gt;

&lt;p&gt;获取ARP 表项&lt;/p&gt;

&lt;p&gt;删除ARP 表项&lt;/p&gt;

&lt;p&gt;struct arpreq&lt;/p&gt;

&lt;p&gt;struct arpreq&lt;/p&gt;

&lt;p&gt;struct arpreq&lt;/p&gt;

&lt;p&gt;路&lt;/p&gt;

&lt;p&gt;由&lt;/p&gt;

&lt;p&gt;SIOCADDRT&lt;/p&gt;

&lt;p&gt;SIOCDELRT&lt;/p&gt;

&lt;p&gt;增加路径&lt;/p&gt;

&lt;p&gt;删除路径&lt;/p&gt;

&lt;p&gt;struct rtentry&lt;/p&gt;

&lt;p&gt;struct rtentry&lt;/p&gt;

&lt;p&gt;流&lt;/p&gt;

&lt;p&gt;I_xxx&lt;/p&gt;

&lt;p&gt;套接口操作：&lt;/p&gt;

&lt;p&gt;明确用于套接口操作的ioctl 请求有三个, 它们都要求ioctl 的第三个参数是指向某个整数的一个指针。&lt;/p&gt;

&lt;p&gt;SIOCATMARK:    如果本套接口的的度指针当前位于带外标记，那就通过由第三个参数指向的整数返回一个非0 值；否则返回一个0 值。POSIX 以函数sockatmark 替换本请求。&lt;/p&gt;

&lt;p&gt;SIOCGPGRP ：       通过第三个参数指向的整数返回本套接口的进程ID 或进程组ID ，该ID 指定针对本套接口的SIGIO 或SIGURG 信号的接收进程。本请求和fcntl 的F_GETOWN 命令等效，POSIX 标准化的是fcntl 函数。&lt;/p&gt;

&lt;p&gt;SIOCSPGRP ：     把本套接口的进程ID 或者进程组ID 设置成第三个参数指向的整数，该ID 指定针对本套接口的SIGIO 或SIGURG 信号的接收进程，本请求和fcntl 的F_SETOWN 命令等效，POSIX 标准化的是fcntl 操作。&lt;/p&gt;

&lt;p&gt;文件操作：&lt;/p&gt;

&lt;p&gt;以下5 个请求都要求ioctl 的第三个参数指向一个整数。&lt;/p&gt;

&lt;p&gt;FIONBIO ：        根据ioctl 的第三个参数指向一个0 或非0 值分别清除或设置本套接口的非阻塞标志。本请求和O_NONBLOCK 文件状态标志等效，而该标志通过fcntl 的F_SETFL 命令清除或设置。&lt;/p&gt;

&lt;p&gt;FIOASYNC ：      根据iocl 的第三个参数指向一个0 值或非0 值分别清除或设置针对本套接口的信号驱动异步I/O 标志，它决定是否收取针对本套接口的异步I/O 信号（SIGIO ）。本请求和O_ASYNC 文件状态标志等效，而该标志可以通过fcntl 的F_SETFL 命令清除或设置。&lt;/p&gt;

&lt;p&gt;FIONREAD ：     通过由ioctl 的第三个参数指向的整数返回当前在本套接口接收缓冲区中的字节数。本特性同样适用于文件，管道和终端。&lt;/p&gt;

&lt;p&gt;FIOSETOWN ：    对于套接口和SIOCSPGRP 等效。&lt;/p&gt;

&lt;p&gt;FIOGETOWN ：    对于套接口和SIOCGPGRP 等效。&lt;/p&gt;

&lt;p&gt;接口配置：&lt;/p&gt;

&lt;p&gt;得到系统中所有接口由SIOCGIFCONF 请求完成，该请求使用ifconf 结构，ifconf 又使用ifreq&lt;/p&gt;

&lt;p&gt;结构，如下所示：&lt;/p&gt;

&lt;p&gt;Struct ifconf{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int ifc_len;                 // 缓冲区的大小

union{

    caddr_t ifcu_buf;        // input from user-&amp;gt;kernel

    struct ifreq *ifcu_req;    // return of structures returned

}ifc_ifcu;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;};&lt;/p&gt;

&lt;p&gt;#define  ifc_buf  ifc_ifcu.ifcu_buf    //buffer address&lt;/p&gt;

&lt;p&gt;#define  ifc_req  ifc_ifcu.ifcu_req    //array of structures returned
 #define  IFNAMSIZ  16
struct ifreq{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char ifr_name[IFNAMSIZ];           // interface name, e.g., “le0”

union{

    struct sockaddr ifru_addr;

    struct sockaddr ifru_dstaddr;

    struct sockaddr ifru_broadaddr;

    short ifru_flags;

    int ifru_metric;

    caddr_t ifru_data;

}ifr_ifru;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;};&lt;/p&gt;

&lt;p&gt;#define ifr_addr     ifr_ifru.ifru_addr            // address
 #define ifr_dstaddr   ifr_ifru.ifru_dstaddr         // otner end of p-to-p link&lt;/p&gt;

&lt;p&gt;#define ifr_broadaddr ifr_ifru.ifru_broadaddr    // broadcast address&lt;/p&gt;

&lt;p&gt;#define ifr_flags     ifr_ifru.ifru_flags        // flags&lt;/p&gt;

&lt;p&gt;#define ifr_metric    ifr_ifru.ifru_metric      // metric&lt;/p&gt;

&lt;p&gt;#define ifr_data      ifr_ifru.ifru_data        // for use by interface&lt;/p&gt;

&lt;p&gt;再调用ioctl 前我们必须先分撇一个缓冲区和一个ifconf 结构，然后才初始化后者。如下图&lt;/p&gt;

&lt;p&gt;展示了一个ifconf 结构的初始化结构，其中缓冲区的大小为1024 ，ioctl 的第三个参数指向&lt;/p&gt;

&lt;p&gt;这样一个ifconf 结构。&lt;/p&gt;

&lt;p&gt;ifc_len&lt;/p&gt;

&lt;p&gt;Ifc_buf&lt;/p&gt;

&lt;p&gt;1024&lt;/p&gt;

&lt;p&gt;———————&amp;gt; 缓存&lt;/p&gt;

&lt;p&gt;假设内核返回2 个ifreq 结构，ioctl 返回时通过同一个ifconf 结构缓冲区填入了那2 个ifreq 结构，ifconf 结构的ifc_len 成员也被更新，以反映存放在缓冲区中的信息量&lt;/p&gt;

&lt;p&gt;一般来讲ioctl在用户程序中的调用是：
ioctl(int fd,int command, (char*)argstruct)
ioctl调用与网络编程有关（本文只讨论这一点），文件描述符fd实际上是由socket()系统调用返回的。参数command的取值由/usr/include/linux/sockios.h 所规定。这些command的由于功能的不同，可分为以下几个小类：
• 改变路由表 (例如 SIOCADDRT, SIOCDELRT), 
• 读/更新 ARP/RARP 缓存(如：SIOCDARP, SIOCSRARP), 
• 一般的与网络接口有关的(例如 SIOCGIFNAME, SIOCSIFADDR 等等) 
在 Gooodies目录下有很多样例程序展示了如何使用ioctl。当你看这些程序时，注意参数argstruct是与参数command相关的。例如，与 路由表相关的ioctl使用rtentry这种结构，rtentry定义在/usr/include/linux/route.h（参见例子 adddefault.c）。与ARP有关的ioctl调用使用arpreq结构，arpreq定义在/usr/include/linux /if_arp.h（参见例子arpread.c）
与网络接口有关的ioctl调用使用的command参数通常看起来像SIOCxIFyyyy的形式，这里x要 么是S（设定set，写write），要么是G（得到get，读read）。在getifinfo.c程序中就使用了这种形式的command参数来读 IP地址，硬件地址，广播地址和得到与网络接口有关的一些标志（flag）。在这些ioctl调用中，第三个参数是ifreq结构，它在/usr /include/linux/if.h中定义。在某些情况下， ioctrl调用可能会使用到在sockios.h之外的新的定义。&lt;/p&gt;
</description>
        <pubDate>Wed, 27 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/linux/2017/12/27/ioctl.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/linux/2017/12/27/ioctl.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>inetd</title>
        <description>&lt;p&gt;inetd是监视一些网络请求的守护进程，其根据网络请求来调用相应的服务进程来处理连接请求。它可以为多种服务管理连接，当 inetd 接到连接时，它能够确定连接所需的程序，启动相应的进程，并把 socket 交给它 （服务 socket 会作为程序的标准输入、 输出和错误输出描述符）。 使用 inetd 来运行那些负载不重的服务有助于降低系统负载，因为它不需要为每个服务都启动独立的服务程序。
&lt;!-- more --&gt;
inetd是通过rc系统启动的。inetd_enable选项默认设为NO，但可以在安装系统时，由用户根据需要sysinstall通过来打开。
inetd.conf则是inetd的配置文件。inetd.conf文件告诉inetd监听哪些网络端口，为每个端口启动哪个服务。在任何的网络环境中使用Linux系统，第一件要做的事就是了解一下服务器到底要提供哪些服务。不需要的那些服务应该被禁止掉，最好卸载掉，这样黑客就少了一些攻击系统的机会。查看“/etc/inetd.conf”文件，了解一下inetd提供哪些服务。用加上注释的方法（在一行的开头加上#号），禁止任何不需要的服务，再给inetd进程发一个SIGHUP信号。&lt;/p&gt;

&lt;p&gt;从理论上说，UNIX® 是内核，或者说低层软件，它控制对文件系统、内存和处理器等计算机资源的访问。但是，用更通俗的话来说，UNIX 是指在操作系统上运行的一整套软件。实际上，通常说的 “它是一台 UNIX 机器” 是指系统的基础功能：UNIX 机器通常提供 shell 界面、并行访问、强大的安全性和各种连网的服务。
实际上，UNIX（内核等）被选用的原因通常是它的连网应用。FTP、POP、SMTP 和 HTTP 最初都是在 UNIX 上实现的，而且一直在 UNIX 上使用。UNIX 系统还通过运行服务（常常称为守护进程 ）实现各种功能，包括与中心时钟执行同步（网络时间协议）、交换新闻（网络新闻传输协议）、把主机名解析为 IP 地址（DNS）等。在大多数 UNIX 机器上的 /etc/services 中可以找到常用的一部分服务。这个文件与 清单 1 相似。&lt;/p&gt;

&lt;p&gt;清单 1. /etc/services（UNIX 网络服务目录）中常见的条目
ftp             21/tcp
fsp             21/udp          fspd
ssh             22/tcp                       &lt;br /&gt;
ssh             22/udp
telnet          23/tcp
smtp            25/tcp          mail
/etc/services 中的每个条目列出服务的名称；服务使用的端口号和协议（TCP 或 UDP）；服务的别名（可能没有，也可能有多个别名）。每个系统守护进程都通过检查 /etc/services 寻找它提供服务时要使用的端口和协议。&lt;/p&gt;

&lt;p&gt;例如，处理入站电子邮件的守护进程会寻找 “smtp”（服务名称）或 “mail”（别名之一），在端口 25 上监听到达的 TCP 连接。类似地，远程登录守护进程在文件中搜索 “ssh”，在端口 22 上监听到达的 TCP 连接。&lt;/p&gt;

&lt;p&gt;小公司的服务器可能运行多个服务，分别负责与世界时钟同步、提供 Web 页面、传输电子邮件、支持远程 shell 访问、打印页面、传输文件、连接数据库、监视系统的稳定性、提供域名以及通过 NFS 共享文件。这种配置并不少见，这主要是因为守护进程的开销不大。守护进程通常设计为在空闲时休眠，等待请求。当服务请求出现时，守护进程醒来，响应并处理请求，然后继续休眠。&lt;/p&gt;

&lt;p&gt;尽管如此，大量休眠的进程仍然会影响系统性能。因此，如果预期会经常请求某一服务，比如有稳定的 Web 访问请求，那么有必要具有一个长期运行的守护进程。否则，最好把守护进程重新配置为根据需要执行。&lt;/p&gt;

&lt;p&gt;但是，系统如何提供随时可用的服务并在需要的时候启动？解决方案是使用代理服务，它预测到达的各种请求，根据后续处理的需要启动适当的服务。在 UNIX 和 Linux® 系统上，这个代理称为 inetd。
给定一个服务列表，inetd 会监视对这些服务的端口和协议的请求。当发生活动时，inetd 把入站请求映射到标准输入 (stdin)、标准输出 (stdout) 和标准错误 (stderr)，并启动适当的守护进程。服务处理数据并终止。inetd 把资源消耗保持在最低水平，并且让守护进程更容易编写。&lt;/p&gt;

&lt;p&gt;inetd 监听许多端口并在接收到请求时启动服务。服务处理请求并退出。有一些服务例外。例如，传输电子邮件的 SMTP 服务器通常独立地运行。&lt;/p&gt;

&lt;p&gt;根据它的作用，inetd 常常被称为 “超级服务员”。在近几年，inetd 已经被它的变体 xinetd 替代了。这两个软件的用途是相同的，但是后者更安全并提供许多特性，可以在系统负载过重时限制访问。inetd 和 xinetd 的配置相似，但是不完全相同。系统可以运行 inetd 或 xinetd，但是不能同时运行两者。因为后者更安全，它是首选的，所以本文后面一直使用它。&lt;/p&gt;

&lt;p&gt;xinetd 是开放源码的，很容易构建在 UNIX 以及 OpenBSD 和 Linux 等变体上。到 2009 年 10 月底，xinetd 的最新版本是 2.3.14，可以从 xinetd 主页获取它（参见 参考资料）。下载 xinetd 的源代码之后，解压压缩文件，运行配置脚本）并构建软件。在安装 xinetd 之前，一定要备份 inetd 配置（如果有的话），然后禁用和/或删除 inetd。禁用 inetd 的步骤取决于使用的 UNIX 变体；参见系统的 inetd 手册页。执行这个修改很可能需要超级用户访问权。&lt;/p&gt;

&lt;p&gt;无论如何安装和启用 xinetd，如果以前运行过 inetd，就必须把 inetd 配置文件 inetd.conf 转换为与 xinetd 兼容的文件。可以手工地执行转换，也可以使用 xinetd 提供的转换脚本替您修改文件：&lt;/p&gt;

&lt;p&gt;1
2
$ xconv.pl &amp;lt; /etc/inetd.conf &amp;gt; /etc/xinetd.conf
$ mv /etc/inetd.conf /etc/inetd.conf.sav
Xconv.pl 是 xinetd 提供的 Perl 脚本。后一个步骤（把 inetd 配置文件转移到标准位置之外）只是一项预防措施。&lt;/p&gt;

&lt;p&gt;可以完全在 /etc/xinetd.conf 中配置 xinetd。但是，按照惯例，通常在这个文件中提供默认设置，并在特殊目录 /etc/xinetd.d 中包含多个配置文件 — 每个服务一个文件。例如，下面是 Ubuntu 上安装的 xinetd 配置文件：&lt;/p&gt;

&lt;p&gt;1
2
3
4
5
6
defaults
{
    log_type = SYSLOG daemon info
}&lt;/p&gt;

&lt;p&gt;includedir /etc/xinetd.d
defaults 提供 xinetd 控制的所有 服务的值。服务可以覆盖这些全局默认值。在这里，log_type 的默认值指定每个守护进程应该把日志条目发送到哪里（如果启用日志的话）。SYSLOG 选项把输出发送到 syslog（中心系统日志）。info 要求只记录信息性消息。其他值包括 emerg、alert、crit、err、warning、notice 和 debug。第一个值 emerg 从 xinetd 生成最少的输出；最后一个值 debug 提供最详细的输出。如果在从 xinetd 启动某个服务时遇到了问题，可以启用更详细的日志选项以帮助判断问题的原因。&lt;/p&gt;

&lt;p&gt;/etc/xinetd.d 中的文件采用与 xinetd.conf 相同的格式。其中有一个操作，包含零个、一个或更多操作数，还有一组放在大括号 ({}) 中的变量和值。例如，清单 3 是 /etc/xinetd.d/imap，这是用于 IMAP 服务的条目。（IMAP 是用于读取和管理电子邮件的邮箱协议。它与 POP 相比有一个重要的优点：IMAP 邮箱可以跨任意数量的系统保持同步。）&lt;/p&gt;

&lt;p&gt;虽然有一些小差异，但是这个片段看起来应该很熟悉。这个脚本作为用户 martin 运行，因为它不需要特殊的特权。一般来说，应该提供尽可能少的特权 — 不仅是在这里，在授予对任何系统资源的访问权时都应该这样。对于 TCP 协议服务，必须设置 wait=no。server 指向要运行的脚本或可执行程序，log_type 指定更高的日志记录级别，这有助于解决服务中的任何问题。&lt;/p&gt;

&lt;p&gt;重新启动 xinetd，或者向它的进程发送一个重新设置信号。要想重新启动 xinetd，应该在 /etc/init.d 或系统保存启动脚本的地方寻找控制脚本。运行下面这样的命令：&lt;/p&gt;

&lt;p&gt;$ sudo /etc/init.d/xinetd restart
另一种方法是向 xinetd 守护进程发送重新设置信号。信号 SIGHUP 让 xinetd 重新读取它的配置，并且根据新的参数，可能会关闭连接。使用的命令是：&lt;/p&gt;

&lt;p&gt;$ sudo pkill -SIGHUP xinetd
如果系统没有 pkill（它根据进程名寻找进程 ID），那么使用 ps aux | grep xinetd 寻找进程号，然后使用 sudo kill -SIGHUP pid，其中的 pid 是进程 ID。&lt;/p&gt;

&lt;p&gt;为了测试这个新服务，创建一个名为 /tmp/xinetd 的目录，创建 Ruby 脚本并把它保存在 /tmp/xinetd/find.rb 中。用 chmod +x /tmp/xinetd/find.rb 把这个文件设置为可执行的。接下来，创建一些目录和文本文件：&lt;/p&gt;

&lt;p&gt;$ mkdir a b c
$ touch a/d.txt b/e.txt
现在可以测试新服务。当端口 11000 上出现入站连接时，xinetd 启动 Ruby 脚本。发送到标准输出的任何脚本输出会被发送到发出请求的机器上的标准输出。这个脚本不需要输入，但是如果需要，发出请求的机器上的标准输入会被传递给脚本。Telnet 提供一种连接任何服务的简便方法：&lt;/p&gt;

&lt;p&gt;$ telnet localhost 11000
Trying 127.0.0.1…
Connected to localhost.
Escape character is ‘^]’.
/tmp/xinetd/b/e.txt
/tmp/xinetd/a/d.txt
Connection closed by foreign host.
成功了！端口打开了，控制被传递给脚本，脚本生成了预期的输出。&lt;/p&gt;

&lt;p&gt;运行 xinetd 的更多原因
xinetd 有许多优点。它只在需要时运行守护进程，这可以节省资源。它提供一个额外的安全层，可以通过 “修改根目录” 把服务隔离在一个目录中。最重要的是，它实际上可以把任何脚本或程序转换为服务。但是要注意一点：如果您的服务非常受欢迎，应该考虑用 C 等高效的语言重写它。处理请求越快，性能就越好。&lt;/p&gt;

&lt;p&gt;inetd 是一个守护程序，通过一个集中的配置文件（inetd.conf）来管理大多数入网连接。xinetd 守护程序是 inetd 的替代，它提供许多改进的或新的特性，以及更容易的配置。Ted 解释了 inetd 背后的概念，并且给出了在您自己的站点上设置 xinetd 的示例。
经典的 inetd 守护程序已经存在很久了。有几种替换 inetd 的功能的方法，但是最灵活、最简便的方法似乎是 xinetd。inetd 能做的，xinetd 也能做，并且 xinetd 还能做更多的事情。譬如，TCP 封装、模块化配置、连接重定向和入站连接的负载限制，而这些只是使得 xinetd 成为系统管理员良好选择的部分特性。&lt;/p&gt;

&lt;p&gt;本文是为从初学者到中级系统管理员这样的读者而准备的，并且文中的说明和示例并不尝试假设您已经熟悉 inetd。在本文中，我们将研究 xinetd 的一些简单用法，从安装到安全性策略的实现。&lt;/p&gt;

&lt;p&gt;开始之前
为实现本文的目的，您的系统最好安装了最近的主流（2000 或更新）UNIX（Linux、Solaris、BSD）。这些示例在 Perl 和 UNIX（以及其它操作系统）的早期版本上也可以运行，但是它们功能方面的障碍应该由读者作为练习来解决。给定的特定示例是用于 Red Hat Linux 的，但是它们在其它系统上应该也可以运行（除 chkconfig 以外）。&lt;/p&gt;

&lt;p&gt;inetd 到底是什么
对于 UNIX 系统管理员，inetd 和 cp/rm/mv 命令一样基本。它总是存在，并准备着处理入站连接。但它到底是什么？它用来做什么？&lt;/p&gt;

&lt;p&gt;首先从 TCP/IP （它也包括 UDP，但我们目前还不考虑）开始回答。当您建立与一台主机的连接时，实际上是创建了一个 TCP/IP 连接（通常是一个套接字） — 这好象是在您和主机之间打了一个电话。TCP/IP 连接由起始主机和接收主机唯一地定义，但还有其它标识。如果我们都连接到一台服务器，它如何区分 webserver、telnet、SSH、FTP 和其它连接呢？套接字也通过建立连接所使用的端口来定义。例如，端口 21 是入站 FTP、端口 22 是 SSH、端口 23 是 TELNET（有关其它大多数端口，可以查看 UNIX 系统上的 /etc/services）。&lt;/p&gt;

&lt;p&gt;一旦建立了连接，某人就在另一端拿起了电话。这可以是接线员或直线。直线表示您直接连接到了服务器，而接线员是涉及 inetd 的方法。接线员实际上处理一组入站直线（主机上的端口），并亲自将它们交给负责的程序（服务器）。&lt;/p&gt;

&lt;p&gt;UDP 是另一种连接方法。象 TCP 一样，UDP 基本上是和某人的对话，但是不保证它是可靠的。UDP（继续使用电话的比喻）就象将消息扔到传送带上，让接收者站到另一端。您可以从传送带得到许多消息，但是如果消息太多（网络流量高）或者读取消息费时太久（服务器忙），则接收者可能会丢失一些消息。&lt;/p&gt;

&lt;p&gt;如果使用 inetd，在执行一些检查后，您被重定向到特定服务器。只有一个配置文件 — inetd.conf，管理所有入站连接。因而在系统上添加、删除、更改或复查服务变得更为简单。例如，在 Solaris 系统上使用 TCP 封装器将 ftp 定义如下：&lt;/p&gt;

&lt;p&gt;清单 1，FTP 服务的 inetd.conf 定义 ftp stream tcp nowait root /usr/sbin/tcpd in.ftpd&lt;/p&gt;

&lt;p&gt;这些是创建一个 FTP 连接所需的全部参数。简单地说，我们以面向流（stream）的方式使用 TCP/IP（tcp）时，同时允许多个 FTP 连接（nowait）、作为 root 运行以及调用 FTP（接下来，TCP 封装器将调用 FTP 守护程序）。&lt;/p&gt;

&lt;p&gt;用一上午的时间解析很困难吗？绝对困难。有必要这么复杂吗？不。xinetd 继承了 inetd 的设计并将它模块化，这意味着每个服务都可以存在于它自己的配置文件中。xinetd 还添加了一些象 TCP 封装器之类的功能部件，使得配置更加简单。&lt;/p&gt;

&lt;p&gt;xinetd 保持了中央配置（接线员）方法，将所有配置文件存储到单一位置，通常是 /etc/xinetd.conf 和 /etc/xinetd.d/*，使系统管理员可以更容易地获得。模块化配置意味着，您可以通过将服务复制到 xinetd.d 目录来向多台机器上分发该服务，也可以用同类的手段除去它。甚至可以指定额外的包含目录。&lt;/p&gt;

&lt;p&gt;最后，xinetd FAQ（请参阅本文后面的参考资料）声明了 RPC 程序在 xinetd 下运行得不太好。不过没问题，对 RPC 使用 inetd，并对其它所有服务使用 xinetd。这就象雇了两个接线员，一个说西班牙语，另一个说所有其它语言。&lt;/p&gt;

&lt;p&gt;xinetd 简介
那么 xinetd 是什么？一句话，它就是个程序。处理入站网络连接没什么神奇。可以使用 Perl、Python 或 Java 来处理。Xinetd 是用 C 编写的，而且它和它的前辈 inetd 一样快，如果不是更快的话（例如，TCP 封装器不必为每个入站连接而执行；它们在启动时装入内存）。&lt;/p&gt;

&lt;p&gt;xinetd 正在开发中。（您的版本可能过时了，所以请务必到主页上查找最新的版本；请参阅参考资料。）因为它正在开发中，所以 xinetd 的安全漏洞得以迅速弥补，而不象 inetd 那样薄弱，通常要很长时间才能弥补。当然，xinetd 是随源代码一起交付的，所以您可以复查源代码并自己找到可能存在弱点的地方。&lt;/p&gt;

&lt;p&gt;如何使用 xinetd 定义服务呢？编写一个服务文件，它除了指定 /etc/xinetd.conf 中所指定的一般参数之外，还指定特定配置。所以，如果 /etc/xinetd.conf 是这样的：&lt;/p&gt;

&lt;p&gt;清单 2，样本 xinetd.conf（标准的 Red Hat 7.1） defaults
{
instances = 60
log_type = SYSLOG authpriv
log_on_success = HOST PID
log_on_failure = HOST
cps = 25 30
}&lt;/p&gt;

&lt;p&gt;service telnet
{
flags = REUSE
socket_type = stream 
wait = no
user = root
server = /usr/sbin/in.telnetd
log_on_failure += USERID
disable = yes
}&lt;/p&gt;

&lt;p&gt;includedir /etc/xinetd.d&lt;/p&gt;

&lt;p&gt;您放到 /etc/xinetd.d 中的每个服务文件都会继承这些缺省值，并指定它自己的参数。这里，telnet 服务在顶级定义，而不是在子目录中定义。这太棒了，这种模块性允许复杂的配置。&lt;/p&gt;

&lt;p&gt;要使 xinetd 重新读取配置文件，不必重新启动它。只要向它发送 USR2 信号即可。&lt;/p&gt;

&lt;p&gt;那些参数表示什么意思？让我们通读整个清单。您也可以在命令行下使用 man xinetd.conf 来查看列表（如果那个帮助页面正确安装的话），但这个概述试图用更简单的术语来解释参数，并不假定您已经知道关于套接字和服务的所有信息。一些参数（rpc_version、rpc_number）被跳过。&lt;/p&gt;

&lt;p&gt;常规参数&lt;/p&gt;

&lt;p&gt;id 
该服务的唯一名称。服务名称在花括号之前指定，但是 ID 使逻辑上相同的服务可能拥有多个协议。这是对于临时用户的受限使用。例如，NFS 服务可以在 UDP 或 TCP 传输协议上运行。在 Red Hat Linux 7.1 上，TCP 版本（在 /etc/xinetd.d/time 中）和 UDP 版本（在 /etc/xinetd.d/time-udp中）中提供了对于 xinetd 来说内部的时间服务。&lt;/p&gt;

&lt;p&gt;type 
这实际上应该称为“特殊类型”，因为它只适用于特殊服务。它可以是以下几种类型的组合：“RPC”，用于 RPC 服务（由 SUN 引入的远程过程调用，导致了很多安全性问题，最好避免使用）；“INTERNAL”，用于构建到 xinetd 内部的服务，譬如时间服务；“UNLISTED”，用于在系统列表（/etc/services 或用于 RPC 服务的 /etc/rpc）中找不到的非标准服务。&lt;/p&gt;

&lt;p&gt;flags 
这里放置着所有额外标志。列表很长并且技术性很强；我们感兴趣的标志包括 REUSE（用于套接字重用，譬如 telnet）、NAMEINARGS/NOLIBWRAP（如果您希望手工调用 TCP 封装器或者完全地避免使用封装器）、NODELAY/KEEPALIVE（用于调整 TCP 套接字）、DISABLE（覆盖顶级“disable”参数）以及 SENSOR（用于检测和防止某些类型的“拒绝服务（denial-of-service）”网络攻击）。&lt;/p&gt;

&lt;p&gt;disable 
除非您希望禁用某项服务，否则总是把它设成“no”。Red Hat Linux 的 chkconfig 程序将为您打开或关闭“disable”参数；在 Red Hat 上，用 chkconfig 启用和禁用特定服务可能比手工方式简单些。请注意，chkconfig 预期在 /etc/xinetd.d/SERVICE 中找到服务文件。所以对于上面清单 2 中的示例，chkconfig 将不会在请求时打开或关闭 telnet。可以将它认为是一个错误或特性，取决于您的观点。&lt;/p&gt;

&lt;p&gt;socket_type 
通常您希望这个参数设置成“stream”，除非使用 UDP 服务，此时设置成“dgram”。该参数也可以设置成“raw”和“seqpacket”，但极少见。&lt;/p&gt;

&lt;p&gt;protocol 
这是连接所用的协议，通常是“tcp”或“udp”，但是在理论上您可以使用来自 /etc/protocols 的任何值。&lt;/p&gt;

&lt;p&gt;wait 
如果设置成“no”，xinetd 将为每个连接上的服务启动一个新的处理程序。如果是“yes”，xinetd 预期该处理程序处理所有后续连接直到它死亡。在大多数情况下，这个参数是“no”。&lt;/p&gt;

&lt;p&gt;server, server_args 
处理程序的程序名，以及它应当获得的参数。处理程序名不应该象在 inetd 环境下那样，出现在参数中。&lt;/p&gt;

&lt;p&gt;port 
服务的端口。通常不需要，因为端口通过 /etc/services 文件来映射到服务。&lt;/p&gt;

&lt;p&gt;redirect 
允许 xinetd 将所有服务的流量发送给另一台主机。因此，受防火墙保护的主机可以通过中央 xinetd 转发器接受安全流量，而不必建立与外部网络的连接。在某些工作中，可以采用这个特征来在两台主机间执行故障转移服务。&lt;/p&gt;

&lt;p&gt;banner, banner_success, banner_fail 
一个将要在“任意/一个成功/一个不成功”连接上打印的来自文件的定制文本块。&lt;/p&gt;

&lt;p&gt;enabled 
在全局级别上补充“disabled”参数和 DISABLE 标志。&lt;/p&gt;

&lt;p&gt;include, includedir 
告诉 xinetd 要包含文件或目录。&lt;/p&gt;

&lt;p&gt;环境参数&lt;/p&gt;

&lt;p&gt;user, group, umask, groups 
当启动服务处理程序时，xinetd 应该扮演的 UNIX 属性。这主要用于非安全服务。&lt;/p&gt;

&lt;p&gt;nice 
确定该服务对于系统有多重要的 UNIX 优先级级别。可以针对您的系统调整它，请查看“nice”的 man 页面。&lt;/p&gt;

&lt;p&gt;env 
用于服务处理程序的环境变量。&lt;/p&gt;

&lt;p&gt;passenv 
应该向下传递到服务处理程序的 xinetd 中的环境变量。&lt;/p&gt;

&lt;p&gt;资源管理参数&lt;/p&gt;

&lt;p&gt;instances 
可以同时启动的处理程序数。可以调整这个参数以防止拒绝服务攻击。如果您希望缺省（无限制）行为，将它设置成“UNLIMITED”。&lt;/p&gt;

&lt;p&gt;max_load 
I: ) 如果系统过载，停止接受连接。负载数取决于系统，仅当您确实知道自己在做什么时才能调整它。&lt;/p&gt;

&lt;p&gt;rlimit_as, rlmist_cpu, rlimit_data, rlimit_rss, rlimit_stack 
rlimit 参数指定用于服务处理程序的资源限制（内存、CPU 以及特定内存区域）。&lt;/p&gt;

&lt;p&gt;特定于安全性的参数&lt;/p&gt;

&lt;p&gt;only_from, no_access 
对 TCP 封装器的补充，这是阻挡主机建立与我们的连接的方法之一。请注意，缺省值是允许对任何人的访问，除非 TCP 封装器（其规则通常在 /etc/hosts.allow 中）另有规定。&lt;/p&gt;

&lt;p&gt;access_times 
一天中服务可用的时间。例如，“6:00-23:00”意味着服务从上午 6 点到晚上 11:01 可用。&lt;/p&gt;

&lt;p&gt;log_type, log_on_success, log_on_failure 
各种日志记录选项。USERID 标志可能特别麻烦，因为它向连接的主机询问关于与我们连接的用户，这使得处理变慢。尽可能避免使用 USERID。&lt;/p&gt;

&lt;p&gt;bind 
允许服务特定于接口，通常是出于安全性考虑。例如，在网络内部的 FTP 服务只是 FTP，而外部 FTP 连接将生成入侵者警报。“id”参数在这里很有用。&lt;/p&gt;

&lt;p&gt;per_source 
指定来自源 IP 的服务的最大实例数。对于处理“单源拒绝服务（single-source denial-of-service）”攻击或出错程序建立的过多连接非常有用。&lt;/p&gt;

&lt;p&gt;cps 
每秒允许的最大连接数，以及服务再度启用之前的秒数。“30 45”表示“每秒 30 个入站连接，如果超过限制，则等待 45 秒”。主要用于对付拒绝服务攻击。&lt;/p&gt;

&lt;p&gt;deny_time 
对引发 SENSOR 标志的人拒绝服务的时间。&lt;/p&gt;

&lt;p&gt;替换 TCP 封装器
经典的 TCP 封装器软件包是个非常有用的工具。通过一个集中式的文件（通常是 /etc/hosts.allow 和 /etc/hosts.deny），针对每个服务，根据需要来允许或拒绝对任何主机的访问。不幸的是，TCP 封装器库不太了解系统负载、资源限制、多重攻击之类的情况。xinetd 合并了 TCP 封装器功能性（通过 libwrap 库），所以您可以顺利地迁移到 xinted，并继续使用和以前相同的配置文件。&lt;/p&gt;

&lt;p&gt;这差不多就是迁移所要做的全部工作了。保持旧的 hosts.deny 和 hosts.allow 文件，xinetd 将乐意遵循它们。但是，请牢记，xinetd 有许多在 TCP 封装器基础上改进的连接控制选项。例如，限制每秒连接数或过载时的连接数，可以成为对服务器管理极有价值的帮助。&lt;/p&gt;

&lt;p&gt;确保您是使用 libwrap 选项编译 xinetd 的，否则，它将不知道 TCP 封装器。如果 xinetd 来自于 Red Hat Linux 上的 RPM，确保您在开放机器“之前”，测试 TCP 封装器文件是否正常运行。&lt;/p&gt;

&lt;p&gt;高级用途：故障转移
尽管可以有多种方法使用 xinetd，redirect 参数为我们提供了最有趣的使用方法。众所周知，故障转移很难实现，并且硬件故障转移很昂贵。这里所描述的方法（通过简单的软件）既便宜又有效。它具有单故障点 — 重定向点，所以您应该考虑该方式是否可接受。如果不能接受，那么，硬件故障转移就贵得有道理了。&lt;/p&gt;

&lt;p&gt;首先，确定一种方法从两台或者更多的机器中选出一台“活动的”机器。假设您通过一个脚本 set_active.pl 来完成（我们将为 telnet 服务完成该步，但是它对任何其他服务也有效，只要能保持服务切换到其他服务器而不带来不良影响）。脚本将采用我们用来设置新故障转移的机器名，以及给我们适当的用于编辑的 /etc/xinetd.d/SERVICE 文件的服务名。请随意定制脚本以编辑不同文件，或使用不同参数。可以用一行“perl -p -i -e”脚本执行这个作业，但您可以在将来对这种方法作许多扩展，并可以对参数执行错误检查。&lt;/p&gt;

&lt;p&gt;这太简单了。现在只要决定调用这个脚本的过程即可 — 可以是手工、通过一个 cron 作业、或者由另一个程序触发。此时，它成为体系结构决策。别忘了在这时向 xinetd 发送 USR2 信号，如果愿意，也可以重新启动它。在 Red Hat Linux 上可以用“pkill -USR2 xinetd”完成信号的自动化，而重新启动 xinetd 只要使用“/etc/rc.d/init.d/xinetd restart”（在 Linux 上）或者其它类似命令（在大多数 UNIX 系统上）。&lt;/p&gt;

&lt;p&gt;这种故障转移将“不会”对数据库连通性生效，除非在数据库端做许多额外工作。建议您最好将它用于诸如 rsync、ssh、ftp 和 telnet 之类的协议，其中，故障转移机器彼此没有相互依赖性。&lt;/p&gt;

&lt;p&gt;Linux inetd 有多个服务
1， 开启方式   命令行输入 inetd。&lt;/p&gt;

&lt;p&gt;2， 开启服务选择  /etc/inetd.conf       ftp  telnet   etc.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;开启服务对应程序建立软连接  指向 busybox 对应程序     busybox cp .&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开启对应端口 /etc/server&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 27 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/linux/2017/12/27/inetd.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/linux/2017/12/27/inetd.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>Django_nginx_uwsgi</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;安装Python包管理
easy_install 包 https://pypi.python.org/pypi/distribute
wget https://pypi.python.org/packages/source/d/distribute/distribute-0.6.49.tar.gz
tar xf distribute-0.6.49.tar.gz
cd distribute-0.6.49
python2.7 setup.py install
easy_install –version
安装 uwsgi
uwsgi:https://pypi.python.org/pypi/uWSGI&lt;/p&gt;

&lt;p&gt;uwsgi 参数详解：http://uwsgi-docs.readthedocs.org/en/latest/Options.html&lt;/p&gt;

&lt;p&gt;pip install uwsgi
uwsgi –version    # 查看 uwsgi 版本
测试 uwsgi 是否正常：&lt;/p&gt;

&lt;p&gt;新建 test.py 文件，内容如下：&lt;/p&gt;

&lt;p&gt;def application(env, start_response):
    start_response(‘200 OK’, [(‘Content-Type’,’text/html’)])
    return “Hello World”
然后在终端运行：&lt;/p&gt;

&lt;p&gt;uwsgi –http :8001 –wsgi-file test.py&lt;/p&gt;

&lt;p&gt;在浏览器内输入：http://127.0.0.1:8001，查看是否有”Hello World”输出，若没有输出，请检查你的安装过程。&lt;/p&gt;

&lt;p&gt;安装 Django
pip install django
测试 django 是否正常，运行：&lt;/p&gt;

&lt;p&gt;django-admin.py startproject demosite
cd demosite
python2.7 manage.py runserver 0.0.0.0:8002
在浏览器内输入：http://127.0.0.1:8002，检查django是否运行正常。&lt;/p&gt;

&lt;p&gt;安装 Nginx
安装命令如下：&lt;/p&gt;

&lt;p&gt;cd ~
wget http://nginx.org/download/nginx-1.5.6.tar.gz
tar xf nginx-1.5.6.tar.gz
cd nginx-1.5.6
./configure –prefix=/usr/local/nginx-1.5.6 \
–with-http_stub_status_module \
–with-http_gzip_static_module
make &amp;amp;&amp;amp; make install
你可以阅读 Nginx 安装配置 了解更多内容。&lt;/p&gt;

&lt;p&gt;uwsgi 配置
uwsgi支持ini、xml等多种配置方式，本文以 ini 为例， 在/ect/目录下新建uwsgi9090.ini，添加如下配置：&lt;/p&gt;

&lt;p&gt;[uwsgi]
socket = 127.0.0.1:9090
master = true         //主进程
vhost = true          //多站模式
no-site = true        //多站模式时不设置入口模块和文件
workers = 2           //子进程数
reload-mercy = 10   &lt;br /&gt;
vacuum = true         //退出、重启时清理文件
max-requests = 1000 &lt;br /&gt;
limit-as = 512
buffer-size = 30000
pidfile = /var/run/uwsgi9090.pid    //pid文件，用于下面的脚本启动、停止该进程
daemonize = /website/uwsgi9090.log
Nginx 配置
找到nginx的安装目录（如：/usr/local/nginx/），打开conf/nginx.conf文件，修改server配置：&lt;/p&gt;

&lt;p&gt;server {
        listen       80;
        server_name  localhost;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    location / {            
        include  uwsgi_params;
        uwsgi_pass  127.0.0.1:9090;              //必须和uwsgi中的设置一致
        uwsgi_param UWSGI_SCRIPT demosite.wsgi;  //入口文件，即wsgi.py相对于项目根目录的位置，“.”相当于一层目录
        uwsgi_param UWSGI_CHDIR /demosite;       //项目根目录
        index  index.html index.htm;
        client_max_body_size 35m;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WSGI是Web Server Gateway Interface的缩写。以层的角度来看，WSGI所在层的位置低于CGI。但与CGI不同的是WSGI具有很强的伸缩性且能运行于多线程或多进程的环境下，这是因为WSGI只是一份标准并没有定义如何去实现。实际上WSGI并非CGI，因为其位于web应用程序与web服务器之间，而web服务器可以是CGI，mod_python（注：现通常使用mod_wsgi代替），FastCGI或者是一个定义了WSGI标准的web服务器就像python标准库提供的独立WSGI服务器称为wsgiref。&lt;/p&gt;

&lt;p&gt;Python Paste - WSGI底层工具集. 包括多线程, SSL和 基于Cookies, sessions等的验证(authentication)库. 可以用Paste方便地搭建自己的Web框架。
WSGI:Python Web Server Gateway Interface v1.0
它是 PEP3333中定义的（PEP3333的目标建立一个简单的普遍适用的服务器与Web框架之间的接口）
WSGI是Python应用程序或框架和Web服务器之间的一种接口&lt;/p&gt;
</description>
        <pubDate>Wed, 27 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/web/2017/12/27/Django_nginx_uwsgi.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/web/2017/12/27/Django_nginx_uwsgi.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>UNIX下的5种IO模型</title>
        <description>&lt;!-- more --&gt;
&lt;p&gt;套接字的IO操作，如recvfrom，分为两个阶段：&lt;/p&gt;

&lt;p&gt;（1）等待内核中的接收缓冲区中有数据可读。&lt;/p&gt;

&lt;p&gt;（2）将接收缓冲区中的数据复制进应用缓冲区。&lt;/p&gt;

&lt;p&gt;1，阻塞式IO&lt;/p&gt;

&lt;p&gt;文件描述符open时，如果没有指定flags为O_NONBLOCK，或者open后，没有使用fcntl设置O_NONBLOCK，默认文件描述符为阻塞模式。&lt;/p&gt;

&lt;p&gt;阻塞式IO在等待接收缓冲区数据到来时，会阻塞；&lt;/p&gt;

&lt;p&gt;数据到来，进行数据复制时，也会阻塞。&lt;/p&gt;

&lt;p&gt;2，非阻塞式IO&lt;/p&gt;

&lt;p&gt;如上所述，可以通过open或者fcntl设置文件描述符为非阻塞模式。&lt;/p&gt;

&lt;p&gt;非阻塞式IO，当内核缓冲区没有数据时，不会阻塞，会立即返回一个错误——EAGAIN或者EWOULDBLOCK。EAGAIN表示需要再次调用recvfrom，以判断数据是否准备好，这也是非阻塞式IO的用法，不断的调用recvfrom，以判断是否可以读。EWOULDBLOCK是虚拟语气，表示“本应该阻塞”，其实没有阻塞。由于并不确定返回EAGAIN还是EWOULDBLOCK，因此需要对这两个值都进行判断。&lt;/p&gt;

&lt;p&gt;从接收缓冲区向应用缓冲区复制数据阶段，调用进程阻塞。&lt;/p&gt;

&lt;p&gt;3，IO复用&lt;/p&gt;

&lt;p&gt;在阻塞式IO中，如果接收缓冲区没有数据，调用进程阻塞于recvfrom操作。使用select或者poll，可以在此情况下使进程阻塞于select或者poll操作（因此要把文件描述符设置为非阻塞式），而且可以同时检测多个文件描述符是否可读，即检测这些描述符对应的内核中的接收缓冲区是否有数据。&lt;/p&gt;

&lt;p&gt;从接收缓冲区向应用缓冲区复制数据阶段，调用进程阻塞。&lt;/p&gt;

&lt;p&gt;4，信号驱动式IO&lt;/p&gt;

&lt;p&gt;信号驱动式IO与上述三个IO模型相比，即不像阻塞式IO那样阻塞于recvfrom操作，也不像非阻塞式IO那样需要多次调用甚至轮询recvfrom才能得知是否有数据，也不像IO复用那样阻塞于select或者poll，而是当内核接收缓冲区有数据时向调用进程发送一个信号。&lt;/p&gt;

&lt;p&gt;从接收缓冲区向应用缓冲区复制数据阶段，调用进程阻塞。&lt;/p&gt;

&lt;p&gt;5，异步IO&lt;/p&gt;

&lt;p&gt;上述4种IO模型，其不同点在于当接收缓冲区没有数据时，如何判断数据已经到来：阻塞式IO中recvfrom会阻塞直到接收缓冲区有数据；非阻塞式IO通过轮询recvfrom以判断接收缓冲区是否有数据；IO复用中使用select或者poll以判断接收缓冲区是否有数据；信号驱动IO通过信号通知接收缓冲区是否有数据。&lt;/p&gt;

&lt;p&gt;其相同点在于，IO操作的第二个阶段，即从内核接收缓冲区向应用缓冲区复制数据时，调用recvfrom的进程会阻塞。&lt;/p&gt;

&lt;p&gt;可见，上述4种IO模型都会使进程阻塞，直到IO操作的两个阶段都完成才能执行其他操作，因此称为同步IO。&lt;/p&gt;

&lt;p&gt;异步IO模型中，IO操作的两个阶段都不阻塞，因此称为异步IO。&lt;/p&gt;

&lt;p&gt;阻塞IO
这是我们熟悉的IO模型，一个进程在作IO操作时，非要等到数据从内核空间拷贝到用户进程空间，才会返回。这个模型的优点就是简单，而且在阻塞的时候，CPU还可以进行调度，去执行别的进程。
非阻塞IO
一开始我看是非阻塞IO，觉得应该要比阻塞IO模型先进，可是当我一看使用方法的时候，就知道这个模型是不会被实际使用的，仅仅只能作为理论上存在的IO模型。这个模型的观点是：进行IO操作的时候，不阻塞，如果没有数据准备好，就直接返回错误码（或者是别的代码）。因此，使用者就只能不断进行轮询来调用IO函数。这样的后果就是，不仅在宏观上形成了与阻塞IO一共的“阻塞”效果，而且在微观上，CPU一直被用来轮询，造成了CPU的浪费。所以，这个模型还不如阻塞IO模型实用。
IO复用
对于IO复用，我的理解有三点：
在一次系统调用中，实现了询问多个描述符的IO准备情况 —— 根据事件通知
为了实现第一点，就需要把阻塞的地方进行转移。把一次系统调用，分为两次系统调用。第一次系统调用可以询问多个描述符的IO准备情况，在这个地方进行阻塞；而第二次系统调用，是针对已经准备好IO的描述符进行调用，此时，理论上（按照我的理解），也是会发生阻塞的，只不过是此时内核已经把数据准备好了，阻塞的时间可以忽略不计罢了。
本质上，还是阻塞的。
信号IO
我们都知道，信号是UNIX提供了进程间进行通信的一种方式。我们常用的 kill -9 命令（kill是向进程传递信号量，9只是众多信号中的一个代号），或者是 Ctrl + C 的时候，就是向某个进程发出终止的信号，这样进程就退出了。
而对于信号IO的模型，我是这么理解的：进程在发起IO操作，系统调用之后，直接访问，内核会在IO数据准备好之后，以某个信号通知发起IO操作的进程，从而使得该进程的信号处理函数可以读取IO数据的操作。
本质上，这也是阻塞的IO模型，因为在信号处理函数中，同样也是要进行阻塞的，只是在在这个时候发起系统系统，内核已经把数据准备好了。
异步IO
这是真正的异步IO了。实现的机制是：用户在发起异步IO的系统调用时，会把相应的数据处理函数作为回调函数，等到IO数据准备好，内核会主动调用此回调函数。可以看出，用户进程在这种模型下，只调用了一次系统调用，而且是立即返回的，因此，就不会出现让进程阻塞的情况，也就符合了POSIX中异步IO的定义。
其实我理解起来，思路是和信号IO差不多的，唯一不同的地方，对于IO数据的操作，异步IO是由内核主动发起的，而信号IO是由用户进程发起的。&lt;/p&gt;

&lt;p&gt;进程切换
为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。&lt;/p&gt;

&lt;p&gt;从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;保存处理机上下文，包括程序计数器和其他寄存器。&lt;/li&gt;
  &lt;li&gt;更新PCB信息。&lt;/li&gt;
  &lt;li&gt;把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。&lt;/li&gt;
  &lt;li&gt;选择另一个进程执行，并更新其PCB。&lt;/li&gt;
  &lt;li&gt;更新内存管理的数据结构。&lt;/li&gt;
  &lt;li&gt;恢复处理机上下文。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 24 Dec 2017 00:00:00 +0800</pubDate>
        <link>https://xiazemin.github.io/MyBlog/linux/2017/12/24/unix_io5.html</link>
        <guid isPermaLink="true">https://xiazemin.github.io/MyBlog/linux/2017/12/24/unix_io5.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
  </channel>
</rss>
