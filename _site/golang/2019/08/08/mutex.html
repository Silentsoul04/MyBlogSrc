<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="http://localhost:4000/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="http://localhost:4000/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "http://localhost:4000/MyBlog/img/BPlusTree.png", "http://localhost:4000/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="http://localhost:4000/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">mutex</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-08-08T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Aug 8, 2019</time></p>
					</div>
					 <p>CAS原子操作。<br />
需要有一种阻塞和唤醒机制。<br />
尽量减少阻塞和唤醒切换成本。<br />
锁尽量公平，后来者要排队。即使被后来者插队了，也要照顾先来者，不能有“饥饿”现象。<br />
先看3，4点。再看2，1点。最后是源码。<br />
<!-- more --><br />
尽量减少阻塞和唤醒切换成本<br />
减少切换成本的方法就是不切换，简单而直接。</p><br />
<br />
<p>不切换的方式就是让竞争者自旋。自旋一会儿，然后抢锁。不成功就再自旋。到达上限次数才阻塞。</p><br />
<br />
<p>自旋就是CPU空转一定的时钟周期</p><br />
<br />
<p>不同平台上自旋所用的指令不一样。例如在amd64平台下，汇编的实现如下</p><br />
<br />
<p>TEXT runtime·procyield(SB),NOSPLIT,$0-0<br />
  MOVL  cycles+0(FP), AX<br />
again:<br />
    // 自旋cycles次，每次自旋执行PAUSE指令<br />
  PAUSE<br />
  SUBL  $1, AX<br />
  JNZ  again<br />
  RET<br />
是否允许自旋的判断是严格的。而且最多自旋四次，每次30个CPU时钟周期。</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>能不能自旋全由这个条件语句决定if old&amp;(mutexLocked</td><br />
      <td>mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter)。</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>翻译下，就是下面的条件都满足，才允许自旋。</p><br />
<br />
<p>锁已被占用，并且锁不处于饥饿模式。</p><br />
<br />
<p>积累的自旋次数小于最大自旋次数（active_spin=4）。</p><br />
<br />
<p>cpu核数大于1。</p><br />
<br />
<p>有空闲的P。</p><br />
<br />
<p>当前goroutine所挂载的P下，本地待运行队列为空。</p><br />
<br />
<p>可以看到自旋要求严格，毕竟在锁竞争激烈时，还无限制地自旋就肯定会影响其他goroutine。</p><br />
<br />
<p>const   active_spin     = 4<br />
func sync_runtime_canSpin(i int) bool {<br />
  // 自旋次数不能大于 active_spin(4) 次<br />
  // cpu核数只有一个，不能自旋<br />
  // 没有空闲的p了，不能自旋<br />
  if i &gt;= active_spin || ncpu &lt;= 1 || gomaxprocs &lt;= int32(sched.npidle+sched.nmspinning)+1 {<br />
    return false<br />
  }<br />
  // 当前g绑定的p里面本地待运行队列不为空，不能自旋<br />
  if p := getg().m.p.ptr(); !runqempty(p) {<br />
    return false<br />
  }<br />
  return true<br />
}</p><br />
<br />
<p>锁模式介绍<br />
上面的出现了两个常量，mutexStarving和mutexLocked。它们与锁对象结构有关。比较基础，这里介绍一下。</p><br />
<br />
<p>type Mutex struct {<br />
  // [阻塞的goroutine个数, starving标识, woken标识, locked标识]<br />
  state int32<br />
  sema  uint32<br />
}<br />
Mutex结构简单的就只有两个成员变量。sema是信号量，下文会介绍到。这里主要介绍state的结构。</p><br />
<br />
<p>一个32位的变量，被划分成上图的样子。右边的标识也有对应的常量</p><br />
<br />
<p>const (<br />
  mutexLocked = 1 « iota // mutex is locked<br />
  mutexWoken  <br /><br />
  mutexStarving <br />
  mutexWaiterShift = iota<br />
)</p><br />
<br />
<p>含义如下：</p><br />
<br />
<p>mutexLocked对应右边低位第一个bit。值为1，表示锁被占用。值为0，表示锁未被占用。</p><br />
<br />
<p>mutexWoken对应右边低位第二个bit。值为1，表示打上唤醒标记。值为0，表示没有唤醒标记。</p><br />
<br />
<p>mutexStarving对应右边低位第三个bit。值为1，表示锁处于饥饿模式。值为0，表示锁存于正常模式。</p><br />
<br />
<p>mutexWaiterShift是偏移量。它值为3。用法是state»=mutexWaiterShift之后，state的值就表示当前阻塞等待锁的goroutine个数。最多可以阻塞2^29个goroutine。</p><br />
<br />
<p>Mutex锁分为两种模式，正常模式 和 饥饿模式。</p><br />
<br />
<p>正常模式下，对于新来的goroutine而言，它有两种选择，要么抢到了锁，直接执行；要么抢不到锁，追加到阻塞队列尾部，等待被唤醒的。</p><br />
<br />
<p>饥饿模式下，对于新来的goroutine，它只有一个选择，就是追加到阻塞队列尾部，等待被唤醒的。而且在该模式下，所有锁竞争者都不能自旋。</p><br />
<br />
<p>除了这两种模式。还有一个Woken(唤醒标记)。它主要用于自旋状态的通知和锁公平性的保证。分两个角度理解：</p><br />
<br />
<p>一、新的goroutine申请锁时，发现锁被占用了。但自己满足自旋条件，于是自己自旋，并设置上的Woken标记。此时占用锁的goroutine在释放锁时，检查Woken标记，如果被标记。哪怕现在锁上面的阻塞队列不为空，也不做唤醒。直接return，让自旋着的goroutine有更大机会抢到锁。</p><br />
<br />
<p>if old»mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {<br />
    return<br />
}<br />
二、释放锁时，检查Woken标记为空。而阻塞队列里有goroutine需要被唤醒。那么在唤醒时，同时标记锁Woken。这里可能有疑问，原来没有Woken标记，为什么在唤醒一个goroutine要主动标记呢？目的是保证锁公平。</p><br />
<br />
<p>考虑这样的场景：现在阻塞队列里只有一个goroutine。把它唤醒后，还得等调度器运行到它，它自己再去抢锁。但在调度器运行到它之前，很可能新的竞争者参与进来，此时锁被抢走的概率就很大。</p><br />
<br />
<p>这有失公平，被阻塞的goroutine是先到者，新的竞争者是后来者。应该尽量让它们一起竞争。</p><br />
<br />
<p>// 唤醒一个阻塞的goroutine，并把锁的Woken标记设置上<br />
new = (old - 1«mutexWaiterShift) | mutexWoken<br />
设置Woken标记后，state就肯定不为零。此时新来的竞争者，在执行Lock()的fast-path时会失败，接下来就只能乖乖排队了。</p><br />
<br />
<p>func (m *Mutex) Lock() {<br />
  // Fast path: grab unlocked mutex.<br />
  // Woken标记设置后，这里的CAS就会为false<br />
  if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {<br />
    // …<br />
    return<br />
  }<br />
  // 接下来在阻塞里排队<br />
}<br />
小总结：为了减少切换成本，短暂的自旋等待是简单的方法。而竞争者在自旋时，要主动设置Woken标记。这样释放者才能感知到。</p><br />
<br />
<p>锁尽量公平<br />
为什么不是绝对公平？要绝对公平的粗暴做法就是在锁被占用后，其它所有竞争者，包括新来的，全部排队。</p><br />
<br />
<p>但排队的问题也很明显，排队阻塞唤醒的切换成本(这是损耗性能的潜在的隐患，下面Mutex的问题有举例)。假如临界区代码执行只需要十几个时钟周期时，让竞争者自旋等待一下，立刻就可以获得锁。减少不必要的切换成本，效率更高。</p><br />
<br />
<p>尽量公平的结果就是阻塞的竞争者被唤醒后，也要与(正在自旋的)新竞争者抢夺锁资源。</p><br />
<br />
<p>go使用三种手段保证Mutex锁尽量公平：</p><br />
<br />
<p>上面介绍的，在锁释放时，主动设置Woken标记，防止新的竞争者轻易抢到锁。</p><br />
<br />
<p>竞争者进阻塞队列策略不一样。新的竞争者，抢不到锁，就排在队列尾部。先来竞争者，从队列中被唤醒后，还是抢不到锁，就放在队列头部。</p><br />
<br />
<p>任何竞争者，被阻塞等待的时间超过指定阀值(1ms)。锁就转为饥饿模式。这时锁释放时会唤醒它们，手递手式把锁资源给它们。别的竞争者（包括新来的）都抢不到。直接把饥饿问题解决掉。</p><br />
<br />
<p>饥饿问题是会积压的。要尽快解决。举个例子解释一下：</p><br />
<br />
<p>蓝色是新竞争者，红色是阻塞等待时间超过阀值的竞争者。每次持锁时间是0.3ms。</p><br />
<br />
<p>只要有竞争者阻塞超时了，锁就会转换为饥饿模式。饥饿模式下，所有的新竞争者都得排队。</p><br />
<br />
<p>时刻4中的G3就是被积压的。如果时刻0中的竞争者更多时，并且抢锁顺序不变。那么时刻4的积压就更严重。</p><br />
<br />
<p>同时反映出一个问题。</p><br />
<br />
<p>Mutex带来的问题<br />
假设在业务某个场景中，对每个请求都需要访问某互斥资源。使用Mutex锁时，如果QPS很高，阻塞队列肯定会很满。虽然QPS可能会降，但请求是持续的。</p><br />
<br />
<p>新来的请求，在访问互斥资源时有可能抢锁成功，后来者胜于先到者。这种情况持续发生的话，就会导致阻塞队列中所有的请求得不到处理，耗时增高，直至超出上游设置的超时时间，一下子失败率突增，上游再影响它的上游，引起连锁反应进而服务故障异常。</p><br />
<br />
<p>解决方案要根据实际业务场景来优化。削减锁的粒度；或者使用CAS的方式进队列，然后阻塞在通道上；或者使用无锁结构等待。</p><br />
<br />
<p>阻塞在通道而不是阻塞的锁上，是因为go的runtime对待锁唤醒和通道唤醒goroutine的效率是不一样的。这也引出了还有一种方案是改runtime，让锁唤醒的goroutine更快地得到执行。毕竟上面问题点是被唤醒的goroutine和新的goroutine在竞争中不能保证稳胜，被唤醒的goroutine会有一个调度耗时，减少耗时就有可能提高竞争成功率。</p><br />
<br />
<p>阻塞和唤醒机制<br />
go的阻塞和唤醒是semacquire和semrelease。虽然命名上是sema，但实际用途却是一套阻塞唤醒机制。</p><br />
<br />
<p>// That is, don’t think of these as semaphores.<br />
// Think of them as a way to implement sleep and wakeup</p><br />
<br />
<p>阻塞和唤醒机制</p><br />
<br />
<p>go的runtime有一个全局变量semtable，它放置了所有的信号量。</p><br />
<br />
<p>var semtable [semTabSize]struct {<br />
  root semaRoot<br />
  pad  [sys.CacheLineSize - unsafe.Sizeof(semaRoot{})]byte<br />
}</p><br />
<br />
<p>func semacquire1(addr *uint32, lifo bool, profile semaProfileFlags)<br />
func semrelease1(addr *uint32, handoff bool)<br />
每个信号量都由一个变量地址指定。Mutex就是用成员sema的地址。</p><br />
<br />
<p>在阻塞时，调用semacquire1，把地址(addr)传给它。</p><br />
<br />
<p>如果addr大于1，并且通过CAS减一成功，那就说明获取信号量成功。不用阻塞。</p><br />
<br />
<p>否则，semacquire1会在semtable数组中找一个元素和它对应上。每个元素都有一个root，这个root是Treap树（ACM同学应该熟悉）。</p><br />
<br />
<p>最后addr变成一个树节点，这个树节点，有自己的一个队列，专门放被阻塞的goroutine。叫它阻塞队列吧。</p><br />
<br />
<p>这个阻塞队列是个双端队列，头尾都可以进。</p><br />
<br />
<p>semacquire1把当前goroutine相关元数据放进阻塞队列之后，就挂起了。</p><br />
<br />
<p>semrelease1是给addr CAS加一。<br />
如果坚持发现当前addr上有阻塞的goroutine时，就取一个出来，唤醒它，让它自己再去semacquire1。这是handoff为false的情况。<br />
但handoff为true的话，就尝试手递手地把信号量送给这个goroutine。等于说goroutine不用再自己去抢了，因为自己再去抢有可能抢不到。<br />
最后semrelease1会把取出来的这个goroutine挂在当前P的本地待运行队列尾部，等待调度执行。<br />
就是这样，在获取不到Mutex锁时，通过信号量来阻塞和唤醒goroutine。</p><br />
<br />
<p>CAS原子操作<br />
CAS就是基本的原子操作。没什么好说的。</p><br />
<br />
<p>例如在amd64上，go的汇编实现：</p><br />
<br />
<p>TEXT ·CompareAndSwapUint32(SB),NOSPLIT,$0-17<br />
  MOVV  addr+0(FP), R1<br />
  MOVW  old+8(FP), R2<br />
  MOVW  new+12(FP), R5<br />
  SYNC<br />
cas_again:<br />
  MOVV  R5, R3<br />
  LL  (R1), R4<br />
  BNE  R2, R4, cas_fail<br />
  SC  R3, (R1)<br />
  BEQ  R3, cas_again<br />
  MOVV  $1, R1<br />
  MOVB  R1, swapped+16(FP)<br />
  SYNC<br />
  RET<br />
cas_fail:<br />
  MOVV  $0, R1<br />
  JMP  -4(PC)</p><br />
<br />
<p>源码<br />
type Mutex struct {<br />
  // [阻塞的goroutine个数, starving标识, woken标识, locked标识]<br />
  // [0~28, 1, 1, 1]<br />
  state int32<br />
  sema  uint32<br />
}</p><br />
<br />
<p>const (<br />
  mutexLocked = 1 « iota // mutex is locked<br />
  mutexWoken    // 唤醒标记<br />
  mutexStarving // 饥饿模式<br />
  mutexWaiterShift = iota // 位移数</p><br />
<br />
<p>starvationThresholdNs = 1e6  // 阻塞时间阀值1ms<br />
)</p><br />
<br />
<p>func (m *Mutex) Lock() {<br />
  // Fast path: grab unlocked mutex.<br />
  // 尝试CAS上锁<br />
  if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {<br />
    if race.Enabled {<br />
      race.Acquire(unsafe.Pointer(m))<br />
    }<br />
    // 上锁成功，直接返回<br />
    return<br />
  }</p><br />
<br />
<p>var waitStartTime int64<br />
  starving := false<br />
  awoke := false<br />
  iter := 0<br />
  old := m.state<br />
  for {</p><br />
<br />
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 进入到这个循环的，有两种角色goroutine<br />
// 一种是新来的goroutine。另一种是被唤醒的goroutine。所以它们可能在这个地方再一起竞争锁<br />
// 如果新来的goroutine抢成功了，那另一个只能再阻塞着等待。但超过1ms后，锁会转换成饥饿模式<br />
// 在这个模式下，所有新来的goroutine必须排在队伍的后面。没有抢锁资格<br />
<br />
// 饥饿模式下，不能自旋<br />
// 锁被占用了，不能自旋<br />
if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {<br />
  // woken位没有被设置；被阻塞等待goroutine的个数大于0<br />
  if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;<br />
    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {<br />
    // 可以自旋了，那就设置上woken位，在unlock时，如果发现有别的goroutine在自旋，就立即返回，有被阻塞的goroutine也不唤醒了<br />
    awoke = true<br />
  }<br />
  // runtime_doSpin -&gt; sync_runtime_doSpin<br />
  // 每次自旋30个时钟周期，最多120个周期<br />
  runtime_doSpin()<br />
  iter++<br />
  old = m.state<br />
  continue<br />
}<br />
<br />
// 自旋完了还是等不到锁 或 可以上锁<br />
<br />
new := old<br />
// 饥饿模式下的锁不抢<br />
if old&amp;mutexStarving == 0 {<br />
  // 非饥饿模式下，可以抢锁<br />
  new |= mutexLocked<br />
}<br />
if old&amp;(mutexLocked|mutexStarving) != 0 {<br />
  // 已经被上锁了，或锁处于饥饿模式下，就阻塞当前的goroutine<br />
  new += 1 &lt;&lt; mutexWaiterShift<br />
}<br />
if starving &amp;&amp; old&amp;mutexLocked != 0 {<br />
  // 当前的goroutine已经被饿着了，所以要把锁设置为饥饿模式<br />
  new |= mutexStarving<br />
}<br />
if awoke {<br />
  // 当前的goroutine有自旋过，但现在已经自旋结束了。所以要取消woken模式<br />
  if new&amp;mutexWoken == 0 {<br />
    panic("sync: inconsistent mutex state")<br />
  }<br />
  // 取消woken标志<br />
  new &amp;^= mutexWoken<br />
}<br />
if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {<br />
  if old&amp;(mutexLocked|mutexStarving) == 0 {<br />
    // 成功上锁<br />
    break // locked the mutex with CAS<br />
  }<br />
  <br />
  // 主要是为了和第一次调用的Lock的g划分不同的优先级<br />
  queueLifo := waitStartTime != 0<br />
  if waitStartTime == 0 {<br />
    waitStartTime = runtime_nanotime()<br />
  }<br />
  // 使用信号量阻塞当前的g<br />
  // 如果当前g已经阻塞等待过一次了，queueLifo被赋值true<br />
  runtime_SemacquireMutex(&amp;m.sema, queueLifo)<br />
  // 判断当前g是否被饿着了<br />
  starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs<br />
  old = m.state<br />
  if old&amp;mutexStarving != 0 {<br />
    // 饥饿模式下，被手递手喂信号量唤醒的<br />
    if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {<br />
      panic("sync: inconsistent mutex state")<br />
    }<br />
    delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift) // -7(111)<br />
    if !starving || old&gt;&gt;mutexWaiterShift == 1 {<br />
      // 退出饥饿模式<br />
      // 饥饿模式会影响自旋<br />
      delta -= mutexStarving<br />
    }<br />
    atomic.AddInt32(&amp;m.state, delta)<br />
    break<br />
  }<br />
  // 不是手递手的信号量，那就自己继续竞争锁<br />
  // 必须设置为true，这样新一轮的CAS之前，就可以取消woken模式。<br />
  // 因为通过信号量释放锁时，为了保持公平性，会同时设置woken模式。<br />
  awoke = true<br />
  iter = 0<br />
} else {<br />
  old = m.state<br />
}   }<br />
</code></pre></div></div><br />
<br />
<p>if race.Enabled {<br />
    race.Acquire(unsafe.Pointer(m))<br />
  }<br />
}</p><br />
<br />
<p>func (m *Mutex) Unlock() {<br />
  if race.Enabled {<br />
    _ = m.state<br />
    race.Release(unsafe.Pointer(m))<br />
  }</p><br />
<br />
<p>// Fast path: drop lock bit.<br />
  new := atomic.AddInt32(&amp;m.state, -mutexLocked)<br />
  if (new+mutexLocked)&amp;mutexLocked == 0 {<br />
    // 不能多次执行unclock()<br />
    panic(“sync: unlock of unlocked mutex”)<br />
  }<br />
  if new&amp;mutexStarving == 0 {<br />
    // 非饥饿模式<br />
    old := new<br />
    for {<br />
      // 没有被阻塞的goroutine。直接返回<br />
      // 有阻塞的goroutine，但处于woken模式，直接返回<br />
      // 有阻塞的goroutine，但被上锁了。可能发生在此for循环内，第一次CAS不成功。因为CAS前可能被新的goroutine抢到锁。直接返回<br />
      // 有阻塞的goroutine，但锁处于饥饿模式。可能发生在被阻塞的goroutine不是被唤醒调度的，而是被正常调度运行的。直接返回<br />
      if old»mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {<br />
        return<br />
      }</p><br />
<br />
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // 有阻塞的goroutine，唤醒一个或变为没有阻塞的goroutine了就退出<br />
  // 这个被唤醒的goroutine还需要跟新来的goroutine竞争<br />
  // 如果只剩最后一个被阻塞的goroutine。唤醒它之后，state就变成0。<br />
  // 如果此刻来一个新的goroutine抢锁，它有可能在goroutine被重新调度之前抢锁成功。<br />
  // 这样就失去公平性了，不能让它那么干，所以这里也要设置为woken模式。<br />
  // 因为Lock方法开始的fast path，CAS操作的old值是0。这里设置woken模式成功后，后来者就只能乖乖排队。保持了锁的公平性<br />
  new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken<br />
  if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {<br />
    runtime_Semrelease(&amp;m.sema, false)<br />
    return<br />
  }<br />
  old = m.state<br />
}   } else {<br />
// 饥饿模式<br />
// 手递手唤醒一个goroutine<br />
runtime_Semrelease(&amp;m.sema, true)   } }<br />
</code></pre></div></div><br />
<br />
<p>golang 1.10 mutex互斥锁源码<br />
2018年05月13日 18:10:54 tydhot 阅读数 369<br />
Mutex锁分为normal模式和starvation模式。一开始默认处于normal模式。在normal模式中，每个新加入竞争锁行列的协程都会直接参与到锁的竞争当中来，而处于starvation模式时，所有所有新进入的协程都会直接被放入等待队列中挂起，直到其所在队列之前的协程全部执行完毕。</p><br />
<br />
<p>在normal模式中协程的挂起等待时间如果大于某个值，就会进入starvation模式。</p><br />
<br />
<p>type Mutex struct {<br />
   state int32<br />
   sema  uint32<br />
}<br />
其中，state用来保存mutex的状态量，低一位表示是否上锁，低二位表示当前锁对象是否被唤醒，低三位表示该锁是否处于staration状态，而后几位表示当前正被该锁阻塞的协程数。而sema则是作为信号量来作为阻塞的依据。</p><br />
<br />
<p>Lock()方法进行加锁。</p><br />
<br />
<p>func (m *Mutex) Lock() {<br />
   // Fast path: grab unlocked mutex.<br />
   if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {<br />
      if race.Enabled {<br />
         race.Acquire(unsafe.Pointer(m))<br />
      }<br />
      return<br />
   }</p><br />
<br />
<p>var waitStartTime int64<br />
   starving := false<br />
   awoke := false<br />
   iter := 0<br />
   old := m.state<br />
   for {<br />
      // Don’t spin in starvation mode, ownership is handed off to waiters<br />
      // so we won’t be able to acquire the mutex anyway.<br />
      if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {<br />
         // Active spinning makes sense.<br />
         // Try to set mutexWoken flag to inform Unlock<br />
         // to not wake other blocked goroutines.<br />
         if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old»mutexWaiterShift != 0 &amp;&amp;<br />
            atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {<br />
            awoke = true<br />
         }<br />
         runtime_doSpin()<br />
         iter++<br />
         old = m.state<br />
         continue<br />
      }<br />
      new := old<br />
      // Don’t try to acquire starving mutex, new arriving goroutines must queue.<br />
      if old&amp;mutexStarving == 0 {<br />
         new |= mutexLocked<br />
      }<br />
      if old&amp;(mutexLocked|mutexStarving) != 0 {<br />
         new += 1 « mutexWaiterShift<br />
      }<br />
      // The current goroutine switches mutex to starvation mode.<br />
      // But if the mutex is currently unlocked, don’t do the switch.<br />
      // Unlock expects that starving mutex has waiters, which will not<br />
      // be true in this case.<br />
      if starving &amp;&amp; old&amp;mutexLocked != 0 {<br />
         new |= mutexStarving<br />
      }<br />
      if awoke {<br />
         // The goroutine has been woken from sleep,<br />
         // so we need to reset the flag in either case.<br />
         if new&amp;mutexWoken == 0 {<br />
            throw(“sync: inconsistent mutex state”)<br />
         }<br />
         new &amp;^= mutexWoken<br />
      }<br />
      if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {<br />
         if old&amp;(mutexLocked|mutexStarving) == 0 {<br />
            break // locked the mutex with CAS<br />
         }<br />
         // If we were already waiting before, queue at the front of the queue.<br />
         queueLifo := waitStartTime != 0<br />
         if waitStartTime == 0 {<br />
            waitStartTime = runtime_nanotime()<br />
         }<br />
         runtime_SemacquireMutex(&amp;m.sema, queueLifo)<br />
         starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs<br />
         old = m.state<br />
         if old&amp;mutexStarving != 0 {<br />
            // If this goroutine was woken and mutex is in starvation mode,<br />
            // ownership was handed off to us but mutex is in somewhat<br />
            // inconsistent state: mutexLocked is not set and we are still<br />
            // accounted as waiter. Fix that.<br />
            if old&amp;(mutexLocked|mutexWoken) != 0 || old»mutexWaiterShift == 0 {<br />
               throw(“sync: inconsistent mutex state”)<br />
            }<br />
            delta := int32(mutexLocked - 1«mutexWaiterShift)<br />
            if !starving || old»mutexWaiterShift == 1 {<br />
               // Exit starvation mode.<br />
               // Critical to do it here and consider wait time.<br />
               // Starvation mode is so inefficient, that two goroutines<br />
               // can go lock-step infinitely once they switch mutex<br />
               // to starvation mode.<br />
               delta -= mutexStarving<br />
            }<br />
            atomic.AddInt32(&amp;m.state, delta)<br />
            break<br />
         }<br />
         awoke = true<br />
         iter = 0<br />
      } else {<br />
         old = m.state<br />
      }<br />
   }</p><br />
<br />
<p>if race.Enabled {<br />
      race.Acquire(unsafe.Pointer(m))<br />
   }<br />
}<br />
一开始会直接通过cas将原本值为0（也就是当前没任何协程占用锁）的state赋为1，表示这个锁已经有人加锁。如果成功，表示这是当前锁第一次加锁并且加锁成功，那么可以直接返回。</p><br />
<br />
<p>如果之前加锁失败，也就是刚刚的cas操作失败，那么说明就需要等待锁的释放，首先判断是否已经加锁并处于normal模式，将原先锁的state与1和4相或的结果相与，如果与1相等，则说明此时处于normal模式并且已经加锁，而后判断当前协程是否可以自旋。如果可以自旋，则通过右移三位判断是否还有协程正在等待这个锁，如果有，并通过低2位判断是否该所处于被唤醒状态，如果并没有，则将其状态量设为被唤醒的状态，之后进行自旋，直到该协程自旋数量达到上限，或者当前锁被解锁，或者当前锁已经处于starvation模式。</p><br />
<br />
<p>if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {<br />
   // Active spinning makes sense.<br />
   // Try to set mutexWoken flag to inform Unlock<br />
   // to not wake other blocked goroutines.<br />
   if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old»mutexWaiterShift != 0 &amp;&amp;<br />
      atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {<br />
      awoke = true<br />
   }<br />
   runtime_doSpin()<br />
   iter++<br />
   old = m.state<br />
   continue<br />
}<br />
在超过自旋数量上限或者当前锁已经解锁或者当前锁已经处于starvation模式，那么就在循环中进入下面的部分。</p><br />
<br />
<p>new := old<br />
// Don’t try to acquire starving mutex, new arriving goroutines must queue.<br />
if old&amp;mutexStarving == 0 {<br />
   new |= mutexLocked<br />
}<br />
if old&amp;(mutexLocked|mutexStarving) != 0 {<br />
   new += 1 « mutexWaiterShift<br />
}<br />
// The current goroutine switches mutex to starvation mode.<br />
// But if the mutex is currently unlocked, don’t do the switch.<br />
// Unlock expects that starving mutex has waiters, which will not<br />
// be true in this case.<br />
if starving &amp;&amp; old&amp;mutexLocked != 0 {<br />
   new |= mutexStarving<br />
}<br />
if awoke {<br />
   // The goroutine has been woken from sleep,<br />
   // so we need to reset the flag in either case.<br />
   if new&amp;mutexWoken == 0 {<br />
      throw(“sync: inconsistent mutex state”)<br />
   }<br />
   new &amp;^= mutexWoken<br />
}<br />
if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {<br />
   if old&amp;(mutexLocked|mutexStarving) == 0 {<br />
      break // locked the mutex with CAS<br />
   }<br />
   // If we were already waiting before, queue at the front of the queue.<br />
   queueLifo := waitStartTime != 0<br />
   if waitStartTime == 0 {<br />
      waitStartTime = runtime_nanotime()<br />
   }<br />
   runtime_SemacquireMutex(&amp;m.sema, queueLifo)<br />
   starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs<br />
   old = m.state<br />
   if old&amp;mutexStarving != 0 {<br />
      // If this goroutine was woken and mutex is in starvation mode,<br />
      // ownership was handed off to us but mutex is in somewhat<br />
      // inconsistent state: mutexLocked is not set and we are still<br />
      // accounted as waiter. Fix that.<br />
      if old&amp;(mutexLocked|mutexWoken) != 0 || old»mutexWaiterShift == 0 {<br />
         throw(“sync: inconsistent mutex state”)<br />
      }<br />
      delta := int32(mutexLocked - 1«mutexWaiterShift)<br />
      if !starving || old»mutexWaiterShift == 1 {<br />
         // Exit starvation mode.<br />
         // Critical to do it here and consider wait time.<br />
         // Starvation mode is so inefficient, that two goroutines<br />
         // can go lock-step infinitely once they switch mutex<br />
         // to starvation mode.<br />
         delta -= mutexStarving<br />
      }<br />
      atomic.AddInt32(&amp;m.state, delta)<br />
      break<br />
   }<br />
   awoke = true<br />
   iter = 0<br />
} else {<br />
   old = m.state<br />
}</p><br />
<br />
<p>首先，如果此时还是由于别的协程的占用无法获得锁或者处于starvation模式，都在其state加8表示有新的协程正在处于等待状态。并且如果之前由于自旋而将该锁唤醒，那么此时将其低二位的状态量赋值为0。之后判断starving是否为true，如果为true说明在上一次的循环中，锁需要被定义为starvation模式，那么在这里就将相应的状态量低三位设置为1表示进入starvation模式。</p><br />
<br />
<p>之后尝试通过cas将新的state状态量赋值给state，如果失败，则重新获得其 state在下一步循环重新重复上述的操作。如果成功，首先判断已经阻塞时间，如果为零，则从现在开始记录。</p><br />
<br />
<p>之后通过runtime_SemacquireMutex()通过信号量将当前协程阻塞。</p><br />
<br />
<p>上述runtime_SemacquireMutex()方法的具体实现在了sema.go中。</p><br />
<br />
<p>func sync_runtime_SemacquireMutex(addr *uint32, lifo bool) {<br />
   semacquire1(addr, lifo, semaBlockProfile|semaMutexProfile)<br />
}</p><br />
<br />
<p>func semacquire1(addr *uint32, lifo bool, profile semaProfileFlags) {<br />
   gp := getg()<br />
   if gp != gp.m.curg {<br />
      throw(“semacquire not on the G stack”)<br />
   }</p><br />
<br />
<p>// Easy case.<br />
   if cansemacquire(addr) {<br />
      return<br />
   }</p><br />
<br />
<p>// Harder case:<br />
   // increment waiter count<br />
   // try cansemacquire one more time, return if succeeded<br />
   // enqueue itself as a waiter<br />
   // sleep<br />
   // (waiter descriptor is dequeued by signaler)<br />
   s := acquireSudog()<br />
   root := semroot(addr)<br />
   t0 := int64(0)<br />
   s.releasetime = 0<br />
   s.acquiretime = 0<br />
   s.ticket = 0<br />
   if profile&amp;semaBlockProfile != 0 &amp;&amp; blockprofilerate &gt; 0 {<br />
      t0 = cputicks()<br />
      s.releasetime = -1<br />
   }<br />
   if profile&amp;semaMutexProfile != 0 &amp;&amp; mutexprofilerate &gt; 0 {<br />
      if t0 == 0 {<br />
         t0 = cputicks()<br />
      }<br />
      s.acquiretime = t0<br />
   }<br />
   for {<br />
      lock(&amp;root.lock)<br />
      // Add ourselves to nwait to disable “easy case” in semrelease.<br />
      atomic.Xadd(&amp;root.nwait, 1)<br />
      // Check cansemacquire to avoid missed wakeup.<br />
      if cansemacquire(addr) {<br />
         atomic.Xadd(&amp;root.nwait, -1)<br />
         unlock(&amp;root.lock)<br />
         break<br />
      }<br />
      // Any semrelease after the cansemacquire knows we’re waiting<br />
      // (we set nwait above), so go to sleep.<br />
      root.queue(addr, s, lifo)<br />
      goparkunlock(&amp;root.lock, “semacquire”, traceEvGoBlockSync, 4)<br />
      if s.ticket != 0 || cansemacquire(addr) {<br />
         break<br />
      }<br />
   }<br />
   if s.releasetime &gt; 0 {<br />
      blockevent(s.releasetime-t0, 3)<br />
   }<br />
   releaseSudog(s)<br />
}</p><br />
<br />
<p>首先，在上述的方法中，首先通过semroot()方法根据传入的地址获得semRoot，其具体操作如下。</p><br />
<br />
<p>func semroot(addr *uint32) *semaRoot {<br />
   return &amp;semtable[(uintptr(unsafe.Pointer(addr))»3)%semTabSize].root<br />
}</p><br />
<br />
<p>将传入的Mutex的信号量sema的地址右移三位并与251取余，得到的新地址来得到semRoot，做到将semRoot通过信号量sema来与相应的Mutex绑定的目的。</p><br />
<br />
<p>semRoot的结构如下。</p><br />
<br />
<p>type semaRoot struct {<br />
   lock  mutex<br />
   treap *sudog // root of balanced tree of unique waiters.<br />
   nwait uint32 // Number of waiters. Read w/o the lock.<br />
}</p><br />
<br />
<p>其中的mutex与之前的Mutex无关，只是一个简单的uintptr来简单的实现并发的线程安全的功能。Treap则是其中平衡二叉树的根节点，nwait则表示证在平衡二叉树阻塞的协程数量。</p><br />
<br />
<p>此时，会对信号量sema的值进行判断，如果为0，则继续，否则尝试减1并返回。</p><br />
<br />
<p>而后通过semRoot中的mutex进行加锁，这里的锁实现很简单，简单来说实则只是对互斥信号量的cas操作。</p><br />
<br />
<p>之后给semRoot的nwait加一，表示新的协程进入等待。</p><br />
<br />
<p>之后通过queue()方法正式将目标协程放入平衡二叉树中等待。</p><br />
<br />
<p>对于这个节点，首先设置该节点中保存的协程为当前协程，并保存当前信号量地址。</p><br />
<br />
<p>首先，如果是第一次根据新的信号量而要加入的节点，那么会直接加入到平衡二叉树中，这颗二叉树中节点的位置通过信号量的地址作为排序的依据，然后插入。</p><br />
<br />
<p>s.ticket = fastrand() | 1<br />
s.parent = last<br />
*pt = s</p><br />
<br />
<p>// Rotate up into tree according to ticket (priority).<br />
for s.parent != nil &amp;&amp; s.parent.ticket &gt; s.ticket {<br />
   if s.parent.prev == s {<br />
      root.rotateRight(s.parent)<br />
   } else {<br />
      if s.parent.next != s {<br />
         panic(“semaRoot queue”)<br />
      }<br />
      root.rotateLeft(s.parent)<br />
   }<br />
}<br />
如果不是第一次的插入，那么首先根据信号量的地址从平衡二叉树根节点开始寻找对应的信号量地址所绑定的节点，通过大小确定寻找的左儿子节点或者右儿子节点，直到找到。</p><br />
<br />
<p>找到之后，之前在将协程准备阻塞之前会判断以等待时间，如果不为0，说明该协程已经进入过该平衡二叉树。那么将新生成的节点取代原本节点在平衡二叉树的位置，并将老节点放置在该信号量绑定节点的等待队列的头部。如果是第一次，那么只需要将新的节点放在等待队列的末尾。</p><br />
<br />
<p>var last *sudog<br />
pt := &amp;root.treap<br />
for t := *pt; t != nil; t = *pt {<br />
   if t.elem == unsafe.Pointer(addr) {<br />
      // Already have addr in list.<br />
      if lifo {<br />
         // Substitute s in t’s place in treap.<br />
         *pt = s<br />
         s.ticket = t.ticket<br />
         s.acquiretime = t.acquiretime<br />
         s.parent = t.parent<br />
         s.prev = t.prev<br />
         s.next = t.next<br />
         if s.prev != nil {<br />
            s.prev.parent = s<br />
         }<br />
         if s.next != nil {<br />
            s.next.parent = s<br />
         }<br />
         // Add t first in s’s wait list.<br />
         s.waitlink = t<br />
         s.waittail = t.waittail<br />
         if s.waittail == nil {<br />
            s.waittail = t<br />
         }<br />
         t.parent = nil<br />
         t.prev = nil<br />
         t.next = nil<br />
         t.waittail = nil<br />
      } else {<br />
         // Add s to end of t’s wait list.<br />
         if t.waittail == nil {<br />
            t.waitlink = s<br />
         } else {<br />
            t.waittail.waitlink = s<br />
         }<br />
         t.waittail = s<br />
         s.waitlink = nil<br />
      }<br />
      return<br />
   }<br />
   last = t<br />
   if uintptr(unsafe.Pointer(addr)) &lt; uintptr(t.elem) {<br />
      pt = &amp;t.prev<br />
   } else {<br />
      pt = &amp;t.next<br />
   }<br />
}</p><br />
<br />
<p>将当次阻塞加入平衡二叉树中队列之后，就可以先将semRoot中的mutex解锁，并将当前协程挂起。</p><br />
<br />
<p>回到Mutex的Lock()中，当之前调用方法将协程挂起后，如果协程被唤醒，那么就会继续下面的流程。</p><br />
<br />
<p>starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs<br />
old = m.state<br />
if old&amp;mutexStarving != 0 {<br />
   // If this goroutine was woken and mutex is in starvation mode,<br />
   // ownership was handed off to us but mutex is in somewhat<br />
   // inconsistent state: mutexLocked is not set and we are still<br />
   // accounted as waiter. Fix that.<br />
   if old&amp;(mutexLocked|mutexWoken) != 0 || old»mutexWaiterShift == 0 {<br />
      throw(“sync: inconsistent mutex state”)<br />
   }<br />
   delta := int32(mutexLocked - 1«mutexWaiterShift)<br />
   if !starving || old»mutexWaiterShift == 1 {<br />
      // Exit starvation mode.<br />
      // Critical to do it here and consider wait time.<br />
      // Starvation mode is so inefficient, that two goroutines<br />
      // can go lock-step infinitely once they switch mutex<br />
      // to starvation mode.<br />
      delta -= mutexStarving<br />
   }<br />
   atomic.AddInt32(&amp;m.state, delta)<br />
   break<br />
}</p><br />
<br />
<p>如果这里协程阻塞而挂起的时间超过了默认值，那么就会将starve设置为true，就会在下一次的循环中将该锁这是为starvation模式。如果已经是这个模式，那么就会将状态量的等待数减1，并判断当前如果已经没有等待的协程，就没有必要继续维持starvation模式，同时也没必要继续执行该循环（当前只有一个协程在占用锁）。</p><br />
<br />
<p>解锁通过Unlock()方法。</p><br />
<br />
<p>func (m *Mutex) Unlock() {<br />
   if race.Enabled {<br />
      _ = m.state<br />
      race.Release(unsafe.Pointer(m))<br />
   }</p><br />
<br />
<p>// Fast path: drop lock bit.<br />
   new := atomic.AddInt32(&amp;m.state, -mutexLocked)<br />
   if (new+mutexLocked)&amp;mutexLocked == 0 {<br />
      throw(“sync: unlock of unlocked mutex”)<br />
   }<br />
   if new&amp;mutexStarving == 0 {<br />
      old := new<br />
      for {<br />
         // If there are no waiters or a goroutine has already<br />
         // been woken or grabbed the lock, no need to wake anyone.<br />
         // In starvation mode ownership is directly handed off from unlocking<br />
         // goroutine to the next waiter. We are not part of this chain,<br />
         // since we did not observe mutexStarving when we unlocked the mutex above.<br />
         // So get off the way.<br />
         if old»mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {<br />
            return<br />
         }<br />
         // Grab the right to wake someone.<br />
         new = (old - 1«mutexWaiterShift) | mutexWoken<br />
         if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {<br />
            runtime_Semrelease(&amp;m.sema, false)<br />
            return<br />
         }<br />
         old = m.state<br />
      }<br />
   } else {<br />
      // Starving mode: handoff mutex ownership to the next waiter.<br />
      // Note: mutexLocked is not set, the waiter will set it after wakeup.<br />
      // But mutex is still considered locked if mutexStarving is set,<br />
      // so new coming goroutines won’t acquire it.<br />
      runtime_Semrelease(&amp;m.sema, true)<br />
   }<br />
}</p><br />
<br />
<p>解锁首先直接将第一位状态量变为0，表示已经解锁。然后根据模式，如果处于normal模式，根据状态量当前是否有协程等待，或者已经有协程已经在自旋等待锁，那么就可以直接结束。否则，就通过runtime_Semrelease()方法尝试唤醒挂起的协程。在runtime_Semrelease()中与之前对应，通过dequeue()方法将寻找到的二叉树节点，也就是循环队列的头部取出，节点中保存的协程作为要唤醒的协程。但是，这里唤醒的携程并不一定会立即获取锁，锁的获取仍旧需要竞争。</p><br />
<br />
<p>而如果处于starvation模式，那么会直接通过runtime_Semrelease()方法尝试唤醒挂起的协程，这里唤醒的协程必定持有锁。</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="http://localhost:4000/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>