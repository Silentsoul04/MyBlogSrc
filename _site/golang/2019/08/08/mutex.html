<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">mutex</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-08-08T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Aug 8, 2019</time></p>
					</div>
					 <p>CAS原子操作。<br />
需要有一种阻塞和唤醒机制。<br />
尽量减少阻塞和唤醒切换成本。<br />
锁尽量公平，后来者要排队。即使被后来者插队了，也要照顾先来者，不能有“饥饿”现象。<br />
先看3，4点。再看2，1点。最后是源码。<br />
<!-- more --><br />
尽量减少阻塞和唤醒切换成本<br />
减少切换成本的方法就是不切换，简单而直接。</p><br />
<br />
<p>不切换的方式就是让竞争者自旋。自旋一会儿，然后抢锁。不成功就再自旋。到达上限次数才阻塞。</p><br />
<br />
<p>自旋就是CPU空转一定的时钟周期</p><br />
<br />
<p>不同平台上自旋所用的指令不一样。例如在amd64平台下，汇编的实现如下</p><br />
<br />
<p>TEXT runtime·procyield(SB),NOSPLIT,$0-0<br />
  MOVL  cycles+0(FP), AX<br />
again:<br />
    // 自旋cycles次，每次自旋执行PAUSE指令<br />
  PAUSE<br />
  SUBL  $1, AX<br />
  JNZ  again<br />
  RET<br />
是否允许自旋的判断是严格的。而且最多自旋四次，每次30个CPU时钟周期。</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>能不能自旋全由这个条件语句决定if old&amp;(mutexLocked</td><br />
      <td>mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter)。</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>翻译下，就是下面的条件都满足，才允许自旋。</p><br />
<br />
<p>锁已被占用，并且锁不处于饥饿模式。</p><br />
<br />
<p>积累的自旋次数小于最大自旋次数（active_spin=4）。</p><br />
<br />
<p>cpu核数大于1。</p><br />
<br />
<p>有空闲的P。</p><br />
<br />
<p>当前goroutine所挂载的P下，本地待运行队列为空。</p><br />
<br />
<p>可以看到自旋要求严格，毕竟在锁竞争激烈时，还无限制地自旋就肯定会影响其他goroutine。</p><br />
<br />
<p>const   active_spin     = 4<br />
func sync_runtime_canSpin(i int) bool {<br />
  // 自旋次数不能大于 active_spin(4) 次<br />
  // cpu核数只有一个，不能自旋<br />
  // 没有空闲的p了，不能自旋<br />
  if i &gt;= active_spin || ncpu &lt;= 1 || gomaxprocs &lt;= int32(sched.npidle+sched.nmspinning)+1 {<br />
    return false<br />
  }<br />
  // 当前g绑定的p里面本地待运行队列不为空，不能自旋<br />
  if p := getg().m.p.ptr(); !runqempty(p) {<br />
    return false<br />
  }<br />
  return true<br />
}</p><br />
<br />
<p>锁模式介绍<br />
上面的出现了两个常量，mutexStarving和mutexLocked。它们与锁对象结构有关。比较基础，这里介绍一下。</p><br />
<br />
<p>type Mutex struct {<br />
  // [阻塞的goroutine个数, starving标识, woken标识, locked标识]<br />
  state int32<br />
  sema  uint32<br />
}<br />
Mutex结构简单的就只有两个成员变量。sema是信号量，下文会介绍到。这里主要介绍state的结构。</p><br />
<br />
<p>一个32位的变量，被划分成上图的样子。右边的标识也有对应的常量</p><br />
<br />
<p>const (<br />
  mutexLocked = 1 « iota // mutex is locked<br />
  mutexWoken  <br /><br />
  mutexStarving <br />
  mutexWaiterShift = iota<br />
)</p><br />
<br />
<p>含义如下：</p><br />
<br />
<p>mutexLocked对应右边低位第一个bit。值为1，表示锁被占用。值为0，表示锁未被占用。</p><br />
<br />
<p>mutexWoken对应右边低位第二个bit。值为1，表示打上唤醒标记。值为0，表示没有唤醒标记。</p><br />
<br />
<p>mutexStarving对应右边低位第三个bit。值为1，表示锁处于饥饿模式。值为0，表示锁存于正常模式。</p><br />
<br />
<p>mutexWaiterShift是偏移量。它值为3。用法是state»=mutexWaiterShift之后，state的值就表示当前阻塞等待锁的goroutine个数。最多可以阻塞2^29个goroutine。</p><br />
<br />
<p>Mutex锁分为两种模式，正常模式 和 饥饿模式。</p><br />
<br />
<p>正常模式下，对于新来的goroutine而言，它有两种选择，要么抢到了锁，直接执行；要么抢不到锁，追加到阻塞队列尾部，等待被唤醒的。</p><br />
<br />
<p>饥饿模式下，对于新来的goroutine，它只有一个选择，就是追加到阻塞队列尾部，等待被唤醒的。而且在该模式下，所有锁竞争者都不能自旋。</p><br />
<br />
<p>除了这两种模式。还有一个Woken(唤醒标记)。它主要用于自旋状态的通知和锁公平性的保证。分两个角度理解：</p><br />
<br />
<p>一、新的goroutine申请锁时，发现锁被占用了。但自己满足自旋条件，于是自己自旋，并设置上的Woken标记。此时占用锁的goroutine在释放锁时，检查Woken标记，如果被标记。哪怕现在锁上面的阻塞队列不为空，也不做唤醒。直接return，让自旋着的goroutine有更大机会抢到锁。</p><br />
<br />
<p>if old»mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {<br />
    return<br />
}<br />
二、释放锁时，检查Woken标记为空。而阻塞队列里有goroutine需要被唤醒。那么在唤醒时，同时标记锁Woken。这里可能有疑问，原来没有Woken标记，为什么在唤醒一个goroutine要主动标记呢？目的是保证锁公平。</p><br />
<br />
<p>考虑这样的场景：现在阻塞队列里只有一个goroutine。把它唤醒后，还得等调度器运行到它，它自己再去抢锁。但在调度器运行到它之前，很可能新的竞争者参与进来，此时锁被抢走的概率就很大。</p><br />
<br />
<p>这有失公平，被阻塞的goroutine是先到者，新的竞争者是后来者。应该尽量让它们一起竞争。</p><br />
<br />
<p>// 唤醒一个阻塞的goroutine，并把锁的Woken标记设置上<br />
new = (old - 1«mutexWaiterShift) | mutexWoken<br />
设置Woken标记后，state就肯定不为零。此时新来的竞争者，在执行Lock()的fast-path时会失败，接下来就只能乖乖排队了。</p><br />
<br />
<p>func (m *Mutex) Lock() {<br />
  // Fast path: grab unlocked mutex.<br />
  // Woken标记设置后，这里的CAS就会为false<br />
  if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {<br />
    // …<br />
    return<br />
  }<br />
  // 接下来在阻塞里排队<br />
}<br />
小总结：为了减少切换成本，短暂的自旋等待是简单的方法。而竞争者在自旋时，要主动设置Woken标记。这样释放者才能感知到。</p><br />
<br />
<p>锁尽量公平<br />
为什么不是绝对公平？要绝对公平的粗暴做法就是在锁被占用后，其它所有竞争者，包括新来的，全部排队。</p><br />
<br />
<p>但排队的问题也很明显，排队阻塞唤醒的切换成本(这是损耗性能的潜在的隐患，下面Mutex的问题有举例)。假如临界区代码执行只需要十几个时钟周期时，让竞争者自旋等待一下，立刻就可以获得锁。减少不必要的切换成本，效率更高。</p><br />
<br />
<p>尽量公平的结果就是阻塞的竞争者被唤醒后，也要与(正在自旋的)新竞争者抢夺锁资源。</p><br />
<br />
<p>go使用三种手段保证Mutex锁尽量公平：</p><br />
<br />
<p>上面介绍的，在锁释放时，主动设置Woken标记，防止新的竞争者轻易抢到锁。</p><br />
<br />
<p>竞争者进阻塞队列策略不一样。新的竞争者，抢不到锁，就排在队列尾部。先来竞争者，从队列中被唤醒后，还是抢不到锁，就放在队列头部。</p><br />
<br />
<p>任何竞争者，被阻塞等待的时间超过指定阀值(1ms)。锁就转为饥饿模式。这时锁释放时会唤醒它们，手递手式把锁资源给它们。别的竞争者（包括新来的）都抢不到。直接把饥饿问题解决掉。</p><br />
<br />
<p>饥饿问题是会积压的。要尽快解决。举个例子解释一下：</p><br />
<br />
<p>蓝色是新竞争者，红色是阻塞等待时间超过阀值的竞争者。每次持锁时间是0.3ms。</p><br />
<br />
<p>只要有竞争者阻塞超时了，锁就会转换为饥饿模式。饥饿模式下，所有的新竞争者都得排队。</p><br />
<br />
<p>时刻4中的G3就是被积压的。如果时刻0中的竞争者更多时，并且抢锁顺序不变。那么时刻4的积压就更严重。</p><br />
<br />
<p>同时反映出一个问题。</p><br />
<br />
<p>Mutex带来的问题<br />
假设在业务某个场景中，对每个请求都需要访问某互斥资源。使用Mutex锁时，如果QPS很高，阻塞队列肯定会很满。虽然QPS可能会降，但请求是持续的。</p><br />
<br />
<p>新来的请求，在访问互斥资源时有可能抢锁成功，后来者胜于先到者。这种情况持续发生的话，就会导致阻塞队列中所有的请求得不到处理，耗时增高，直至超出上游设置的超时时间，一下子失败率突增，上游再影响它的上游，引起连锁反应进而服务故障异常。</p><br />
<br />
<p>解决方案要根据实际业务场景来优化。削减锁的粒度；或者使用CAS的方式进队列，然后阻塞在通道上；或者使用无锁结构等待。</p><br />
<br />
<p>阻塞在通道而不是阻塞的锁上，是因为go的runtime对待锁唤醒和通道唤醒goroutine的效率是不一样的。这也引出了还有一种方案是改runtime，让锁唤醒的goroutine更快地得到执行。毕竟上面问题点是被唤醒的goroutine和新的goroutine在竞争中不能保证稳胜，被唤醒的goroutine会有一个调度耗时，减少耗时就有可能提高竞争成功率。</p><br />
<br />
<p>阻塞和唤醒机制<br />
go的阻塞和唤醒是semacquire和semrelease。虽然命名上是sema，但实际用途却是一套阻塞唤醒机制。</p><br />
<br />
<p>// That is, don’t think of these as semaphores.<br />
// Think of them as a way to implement sleep and wakeup</p><br />
<br />
<p>阻塞和唤醒机制</p><br />
<br />
<p>go的runtime有一个全局变量semtable，它放置了所有的信号量。</p><br />
<br />
<p>var semtable [semTabSize]struct {<br />
  root semaRoot<br />
  pad  [sys.CacheLineSize - unsafe.Sizeof(semaRoot{})]byte<br />
}</p><br />
<br />
<p>func semacquire1(addr *uint32, lifo bool, profile semaProfileFlags)<br />
func semrelease1(addr *uint32, handoff bool)<br />
每个信号量都由一个变量地址指定。Mutex就是用成员sema的地址。</p><br />
<br />
<p>在阻塞时，调用semacquire1，把地址(addr)传给它。</p><br />
<br />
<p>如果addr大于1，并且通过CAS减一成功，那就说明获取信号量成功。不用阻塞。</p><br />
<br />
<p>否则，semacquire1会在semtable数组中找一个元素和它对应上。每个元素都有一个root，这个root是Treap树（ACM同学应该熟悉）。</p><br />
<br />
<p>最后addr变成一个树节点，这个树节点，有自己的一个队列，专门放被阻塞的goroutine。叫它阻塞队列吧。</p><br />
<br />
<p>这个阻塞队列是个双端队列，头尾都可以进。</p><br />
<br />
<p>semacquire1把当前goroutine相关元数据放进阻塞队列之后，就挂起了。</p><br />
<br />
<p>semrelease1是给addr CAS加一。<br />
如果坚持发现当前addr上有阻塞的goroutine时，就取一个出来，唤醒它，让它自己再去semacquire1。这是handoff为false的情况。<br />
但handoff为true的话，就尝试手递手地把信号量送给这个goroutine。等于说goroutine不用再自己去抢了，因为自己再去抢有可能抢不到。<br />
最后semrelease1会把取出来的这个goroutine挂在当前P的本地待运行队列尾部，等待调度执行。<br />
就是这样，在获取不到Mutex锁时，通过信号量来阻塞和唤醒goroutine。</p><br />
<br />
<p>CAS原子操作<br />
CAS就是基本的原子操作。没什么好说的。</p><br />
<br />
<p>例如在amd64上，go的汇编实现：</p><br />
<br />
<p>TEXT ·CompareAndSwapUint32(SB),NOSPLIT,$0-17<br />
  MOVV  addr+0(FP), R1<br />
  MOVW  old+8(FP), R2<br />
  MOVW  new+12(FP), R5<br />
  SYNC<br />
cas_again:<br />
  MOVV  R5, R3<br />
  LL  (R1), R4<br />
  BNE  R2, R4, cas_fail<br />
  SC  R3, (R1)<br />
  BEQ  R3, cas_again<br />
  MOVV  $1, R1<br />
  MOVB  R1, swapped+16(FP)<br />
  SYNC<br />
  RET<br />
cas_fail:<br />
  MOVV  $0, R1<br />
  JMP  -4(PC)</p><br />
<br />
<p>源码<br />
type Mutex struct {<br />
  // [阻塞的goroutine个数, starving标识, woken标识, locked标识]<br />
  // [0~28, 1, 1, 1]<br />
  state int32<br />
  sema  uint32<br />
}</p><br />
<br />
<p>const (<br />
  mutexLocked = 1 « iota // mutex is locked<br />
  mutexWoken    // 唤醒标记<br />
  mutexStarving // 饥饿模式<br />
  mutexWaiterShift = iota // 位移数</p><br />
<br />
<p>starvationThresholdNs = 1e6  // 阻塞时间阀值1ms<br />
)</p><br />
<br />
<p>func (m *Mutex) Lock() {<br />
  // Fast path: grab unlocked mutex.<br />
  // 尝试CAS上锁<br />
  if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {<br />
    if race.Enabled {<br />
      race.Acquire(unsafe.Pointer(m))<br />
    }<br />
    // 上锁成功，直接返回<br />
    return<br />
  }</p><br />
<br />
<p>var waitStartTime int64<br />
  starving := false<br />
  awoke := false<br />
  iter := 0<br />
  old := m.state<br />
  for {</p><br />
<br />
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 进入到这个循环的，有两种角色goroutine<br />
// 一种是新来的goroutine。另一种是被唤醒的goroutine。所以它们可能在这个地方再一起竞争锁<br />
// 如果新来的goroutine抢成功了，那另一个只能再阻塞着等待。但超过1ms后，锁会转换成饥饿模式<br />
// 在这个模式下，所有新来的goroutine必须排在队伍的后面。没有抢锁资格<br />
<br />
// 饥饿模式下，不能自旋<br />
// 锁被占用了，不能自旋<br />
if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {<br />
  // woken位没有被设置；被阻塞等待goroutine的个数大于0<br />
  if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;<br />
    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {<br />
    // 可以自旋了，那就设置上woken位，在unlock时，如果发现有别的goroutine在自旋，就立即返回，有被阻塞的goroutine也不唤醒了<br />
    awoke = true<br />
  }<br />
  // runtime_doSpin -&gt; sync_runtime_doSpin<br />
  // 每次自旋30个时钟周期，最多120个周期<br />
  runtime_doSpin()<br />
  iter++<br />
  old = m.state<br />
  continue<br />
}<br />
<br />
// 自旋完了还是等不到锁 或 可以上锁<br />
<br />
new := old<br />
// 饥饿模式下的锁不抢<br />
if old&amp;mutexStarving == 0 {<br />
  // 非饥饿模式下，可以抢锁<br />
  new |= mutexLocked<br />
}<br />
if old&amp;(mutexLocked|mutexStarving) != 0 {<br />
  // 已经被上锁了，或锁处于饥饿模式下，就阻塞当前的goroutine<br />
  new += 1 &lt;&lt; mutexWaiterShift<br />
}<br />
if starving &amp;&amp; old&amp;mutexLocked != 0 {<br />
  // 当前的goroutine已经被饿着了，所以要把锁设置为饥饿模式<br />
  new |= mutexStarving<br />
}<br />
if awoke {<br />
  // 当前的goroutine有自旋过，但现在已经自旋结束了。所以要取消woken模式<br />
  if new&amp;mutexWoken == 0 {<br />
    panic("sync: inconsistent mutex state")<br />
  }<br />
  // 取消woken标志<br />
  new &amp;^= mutexWoken<br />
}<br />
if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {<br />
  if old&amp;(mutexLocked|mutexStarving) == 0 {<br />
    // 成功上锁<br />
    break // locked the mutex with CAS<br />
  }<br />
  <br />
  // 主要是为了和第一次调用的Lock的g划分不同的优先级<br />
  queueLifo := waitStartTime != 0<br />
  if waitStartTime == 0 {<br />
    waitStartTime = runtime_nanotime()<br />
  }<br />
  // 使用信号量阻塞当前的g<br />
  // 如果当前g已经阻塞等待过一次了，queueLifo被赋值true<br />
  runtime_SemacquireMutex(&amp;m.sema, queueLifo)<br />
  // 判断当前g是否被饿着了<br />
  starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs<br />
  old = m.state<br />
  if old&amp;mutexStarving != 0 {<br />
    // 饥饿模式下，被手递手喂信号量唤醒的<br />
    if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {<br />
      panic("sync: inconsistent mutex state")<br />
    }<br />
    delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift) // -7(111)<br />
    if !starving || old&gt;&gt;mutexWaiterShift == 1 {<br />
      // 退出饥饿模式<br />
      // 饥饿模式会影响自旋<br />
      delta -= mutexStarving<br />
    }<br />
    atomic.AddInt32(&amp;m.state, delta)<br />
    break<br />
  }<br />
  // 不是手递手的信号量，那就自己继续竞争锁<br />
  // 必须设置为true，这样新一轮的CAS之前，就可以取消woken模式。<br />
  // 因为通过信号量释放锁时，为了保持公平性，会同时设置woken模式。<br />
  awoke = true<br />
  iter = 0<br />
} else {<br />
  old = m.state<br />
}   }<br />
</code></pre></div></div><br />
<br />
<p>if race.Enabled {<br />
    race.Acquire(unsafe.Pointer(m))<br />
  }<br />
}</p><br />
<br />
<p>func (m *Mutex) Unlock() {<br />
  if race.Enabled {<br />
    _ = m.state<br />
    race.Release(unsafe.Pointer(m))<br />
  }</p><br />
<br />
<p>// Fast path: drop lock bit.<br />
  new := atomic.AddInt32(&amp;m.state, -mutexLocked)<br />
  if (new+mutexLocked)&amp;mutexLocked == 0 {<br />
    // 不能多次执行unclock()<br />
    panic(“sync: unlock of unlocked mutex”)<br />
  }<br />
  if new&amp;mutexStarving == 0 {<br />
    // 非饥饿模式<br />
    old := new<br />
    for {<br />
      // 没有被阻塞的goroutine。直接返回<br />
      // 有阻塞的goroutine，但处于woken模式，直接返回<br />
      // 有阻塞的goroutine，但被上锁了。可能发生在此for循环内，第一次CAS不成功。因为CAS前可能被新的goroutine抢到锁。直接返回<br />
      // 有阻塞的goroutine，但锁处于饥饿模式。可能发生在被阻塞的goroutine不是被唤醒调度的，而是被正常调度运行的。直接返回<br />
      if old»mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {<br />
        return<br />
      }</p><br />
<br />
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // 有阻塞的goroutine，唤醒一个或变为没有阻塞的goroutine了就退出<br />
  // 这个被唤醒的goroutine还需要跟新来的goroutine竞争<br />
  // 如果只剩最后一个被阻塞的goroutine。唤醒它之后，state就变成0。<br />
  // 如果此刻来一个新的goroutine抢锁，它有可能在goroutine被重新调度之前抢锁成功。<br />
  // 这样就失去公平性了，不能让它那么干，所以这里也要设置为woken模式。<br />
  // 因为Lock方法开始的fast path，CAS操作的old值是0。这里设置woken模式成功后，后来者就只能乖乖排队。保持了锁的公平性<br />
  new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken<br />
  if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {<br />
    runtime_Semrelease(&amp;m.sema, false)<br />
    return<br />
  }<br />
  old = m.state<br />
}   } else {<br />
// 饥饿模式<br />
// 手递手唤醒一个goroutine<br />
runtime_Semrelease(&amp;m.sema, true)   } }<br />
</code></pre></div></div><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>